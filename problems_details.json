[
  {
    "code": 200,
    "data": {
      "body": "Given two numbers $N, M$ and a 2D array of size $N * M$. Print the inverted array that appeared in the mirror.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N, M \\leq 100 $ \n$ 1 \\leq A[i][j] \\leq 10^9 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n, m;\n        cin >> n >> m;\n\n        int A[n][m];\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < m; j++)\n            {\n                cin >> A[i][j];\n            }\n        }\n\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < m / 2; j++)\n            {\n                int t = A[i][j];\n                A[i][j] = A[i][m - j - 1];\n                A[i][m - j - 1] = t;\n            }\n            for (int j = 0; j < m; j++)\n            {\n                cout << A[i][j] << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:31:31.491420+00:00"
      },
      "hints": {
        "hint1": "We only need to reverse the columns for each row of the matrix.",
        "hint2": "Can we store the palindrome of each row inplace within the matrix?",
        "solution_approach": "Loop across the rows of the matrix. For each row, loop through half the columns and swap the values of $A[i][j]$ and $A[i][m-j-1]$.\nThis will reverse each column, making it look like a mirror array.\nTime complexity: $O(N*M)$"
      },
      "id": 1142,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains two space seperated integers $ N $ and $ M $. \n$N$ denotes number of rows, $M$ denotes number of columns. Next $N$ lines contains $M$ space separated integers each denoting an element of the array.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the $ \\textbf{inverted} $ array.",
      "samples": [
        {
          "input": "1\n3 3\n2 3 5\n7 9 20\n35 1 12\n",
          "output": "5 3 2 \n20 9 7 \n12 1 35 \n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Mirror Array",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$ and a 2D array $A$ of size $N * N$. Print the $ \\textbf{absolute difference} $ between the $ \\textbf{summation} $  of its two diagonals ($ \\textbf{primary diagonal and secondary diagonal} $).",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N \\leq 100 $\n$ -100 \\leq A[i] \\leq 100 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n][n];\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                cin >> arr[i][j];\n            }\n        }\n\n        int s1 = 0, s2 = 0;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (i == j)\n                {\n                    s1 += arr[i][j];\n                }\n                if (i == n - j - 1)\n                {\n                    s2 += arr[i][j];\n                }\n            }\n        }\n\n        cout << abs(s1 - s2) << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:31:35.300376+00:00"
      },
      "hints": {
        "hint1": "How will you obtain dialgonal elements of the matrix?",
        "hint2": "For the left diagonal, row index will always be equal to column index. Guess for the right diagonal.",
        "solution_approach": "For the left diagonal, row index will always be equal to column index. \nFor the right diagonal, row index will always be equal to $ N - $$ column$ $index $$ - 1 $.\nIterate to sum over the diagonal elements and print the absolute difference.\nTime Complexity: $O(N*M)$"
      },
      "id": 1144,
      "input_format": "The first line contains $T$, the number of test cases. \nFor each testcase: The first line contains an integer $ N $. Next $N$ lines contains $N$ space separated integers each denoting an elements of the array $A$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the $ \\textbf{absolute difference} $ between the $ \\textbf{summation} $ of the matrix main diagonals.",
      "samples": [
        {
          "input": "1\n4\n1 5 12 1\n2 -4 6 7\n3 8 5 9\n3 5 23 -6\n",
          "output": "22\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Matrix",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$ and an array $A$ of $N$ numbers. Print the array after doing the following operations:\n\n$ \\bullet $ Replace every $ \\textbf{positive} $ number by 1.\n$ \\bullet $ Replace every $ \\textbf{negative} $ number by 2.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 2 \\leq N \\leq 10^3 $ \n$ -10^5 \\leq A[i] \\leq 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n\n        for (int i = 0; i < n; i++)\n        {\n            if (arr[i] > 0)\n            {\n                arr[i] = 1;\n            }\n            else if (arr[i] < 0)\n            {\n                arr[i] = 2;\n            }\n        }\n\n        for (int i = 0; i < n; i++)\n        {\n            cout << arr[i] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:43:07.411156+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 1158,
      "input_format": "The first line contains $T$. The number of test cases. \nFor each testcase: \nThe first line contains an integer $ N $ , the number of elements. The second line contains $N$ space separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "if A[i] > 0 it must be replaced with 1. if it is less than zero, it must be replaced with 2. 0 should not be replaced.",
      "output_format": "Print the array after the $ \\textbf{replacement} $ and it's values separated by space.",
      "samples": [
        {
          "input": "1\n5\n1 -2 0 3 4\n",
          "output": "1 2 0 1 1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Replacement",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array A of N integers. Find the length of the largest increasing subsequence if the array A is concatenated to itself N times. A sequence A is a subsequence of an array B if A can be obtained from B by deletion of several (possibly, zero or all) elements. The longest increasing subsequence should be strictly increasing.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 2 \\times 10^5$  \n\n$1 \\leq N \\leq 10^6$  \n\n$1 \\leq A_i \\leq 10^9$  \n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        set<int> s;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            cin >> x;\n            s.insert(x);\n        }\n        cout << s.size() << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:45:41.825805+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "There are N copies of the given array A. You can take the smallest integer from the first copy, the second smallest integer from the second copy and so on. Since the subsequence has to be strictly increasing, the answer would be the number of distinct integers in the array.\n\nTime Complexity per test case: $O(N \\log N)$"
      },
      "id": 373,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer N - the length of the array. \n\nThe second line of each test case contains N space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For the first test case, 2 <strong>1</strong> 3 <strong>2</strong> 1 <strong>3</strong> 2 1 3</p><p>For the second test case, 3 1 1 1 4 3 1 1 <strong>1</strong> 4 3 1 1 1 4 <strong>3</strong> 1 1 1 <strong>4</strong> 3 1 1 1 4</p><p>For the third test case, 3 2 <strong>1</strong> 4 3 <strong>2</strong> 1 4 <strong>3</strong> 2 1 <strong>4</strong> 3 2 1 4</p>",
      "output_format": "For each test case, print the length of the largest increasing subsequence if the array A is concatenated to itself N times.",
      "samples": [
        {
          "input": "3\n3\n2 1 3\n5\n3 1 1 1 4\n4\n3 2 1 4\n",
          "output": "3\n3\n4\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Concatenate Array AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$ and an array $A$ of $N$ numbers. Print the numbers after $\\textbf{sorting}$ them.\n\n$ \\textbf{Note:} $\n\nDon't use built-in-functions.\ntry to solve it with bubble sort algorithm or Selection Sort.\nfor more information watch : https://www.youtube.com/watch?v=Q-NXg6Tzyks",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N \\leq 10^3 $\n$ -100 \\leq A[i] \\leq 100 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n\n        for (int i = 0; i < n - 1; i++) \n        {\n            for (int j = 0; j < n - i - 1; j++) \n            {\n                if (arr[j] > arr[j + 1]) \n                {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n        \n        for (int i = 0; i < n; i++)\n        {\n            cout << arr[i] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:31:50.391602+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Let us use a standard bubble sorting technique to sort the array. Loop through the array and check in two adjacent elements of the array. Move the greater one to the right and smaller to the left. Repeat this cycle $n$ times. This will sort the array. This algorithm is called $Bubble$ $sort$.\nTime Complexity: $O(n^2)$"
      },
      "id": 1153,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains $ N $, the number of elements.\nSecond line contains $N$ space separated integers denoting the array",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the numbers after $\\textbf{sorting}$ them.",
      "samples": [
        {
          "input": "1\n3\n3 1 2\n",
          "output": "1 2 3 \n"
        },
        {
          "input": "2\n3\n3 1 2\n4\n5 2 7 3\n",
          "output": "1 2 3 \n2 3 5 7 \n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Sorting",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two numbers $N$ and $M$, a 2D array of size $N * M$ and a number $X$. Determine whether $X$ $ \\textbf{exists} $ in the 2D array $A$ or $ \\textbf{not} $.",
      "complete_approach": "",
      "constraints": "$ 2 \\leq N, M \\leq 100 $\n$ 1 \\leq A[i] \\leq 10^5 $\n$ 0 \\leq X \\leq 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n, m;\n        cin >> n >> m;\n\n        int arr[n * m];\n        for (int i = 0; i < n * m; i++)\n        {\n            cin >> arr[i];\n        }\n\n        int x;\n        cin >> x;\n\n        bool flag = false;\n        for (int i = 0; i < n * m; i++)\n        {\n            if (arr[i] == x)\n            {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag)\n        {\n            cout << \"will take number\" << endl;\n        }\n        else\n        {\n            cout << \"will not take number\" << endl;\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:40:38.087902+00:00"
      },
      "hints": {
        "hint1": "Use nested loop to itarate over rows and columns of the matrix.",
        "hint2": "Check for X with each element of the matrix.",
        "solution_approach": "Loop across the matrix using a nested loop and check for X.\n$ \\forall i \\in [0, N-1], \\forall j \\in [0, M-1], if (A[i][j] = X) $, you will have your answer.\nTime Complexity: $O(N*M)$"
      },
      "id": 1145,
      "input_format": "First line contains an integer $T$, the number of test cases.\nFirst line of each testcase contains $N$ and $M$ separated by space. Next $N$ lines contains $M$ space separated integers. Next line contains $X$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print $\\textbf{\"will take number\"}$ if the number doesn't exist in the 2D array otherwise, print $\\textbf{\"will not take number\"}$.",
      "samples": [
        {
          "input": "1\n2 2\n1 2\n3 4\n3\n",
          "output": "will not take number\n"
        },
        {
          "input": "2\n2 2\n1 2\n3 4\n3\n2 2\n1 2\n3 4\n10\n",
          "output": "will not take number\nwill take number\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Search in Matrix",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$ and an array $A$ of $N$ numbers. Print all array $ \\textbf{positions} $ that store a number less than or equal to $ \\textbf{10} $ and the $ \\textbf{number stored} $ in that position.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 2 \\leq N \\leq 10^3 $\n$ -10^5 \\leq A[i] \\leq 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        int A[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> A[i];\n        }\n\n        for (int i = 0; i < n; i++)\n        {\n            if (A[i] <= 10)\n            {\n                cout << \"A[\" << i << \"] = \" << A[i] << \"\\n\";\n            }\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:32:01.758748+00:00"
      },
      "hints": {
        "hint1": "Try iterating through the array and comparing the current element with $10$.",
        "hint2": "",
        "solution_approach": "Loop through the array and, \n$ \\forall i \\in [0, N-1] $ if ($A[i] <= 10$) then print the element in given format.\nTime Complexity: $O(n)$"
      },
      "id": 1157,
      "input_format": "The first line contains $T$. The number of test cases.\nFor each testcase: The first line contains a number $ N $ , the number of elements.\nSecond line contains $ N $ numbers. \n$ \\textbf{it's guaranteed that there is at least one number in array less than or equal to 10.} $",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each number in the array that is equal to or less than $\\textbf{10}$ print a single line contains \"$A[i] = X$\", where $ \\textbf{i}$ is the $ \\textbf{position}$ in the array and $X$ is the number $ \\textbf{stored in the position}$.",
      "samples": [
        {
          "input": "1\n5\n1 2 100 0 30\n",
          "output": "A[0] = 1\nA[1] = 2\nA[3] = 0\n"
        },
        {
          "input": "2\n3\n11 12 3\n4\n1 2 3 4\n",
          "output": "A[2] = 3\nA[0] = 1\nA[1] = 2\nA[2] = 3\nA[3] = 4\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Position in Array",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string $S$. Print the $\\textbf{origin string}$ if it's $\\textbf{not too long}$ otherwise, print the $\\textbf{special abbreviation}$.\n\n$\\textbf{Note:}$ The string is called $\\textbf{too long}$, if its length is strictly more than $\\textbf{10}$ characters. If the string is $\\textbf{too long}$ then you have to print the string in the following manner:\n\n1. Print the $\\textbf{first}$ character in the string.\n2. Print number of characters between the first and the last characters.\n3. Print the $\\textbf{last}$ character in the string.\n\n$\\textbf{For example:}$ \"localization\" will be \"l10n\", and \"internationalization\" will be \"i18n\".",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 100 $ </br>\n$ 1 \\leq |S| \\leq 100 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string s; cin >> s;\n    if (s.size() <= 10) {\n        cout << s;\n    } else {\n        cout << s[0] << s.size() - 2 << s[s.size() - 1];\n    }\n    cout << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    int t; cin >> t;\n    while (t--) {\n        solution();\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:33:57.373998+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Check the size of the string if it's greater than 10 then print first character then rest size and then the last character."
      },
      "id": 1188,
      "input_format": "The first line contains a number $T$ number of test cases. </br>\nEach of the $T$ following lines contains a string $S$.\n$\\textbf{It's guaranteed that S contains only lowercase Latin letters.}$",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the result string.",
      "samples": [
        {
          "input": "4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n",
          "output": "word\nl10n\ni18n\np43s\n"
        },
        {
          "input": "5\narijit\nbiswas\narijitbiswas\nbiswasarijit\narijitarijitbiswasbiswas\n",
          "output": "arijit\nbiswas\na10s\nb10t\na22s\n"
        },
        {
          "input": "2\ncodeforces\nalgozenith\n",
          "output": "codeforces\nalgozenith\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Way Too Long Words",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$, and $N$ numbers, find **maximum** number in these $N$ numbers.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N \\leq 10^3 $\n$ 0 \\leq X_i \\leq 10^9 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// O(N) time\n// O(1) space\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    int mx = -1;\n    // all elements greater than -1, so initialising it as -1 allows it to get modified as we process the input\n    // this stores the maximum element in the sequence\n    for (int i = 0; i < n; i++) // can be done while taking in the input\n    {\n        int y;\n        cin >> y;\n        if (y > mx) // update\n            mx = y;\n    }\n\n    cout << mx << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:36:06.349034+00:00"
      },
      "hints": {
        "hint1": "A value which is equal to at least one element will be the maximum of the array. Can you check whether an element is maximum or not for all elements?",
        "hint2": "",
        "solution_approach": "Naively, checking for each element, whether it is maximum or not, takes $O(N^2)$ time and $O(N)$ space, as you can stop your search once you find a maximum element.\n\nHowever, we can store the current max found till now, iterating the array from $0th$ index and the maximum after the $Nth$ iteration will be our answer. The space complexity will be $O(1)$ and time complexity will be $O(N)$."
      },
      "id": 1215,
      "input_format": "First line contains a number $N$.\nSecond line contains $N$ numbers $X_i (1 \\le i \\le N)$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first sample, $8$ is the maximum element $1$.\nFor the second sample, both the elements are $2$ and it is maximum.",
      "output_format": "Print the **maximum** number.",
      "samples": [
        {
          "input": "5\n1 8 5 7 5\n",
          "output": "8\n"
        },
        {
          "input": "2\n2 2\n",
          "output": "2\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Max",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string $S$. Print the string $S$ from the beginning to the first \"\\\\\" character without printing the \"\\\\\".\n\n$\\textbf{Hint:}$ use function $\\textbf{getline(cin, s)}$.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq |S| \\leq 10^6 $ where |S| is the length of the string.",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string s;\n    getline(cin, s);\n    for (auto c : s) {\n        if (c == 92) {\n            break;\n        }\n        cout << c;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:47:09.792196+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Check the characters in the string is alphabet or not if yes then print them if you get \"\\\\\" this don't print any more characters."
      },
      "id": 1184,
      "input_format": "Only one line contains a string $S$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the answer required above.",
      "samples": [
        {
          "input": "Egyptian collegiate programming\\ contest\n",
          "output": "Egyptian collegiate programming\n"
        },
        {
          "input": "google \\or facebook\n",
          "output": "google\n"
        },
        {
          "input": "Codeforces Atcoder\\ Codechef\n",
          "output": "Codeforces Atcoder\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Let's Use Getline",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an <i>array</i> of <i>N</i> positive integers. You can perform this operation any number of times, choose two indices x and y. If array[x] = a and array[y] = b, then after the operation</p><p>1. array[x] = a OR b, array[y] = a AND b.</p><p>Perform the operations optimally such that ∑array[i]*array[i] for all 1&lt;=i&lt;=n is maximum. Print the largest sum of squares you can get after performing the operations greater than equal to zero times.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n//One of the another approach in which I am simulating the whole process.\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nsigned main()\n{\n   ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\n   int testcases;\n   cin>>testcases;\n   while(testcases--){\n\n       vector < ll > bit[20];\n       ll n;\n       cin>>n;\n       vector < ll > arr(n);\n       for(int i=0;i<n;i++)cin>>arr[i];\n       vector < ll > done(n+1,0);\n       for(int i=0;i<n;i++){\n           for(int j=0;j<20;j++){\n               if(arr[i]&(1<<j))\n                   bit[j].push_back(i);  // push in bit[i] all the index which have ith bit on.\n           }\n       }\n       ll k = 19;  \n       while(k>=0){   // Greedily increasing the value of every number, starting from the most significant digit\n           if(bit[k].size()){\n               ll x = bit[k][bit[k].size()-1]; // taking a element which may or may not have the kth bit set as it might be changed.\n               bit[k].pop_back();\n               if(done[x] or !((1<<k)&arr[x])) // if it is already done or bit is not set then continue\n                   continue;\n               done[x] = 1;  // trying to increase the value as much as I can using the lower bits.\n               for(int i = 0;i<k+1;i++){\n                   if(arr[x]&(1<<i)) // it bit is already set then continue\n                       continue;\n                   while(bit[i].size()){  // find a index which has this bet set, then apply the operation to increase the value of x.\n                       ll y = bit[i][bit[i].size()-1];\n                       bit[i].pop_back();\n                       if(done[y] or !((1<<i)&arr[y]))\n                           continue;\n\n                       ll temp = arr[y];\n                       arr[y] = arr[y]&arr[x];  // because of this operation the set bit of arr[y] can be unset.\n                       arr[x]|=temp;\n                       break;\n                   }\n               }\n           }\n           else\n               k--;\n\n       }\n       ll ans=0;\n       for(int i=0;i<n;i++)ans+=arr[i]*arr[i];\n       cout<<ans<<\"\\n\";\n   }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:39:08.945009+00:00"
      },
      "hints": {
        "hint1": "<p>Observe the operations, after the operation, a + b = a XOR b + 2*(a AND b) as well as a + b = a OR b + a AND b. So the sum is constant even after performing the operation.</p>",
        "hint2": "<p>If the sum is constant and you have to maximize the sum of squares, then it is always optimal to increase the largest value as much as you can, then increase the 2nd largest value and so on.</p>",
        "solution_approach": ""
      },
      "id": 52,
      "input_format": "<p>The first line of the input contains a single integer <i>T</i> denoting the number of test cases, <i>(1&lt;=T&lt;=100)</i>.</p><p>The first line of each test case contains a single integer <i>N</i>, <i>(2&lt;=N&lt;=100000)</i>.</p><p>The second line contains <i>N</i> space-separated integers A<sub>1</sub>,A<sub>2</sub>,…,A<sub>N</sub>, <i>(1&lt;=A<sub>i</sub>&lt;=10^6)</i>.</p><p>Sum of <i>N</i> over all test cases does not exceed <i>10^6</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>For each test case output a single integer representing the largest possible sum of squares that can be achieved after several (possibly zero) operations.</p>",
      "samples": [
        {
          "input": "5\n2\n2 5\n3\n1 2 3\n5\n1 2 3 4 5\n1\n1234\n10\n2 5 234 3454 3423 34545 65433 654345 9876 76567",
          "output": "49\n18\n99\n1522756\n448865876262"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Bitwise Operations",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two numbers $A$ and $B$. Print the **greatest common divisor** between $(A, B)$.\n\n**Note:** The greatest common divisor (**GCD**) of two or more integers, which are not all zeroes, **is the largest positive integer that divides each of the integers.**\n\nFor example:\n\nthe **GCD** of **$8$** and **$12$** is **$4$**.\n\nbecause the numbers that divides both **$8$** and **$12$** are **$(1,2,4)$** and **$4$** is the largest one .",
      "complete_approach": "",
      "constraints": "$ 1 \\leq A, B \\leq 10^3 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int a, b;\n    cin >> a >> b;\n\n    if (a < b)\n        swap(a, b);\n\n    while (b != 0)\n    {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    cout << a << \"\\n\";\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:34:43.531370+00:00"
      },
      "hints": {
        "hint1": "You can do it naively by enumerating factors of both A and B and looking for largest common factor. This will take $O(\\sqrt{A+B})$ time.",
        "hint2": "",
        "solution_approach": "We can use euclidean algorithm to find the GCD of two numbers. The algorithm is as follows:\n\n```\ngcd(A, B) = gcd(B, A mod B)\n```\n\nThe complete pseudo code is as follows:\n\n```\nfunction gcd(A, B)\n\twhile B ≠ 0\n\t   T := B\n\t   B := A mod B\n\t   A := T\n\treturn A\n```\n\nThe time complexity of this algorithm is $O(log(min(A,B)))$ and space complexity is $O(1)$."
      },
      "id": 1206,
      "input_format": "Only one line containing two numbers $A$ and $B$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "**Note**\nWhat is the greatest common divisor of **$54$ and $24$**?\n\nThe number $54$ can be expressed as a product of two integers in several different ways:\n\n$54 * 1 = 27 * 2 = 18 * 3 = 9 * 6 .....$\n\nThus the divisors of $54$ are: **$1,2,3,6,9,18,27,54$**\n\nSimilarly, the divisors of $24$ are: $1,2,3,4,6,8,12,24$\n\nThe numbers that these two lists share in common are **the common divisors of $54$ and $24$:**\n\n$1,2,3,6$\n\nThe greatest of these is $6$. That is, the greatest common divisor of $54$ and $24$. One writes:\n\n**gcd($54,24$) = $6$.**",
      "output_format": "Print the **GCD** of $A$ and $B$.",
      "samples": [
        {
          "input": "12 8\n",
          "output": "4\n"
        },
        {
          "input": "3 7\n",
          "output": "1\n"
        },
        {
          "input": "5 10\n",
          "output": "5\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Gcd",
      "video_editorial_id": 10692
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Write a C++ program to print the first $N$ rows where $i^{th}$ row contains the first $i$ capital letters.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 26 $\n$ 1 \\leq N \\leq 26 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n\n  for (int tt = 1; tt <= t; tt++) {\n    int rows;\n    cin >> rows;\n    for (int k = 0; k < rows; k++) {\n      for (int i = 0; i <= k; i++) {\n        cout << char('A' + i);\n      }\n      cout << \"\\n\";\n    }\n  }\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:28:49.436653+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 1090,
      "input_format": "The first line contains the number $T$ of test cases. \nFor each test case: There is only one line containing $N$, which is the number of rows in the pattern.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the pattern.",
      "samples": [
        {
          "input": "1\n1\n",
          "output": "A\n"
        },
        {
          "input": "1\n5\n",
          "output": "A\nAB\nABC\nABCD\nABCDE\n"
        },
        {
          "input": "2\n4\n7\n",
          "output": "A\nAB\nABC\nABCD\nA\nAB\nABC\nABCD\nABCDE\nABCDEF\nABCDEFG"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Alphabetical Pattern",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Find the minimum number of edges to be deleted to make a Directed Graph a DAG (directed acyclic graph).</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nbool isEdge[15][15];\nint dp[(1<<15)];\nint n;\n\nint dfs(int vis) {\n    int pos = __builtin_popcount(vis);\n    if(pos == n) {\n        return 0;\n    }\n    if(dp[vis] != -1) {\n        return dp[vis];\n    }\n    int ans = 2e18;\n    for (int i = 0; i < n; ++i) {\n        if((vis & (1<<i)) == 0) {\n            int temp = 0;\n            for (int j = 0; j < n; ++j) {\n                if(vis & (1<<j)) {\n                    temp += isEdge[i][j];\n                }\n            }\n            ans = min(ans, dfs(vis | (1<<i)) + temp);\n        }\n    }\n\n    dp[vis] = ans;\n    return ans;\n}\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        cin >> n;\n        for (int j = 0; j < (1<<n); ++j) {\n            dp[j] = -1;\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cin >> isEdge[i][j];\n            }\n        }\n        cout << dfs(0) << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:43:16.803694+00:00"
      },
      "hints": {
        "hint1": "<p>We need to make the directed graph, acyclic. This can be done by removing any cycles in the graph. It would be difficult to think in terms of finding cycles and then removing the edges. Can you use topological sorting to find the cycles?</p>",
        "hint2": "<p>If we find the topological sorting of a graph, the back edges, i.e. any edge from j to i (i &lt; j), if removed will result in a DAG. But there are multiple number of topological sortings present in a graph, so you need to consider all of them and find the minimum edges to remove.</p>",
        "solution_approach": "<p>We would make the DP array as DP[pos][vis] which denotes the minimum edges to delete to make the graph DAG, pos denotes the current vertex we are at and vis denotes the subset of vertices we have visited. When we need to assign a vertex to the current position, we need to ensure that the vertex has not been visited and for finding the back edges from i to the vertices already visited, we would use another loop and check this.</p><p>Optimisation similar to the problem Chess and GCD can be made here. The current vertex, pos would be equal to the number of vertices we have already visited, so the DP array can be made as DP[vis].</p><p>Time Complexity per test case: O(N^2 * 2^N)</p>"
      },
      "id": 457,
      "input_format": "<p>The first line contains an integer T (1 ≤ T ≤ 50) - the number of testcases.</p><p>The first line of each test case contains an integer N. 1 ≤ N ≤ 15.</p><p>The next N lines contains N space-separated integers, IsEdge[i][j] which denotes if there is an edge from node i to node j. IsEdge[i][j] = 0 if there is no edge from node i to node j and IsEdge[i][j] = 1 if there is an edge from node i to node j.</p><p><strong>Given graph is directed.</strong></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the output in a new line.</p>",
      "samples": [
        {
          "input": "10\n8\n1 0 0 1 1 0 0 0\n0 0 0 1 1 0 0 0\n0 1 1 0 1 0 0 0\n0 0 0 1 1 0 0 0\n1 0 0 0 0 0 1 1\n0 0 0 0 0 1 1 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 1\n5\n1 1 0 0 0\n0 1 0 1 1\n0 1 0 1 1\n0 1 0 0 0\n0 0 1 1 1\n2\n0 1\n0 0\n6\n0 1 0 0 1 0\n0 1 0 0 0 1\n0 1 0 0 0 0\n0 0 0 1 0 0\n0 0 0 0 0 0\n1 0 0 0 1 1\n11\n0 1 0 0 0 0 1 1 0 0 0\n1 0 0 0 0 0 0 0 0 0 0\n0 0 1 0 1 0 0 1 1 1 1\n0 0 0 0 1 0 1 1 0 0 1\n1 0 1 1 0 0 0 1 0 0 1\n1 0 0 0 0 0 0 0 0 0 0\n0 1 0 0 0 0 0 0 0 0 0\n0 0 1 0 0 1 0 0 0 0 0\n0 1 0 0 0 1 0 0 0 0 1\n0 0 0 0 0 0 0 0 1 1 0\n1 1 1 0 0 0 0 0 0 0 1\n2\n1 1\n0 0\n4\n0 0 1 1\n0 0 0 0\n1 1 0 0\n1 0 0 0\n5\n0 1 0 0 0\n1 0 0 0 1\n0 0 0 0 1\n0 0 0 1 0\n1 0 1 0 0\n3\n0 0 0\n0 0 0\n0 0 0\n8\n0 0 0 0 0 1 0 0\n0 1 0 0 0 0 0 0\n1 0 0 0 0 0 0 1\n1 0 0 0 1 1 0 0\n0 0 0 0 0 0 1 0\n0 0 0 1 1 0 0 1\n0 0 1 0 0 0 1 0\n0 0 0 0 0 0 1 0 ",
          "output": "1\n2\n0\n1\n6\n0\n2\n2\n0\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Minimum Edge Deletion to make DAG",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given an array of integers. find the maximum XOR subarray value in the given array.",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nclass trieNode {\npublic:\n    int freq;\n    trieNode* left;\n    trieNode* right;\n    trieNode() {\n        freq = 0;\n        left = NULL;\n        right = NULL;\n    }\n};\n\nvoid insert(int n, trieNode* head) {\n    trieNode* cur = head;\n    for (int i = 31; i >= 0; --i) {\n        int bit = (n >> i)&1;\n        if(bit) {\n            if(!cur->right) {\n                cur->right = new trieNode();\n            }\n            cur = cur->right;\n            cur->freq++;\n        }\n        else {\n            if(!cur->left) {\n                cur->left = new trieNode();\n            }\n            cur = cur->left;\n            cur->freq++;\n        }\n    }\n}\n\nint findMaxXOR(int n, trieNode* head) {\n    trieNode* cur = head;\n    int ans = 0;\n    for (int j = 31; j >= 0; --j) {\n        int bit = (n >> j)&1;\n        if(bit) {\n            if(cur->left && cur->left->freq > 0) {\n                ans += (1<<j);\n                cur = cur->left;\n            }\n            else {\n                cur = cur->right;\n            }\n        }\n        else {\n            if(cur->right && cur->right->freq > 0) {\n                ans += (1<<j);\n                cur = cur->right;\n            }\n            else {\n                cur = cur->left;\n            }\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        int n;\n        cin >> n;\n        vector<int> v(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> v[i];\n        }\n        trieNode* head = new trieNode();\n        int pre = 0;\n        int ans = 0;\n        insert(0, head);\n        for (int i = 0; i < n; ++i) {\n            pre ^= v[i];\n            ans = max(ans, findMaxXOR(pre, head));\n            insert(pre, head);\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:33.613846+00:00"
      },
      "hints": {
        "hint1": "If you make a prefix array of xors, prefix[r]^prefix[l-1] will give the xor of the subarray (l,r). This will take O(N^2) if we consider each subarray. Can you implement the same using tries?",
        "hint2": "",
        "solution_approach": "<p>You need to insert the prefix xors while traversing through the trie, at any i, the trie will have all the prefix xors till (i-1). So you can check the maximum xor you can get by taking the current number, a(i) with any number present in the trie. Do this for all the indexes and take the maximum from them.</p><p>Time Complexity per test case: O(N*max(A<sub>i</sub>))</p>"
      },
      "id": 420,
      "input_format": "<p>The first line contains an integer T ( 1 ≤ T ≤ 10), the number of test cases.</p><p>The first line of each test case contains 2 space-separated integers N,1 ≤ N ≤ 10^5.</p><p>The second line of each test case contains N space-separated integers, 1≤ Ai ≤ 10^5</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the answer in a new line.</p>",
      "samples": [
        {
          "input": "3\n5\n1 2 3 4 5\n6\n7 14 6 8 6 65\n5\n74 14 5 6 9",
          "output": "7\n79\n78"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Max XOR Subarray",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Write a C++ program to print pyramid of height $N$. See sample examples.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 100 $\n$ 1 \\leq N \\leq 100 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n\n  for (int tt = 1; tt <= t; tt++) {\n    int rows;\n    cin >> rows;\n    for (int i = 1, k = 0; i <= rows; ++i, k = 0) {\n      for (int space = 1; space <= rows - i; ++space) {\n        cout << \"  \";\n      }\n      while (k != 2 * i - 1) {\n        cout << \"* \";\n        ++k;\n      }\n      cout << endl;\n    }\n  }\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:28:51.015771+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 1091,
      "input_format": "The first line contains the number $T$ of test cases. \nFor each test case: There is a line containing $N$ denoting the pyramid's height.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the pattern.",
      "samples": [
        {
          "input": "1\n2",
          "output": "  * \n* * *\n"
        },
        {
          "input": "1\n5",
          "output": "        * \n      * * * \n    * * * * * \n  * * * * * * * \n* * * * * * * * * "
        },
        {
          "input": "2\n4\n7",
          "output": "      * \n    * * * \n  * * * * * \n* * * * * * * \n            * \n          * * * \n        * * * * * \n      * * * * * * * \n    * * * * * * * * * \n  * * * * * * * * * * * \n* * * * * * * * * * * * * "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Pyramid Pattern",
      "video_editorial_id": 10666
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two numbers $X$ and $Y$. Print the sum of all **odd numbers** between them, excluding $X$ and $Y$.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq X,Y  \\leq 10^4 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// O(1) time complexity\n// O(1) space complexity\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int x, y;\n        cin >> x >> y;\n        // if x is greater than y swap them\n        if (x > y)\n            swap(x, y);\n        /* we now try to modify x and y st the sum we are looking for includes x and y*/    \n        if (x % 2) // if odd we know next odd that will start the sum is x+2\n            x += 2;\n        else    // similarly if even\n            x += 1;\n        if (y % 2)// if odd we know last odd that ends sum is y-2\n            y -= 2;\n        else    // similarly if even\n            y -= 1;\n        int d = (y - x) / 2;// d is difference , and d+1 is the number of elements\n        // we are trying to model the sum as\n        // x, x+2, x+4,....y\n        // so subtract x from all\n        // x*(d+1) + 0+2+4+y-x\n        // x*(d+1) + 2(0+1+2+(y-x)/2)\n        // x*(d+1) + (d)*(d+1)\n        // (x+d)*(d+1)\n        if (d < 0) // if nothing exists in between print 0\n            cout << \"0\\n\";\n        else\n            cout << d * (d + 1) + x * (d + 1) << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:35:12.173561+00:00"
      },
      "hints": {
        "hint1": "You can simply iterate between $X$ and $Y$ and sum the odd numbers. The time complexity will be $O(X-Y)$ per test case (assuming $X \\geq Y$).",
        "hint2": "",
        "solution_approach": "We can solve the problem in $O(1)$ time per test case.\n\nSuppose $X \\leq Y$, if not, we swap them. Then we modify $X$ and $Y$ such that $X$ and $Y$ are **odd**, and we are summing from $X$ and $Y$ including $X$ and $Y$. Let $d = (X-Y)/2$, then $d+1$ is the **number of elements** we are summing. The sum can be written as $X,X+2,X+4,..,Y$ which is also equal to $X*(d+1)+0+2+4+..+(Y-X)$ which is further equal to $X*(d+1)+d*(d+1).$\nTherefore, the time complexity over all test cases is $O(T)$."
      },
      "id": 1212,
      "input_format": "First line contains a number $T$, the number of test cases.\nNext $T$ lines will contain two numbers $X$ and $Y$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first sample, there are **three** test cases.\nFor the first test case, there are no odd numbers between $5$ and $6$.\nFor the second test case, there are $3$ odd numbers between $10$ and $4$, i.e. $5, 7$ and $9$. Hence the sum is $21$.\nFor the third test case, there are $2$ odd numbers between $4$ and $9$, i.e. $5$ and $7$. Hence the sum is $12$.",
      "output_format": "Print the sum of all odd numbers between $X$ and $Y$.",
      "samples": [
        {
          "input": "3\n5 6\n10 4\n4 9\n",
          "output": "0\n21\n12\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Sum of Consecutive Odd Numbers",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Given an unsigned integer <i>N</i> you have to swap all odd bits with even bits. For example, 53 (<strong>1</strong>1<strong>0</strong>1<strong>0</strong>1) is converted to 58 (1<strong>1</strong>1<strong>0</strong>1<strong>0).</strong></span></p><p>Try to do it in O(1).</p>",
      "complete_approach": "",
      "constraints": "<p><i>1 ≤ T ≤ 10<sup>5</sup></i><br><i>1 ≤ N ≤ 10<sup>8</sup></i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int even_mask = 0xAAAAAAAA, odd_mask = 0x55555555;\n       \n        int even_bits = n & even_mask, odd_bits = n & odd_mask;\n        \n        even_bits >>= 1;\n        odd_bits <<= 1;\n        \n        cout << (even_bits | odd_bits) << '\\n';\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:18:57.407230+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Can you come up with some bit wise operations to solve each test case in constant time?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Left shift the even bits and right shift the odd bits</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Extract the even and odd bits of <i>N</i> using <i><strong>0xAAAAAAAA</strong></i> (32-bit integer with even-bits set as 1 and odd-bits 0) and <i><strong>0x55555555</strong></i> (32-bit integer with odd-bits set as 1 and even-bits 0). Left shift the even-bits so that they become odd-bits and right shift the odd-bits so that they become the even-bits. The bit wise OR of these bits gives the final answer.</span></p>"
      },
      "id": 600,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains <i>T</i> - the number of test cases.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>T</i> lines follow each containing a single integer <i>N.</i></span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">1 (01) -&gt; 2 (10)</span><br><span style=\"background-color:transparent;color:#000000;\">2 (10) -&gt; 1 (01)</span><br><span style=\"background-color:transparent;color:#000000;\">3 (11) -&gt; 3 (11)</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the modified integer for every test case in a new line.</span></p>",
      "samples": [
        {
          "input": "5\n1\n2\n3\n53\n23",
          "output": "2\n1\n3\n58\n43"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "SWAPBIT",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $Q$ and a string $S$. If $Q$ is equal to 1 then print $S$ after $\\textbf{encrypting}$ it otherwise, print $S$ after $\\textbf{decrypting}$ it.\n\nKey = \"PgEfTYaWGHjDAmxQqFLRpCJBownyUKZXkbvzIdshurMilNSVOtec#@\\_!=.+-\\*/\".\n\nOriginal = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".\n\n$\\textbf{Note:}$\n\n1. In Encryption: For each letter x in \"$\\textbf{Original}$\" replace it by the equivalent letter y from \"$\\textbf{Key}$\"\n2. In Decryption: For each letter y in \"$\\textbf{Key}$\" replace it by the equivalent letter x from \"$\\textbf{Original}$\".\n3. Key and Original have the same length.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq Q \\leq 2 $\n$ 1 \\leq |S| \\leq 10^5 $ where |S| is the length of the string and it consists of $\\textbf{lowercase}$ and $\\textbf{uppercase}$ English letters.",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string key = \"PgEfTYaWGHjDAmxQqFLRpCJBownyUKZXkbvzIdshurMilNSVOtec#@_!=.+-*/\";\n    string original = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    int flag; cin >> flag;\n    string s; cin >> s;\n    int n = s.size(), z = 0;\n    if (flag == 1) {\n        for (int i = 0; i < n; i++) {\n            for (z = 0; z < original.size(); z++) {\n                if (s[i] == original[z]) {\n                    break;\n                }\n            }\n            cout << key[z];\n        }\n    } else {\n        for (int i = 0; i < n; i++) {\n            for (z = 0; z < key.size(); z++) {\n                if (s[i] == key[z]) {\n                    break;\n                }\n            }\n            cout << original[z];\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:34:34.384553+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "If the query is 1 then find ith character of S in Original and print that index element of Key. Just do opposite for query 2."
      },
      "id": 1202,
      "input_format": "The first line contains a number $Q$.\nThe second line contains a string $S$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the answer required above.",
      "samples": [
        {
          "input": "1\nEgypt\n",
          "output": "ZaoQR\n"
        },
        {
          "input": "2\n#@_!=.+-*/\n",
          "output": "0123456789\n"
        },
        {
          "input": "2\nZaoQR\n",
          "output": "Egypt\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Encrypt And Decrypt Message",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given two sets, A and B of N and M integers respectively. There are no duplicate integers in each respective array. Find the set union, set intersection and set difference (A-B) of the two sets in sorted order.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ N, M ≤ 10^4</span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ A<sub>i</sub>, B<sub>i</sub> ≤ 10<sup>9</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of N and the sum of M over all test cases does not exceed 2*</span><span style=\"background-color:#ffffff;color:#000000;\">10^5</span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n, m;\n    cin >> n >> m;\n    set<int> uni, inter, diff;\n    for (int i = 0; i < n; ++i) {\n      int x;\n      cin >> x;\n      uni.insert(x);\n      inter.insert(x);\n      diff.insert(x);\n    }\n    set<int> inters;\n    for (int i = 0; i < m; ++i) {\n      int x;\n      cin >> x;\n      uni.insert(x);\n      if (inter.find(x) != inter.end()) {\n        inters.insert(x);\n      }\n      if (diff.find(x) != diff.end()) {\n        diff.erase(x);\n      }\n    }\n    for (int i : uni) {\n      cout << i << \" \";\n    }\n    cout << \"\\n\";\n    for (int i : inters) {\n      cout << i << \" \";\n    }\n    cout << \"\\n\";\n    for (int i : diff) {\n      cout << i << \" \";\n    }\n    cout << \"\\n\";\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:45:13.237078+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "### Union :\n  Insert all the integers of A and B in `uni` set. Finally elements contained in `uni` contain the answer.\n### Intersection :\n Insert all integers of A in `inter` set and iterate through B to check if the element exists in `inter`. If yes keep that element, if not remove from `inter`. Finally `inter` stores the result.\n### Difference :\n For difference, insert all integers of A in `diff` set and erase all the integers of B if it exists in `diff` set.Finally `diff` stores the difference result.\n\nTime Complexity per test case: $O(N \\log N)$"
      },
      "id": 372,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains two space-separated integers N, M - the length of the sets.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The second line of each test case contains N space-separated integers.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The third line of each test case contains M space-separated integers.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the set union, set intersection and set difference (A-B) of the two sets&nbsp; in sorted order, each on a separate line.</span></p>",
      "samples": [
        {
          "input": "3\n4 5\n2 4 1 5\n4 5 6 9 3\n2 3\n4 5\n6 7 1\n3 3\n1 2 3\n1 2 3\n",
          "output": "1 2 3 4 5 6 9 \n4 5 \n1 2 \n1 4 5 6 7 \n\n4 5 \n1 2 3 \n1 2 3\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Set Operations AZ101",
      "video_editorial_id": 8189
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given $N$ numbers. Count how many of these values are **even**, **odd**, **positive** and **negative**.",
      "complete_approach": "",
      "constraints": "$ 1 ≤ N ≤ 10^3 $\n$-10^5 ≤ X_{i} ≤ 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// O(n) time\n// O(1) space\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\n    // odd, even, pos, neg\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        if (x % 2)\n            c1++;\n        else\n            c2++;\n        if (x > 0)\n            c3++;\n        else if (x < 0)\n            c4++;\n    }\n    cout << \"Even: \" << c2 << \"\\n\";\n    cout << \"Odd: \" << c1 << \"\\n\";\n    cout << \"Positive: \" << c3 << \"\\n\";\n    cout << \"Negative: \" << c4 << \"\\n\";\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:36:56.015245+00:00"
      },
      "hints": {
        "hint1": "A number can either be **even** or **odd**. Similarly it can either be **positive**, **negative** or **zero**.",
        "hint2": "",
        "solution_approach": "Maintain $4$ counters initialized with $0$. Traverse through the input and increment corresponding counter if the condition for it is met. The time complexity will be $O(N)$ but space complexity can be reduced to $O(1)$ if the output is calculated when taking the input."
      },
      "id": 1221,
      "input_format": "First line contains one number $N$, number of values.\nSecond line contains $N$ numbers where ith number from start is called $X_i$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "**First Example** :\n\nEven Numbers are : **0, -4 , 12**\n\nOdd Numbers are : **-5 , -3**\n\nPositive Numbers are : **12**\n\nNegative Numbers are : **-5 , -3 , -4**",
      "output_format": "Print four lines with the following format:\n\nFirst Line: \"Even: $X$\", where $X$ is the number of **even** numbers in the given input.\n\nSecond Line: \"Odd: $X$\", where $X$ is the number of **odd** numbers in the given input.\n\nThird Line: \"Positive: $X$\", where $X$ is the number of **positive** numbers in the given input.\n\nFourth Line: \"Negative: $X$\", where $X$ is the number of **negative** numbers in the given input.",
      "samples": [
        {
          "input": "5\n-5 0 -3 -4 12\n",
          "output": "Even: 3\nOdd: 2\nPositive: 1\nNegative: 3\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Even, Odd, Positive and Negative",
      "video_editorial_id": 10690
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a string <i>S</i> consisting of the lowercase character of length N. Score of a string is the number of unique characters present in the string( characters which are only present once in the string). Like score of \"character\" is 3 {h,t,e}.</p><p>Find the sum of the score of all substring of S.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nsigned main(){\n   ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);;\n   ll testcases;\n   cin>>testcases;\n   while(testcases--){\n       ll n;\n       cin>>n;\n       string s;\n       cin>>s;\n       vector < ll >  occurence[26];\n       for(ll i=0;i<26;i++)\n           occurence[i].push_back(-1);\n       for(ll i=0;i<n;i++)\n           occurence[s[i]-'a'].push_back(i);\n       for(ll i=0;i<26;i++)\n           occurence[i].push_back(n);\n       ll ans = 0;\n       for(ll i=0;i<26;i++){\n           for(ll j=1;j<(int)occurence[i].size()-1;j++){\n               ans+=(occurence[i][j]-occurence[i][j-1])*(occurence[i][j+1]-occurence[i][j]);\n           }\n       }\n       cout<<ans<<\"\\n\";\n   }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:28:39.373127+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Since the strings are made of only lowercase alphabets, we can calculate the contribution of each letter from ‘a’ to ‘z’ to the final answer.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">We need to calculate the contribution of each letter from ‘a’ to ‘z’ to the final answer. For the answer, we will consider the case for ‘a’, you need to do the same for each letter from ‘a’ to ‘z’. For a particular ‘a’ to contribute to the final answer, it should exist only once in the subarray (that is how it will become unique). So to calculate the number of subarrays having that ‘a’ only once, we can find its closest left ‘a’ and its closest right ‘a’. The left point of the subarray should be between the closest left ‘a’ and the current ‘a’ and similarly</span>,<span style=\"background-color:transparent;color:#000000;\"> the right point of the subarray should be between the current ‘a’ and the closest right ‘a’. To find the number of subarrays including current ‘a’, we can multiply the possible values of the left and right points. Do this for each character ‘a’ present in the string and then the same for each character from ‘a’ to ‘z’.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N)</span></p>",
        "solution_approach": ""
      },
      "id": 63,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases <i>(1&lt;=T&lt;=10)</i>.</p><p>The first line of each test case contains an integers <i>N, </i>size of the string, <i>1&lt;=N&lt;=10^5.</i></p><p>The second line of each test case contains a string <i>S</i> of length <i>N</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "<p><strong>For the 1st test case:</strong><br>Substring and score = (\"a\",1), (\"c\",1) (\"ac\",2).<br>Total score = 4</p><p><strong>For the 2nd test case:</strong><br>Substring and score = (\"a\",1), (\"aa\",0), (\"aac\",1), (\"a\",1), (\"ac\",2), (\"c\",1).<br>Total score = 6</p>",
      "output_format": "<p>For each test case print the sum of the score of all substring of <i>S</i> in a newline.</p>",
      "samples": [
        {
          "input": "5\n2\nac\n3\naac\n5\nabode\n5\naaaaa\n10\njdnbfjdhzw",
          "output": "4\n6\n35\n5\n194"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Count Unique Char in Substrings",
      "video_editorial_id": 8138
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two strings A and B. Print three lines contain the following:\n\n1. The size of the string A and size of the string B separated by a space\n2. The string produced by concatenating A and B (A + B).\n3. The two strings separated by a single space respectively, after swapping their first character.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq |A| \\leq 10 $ </br>\n$ 1 \\leq |B| \\leq 10 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string x, y;\n    cin >> x >> y;\n    cout << x.size() << \" \" << y.size() << endl;\n    cout << x + y << endl;\n    swap(x[0], y[0]);\n    cout << x << \" \" << y << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:33:51.075168+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "for size use .size() and for swap use swap() stls in c++."
      },
      "id": 1186,
      "input_format": "The first line contains a string $A$ where |A| is the length of A. </br>\nThe first line contains a string $B$ where |B| is the length of B.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the answer required above.",
      "samples": [
        {
          "input": "abcd\nef\n",
          "output": "4 2\nabcdef\nebcd af\n"
        },
        {
          "input": "abcde\nefghi\n",
          "output": "5 5\nabcdeefghi\nebcde afghi\n"
        },
        {
          "input": "a\nz\n",
          "output": "1 1\naz\nz a\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Strings",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two strings $S$ and $T$. Print a new string that contains the following:\n\n1. The first letter of the string $S$ followed by the first letter of the string $T$.\n2. the second letter of the string $S$ followed by the second letter of the string $T$.\n3. and so on...\n\nIn other words, the new string should be $(S0 + T0 + S1 + T1 + ....)$.\n$\\textbf{Note:}$ If the length of S is greater than the length of $T$ then you have to add the rest of $S$ lettersat the end of the new string and $\\textbf{vice versa}$.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N \\leq 50 $ </br>\n$ 1 \\leq |S|,|T| \\leq 50 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string s, t;\n    cin >> s >> t;\n    int s_size = s.size(), t_size = t.size();\n    int m = min(s_size, t_size);\n    string ans;\n    for (int i = 0; i < m; i++) {\n        ans += s[i];\n        ans += t[i];\n    }\n    for (int i = m; i < s_size; i++) {\n        ans += s[i];\n    }\n    for (int i = m; i < t_size; i++) {\n        ans += t[i];\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    int n; cin >> n;\n    while (n--) {\n        solution();\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:42:21.736319+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Just traverse the smallest size part in both the strings then traverse rest parts of both strings and add those characters."
      },
      "id": 1192,
      "input_format": "The first line contains a number $N$ the number of test cases.\nEach of the $N$ following lines contains two string $S, T$ consists of $\\textbf{lower}$ and $\\textbf{upper}$ English letters.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the required string.",
      "samples": [
        {
          "input": "2\nipAsu ccsit\ney gpt\n",
          "output": "icpcAssiut\negypt\n"
        },
        {
          "input": "1\narijit biswas\n",
          "output": "abriisjwiats\n"
        },
        {
          "input": "5\nBruce banner\nstephen Strange\nSteve Rogers\ntony stark\npeter parker\n",
          "output": "Bbrauncneer\nsStterpahnegne\nSRtoegveers\ntsotnayrk\nppeatrekrer\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "I Love Strings",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p><p>Complete the function:</p><p><i>vector&lt;int&gt; getPostorderTraversal(Node* root)</i></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n \n\nvoid postorderTraversal(Node* root, vector<int>&ans){\n   if(root==NULL)\n       return;\n   postorderTraversal(root->left,ans);\n   postorderTraversal(root->right,ans);\n   ans.push_back(root->val);\n}\n\nvector<int> getPostorderTraversal(Node* root) {\n   vector<int> ans;\n   if(root==NULL)\n       return ans;\n   postorderTraversal(root, ans);\n   return ans;\n}\n\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        vector<int> ans = getPostorderTraversal(tree);\n        for(auto v:ans){\n            cout<<v<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:18:37.878953+00:00"
      },
      "hints": {
        "hint1": "<p>First, go to the left tree and print the postorder traversal of the left tree.&nbsp;</p><p>Then go to the right tree and print the postorder traversal of the right</p><p>Then print the value of the current node.</p>",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 575,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, &nbsp;the length of the array representing the serialized representation of a tree.</p><p>The next line contains N-space-separated integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<pre><code class=\"language-cpp\">Test case 2- \n 5222\n    \\\n   3819\n    /\n  6801\n\t\nTest case 3 - \n   8901\n   /\n  7891\n   /   \\\n  5407 1720</code></pre>",
      "output_format": "<p>Return the postorder traversal of the tree.</p>",
      "samples": [
        {
          "input": "3\n3\n6004 -1 -1 \n7\n5222 -1 3819 6801 -1 -1 -1 \n9\n8901 7891 5407 -1 -1 1720 -1 -1 -1 ",
          "output": "6004 \n6801 3819 5222 \n5407 1720 7891 8901 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n</fix>\n\nvector<int> getPostorderTraversal(Node* root) {\n    //Complete the function\n}\n\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        vector<int> ans = getPostorderTraversal(tree);\n        for(auto v:ans){\n            cout<<v<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Postorder Traversal",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Write a C++ program to print hollow rectangle pattern of $N$ length and $M$ width using for loop.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 100 $\n$ 2 \\leq N, M \\leq 200 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n\n  for (int tt = 1; tt <= t; tt++) {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n      cout << \"*\";\n    }\n    cout << \"\\n\";\n    for (int i = 0; i < n - 2; ++i) {\n      cout << \"*\";\n      for (int i = 0; i < m - 2; ++i) {\n        cout << \" \";\n      }\n      cout << \"*\\n\";\n    }\n    for (int i = 0; i < m; ++i) {\n      cout << \"*\";\n    }\n    cout << \"\\n\";\n  }\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:39:14.612956+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "The first and last lines are exceptional cases.\nIn all other lines, the characters have to only be printed at the first and  $M^{th}$ columns.\nRefer to the editorial code."
      },
      "id": 1089,
      "input_format": "The first line contains the number $T$ of test cases. \nFor each testcase: There is line which contains the $2$ numbers - $N$ and $M$, which is the length and width of the rectangle. Look at samples for more clarity.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the pattern.",
      "samples": [
        {
          "input": "1\n2 2\n",
          "output": "**\n**\n"
        },
        {
          "input": "1\n4 5\n",
          "output": "*****\n*   *\n*   *\n*****\n"
        },
        {
          "input": "2\n4 4\n4 4\n",
          "output": "****\n*  *\n*  *\n****\n****\n*  *\n*  *\n****\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Hollow Pattern",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You recently bought a new mobile phone. There are N applications in the phone and all generate notifications. There are 3 types of events\n\n1. 1 X - A new notification is generated by application X\n2. 2 X - You read all notifications by application X, you may re-read some notifications\n3. 3 Y - You read the first Y notifications in the phone. Note that you don’t read the first Y unread notifications, you just read the first Y notifications and you might re-read a few notifications. It is guaranteed that there have been Y notifications before this. \nAfter every event, find the number of unread notifications in the mobile phone.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$1 \\leq N, Q \\leq 10^5$  \n\n$1 \\leq Z \\leq 3$  \n\n$1 \\leq X \\leq N$  \n\n$1 \\leq Y \\leq Q$  \n\nIt is guaranteed that the sum of $N$ and the sum of $Q$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n, q1;\n    cin >> n >> q1;\n    // Create a queue to store all notification\n    queue<pair<int, int>> q;\n    // Create a queue for each application\n    queue<int> q2[n + 1];\n    int cur = 0;\n    bool mark[q1 + 1] = {};\n    int i = 1;\n    while (q1--) {\n      int t, x;\n      cin >> t >> x;\n      if (t == 1) {\n        // Push notifiation with query id in application x\n        q2[x].push(i);\n        // Push notification in a queue\n        q.push({i, x});\n        cur++;\n        i++;\n      } else if (t == 2) {\n        // Empty all notifications from queue x\n        while (!q2[x].empty()) {\n          int y = q2[x].front();\n          // Pop the notification and marked it as 1\n          q2[x].pop();\n          mark[y] = 1;\n          cur--;\n        }\n      } else {\n        // Pop notification from q until it's id <= x\n        while (!q.empty() && q.front().first <= x) {\n          int a = q.front().first;\n          int b = q.front().second;\n          // Pop notification from queue\n          q.pop();\n          // If the notification is not already popped out, then popped it from\n          // that application queue as well.\n          if (!mark[a]) {\n            mark[a] = 1;\n            q2[b].pop();\n            cur--;\n          }\n        }\n      }\n      cout << cur << \"\\n\";\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:46:03.855205+00:00"
      },
      "hints": {
        "hint1": "Store the unread notifications for each application in separate queues and store a separate queue of pair for storing all the notifications with the application number and query number.",
        "hint2": "",
        "solution_approach": "For event of type $1$, increase the number of unread notifs by $1$ and add (query number, $x$) to $Q$. Also add the query in the application queue for $x$. For event of type $2$, mark and pop all numbers in the application queue for $x$. Also decrease the number of unread notifs by $1$. For event of type $3$, pop the queue until the $y$-th notification, it is unread, decrease the number of unread notifs by $1$.\n\nTime Complexity per test case: $O(Q)$"
      },
      "id": 382,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains two space-separated integers N Q - the number of applications and the number of queries.\n\nEach of the next Q lines contains two space-separated integers Z X or Z Y - the description of each event.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case,\n\n1. Application 1 generates a notification\n2. Application 3 generates a notification\n3. Read the first 2 notifications.\n4. Read all notifications by application 1\n\nFor the second test case, \n\n1. Application 4 generates a notification\n2. Application 3 generates a notification\n3. Application 5 generates a notification\n4. Read the first 3 notifications\n5. Application 2 generates a notification\n6. Read all notifications by application 4",
      "output_format": "For each test case, find the number of unread notifications in the mobile phone after every event.",
      "samples": [
        {
          "input": "2 \n3 4 \n1 1 \n1 3 \n3 2 \n2 1 \n5 6 \n1 4 \n1 3 \n1 5 \n3 3 \n1 2 \n2 4",
          "output": "1\n2\n0\n0\n1\n2\n3\n0\n1\n1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Mobile Notifications AZ101",
      "video_editorial_id": 8194
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$. Print all the **divisors** of $N$ in ascending order.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N \\leq 10^4 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// O(root(N)) time\n//  O(root(N)) space\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    // stores the divisors uptil root(N)\n    vector <int> v;\n    for (int i = 1; i * i <= n; i++)\n    {\n        if (n % i == 0)\n        {\n            cout << i << \"\\n\";\n            // dont add to vector if square root as already printed\n            if (i == n / i)\n                continue;\n            v.push_back(n / i);\n        }\n    }\n    // traverse in reverse order since need smaller quotient first, so larger divisor chosen first\n    for (int i = v.size() - 1; i >= 0; i--)\n    {\n        cout << v[i] << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:34:41.800070+00:00"
      },
      "hints": {
        "hint1": "What can be the **minimum** and **maximum** divisor of a number?",
        "hint2": "",
        "solution_approach": "We can simply iterate over all numbers from $2$ to $N-1$ and check if it divides $N$, since we know the minimum divisor is $1$ and maximum divisor is $N$. The time complexity for this approach is $O(N)$ and space complexity $O(1)$.\n\nHowever we can also improve its complexity to $O(\\sqrt{N})$. We first compute the divisors upto $\\sqrt{N}$ and store them in a **vector**. We can then print the **quotient** of dividing these divisors traversing the vector in **reverse order**. This takes $O(\\sqrt{N})$ time and $O(\\sqrt{N})$ space."
      },
      "id": 1205,
      "input_format": "Only one line containing a number $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first sample, $1,2,3$ and $6$ divide $6$ and hence printed accordingly.\n\nSimilarly for other samples.",
      "output_format": "Print all **positive divisors** of $N$, one number per line.",
      "samples": [
        {
          "input": "6\n",
          "output": "1\n2\n3\n6\n"
        },
        {
          "input": "7\n",
          "output": "1\n7\n"
        },
        {
          "input": "4\n",
          "output": "1\n2\n4\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Divisors",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string S. Determine how many times does each letter $\\textbf{occurred}$ in $S$.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq |S| \\leq 10^7 $ where $|S|$ is the length of the string and it consists of only $\\textbf{lowercase}$ English letters.",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string s; cin >> s;\n    int n = s.size();\n    int arr[26] = {0}; // initializes whole array with zero\n    for (int i = 0; i < n; i++) {\n        arr[s[i] - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n        if (arr[i]) {\n            cout << (char)(i + 'a') << \" : \" << arr[i] << endl;\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:34:06.720576+00:00"
      },
      "hints": {
        "hint1": "Use hashing.",
        "hint2": "Do you really need a hashmap to solve?",
        "solution_approach": "Use a array of sized 26 to hash the string characters because there are only 26 characters in english."
      },
      "id": 1191,
      "input_format": "Only one line contains the string $S$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each character that appears in $S$, print a single line that contains the following format: $\"X : Y\"$ where $X$ is the letter and $Y$ is the number of times that letter $X$ occurred in $S$.",
      "samples": [
        {
          "input": "aaabbc\n",
          "output": "a : 3\nb : 2\nc : 1\n"
        },
        {
          "input": "regff\n",
          "output": "e : 1\nf : 2\ng : 1\nr : 1\n"
        },
        {
          "input": "abcdef\n",
          "output": "a : 1\nb : 1\nc : 1\nd : 1\ne : 1\nf : 1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Count Letters",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "For a given integer $N$, print the pattern as shown in the examples below.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10$\n$1 \\leq N \\leq 10^2$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  // including all the test cases\n  int t;\n  cin >> t;\n\n  while (t--) {\n    int n, i, j;\n    cin >> n;\n\n    // printing the first n rows\n    for (i = 1; i <= n; i++) {\n      // iterating over every column\n      for (j = 1; j <= 2 * n - 1; j++) {\n        if (j <= i || j >= 2 * n - i)\n          cout << \"*\";\n        else\n          cout << \" \";\n      }\n\n      cout << \"\\n\";\n    }\n\n    // printing the next n-1 rows\n    for (i = 1; i < n; i++) {\n      // iterating over every column\n      for (j = 1; j <= 2 * n - 1; j++) {\n        if (j <= n - i || j >= n + i)\n          cout << \"*\";\n        else\n          cout << \" \";\n      }\n\n      cout << \"\\n\";\n    }\n\n    // spacing between different test cases\n    cout << \"\\n\";\n  }\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:28:58.687586+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 1093,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\nThe first line of each test case contains the integer $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the desired pattern. Add an empty line after each test case.",
      "samples": [
        {
          "input": "2\n3\n4\n",
          "output": "*   *\n** **\n*****\n** **\n*   *\n\n*     *\n**   **\n*** ***\n*******\n*** ***\n**   **\n*     *\n"
        },
        {
          "input": "2\n1\n2\n\n",
          "output": "*\n\n* *\n***\n* *\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Butterfly Pattern",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$. Print a pyramid that has $N$ rows.\n\n**For more clarification see the example below.**",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N \\leq 99 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// O(N^2) time complexity\n// O(1) space complexity\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    // to decide how much gap before \"*\"\n    int jump = n - 1;\n    // to decide how much times to print \"*\"\n    int times = 1;\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < jump; j++)\n        {\n            cout << \" \";\n        }\n        for (int j = 0; j < times; j++)\n        {\n            cout << \"*\";\n        }\n        cout << \"\\n\";\n        jump -= 1;\n        times += 2;\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:35:13.766858+00:00"
      },
      "hints": {
        "hint1": "Try find pattern as a function of a particular row number. Notice spaces decrease gradually and stars increase linearly.",
        "hint2": "",
        "solution_approach": "In the structure, the number of spaces in first row before star is $N-1$, in second row is $N-2$, .. and so on. Similarly, the number of stars in first row is $1$, in second row is $3$, in third row is $5$, ..and so on. So, we can print the spaces and stars in each row using two nested loops. The outer loop is used to handle the **number of rows** and the inner loop is used to handle the number of spaces and stars in each row. There a total of N rows, each row having $O(N)$ **characters** to print. So the time complexity is $O(N^2)$ and space complexity is $O(1)$."
      },
      "id": 1213,
      "input_format": "Only one line containing a number $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the answer according to the required above.",
      "samples": [
        {
          "input": "4\n",
          "output": "   *\n  ***\n *****\n*******\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Shape2",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $𝑁$ and an array $𝐴$ of $𝑁$ numbers. Determine if it's $ \\textbf{palindrome} $ or $ \\textbf{not} $.\n\n$ \\textbf{Note:} $\n\nAn array is called $ \\textbf{palindrome} $ if it reads the same backward and forward, for example, arrays { $ \\textbf{1} $ } and { $ \\textbf{1,2,3,2,1} $ } are $ \\textbf{palindromes} $, while arrays { $ \\textbf{1,12} $ } and { $ \\textbf{4,7,5,4} $ } are not.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N \\leq 10^5 $\n$ 1 \\leq A[i] \\leq 10^9 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n];\n        bool pal = true;\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n\n        for (int i = 0; i < n/2; i++)\n        {\n            if (arr[i] != arr[n-i-1]) \n            {\n                pal = false;\n            }\n        }\n\n        if (pal) \n        {\n            cout << \"YES\\n\";\n        }\n        else \n        {\n            cout << \"NO\\n\";\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:39:51.784299+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Loop through half the array, and check if $a[i] == a[n-i-1]$. If for any index, they are unequal, the array is not a palindrome array, else it is a palindrome array.\nTime Complexity : $O(n/2) \\approx O(n)$"
      },
      "id": 1154,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains $ N $, the number of elements.\nSecond line contains $N$ space separated integers denoting the array",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print $\\textbf{\"YES\"}$ (without quotes) if A is a $ \\textbf{palindrome} $ array, otherwise, print $\\textbf{\"NO\"}$ (without quotes)",
      "samples": [
        {
          "input": "1\n5\n1 3 2 3 1\n",
          "output": "YES\n"
        },
        {
          "input": "2\n5\n1 3 2 3 1\n4\n1 2 3 4\n",
          "output": "YES\nNO\n        \n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Palindrome Array",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string $S$ that represents a $\\textbf{URL}$ request. Print five lines contains the following format: \"$X: Y$\" where $X$ is the parameter and $Y$ is the parameter's value.\n\n$\\textbf{Note:}$ The parameters of the $\\textbf{URL: username, pwd, profile, role}$ and $\\textbf{key}$.",
      "complete_approach": "",
      "constraints": "$ 100 \\leq |S| \\leq 10^4 $ where |S| is the length of the string.",
      "editorial_code": [
        {
          "code": "```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string s; cin >> s;\n    int n = s.size();\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '?') {\n            i++;\n            for (int z = i; z < n; z++) {\n                if (s[z] == '=') {\n                    cout << \": \";\n                    continue;\n                }\n                if (s[z] == '&') {\n                    cout << endl;\n                    continue;\n                }\n                cout << s[z];\n            }\n            break;\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Editorial code is not passing the Sample cases.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:34:33.982963+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "\nThe approach is very simple just the implementation is tricky. traverse the string if we get '?' after that we run a for loop fron that index to the end of the array then print accordingly if we get '=' then print ': ' if we get '&' then break the line.\n"
      },
      "id": 1201,
      "input_format": "Only one line containining a string $S$. It consists of $\\textbf{uppercase}$ and $\\textbf{lowercase}$ English letters, $\\textbf{digits}$, and $\\textbf{special characters}$.\nThe URL will be in the following format:\nhttp://www.{word}.{word}/{word}/{word}?username={word}&pwd={word}&profile={word}&role={word}&key={word}\n$\\textbf{It's guaranteed that all parameters will have a value. The value will always be a string of alphabets and digits.}$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3",
        "cpp"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print 5 lines that contain the answer required above.",
      "samples": [
        {
          "input": "http://www.cleartrip.com/signin/service?username=test&pwd=test&profile=developer&role=ELITE&key=manager\n",
          "output": "username: test\npwd: test\nprofile: developer\nrole: ELITE\nkey: manager\n"
        },
        {
          "input": "http://www.codeforces.com/signin/service?username=Arijit&pwd=jackTheKing&profile=useless&role=newbie&key=wrongAnswerOnTestCase2\n",
          "output": "username: Arijit\npwd: jackTheKing\nprofile: useless\nrole: newbie\nkey: wrongAnswerOnTestCase2\n"
        },
        {
          "input": "http://www.algozenith.com/signin/service?username=hackNasaUsingHtml&pwd=areYouSerious&profile=ownerOfTwitter&role=fakePromises&key=planToOwnNasa",
          "output": "username: hackNasaUsingHtml\npwd: areYouSerious\nprofile: ownerOfTwitter\nrole: fakePromises\nkey: planToOwnNasa"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "\n\n",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "URL",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given an array A of N integers. A sequence is called good if the value x occurs x times in the array. Find the minimum number of integers you need to delete from A to make it good.</p>",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$1 \\leq N \\leq 10^5$  \n\n$1 \\leq A_i \\leq 10^9$  \n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        map<int, int> m;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            cin >> x;\n            m[x]++;\n        }\n        int ans = 0;\n        for (auto i : m) {\n            if(i.second >= i.first) {\n                ans += i.second - i.first;\n            }\n            else {\n                ans += i.second;\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:29:46.753236+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Take count of each number in a map. For any element `X` if it’s count is more than `X`, delete the extra count and if it’s count is less than `X`, delete all the occurrences of `X`.\n\nTime Complexity per test case: $O(N \\log N)$"
      },
      "id": 375,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer N - the length of the array. \n\nThe second line of each test case contains N space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, remove 2.  \n\nFor the second test case, remove 3 and 4.  \n\nFor the third test case, remove 6, 6, 1, and 2.",
      "output_format": "For each test case, print the minimum number of integers you need to delete from A to make it good.",
      "samples": [
        {
          "input": "3\n5\n3 2 3 3 1\n4\n3 2 2 4\n5\n6 6 1 1 2\n",
          "output": "1\n2\n4\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Good Sequence AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a letter X. Determine whether X is Digit or Alphabet and if it is Alphabet determine if it is $\\textbf{Capital Case}$ or $\\textbf{Small Case}$.\n\n$\\textbf{Note:}$\n\n1. Digits in ASCII '0' = 48,'1' = 49 ....etc\n2. Capital letters in ASCII 'A' = 65, 'B' = 66 ....etc\n3. Small letters in ASCII 'a' = 97,'b' = 98 ....etc",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <iostream>\nusing namespace std;\nint main()\n{\n    char x; cin >> x;\n    if (x >= 48 && x <= 57) {\n        cout << \"IS DIGIT\";\n    }\n    else if (x >= 65 && x <= 90) {\n        cout << \"ALPHA\" << endl << \"IS CAPITAL\";\n    }\n    else if (x >= 97 && x <= 122) {\n        cout << \"ALPHA\" << endl << \"IS SMALL\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:33:22.715972+00:00"
      },
      "hints": {
        "hint1": "Consider the ASCII values for digits, uppercase letters, and lowercase letters.",
        "hint2": "Use nested if-else statements to check the conditions in a structured manner.",
        "solution_approach": "Check if it's a Digit: Use the condition if (x >= 48 && x <= 57) to check if the character is a digit (ASCII values for digits are from 48 to 57). If true, print \"IS DIGIT.\"\n\nCheck if it's an Uppercase Letter: Use the condition else if (x >= 65 && x <= 90) to check if the character is an uppercase letter (ASCII values for uppercase letters are from 65 to 90). If true, print \"ALPHA\" and \"IS CAPITAL.\"\n\nCheck if it's a Lowercase Letter: Use the condition else if (x >= 97 && x <= 122) to check if the character is a lowercase letter (ASCII values for lowercase letters are from 97 to 122). If true, print \"ALPHA\" and \"IS SMALL.\""
      },
      "id": 1176,
      "input_format": "Only one line containing a character $X$ which will be a capital or small letter or digit.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print a single line contains $\\textbf{\"IS DIGIT\"}$ if $X$ is $\\textbf{digit}$ otherwise, print $\\textbf{\"ALPHA\"}$ in the first line followed by a new line that contains $\\textbf{\"IS CAPITAL\"}$ if $X$ is a $\\textbf{capital}$ letter and $\\textbf{\"IS SMALL\"}$ if $X$ is a $\\textbf{small}$ letter.",
      "samples": [
        {
          "input": "A\n",
          "output": "ALPHA\nIS CAPITAL\n"
        },
        {
          "input": "9\n",
          "output": "IS DIGIT\n"
        },
        {
          "input": "a\n",
          "output": "ALPHA\nIS SMALL\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Capital or Small or Digit",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$. Print a diamond that has $2N$ rows.\n\n**For more clarification see the example below.**",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N \\leq 99 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// O(N^2) time complexity\n// O(1) space\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    int jump = n - 1;\n    int times = 1;\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < jump; j++)\n        {\n            cout << \" \";\n        }\n        for (int j = 0; j < times; j++)\n        {\n            cout << \"*\";\n        }\n        cout << \"\\n\";\n        jump -= 1;\n        times += 2;\n    }\n    // Do the same as shape 1 for upper half and invert the solution for it for the lower half\n    times -= 2;\n    jump += 1;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < jump; j++)\n        {\n            cout << \" \";\n        }\n        for (int j = 0; j < times; j++)\n        {\n            cout << \"*\";\n        }\n        cout << \"\\n\";\n        jump += 1;\n        times -= 2;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:36:15.348912+00:00"
      },
      "hints": {
        "hint1": "Just use the method in **Shape2** and modify it for **lower half**.",
        "hint2": "",
        "solution_approach": "We already saw the approach to the problem in **Shape2**. This problem just is a modified version, where you print the pattern in shape2 first and then **invert** it to get the diamond.\n\nWe must take care of properly inverting the updation of variables for the lower half. Time complexity remains same $O(N^2)$ and space complexity will be $O(1)$."
      },
      "id": 1216,
      "input_format": "Only one line containing number $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the answer according to the required above.",
      "samples": [
        {
          "input": "4\n",
          "output": "   *\n  ***\n *****\n*******\n*******\n *****\n  ***\n   *"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Shape3",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "$ \\textbf{A sub sequence} $ is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\nIF array = $ \\textbf{[1,6,3,7]} $ then the $ \\textbf{some subsequences} $ are $ \\textbf{[1,3,7] , [6,7] , [1] , [6,3,7] , [1,7]} $.\n\nSomething like $ \\textbf{[3,1]} $ and $ \\textbf{[6,7,1]} $ would not be sub sequences of the array $ \\textbf{[1,6,3,7]} $.\n\nGiven $ \\textbf{2} $ numbers $N, M$ and $ \\textbf{2} $ arrays $A$ consists of $N$ numbers and $B$ consists of $M$ numbers. Determine whether $B$ is a sub-sequence of $A$ or not.\n\n$ \\textbf{Note:} $ The array $B$ is called a $ \\textbf{sub-sequence} $ of $A$ if it's possible to remove zero or some elements from $A$ to get $B$.\n\n$ \\textbf{For example:} $ if $A$ = [$ \\textbf{1,4,7} $], and $B$ is [$ \\textbf{1}$], [$ \\textbf{1,4} $], [$ \\textbf{1,7} $],[$ \\textbf{1,4,7} $] or [$ \\textbf{4,7} $] then $B$ is a sub-sequence of $A$.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N, M \\leq 10^4 $\n$ 1 \\leq A[i] \\leq 10^9 $\n$ 1 \\leq B[i] \\leq 10^9 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n, m;\n        cin >> n >> m;\n\n        int A[n], B[m];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> A[i];\n        }\n        for (int i = 0; i < m; i++)\n        {\n            cin >> B[i];\n        }\n\n        int i = 0, j = 0;\n        while (i < n && j < m)\n        {\n            if (A[i] == B[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                i++;\n            }\n        }\n        if (j == m)\n        {\n            cout << \"YES\\n\";\n        }\n        else\n        {\n            cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:31:33.381272+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 1143,
      "input_format": "The first line contains $T$, the number of test cases. The first line of each test case contains two space seperated integers $ N $ and $ M $, the sizes of arrays $A$ and $B$ respectively. Second line contains $N$ space separated integers each denoting an element of the array $A$. Third line contains $M$ space separated integers each denoting an element of the array $B$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print $ \\textbf{\"YES\"} $ (without the quotes), if $B$ is a sub-sequence of $A$ otherwise, print $ \\textbf{\"NO\"} $ (without the quotes).",
      "samples": [
        {
          "input": "1\n3 2\n1 4 7\n1 7\n",
          "output": "YES\n"
        },
        {
          "input": "2\n3 2\n1 4 7\n1 7\n7 4\n1 8 4 7 5 2 7\n4 5 7 2\n",
          "output": "YES\nNO\n"
        },
        {
          "input": "1\n3 3\n21 8 40\n21 8 40\n",
          "output": "YES\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Is B a subsequence of A?",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Write a C++ program to print Pascal's Triangle of height $N$.\n\n*Note*: See https://en.wikipedia.org/wiki/Pascal's_triangle for more information on Pascal's Triangle.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N \\leq 10 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n\n  for (int tt = 1; tt <= t; tt++) {\n    int row_num;\n    cin >> row_num;\n    // Loop to print each row\n    for (int n = 1; n <= row_num; n++) {\n      // Loop to print spaces for triangular display\n      for (int r = 1; r < row_num - n + 1; r++) cout << \"  \";\n\n      // Loop to print values using the Combinations formula\n      int val = 1;\n      for (int r = 1; r <= n; r++) {\n        cout << val << \"   \";\n\n        val = val * (n - r) / r;\n      }\n      cout << endl;\n    }\n  }\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:38:55.687909+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 1092,
      "input_format": "The first line contains the number $T$ of test cases.\nFor each test case: There is a line that contains $N$ denoting the height of Pascal's Triangle.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the pattern.",
      "samples": [
        {
          "input": "1\n2\n",
          "output": "  1   \n1   1 \n"
        },
        {
          "input": "1\n5\n",
          "output": "        1   \n      1   1   \n    1   2   1   \n  1   3   3   1   \n1   4   6   4   1  \n"
        },
        {
          "input": "2\n4\n7\n",
          "output": "      1   \n    1   1   \n  1   2   1   \n1   3   3   1   \n            1   \n          1   1   \n        1   2   1   \n      1   3   3   1   \n    1   4   6   4   1   \n  1   5   10   10   5   1   \n1   6   15   20   15   6   1 \n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Pascal's Triangle",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$. Print a **face down right angled triangle** that has $N$ rows.\n\n**Note :**\nDon't print any **extra** spaces after symbol \" * \".",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N \\leq 99 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// O(n^2) time\n// O(1) space\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    while (n >= 0)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            cout << \"*\";\n        }\n        n--;\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:41:02.651111+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Naively iterate from $1$ to $N$ to print $1st$ row, then $1$ to $N-1$ to print $2nd$ row... and so on for $N-1$ times. In total you will have to print \"*\" $\\frac{N(N+1)}{2}$ times which has $O(N^2)$ time complexity and $O(1)$ space complexity."
      },
      "id": 1210,
      "input_format": "Only one line containing a number $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the answer according to the required above.",
      "samples": [
        {
          "input": "4\n",
          "output": "****\n***\n**\n*\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Shape1",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Some day, an artist wanted to draw an **X** mark on the wall in a fashionable way.\n\nHe wanted to do so by grouping snippets of slashes **/**, backslashes **\\\\**, asterisks **\\*** and a capital **X** letter in an $N×N$ square as shown in the sample. Can you help him?",
      "complete_approach": "",
      "constraints": "$ 3 \\leq N \\leq 49 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// O(N^2) time complexity\n// O(1) space complexity\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        if (i == n / 2) // special case to print X\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (j == n/2)\n                {\n                    cout<<\"X\";\n                }\n                else\n                {\n                    cout << \"*\";\n                }\n            }\n        }\n        else // print \\ and /\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (j == i)\n                {\n                    cout << '\\\\';\n                }\n                else if (j == n - 1 - i)\n                {\n                    cout << \"/\";\n                }\n                else\n                {\n                    cout << \"*\";\n                }\n            }\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:36:19.047318+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We can find that the pattern of the **\\\\** and **/** appearing in each row, for the ith row, the **\\\\** appears in ith column from left and **/** appears at ith column from right. For the middle row, both appear at the same place, so we instead print a **X**. The rest of the places are filled with **\\***. This can be done in $O(N^2)$ time with $O(1)$ space complexity."
      },
      "id": 1219,
      "input_format": "Only one line containing one odd number $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the fashionable drawing.",
      "samples": [
        {
          "input": "5\n",
          "output": "\\***/\n*\\*/*\n**X**\n*/*\\*\n/***\\\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Drawing X",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a directed graph, you have to find its transitive closure, i.e, the reachability of any vertex from any other vertex.",
      "complete_approach": "",
      "constraints": "<p><i>1 ≤ N ≤ 100</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> TransitiveClosureGraph(vector<vector<int>> adj)\n{\n\tint n = (int)adj.size();\n\n\tvector<vector<int>> T(n, vector<int>(n));\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tT[i][j] = adj[i][j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t\tT[i][i] = 1;\n\n\tfor (int k = 0; k < n; k++)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tT[i][j] |= (T[i][k] & T[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn T;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint n;\n\tcin >> n;\n\n\tvector<vector<int>> adj(n, vector<int>(n));\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tcin >> adj[i][j];\n\t\t\tif (i == j)\n\t\t\t{\n\t\t\t\tadj[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int>> T = TransitiveClosureGraph(adj);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tcout << T[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:46:49.524840+00:00"
      },
      "hints": {
        "hint1": "Can we make use of Floyd Warshall Algorithm?",
        "hint2": "<p>In Floyd Warshall algorithm, if change + (Addition) to &amp; (AND). That means, d[i][j] = d[i][v] | (d[i][k] &amp; d[k][j]), we can reach i to j, if there's path from i to k and k to j.</p>",
        "solution_approach": "We can use the Floyd Warshall Algorithm to solve the problem. If the cost of the shortest path between any two vertices is infinity then there does not exist a path between them. However we need not find the shortest path so the solution can be simplified. Instead of storing the cost of the shortest path between two vertices <i>i</i> and <i>j</i> just store a boolean indicating the reachability from <i>i</i> to <i>j</i> and for every <i>k</i> intermediate vertex between <i>i</i> and <i>j,</i> <i>adj[i][j]</i> can be written as <i>adj[i][k] OR adj[k][j]</i>.<br>Keep in mind that a vertex <i>i</i> is reachable from <i>i</i> itself even if it does not have a self loop.</span><br>Time Complexity - <i>O(N<sup>3</sup>)</i>"
      },
      "id": 606,
      "input_format": "The first line of each test case contains $N$ - the number of vertices in the graph.  \n$N$ lines follow containing $N$ integers, where the $j^{\\text{th}}$ integer of the $i^{\\text{th}}$ line is $1$ if there is a directed edge from vertex $i$ to vertex $j$, otherwise it is $0$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "The graph for test case 1:<figure class=\"image image_resized\" style=\"width:40.04%;\"><img src=\"https://lh4.googleusercontent.com/56-CacHhdc2xjpnmKFlqLS2ZDDmDQo6XSf4hq88CwtF8wO6TYcGJbmzJ5zQJEMS0e3GNzYSwD46UAn01dw-wiB4FnvCUfHD8rCl4FRRkIIuQVbbE80Rk-qkPBQVMR0R8wzoZO3Ff\"></figure>The graph for test case 2:<figure class=\"image image_resized\" style=\"width:34.46%;\"><img src=\"https://lh4.googleusercontent.com/NkkHO14-wLGqv6Pqd7vNP9unoIBtXIlzA41n6r4MZ_kaCJFKQByNX5bVx6hYBKKw6XhiS6k_wDaqhERCki5xpJWPMOBRAt4mlTRcNvDVRUvmP3UJ2mhriNf4AAcJKsC7yj-hBXot\"></figure>",
      "output_format": "For each test case print <i>N</i> lines with <i>N</i> integers each, where the <i>j<sup>th</sup></i> integer of the <i>i<sup>th</sup></i> line is <i>1</i> if there is a path from vertex <i>i</i> to vertex <i>j</i>, otherwise it is <i>0</i>.",
      "samples": [
        {
          "input": "3\n0 1 1\n0 0 0\n1 0 0",
          "output": "1 1 1\n0 1 0\n1 1 1"
        },
        {
          "input": "6\n0 0 0 0 1 1\n0 0 0 1 0 1\n1 1 0 0 0 0\n0 0 0 0 0 0\n0 0 0 1 0 0\n1 0 1 0 1 0",
          "output": "1 1 1 1 1 1\n1 1 1 1 1 1\n1 1 1 1 1 1\n0 0 0 1 0 0\n0 0 0 1 1 0\n1 1 1 1 1 1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nvector<vector<int>> TransitiveClosureGraph(vector<vector<int>> adj)\n{\n\t// Complete the function\n}\n\n<fix>\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint n;\n\tcin >> n;\n\n\tvector<vector<int>> adj(n, vector<int>(n));\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tcin >> adj[i][j];\n\t\t\tif (i == j)\n\t\t\t{\n\t\t\t\tadj[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int>> T = TransitiveClosureGraph(adj);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tcout << T[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "GRAPHADJ",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a balanced string $S$ consists of $['R', 'L']$ characters. Split it into maximum number of strings such that the new strings are also balanced.\n\nNote:\n\n1. Balanced strings are those who have $\\textbf{equal quantities of 'L' and 'R' characters}$.\n2. You can not remove or reorder the characters while making the new strings.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq |S| \\leq 1000 $ here $|S|$ is the length of the string.\n$\\textbf{It's guaranteed that S consists of only ['L', 'R'] letters, S is balanced and |S| is even}$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string s; cin >> s;\n    int n = s.size(), row = 0, column = 0, R_cnt = 0, L_cnt = 0, ans = 0;\n    char arr[n + 1][n + 1] = {};\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'R') {\n            arr[row][column] = s[i];\n            R_cnt++;\n        } else {\n            arr[row][column] = s[i];\n            L_cnt++;\n        }\n        column++;\n        if (R_cnt > 0 && R_cnt == L_cnt) {\n            row++;\n            column = 0;\n            ans++;\n            R_cnt = L_cnt = 0;\n        }\n    }\n    cout << ans << endl;\n    for (int i = 0; i < n; i++) {\n        if (arr[i][0] != 'R' && arr[i][0] != 'L') {\n            continue;\n        }\n        cout << arr[i] << endl;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:34:32.042073+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Maintain a 2D array to store all the new substrings formed. If we find L or R then we just push it into the current row then if we get same count of L and R then we go to the next row and then continue do this until the string ends."
      },
      "id": 1200,
      "input_format": "Only one line contains a string $S$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print maximum number of balanced strings then the balanced strings in any order.",
      "samples": [
        {
          "input": "LLRRLLLRRR\n",
          "output": "2\nLLRR\nLLLRRR\n"
        },
        {
          "input": "LLLRRR\n",
          "output": "1\nLLLRRR\n"
        },
        {
          "input": "LLLLLRLLLLRRRRRRRR\n",
          "output": "1\nLLLLLRLLLLRRRRRRRR\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Max Split",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "For a given integer $N$, print the pattern as shown in the examples below.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10$\n$1 \\leq N \\leq 10^2$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  // including all the test cases\n  int t;\n  cin >> t;\n\n  while (t--) {\n    int n, i, j;\n    cin >> n;\n\n    // iterating over every row\n    for (i = 1; i <= n; i++) {\n      // printing the output for each column\n      for (j = 1; j <= n - i + 1; j++) {\n        cout << '*';\n      }\n\n      // moving the printing operation to the next line\n      cout << \"\\n\";\n    }\n\n    // spacing between different test cases\n    cout << \"\\n\";\n  }\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:29:00.877563+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 1095,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\nThe first line of each test case contains the integer $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the desired pattern. Print an empty line after each test case.",
      "samples": [
        {
          "input": "2\n3\n4\n",
          "output": "***\n**\n*\n\n****\n***\n**\n*\n"
        },
        {
          "input": "2\n1\n2\n\n",
          "output": "*\n\n**\n*\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Inverted Right Angled Triangle Pattern",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Write a C++ program to print hollow diamond star pattern series of $N$ rows. See sample examples.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 100 $\n$ 1 \\leq N \\leq 100 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  \n  int t;\n  cin >> t;\n\n  for (int tt = 1; tt <= t; tt++) {\n    int n, rows, columns;\n    cin >> n;\n    // for loop is used to identify the number of rows and\n    // print upper triangle\n    for (rows = 1; rows <= n; rows++) {\n      // used for printing the spaces\n      for (columns = n; columns > rows; columns--) {\n        cout << \" \";\n      }\n\n      cout << \"*\";\n      // again print the spaces\n      for (columns = 1; columns < (rows - 1) * 2; columns++) {\n        cout << \" \";\n      }\n      if (rows == 1) {\n        cout << \"\\n\";\n      } else {\n        cout << \"*\\n\";\n      }\n    }\n    // for loop is used to identify the number of rows and\n    // it is used to print lower triangle\n    for (rows = n - 1; rows >= 1; rows--) {\n      // used for printing the spaces\n      for (columns = n; columns > rows; columns--) {\n        cout << \" \";\n      }\n      // print star\n      cout << \"*\";\n      for (columns = 1; columns < (rows - 1) * 2; columns++) {\n        cout << \" \";\n      }\n      if (rows == 1) {\n        cout << \"\\n\";\n      } else {\n        cout << \"*\\n\";\n      }\n    }\n  }\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:30:33.710349+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "In each line you have to print two characters except the first and last line.\nThe point at which charater is printed has to be increased on one side and decreased on the other till a limit is reached.\nRefer to the editorial code."
      },
      "id": 121,
      "input_format": "The first line contains the number $T$ of test cases. \nFor each testcase: There is line which contains the number $N$ which is the length of the diamond. Look at samples for more clarity.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the third sample the outputs are printed one afte another.",
      "output_format": "For each test case, print the pattern.",
      "samples": [
        {
          "input": "1\n1\n",
          "output": "*\n"
        },
        {
          "input": "1\n5\n",
          "output": "    *\n   * *\n  *   *\n *     *\n*       *\n *     *\n  *   *\n   * *\n    *"
        },
        {
          "input": "2\n8\n8\n",
          "output": "       *\n      * *\n     *   *\n    *     *\n   *       *\n  *         *\n *           *\n*             *\n *           *\n  *         *\n   *       *\n    *     *\n     *   *\n      * *\n       *\n       *\n      * *\n     *   *\n    *     *\n   *       *\n  *         *\n *           *\n*             *\n *           *\n  *         *\n   *       *\n    *     *\n     *   *\n      * *\n       *"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Hollow Diamond",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>For the given <i>n</i>, consider the array <i>A</i> = {1, 2, …, <i>n</i>}. There exist <i>n</i>! unique permutations of the array. When we list all these <i>n</i>! permutations in lexicographically order, your task is to find <i>k</i>th permutation in that list.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i> ≤ 9<br>1 ≤ <i>k</i> ≤ <i>n</i>!</p>",
      "editorial_code": [
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define IOS                       \\\n    ios_base::sync_with_stdio(0); \\\n    cin.tie(0);                   \\\n    cout.tie(0);\n\nvoid func(int k, vector<int> &arr)\n{\n    int n = (int)arr.size();\n    k--;\n    vector<int> ans;\n    int fact = 1;\n    for (int i = 1; i < n; i++)\n    {\n        fact = i * fact;\n    }\n    while (1)\n    {\n        ans.push_back(arr[k / fact]);\n        arr.erase(arr.begin() + k / fact);\n        if ((int)arr.size() == 0)\n            break;\n        k %= fact;\n        fact /= (int)arr.size();\n    }\n    for (auto i : ans)\n    {\n        cout << i << \" \";\n    }\n    cout << \"\\n\";\n}\n\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    if (n <= 13)\n    {\n        vector<int> arr;\n        for (int i = 1; i <= n; i++)\n        {\n            arr.push_back(i);\n        }\n        func(k, arr);\n    }\n    else\n    {\n        vector<int> arr;\n        for (int i = 1; i < n - 12; i++)\n        {\n            cout << i << \" \";\n        }\n        for (int i = n - 12; i <= n; i++)\n        {\n            arr.push_back(i);\n        }\n        func(k, arr);\n    }\n}\n\nsigned main()\n{\n    IOS;\n    solve();\n    return 0;\n}\n```\n\n\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main()\n{\n    // freopen(\"IN\", \"r\", stdin);\n    // freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++)\n    {\n        nums[i] = i + 1;\n    }\n\n    for (int i = 0; i < k - 1; i++)\n    {\n        next_permutation(nums.begin(), nums.end());\n    }\n\n    for (int u : nums)\n    {\n        cout << u << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:44:51.938829+00:00"
      },
      "hints": {
        "hint1": "We can always use next_permutation() to generate all possible permutations.   \nCan you try by using recursion and backtracking?",
        "hint2": "",
        "solution_approach": "Let a = {1, 2, …, n}. \nNow do iteratively. Find out the farthest index from the last, that has to be changed. Suppose index i needs to change, then we've to choose $\\lceil k / (n - i)!\\rceil$ th smallest number from a[i] to a[n - 1].\n\nAnd go on doing the same for other indices from i + 1 to n - 1.\n\nSee editorial code for more clear understanding."
      },
      "id": 476,
      "input_format": "<p>The first line contains two space-separated integers <i>n</i> and <i>k</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><strong>Explanation 1: </strong>All 9 permutations in lexicographic order are</p><pre><code class=\"language-plaintext\">1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1</code></pre><p>The 4th one is {2, 3, 1}.</p>",
      "output_format": "<p>Print <i>n</i> space-separated integers, denoting the <i>k</i>th permutation.</p>",
      "samples": [
        {
          "input": "3 4",
          "output": "2 3 1"
        },
        {
          "input": "4 9",
          "output": "2 3 1 4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Kth Permutation - easy version",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Draw a snake pattern on a <strong>n</strong> by <strong>m</strong> table. The tail of the snake starts at (1,1) and travels right towards cell (1,m). Then it moves 2 rows downwards to (3,m). Next, the snake moves left to (3,1). From there it travels two more rows downward to (5,1) and this pattern carries on. The empty cells is denoted by <strong>.</strong> and the snake by <strong>#</strong> .</p>",
      "complete_approach": "",
      "constraints": "<p>3 ≤ n,m ≤ 50</p><p><strong>n</strong> is a odd number.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\nusing lli = long long int;\n\nint main() {\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    \n    string s1 = \"#\";\n    string s2 = \"#\";\n    for (int i = 2; i <= m; i++) {\n        s1 += \"#\";\n        s2 += \".\";\n    }\n    string s3 = s2;\n    reverse(s2.begin(), s2.end());\n    int p = 0;\n    // s1 = ####\n    // s2 = ...#\n    // s3 = #...\n\n    cout << s1 << \"\\n\"; // print the first line\n    // print intermediate lines\n    for (int i = 1; i < n - 1; i++) {\n        if (i % 2 == 0)\n            cout << s1 << \"\\n\";\n        else if (p == 1)\n            cout << s3 << \"\\n\";\n        else\n            cout << s2 << \"\\n\";\n        if (i % 2)\n            p = 1 - p;\n    }\n    cout << s1 << \"\\n\"; // print last line\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:21:53.610975+00:00"
      },
      "hints": {
        "hint1": "<p>Observe the pattern carefully, there are three types of sentences pattern only.&nbsp;</p><p>Type 1 = #####</p><p>Type 2 = <span class=\"text-huge\">….</span>#</p><p>Type 3 = #<span class=\"text-huge\">….&nbsp;</span></p><p>Is it possible to print the patterns without using nested loops?</p>",
        "hint2": "<p>The different sentences also follow a certain pattern. They can be predefined from before.&nbsp;</p>",
        "solution_approach": "<p>There are n rows and m columns. There are 3 types sentences:-&nbsp;</p><p>s1 = #### upto n times</p><p>s2 = <span class=\"text-huge\">…</span># the dot characters are up to n-1 times.</p><p>s3 = #<span class=\"text-huge\">… </span>the dot characters are up to n-1 times.</p><p>The first and last lines are always of type s1. Handle them separately. The intermediate levels are numbered from 1 to n-2. For every even-numbered intermediate level, the sentence is of type s1. And for odd-numbered levels, print either s2 or s3 alternately. (start with s2, then s2) .</p><p>The generated pattern is like s1 s2 s1 s3 s1 s2 s1 s3 …. s1.</p><p>Time Complexity = O(n*m)</p>"
      },
      "id": 772,
      "input_format": "<p>The input contains two integers <strong>n</strong> and <strong>m</strong> in a single line.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>The output has <strong>n</strong> line each with <strong>m</strong> characters, which is the snake pattern on n by m table.</p>",
      "samples": [
        {
          "input": "5 6",
          "output": "######\n.....#\n######\n#.....\n######"
        },
        {
          "input": "7 3",
          "output": "###\n..#\n###\n#..\n###\n..#\n###"
        },
        {
          "input": "3 4",
          "output": "####\n...#\n####"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Zig-zag Snake",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "**Convert a Binary Tree into its Mirror Tree.**\n\nMirror of a Tree: Mirror of a Binary Tree T is another Binary Tree M(T) with left and right children of all non-leaf nodes interchanged.",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:14.500990+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 646,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, &nbsp;the length of the array representing the serialized representation of a tree.</p><p>The next line contains N-space-separated integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Return the mirror tree.</p>",
      "samples": [
        {
          "input": "3\n3\n2067 -1 -1 \n13\n8365 1448 5240 -1 9909 -1 -1 5843 -1 -1 5682 -1 -1 \n15\n7841 883 -1 -1 4929 6791 -1 -1 9159 2122 -1 -1 4179 -1 -1 ",
          "output": "2067 -1 -1 \n8365 5682 -1 -1 1448 5843 -1 -1 5240 9909 -1 -1 -1 \n7841 4929 9159 4179 -1 -1 2122 -1 -1 6791 -1 -1 883 -1 -1 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n</fix>\n\nNode* getMirrorTree(Node* root) {\n    //Complete the function\n}\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nvoid generateArray(Node* root, vector<int>&ans){\n    if(root==NULL){\n        ans.push_back(-1);\n        return;\n      }\n    ans.push_back(root->val);\n    generateArray(root->left,ans);\n    generateArray(root->right,ans);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        tree = getMirrorTree(tree);\n        vector<int>ans;\n        generateArray(tree,ans);\n        for(auto v:ans)cout<<v<<\" \";\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 3,
      "title": "Mirror Tree",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given an array $A$ of size $N$ and a number $X$. Print the array elements after shifting right the elements $X$ times.\n\n$\\textbf{For example}$: if $A = [1, 2, 3]$ then after shifting it to the right for 1 time $A = [3, 1, 2]$.\n\n$\\textbf{Note}$: Solve this problem using function.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N \\leq 10^4 $\n$ 1 \\leq X \\leq 100 $\n$ 1 \\leq A[i] \\leq 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solution()\n{\n    int n, x;\n    cin >> n >> x;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> arr[i];\n    }\n    x %= n;\n    vector<int> ans(n);\n    for (int i = 0; i < n; i++)\n    {\n        ans[i] = arr[(i - x + n) % n];\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cout << ans[i] << \" \";\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:37:07.680864+00:00"
      },
      "hints": {
        "hint1": "If x is greater than n then is it necessary to rotate the array more than n times think!",
        "hint2": "Rotate the array x%n times in the right direction.",
        "solution_approach": "At first find how many times we have to rotate the array then rotate the array by an second array. \nIn each rotation every element is move one step right except the last element that goes into the first position so in answer array they are their respective position i mapped into (i - x + n) % n in the answer array."
      },
      "id": 1224,
      "input_format": "First line will contain two number $N$ and $X$.\nSecond line will contain $N$ numbers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the array after shifting right its elements $X$ times.",
      "samples": [
        {
          "input": "2 2\n2 1\n",
          "output": "2 1\n"
        },
        {
          "input": "5 21\n1 2 3 4 5\n",
          "output": "5 1 2 3 4\n"
        },
        {
          "input": "5 1\n1 1 1 1 1\n",
          "output": "1 1 1 1 1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Shift Right",
      "video_editorial_id": 10679
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Being the site administrator, you need to register the people on the website. A person registers with his name, S. If the name does not occur in the records, the person gets registered on the website and “OK” is shown. Otherwise, if the record already exists, print the name along with the number of times the person has registered on the website before, without any spaces.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ N ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ |S| ≤ 30</span></p><p><span style=\"background-color:#ffffff;color:#000000;\">It is guaranteed that the sum of N over all test cases does not exceed 10<sup>6</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    map<string, int> m;\n    for (int i = 0; i < n; ++i) {\n      string s;\n      cin >> s;\n      if (!m.count(s)) {\n        cout << \"OK\\n\";\n      } else {\n        cout << s << m[s] << \"\\n\";\n      }\n      m[s]++;\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:27:23.061560+00:00"
      },
      "hints": {
        "hint1": "Save the number of times a person registers in a map.",
        "hint2": "The program uses a map mp to store the name of each person who registers and the number of times they have registered.\nFor each person, the program checks if the name exists in the map mp using the `mp.count()`.  If name not present in map it returns $0$ , In this case, the program outputs \"OK\".\nIf the name already exists in the map, the `mp.count()` returns 1, program outputs the name along with the number of times the person has registered before.\nThe program increments the value of the name in the map by 1.",
        "solution_approach": "The time complexity of the program is $O(n \\log n)$, where n is the total number of people who register in all test cases. This is because the map uses a balanced binary tree (usually a red-black tree) to store the elements, and the `find()` and `insert()` operations have a time complexity of $O(\\log n)$."
      },
      "id": 360,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer N - the number of people who register.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">Each of the next N lines contains a string S - the name in lower case alphabets.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, harry registers again, so his name along with the name of times is printed.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, abc registers thrice, so his name along with the name of times is printed.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print “OK” if the person registers for the first time. Otherwise, print the name along with the number of times the person has registered on the website before, without any spaces.</span></p>",
      "samples": [
        {
          "input": "2\n4\nharry\nron\nharry\nhermione\n3\nabc\nabc\nabc\n",
          "output": "OK\nOK\nharry1\nOK\nOK\nabc1\nabc2\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Registration AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "For a given integer $N$, print the pattern as shown in the examples below.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10$\n$1 \\leq N \\leq 10^2$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  // including all the test cases\n  int t;\n  cin >> t;\n\n  while (t--) {\n    int n, i, j;\n    cin >> n;\n\n    // iterating over every row\n    for (i = 1; i <= n; i++) {\n      // printing the output for each column\n      for (j = 1; j <= i; j++) {\n        cout << '*';\n      }\n\n      // moving the printing operation to the next line\n      cout << \"\\n\";\n    }\n\n    // spacing between different test cases\n    cout << \"\\n\";\n  }\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:29:05.458870+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 1096,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\nThe first line of each test case contains the integer $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the desired pattern. Print an empty line after each test cases.",
      "samples": [
        {
          "input": "2\n3\n4\n",
          "output": "*\n**\n***\n\n*\n**\n***\n****\n"
        },
        {
          "input": "2\n1\n2\n\n",
          "output": "*\n\n*\n**\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Right Angled Triangle Pattern",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given **$3$** lines of input described as follow:\n\n1. First line contains a symbol $S$.\n2. Second line contains a number $N$.\n3. Third line contains $N$ numbers.\n\nFor each number $X_{i}$ in the $N$ numbers print a new line that contains the symbol $S$ repeated $X_{i}$ time.\n\n**Note**:\nDon't print any extra spaces after symbol $S$.",
      "complete_approach": "",
      "constraints": "$S$ can be $(+,−,∗,/)$\n$1 \\leq N \\leq 50$\n$1 \\leq X_{i} \\leq 100$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// O(N*X_max) time\n// O(1) auxillary space\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    char s;\n    cin >> s;\n    int n;\n    cin >> n;\n    int x[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x[i];\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < x[i]; j++)\n        {\n            printf(\"%c\",s);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:35:10.342702+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Store the $N$ numbers in an array and accordingly, for each $X_{i}$, print the symbol $S$ repeated $X_{i}$ time on a newline. The time complexity will be $O(N*X_{max})$ where $X_{max}$ is the maximum value of $X_{i}$ and space complexity will be $O(N)$."
      },
      "id": 1211,
      "input_format": "The first line contains a symbol S.\nThe second line an number $N$.\nThe third line contains $N$ numbers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the answer required above.",
      "samples": [
        {
          "input": "+\n5\n5 2 4 3 7\n",
          "output": "+++++\n++\n++++\n+++\n+++++++\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Numbers Histogram",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array of N integers. For each position, find the nearest position to its left having a smaller value. (1-based indexing)",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$1 \\leq N \\leq 10^5$  \n\n$1 \\leq A_i \\leq 10^9$  \n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a[n];\n    stack<int> s;\n    for (int i = 0; i < n; ++i) {\n      cin >> a[i];\n      while (!s.empty() && a[s.top()] >= a[i]) {\n        s.pop();\n      }\n      if (s.empty()) {\n        cout << \"0 \";\n      } else {\n        cout << s.top() + 1 << \" \";\n      }\n      s.push(i);\n    }\n    cout << \"\\n\";\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:36:37.885162+00:00"
      },
      "hints": {
        "hint1": "Maintain a stack with the given array values. Pop the elements which are greater than the current element.",
        "hint2": "",
        "solution_approach": "This problem can be solved efficiently using a stack. The idea is to traverse the array from left to right, and maintain a stack of indices. For each index `i`, we keep popping indices from the stack until we find an index `j` such that $a[j] < a[i]$. The answer for index `i` is then `j`, or $-1$ if no such index exists.\n\nHere is the step-by-step algorithm:\n* Initialize an empty stack.\n* Traverse the array from left to right.\n* For each index `i`:\n   * While the stack is not empty and a[top of stack] >= a[i], pop the stack.\n   * If the stack is empty, the answer for index `i` is $-1$.\n   * Otherwise, the answer for index `i` is the index at the top of the stack.\n   * Push index `i` onto the stack.\nReturn the list of answers.\n\nTime Complexity per test case: $O(N)$"
      },
      "id": 378,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer N - the length of the array. \n\nThe second line of each test case contains N space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, for 3 there is no smaller value, for 5, A[1] = 3, for 1, there is no smaller value, for 6 A[3] = 1, for 2, A[3] = 1.\n\nFor the second test case, for all 1 there is no smaller value, for 2, A[2] = 1.\n\nFor the third test case, for 1 there is no smaller value, for 3 and 2, A[1] = 1, for 6 and 6, A[3] = 2",
      "output_format": "For each test case, print N space-separated integers, for each position, the nearest position to its left having a smaller value.  If no position to its left has a smaller value, print 0.",
      "samples": [
        {
          "input": "3\n5\n3 5 1 6 2\n4\n1 1 2 1\n5\n1 3 2 6 6\n",
          "output": "0 1 0 3 3 \n0 0 2 0 \n0 1 1 3 3\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Nearest Smaller Values AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a tree with N nodes. Initially, all the nodes values is zero. You have to perform Q queries - 3 space-separated integers x, y, z → add z to all the nodes on the shortest path from x to y.</p><p>After performing all the queries print the final value of nodes 1,2,….n.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:18:53.682669+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 100,
      "input_format": "<p>The first line contains an integer T (1 ≤ T ≤ 10000) - the number of test cases.</p><p>The second line of each test case contains two space-separated integers N (1 ≤ N ≤ 10^5).</p><p>The next N-1 lines contain two space-separated integers u, v (1 ≤ u, v ≤ N, u≠v) denoting there is an undirected edge between node u and node v.</p><p>The next line contains an integer Q (1 ≤ Q ≤ 10^5).</p><p>The next Q lines contain three space-separated integers x, y, z (1 ≤ x, y≤ N, -10^6 ≤ z ≤ 10^6).</p><p>Sum of N+Q across all test cases ≤ 2*10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print N space-separated integers denoting the value of node 1,2….n in a new line.</p>",
      "samples": [
        {
          "input": "2\n5\n5 4\n2 1\n3 2\n4 2\n10\n2 5 -8\n5 2 -3\n4 4 -6\n4 3 -1\n2 2 3\n1 3 6\n2 4 -8\n4 4 -5\n5 3 8\n2 1 6\n16\n13 7\n10 6\n6 4\n8 4\n9 4\n16 12\n14 8\n2 1\n3 1\n12 1\n15 10\n4 3\n11 3\n5 2\n7 2\n36\n1 9 32344\n16 8 335632\n7 14 -184549\n4 14 -566786\n11 9 -710223\n7 4 -902974\n12 6 434571\n13 14 471558\n3 10 642273\n3 7 292965\n15 4 -643712\n15 12 879886\n15 8 -307835\n15 5 -244965\n10 8 612065\n11 11 348816\n3 6 527481\n16 14 567975\n12 7 -950446\n14 5 -144486\n6 7 -283238\n6 1 353436\n7 4 -748946\n11 14 120982\n1 12 -923018\n13 9 -136443\n2 15 564490\n6 2 429536\n8 7 -384482\n1 13 -438491\n7 8 -682297\n4 2 570947\n10 8 724338\n4 10 906307\n10 10 -968424\n2 1 252342",
          "output": "12 3 13 -23 -3 \n-838653 -2519479 1801473 2232885 -389451 4594633 -3947343 562115 -814322 2164423 -240425 344600 -103376 264694 247864 903607 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Partial Sum on Tree",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$ and an array $A$ of $N$ numbers. Print the array in a $ \\textbf{reversed order} $.\n$ \\textbf{Note:} $\n*Don't use built-in-functions.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N \\leq 1000 $\n$ 0 \\leq A[i] \\leq 10^9 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n\n        for (int i = 0; i < n/2; i++)\n        {\n            int t = arr[i];\n            arr[i] = arr[n-i-1];\n            arr[n-i-1] = t;\n        }\n        \n        for (int i = 0; i<n; i++) \n        {\n            cout << arr[i] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:31:59.391117+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Try reinitializing each array element with $n-i-1$, where $n$ is the number of elements in the array and $i$ is the index of the array element. But you just need to go to half of the array and swap the values both ways.\nTime Complexity : $O(n/2) \\approx O(n)$"
      },
      "id": 1155,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains $ N $, the number of elements.\nSecond line contains $N$ space separated integers denoting the array",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the array in a $\\textbf{reversed order}$.",
      "samples": [
        {
          "input": "1\n4\n5 1 3 2\n",
          "output": "2 3 1 5\n"
        },
        {
          "input": "1\n5\n1 2 3 4 5\n",
          "output": "5 4 3 2 1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Reversing",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "For a given integer $N$, print the pattern as shown in the examples below.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10$\n$1 \\leq N \\leq 10^2$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  // including all the test cases\n  int t;\n  cin >> t;\n\n  while (t--) {\n    int n, i, j;\n    cin >> n;\n\n    // iterating over every row\n    for (i = 1; i <= n; i++) {\n      // preceding blank spaces\n      int n_blanks = n - i;\n      for (j = 1; j <= n_blanks; j++) {\n        cout << \"  \";\n      }\n\n      // printing the values in ascending order\n      int max_val = i;\n      for (j = 1; j <= max_val; j++) {\n        cout << j << \" \";\n      }\n\n      // printing the values in descending order\n      for (j = max_val - 1; j >= 1; j--) {\n        cout << j << \" \";\n      }\n\n      // succeeding blank spaces\n      for (j = 1; j <= n_blanks; j++) {\n        cout << \"  \";\n      }\n\n      // moving printing operation to the next line\n      cout << \"\\n\";\n    }\n\n    // spacing between different test cases\n    cout << \"\\n\";\n  }\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:30:50.031069+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 1094,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\nThe first line of each test case contains the integer $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the desired pattern. Add an empty line after each test case.",
      "samples": [
        {
          "input": "2\n3\n4\n",
          "output": "    1     \n  1 2 1   \n1 2 3 2 1 \n\n      1       \n    1 2 1     \n  1 2 3 2 1   \n1 2 3 4 3 2 1 \n"
        },
        {
          "input": "2\n1\n2\n\n",
          "output": "1 \n\n  1   \n1 2 1 \n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Another Pyramid Pattern",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a multiset of <i>N</i> integers. Check whether there exists a nonempty subset of it such that the sum of the subset's elements is divisible by <i>N</i>. Otherwise, state that this subset doesn't exist.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>T</i> ≤ 10<br>1 ≤ <i>N</i> ≤ 10<sup>5</sup><br>1 ≤ <i>A<sub>i</sub></i> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int T; cin >> T;\n    while(T--) {\n        int n; cin >> n;\n        int a[n];\n        for(int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n\n        cout << \"YES\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:38:38.702120+00:00"
      },
      "hints": {
        "hint1": "<p>Subarrays are also the subset. Try to think in the direction of subarrays.</p>",
        "hint2": "<p>Apply Pigeon Hole Principle.</p>",
        "solution_approach": "<p>The answer is always YES irrespective of the array.<br>Consider the <i>pref[i]</i> = (<i>A<sub>1</sub> + A<sub>2</sub> + ... + A<sub>i</sub></i>) mod <i>N</i>. Base conditions <i>pref[0]</i> = 0.<br>Observe that there are <i>N</i> + 1 values in the <i>pref</i> array <i>(pref[0], pref[1], ...., pref[N])</i>, but the remainder can take in total <i>N</i> values only (0, 1, ..., <i>N</i> - 1). That means, there exists at least one pair in the <i>pref</i> array which has the same entries. &nbsp;<br>Suppose <i>pref[j] == pref[k]</i>, and <i>k</i> &gt; <i>j</i>. Then we can conclude that (<i>A<sub>j+1</sub> + ... + A<sub>k</sub></i>) is divisible by <i>N</i>.<br>Hence, the answer is always YES.</p>"
      },
      "id": 275,
      "input_format": "<p>The first line of the input contains an integer <i>T</i> denoting the number of test cases. The description of <i>T</i> test cases follows.<br>The first line of each test consists of a single integer <i>N</i> - the size of the multiset.<br>The second line of each test contains <i>N</i> single space-separated integers - the multiset's elements.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>We can pick {6} as the subset, then its sum is 6 and this is divisible by 3 - the size of the initial multiset.</p>",
      "output_format": "<p>For each test case, print 'YES' if such a subset exists, otherwise print 'NO'.</p>",
      "samples": [
        {
          "input": "1\n3\n4 6 10",
          "output": "YES"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Find the Subset",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number N and an array $A$ of $N$ positive numbers. Print maximum possible operations that can be performed.\n\nThe operation is as follows: if all numbers are $ \\textbf{even} $ then divide each of them by $2$ otherwise, you can not perform any more operations.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 2 \\leq N \\leq 200 $ \n$ 1 \\leq A[i] \\leq 10^9 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n\n        int m = 1e9;\n        for (int i = 0; i < n; i++) \n        {\n            int c = 0;\n            while (arr[i] % 2 == 0)\n            {\n                arr[i] /= 2;\n                c++;\n            }\n            m = min(m, c);\n        }\n\n        cout << m << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:31:47.034934+00:00"
      },
      "hints": {
        "hint1": "Try finding the number which is divisible by 2 minimum number of times.",
        "hint2": "Iterate over the array, get the count of times it is divisible by 2 (keep dividing it till it is even) and minimize this count using a variable.",
        "solution_approach": "Iterate over the array. Keep a count initialised with zero. If current element is even, divide it by two and increment the count. Keep incrementing in similar fashion till element is even.\nStore the minimum value of this count variable using some variable representing answer. Print that answer.\nTime Complexity : $O(nlog(max(A[i]))$"
      },
      "id": 1148,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains $ N $, the number of elements.\nSecond line contains $N$ space separated integers denoting the array",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "First example:\nInitially, $[8,12,40]$ are written on the blackboard. Since all those integers are even, You can perform the operation.\nAfter the operation is performed once, $[4,6,20]$ are written on the blackboard. Since all those integers are again even, You can perform the operation.\nAfter the operation is performed twice, $[2,3,10]$ are written on the blackboard. Now, there is an odd number 3 on the blackboard, so you cannot perform the operation any more.\nThus, you can perform the operation at most twice.\n\nSecond example:\nSince there is an odd number 5 on the blackboard already in the beginning, You cannot perform the operation at all.",
      "output_format": "Print the $ \\textbf{maximum} $ possible number of operations that can be performed.",
      "samples": [
        {
          "input": "2\n3\n8 12 40\n4\n5 6 8 10\n",
          "output": "2\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Minimize Number",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given 3 numbers $A, B$ and $C,$ Print the $\\textbf{minimum}$ and the $\\textbf{maximum}$ numbers.",
      "complete_approach": "",
      "constraints": "$ -10^5 \\leq A,B,C \\leq 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    int minElement = min({a, b, c});\n    int maxElement = max({a, b, c});\n    cout << minElement << \" \" << maxElement << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:33:25.367009+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "For C++ use stl library functions min() and max() ,for Java use Math.min() and Math.max() and for other languages use that language's min and max library functions."
      },
      "id": 1178,
      "input_format": "Only one line containing 3 numbers $A, B$ and $C$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the $\\textbf{minimum}$ number followed by a single space then print the $\\textbf{maximum}$ number.",
      "samples": [
        {
          "input": "1 2 3\n",
          "output": "1 3\n"
        },
        {
          "input": "-1 -2 -3\n",
          "output": "-3 -1\n"
        },
        {
          "input": "10 20 -5\n",
          "output": "-5 20\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Max and Min",
      "video_editorial_id": 10693
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a Number $N$ corresponding to a person's age (in days). Print his age in years, months and days, followed by its respective message \"years\", \"months\", \"days\".\n\n$ \\textbf{Note:} $ consider the whole year has $ \\textbf{365} $ days and $ \\textbf{30} $ days per month.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N \\leq 10^6 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        int y = n/365;\n        n = n%365;\n        int m = n/30;\n        n = n%30;\n        int d = n;\n        cout << y << \" years\\n\" << m << \" months\\n\" << d << \" days\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:32:10.469011+00:00"
      },
      "hints": {
        "hint1": "Try to divide and get the remainder.",
        "hint2": "",
        "solution_approach": "y = n/365\nm = (n%365)/30\nd = n - 365 . y - 30 . m"
      },
      "id": 1162,
      "input_format": "The first line contains T. The number of test cases.\nFor each testcase: The first line contains an integer $ N $.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the output, like the following examples.",
      "samples": [
        {
          "input": "1\n400\n",
          "output": "1 years\n1 months\n5 days\n"
        },
        {
          "input": "2\n800\n10",
          "output": "2 years\n2 months\n10 days\n0 years\n0 months\n10 days"
        },
        {
          "input": "1\n30\n",
          "output": "0 years\n1 months\n0 days\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Age in Days",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$ and an array $A$ of $N$ numbers. Print the $ \\textbf{lowest number} $ and its $ \\textbf{position} $.\n\n$ \\textbf{Note:} $ if there are more than one answer print $ \\textbf{first one's} $ position.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 2 \\leq N \\leq 1000 $\n$ -10^5 \\leq A[i] \\leq 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n        int small = arr[0];\n        int ans = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (small > arr[i]) \n            {\n                small = arr[i];\n                ans = i;\n            }\n        }\n        cout << small << \" \" << ans+1 << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:40:47.320035+00:00"
      },
      "hints": {
        "hint1": "Try finding the smallest element in the array.",
        "hint2": "Iterate through the array using a loop.\nKeep track of the minimum value and its corresponding index as you traverse the array.\nUpdate the minimum value and index whenever you find a smaller element.",
        "solution_approach": "let a variable, min_element = A[0]\n$ \\forall i \\in [1, N] $ min_element = min(min_element, $A[i]$)\nTime Complexity: $O(n)$"
      },
      "id": 1156,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains $ N $, the number of elements.\nSecond line contains $N$ space separated integers denoting the array",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first sample, the smallest element in the array is 1 and its position is 1.\nFor the second sample, the smallest element in the array is 2 and its position is 3 and 5, but we output the first index, 3.\nFor the third sample, the smallest element in the array is 1 and its position is 3.",
      "output_format": "Print the $ \\textbf{lowest number} $ and its $ \\textbf{position (1-index).} $",
      "samples": [
        {
          "input": "1\n3\n1 2 3\n",
          "output": "1 1\n"
        },
        {
          "input": "2\n5\n5 6 2 3 2\n3\n3 2 1\n",
          "output": "2 3\n1 3\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Lowest Number",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$ and an array $A$ of $N$ numbers. Determine if the array is $ \\textbf{lucky}$ or $ \\textbf{not} $.\n\n$ \\textbf{Note:} $ the array is $ \\textbf{lucky} $ if the $ \\textbf{frequency} $ (number of occurrence) of the minimum element is odd.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10^3 $\n$ 1 \\leq N \\leq 3*10^5$ \n$ -10^5 \\leq A[i] \\leq 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n\n        int min_element = arr[0];\n        int freq = 1;\n        for (int i = 1; i<n; i++) \n        {\n            if (min_element >= arr[i]) \n            {\n                if (min_element > arr[i]) freq = 0;\n                min_element = arr[i];\n                freq++;\n            }\n        }\n        \n        if (freq%2) \n        {\n            cout << \"Lucky\" << \"\\n\";\n        } \n        else \n        {\n            cout << \"Unlucky\" << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:42:07.690507+00:00"
      },
      "hints": {
        "hint1": "Try finding the minimum element in the array. Find frequency of this element by counting its occurrences in the array.\nTime Complexity: $O(n)$",
        "hint2": "Use a variable to store the minimum element by comparing its value with every element in the array. Take another variable to count the occurences of this element in the array. Loop through the array and increment this counter if element value matches the minimum element.",
        "solution_approach": "let min_element = $10^5+1$ and count = 0\n$ \\forall i \\in [0, N-1] $ min_element = min(min_element, $A[i]$) \n$ \\forall i \\in [0, N-1] $ count += ($A[i]$ == min_element) ? 1 : 0"
      },
      "id": 1151,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains an integer $ N $, the number of elements in the array.\nThe second line contains $N$ space separated integers denoting the elements of the array.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "First Example :\nminimum element is 5 and its frequency is 1 and it's ODD so the array is lucky.\n\nSecond Example :\nminimum element is 3 and its frequency is 4 and it's EVEN so the array is not lucky.",
      "output_format": "Print $ \\textbf{\"Lucky\"} $ (without quotes) if the frequency of the $ \\textbf{minimum element} $ is $ \\textbf{odd} $, otherwise print $ \\textbf{\"Unlucky\"} $ (without quotes).",
      "samples": [
        {
          "input": "1\n5\n8 8 9 5 9\n",
          "output": "Lucky\n"
        },
        {
          "input": "2\n5\n8 8 9 5 9\n5\n3 3 3 5 3\n",
          "output": "Lucky\nUnlucky\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Lucky Array",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "$ \\textbf{A sub-array}$ of array is an array composed from a contiguous block of the original array's elements.\n$ \\textbf{In other words}$ A sub-array $ \\textbf{A[i-j]}$, where (1 ≤ i ≤ j ≤ N), is a sequence of integers $Ai, Ai + 1, ..., Aj$.\n\nFor Example :\nIf array = $ \\textbf{[1,6,3,7]}$ then the $ \\textbf{subarrays} $ are $ \\textbf{[1] , [6] , [3] , [7] , [1,6] , [6,3],[3,7], [1,6,3] , [6,3,7] , [1,6,3,7]} $.\nSomething like $ \\textbf{[1,3]}$ would not be a sub-array as it's not a contiguous subsection of the original array.\n\nGiven a number $N$ and an array $A$ of $N$ numbers. Print the $ \\textbf{maximum} $ number of every sub-array separated by space in ascending order.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 5 $\n$ 1 \\leq N \\leq 100 $ \n$ -10^5 \\leq A[i] \\leq 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n];\n        vector<int> v;\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n\n        for (int c = 1; c <= n; c++)\n        {\n            for (int i = 0; i < n - c + 1; i++)\n            {\n                int m = arr[i];\n                for (int j = i; j < i + c; j++)\n                {\n                    m = max(m, arr[j]);\n                }\n                v.push_back(m);\n            }\n        }\n        sort(v.begin(), v.end());\n        for (int i = 0; i < v.size(); i++)\n        {\n            cout << v[i] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:42:16.254941+00:00"
      },
      "hints": {
        "hint1": "Try to go brute force.",
        "hint2": "You need to loop across every possible subarray and get the maximum element from that. You can get the subarrays of the array using a nested loop for the subarray boundaries.",
        "solution_approach": "Loop the sizes of the subarrays. In a nested loop, loop across the indexes of the array. The ending index of current subarray will be size+index.\nFor every size of subarray, loop across the subarray and get the maximum element from that. Store this element in a vector. Now sort the vector and print all its elements.\nYou can sort the vector using sort() STL function:\n$sort(vec.begin(), vec.end())$\nTime Complexity: $O(n^3 + 2*n^2log(n)) \\approx O(n^3)$"
      },
      "id": 1150,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains an integer $ N $, the number of elements in the array.\nThe second line contains $N$ space separated integers denoting the elements of the array.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "First Case :\nAll Sub arrays are :\n[1], [6], [3], [7], [1,6], [6,3], [3,7], [1,6,3], [6,3,7], [1,6,3,7]\n- Sub-array [1] it maximum number is 1.\n- Sub-array [6] it maximum number is 6.\n- Sub-array [3] it maximum number is 3.\n- Sub-array [7] it maximum number is 7.\n- Sub-array [1,6] it maximum number is 6.\n- Sub-array [6,3] it maximum number is 6.\n- Sub-array [3,7] it maximum number is 7.\n- Sub-array [1,6,3] it maximum number is 6.\n- Sub-array [6,3,7] it maximum number is 7.\n- Sub-array [1,6,3,7] it maximum number is 7.\nso the maximum numbers are [ 1,6,3,7,6,6,7,6,7,7] you can print them in ascending order.",
      "output_format": "For each test case print a single line contains the $ \\textbf{maximum number} $ of every sub-array separated by space.",
      "samples": [
        {
          "input": "1\n4\n1 6 3 7\n",
          "output": "1 3 6 6 6 6 7 7 7 7 \n"
        },
        {
          "input": "2\n4\n1 6 3 7\n3\n3 1 2\n",
          "output": "1 3 6 6 6 6 7 7 7 7 \n1 2 2 3 3 3 \n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Max Subarray",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "The following lines show some C++ data types, their format specifiers and their most common bit widths:\n\n$ \\bullet \\; \\textbf{int} $ : 32 Bit integer. \n$ \\bullet \\; \\textbf{long long} $ : 64 bit integer \n$ \\bullet \\; \\textbf{Char} $ : 8 bit Characters & symbols \n$ \\bullet \\; \\textbf{Float} $ : 32 bit real value \n$ \\bullet \\; \\textbf{Double} $ : 64 bit real value \n\n### Reading\nTo read a data type, use the following syntax:\ncin >> VariableName;\nFor example, to read a character followed by a double:\nchar ch;\ndouble d;\ncin >> ch >> d;\n \n### Printing\nTo print a data type, use the following syntax:\ncout << VariableName;\nFor example, to print a character followed by a double:\nchar ch = 'd';\ndouble d = 234.432;\ncout << ch << \" \"<< d;",
      "complete_approach": "",
      "constraints": "$ -2147483648 \\leq int \\leq 2147483647 $ \n$ -127 \\leq char \\leq 127 $ \n$ -2^{63} \\leq long \\; long \\leq 2^{63}-1 $ \n$ float = 4 \\; bytes $ \n$ double = 8 \\; bytes $ \nThe sum of $N$ over all test cases does not cross $ 10^6 $.\n$ 1 \\leq A[i] \\leq k $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    long long l;\n    cin >> l;\n    char ch;\n    cin >> ch;\n    float f;\n    cin >> f;\n    double d;\n    cin >> d;\n\n    cout << n << \"\\n\"\n         << l << \"\\n\"\n         << ch << \"\\n\"\n         << f << \"\\n\"\n         << d << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:42:09.705855+00:00"
      },
      "hints": {
        "hint1": "Define variables of each type and take input in order.",
        "hint2": "Print each variable on a new line as required in the output format.",
        "solution_approach": "Pay attention to datatype ranges."
      },
      "id": 1167,
      "input_format": "Only one line containing the following space-separated values: $ \\textbf{int}, \\textbf{long long}, \\textbf{char}, \\textbf{float} $ and $ \\textbf{double} $ respectively.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first sample and third sample, as the range of double exceeds 8 bytes, input gets rounded off to $14049.3$ and $77.7778$ respectively.<br/>",
      "output_format": "Print each element on a $ \\textbf{new line} $ in the same order it was received as input.",
      "samples": [
        {
          "input": "3 12345678912345 a 334.23 14049.30493\n",
          "output": "3\n12345678912345\na\n334.23\n14049.3\n"
        },
        {
          "input": "7 777777777777 s 777.77 7.77777\n",
          "output": "7\n777777777777\ns\n777.77\n7.77777\n"
        },
        {
          "input": "7 777777777777 s 777.77 77.77777\n",
          "output": "7\n777777777777\ns\n777.77\n77.7778\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Basic Data Types",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string S. Print the $\\textbf{summation}$ of its digits.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq |S| \\leq 10^6 $ where |S| is the length of the string.\n$\\textbf{It's guaranteed that S contains only digits from 0 to 9.}$",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string s; cin >> s;\n    int ans = 0;\n    for (auto x : s) {\n        ans += (x - '0');\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:33:53.229482+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Just add the numbers of the string and print that."
      },
      "id": 1187,
      "input_format": "Only one line contains a string $S$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "First Test : 3 + 5 + 1 = 9",
      "output_format": "Print the answer required above.",
      "samples": [
        {
          "input": "351\n",
          "output": "9\n"
        },
        {
          "input": "9999\n",
          "output": "36\n"
        },
        {
          "input": "11111111\n",
          "output": "8\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Count",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a string S. Find the minimum number of parentheses you should add to make the parentheses valid.</p><p>A parentheses is valid if:</p><ol><li>It is an empty string</li><li>It can be written as AB where A and B are valid parentheses</li><li>It can be written as (A) where is a valid parentheses</li></ol>",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 2 \\times 10^5$  \n\n$1 \\leq |S| \\leq 10^5$  \n\nIt is guaranteed that the sum of $|S|$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    string s;\n    cin >> s;\n    int n = s.size();\n    stack<char> st;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n      if (s[i] == '(')\n        st.push('(');\n      else {\n        if (st.empty())\n          ans++;\n        else\n          st.pop();\n      }\n    }\n    while (!st.empty()) {\n      st.pop();\n      ans++;\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n```\n\n\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n  string s;\n  cin >> s;\n  int flag = 0, n = s.size();\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '(') {  // new nesting start\n      flag += 1;\n    } else if (s[i] == ')') {  // close new nesting\n      flag -= 1;\n    }\n    if (flag < 0) {  // if we get ')' and flag =0, we will need to add '('\n                     // somewhere before to balance correctly.\n      ans -= flag;\n      flag = 0;\n    }\n  }\n  ans += flag;  // balance the leftover '(' nestings.\n  cout << ans << endl;\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int _t;\n  cin >> _t;\n  while (_t--) solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:15:27.187565+00:00"
      },
      "hints": {
        "hint1": "Parentheses is valid if at each index the number of opening brackets is greater than or equal to the number of closing brackets. Use stack to keep count of this number. If at any stage, the stack is empty and there is a closing bracket, the answer will increase.\nTime Complexity per test case: $O(N)$",
        "hint2": "",
        "solution_approach": "Let's understand the problem with the logic on a sample. \n(()))(()\n\n### Solution 1 - Using a stack \nNow, let's say you start, with the stack empty, and when ‘(’ comes you push, when ‘)’ Comes you pop.\n\n( → (( → pop the opening bracket -> ( -> pop the opening bracket again -> empty string\n\nNow ) comes and Stack is empty. So, this means this bracket has no matching bracket. hence, we will have to add a opening bracket just before this and balance it out.So the count of our answer increases by 1\n\nNow when the next elements come\n\n ( → (( → pop the opening bracket -> (\n\nFinally, after completion of string traversal there is 1 unmatched ‘(’ bracket in the stack. So we will need to add a Closing bracket for it. So the final answer is going to be 2 in this case. There are 2 cases that need to be handled. \n\n### Solution 2 - Without stack\nWe can solve this problem by using a `flag` variable which increases its value by $+1$ when it encounters a opening bracket and decreases it by $1$ when we get a closing bracket. So if at any time the value of the `flag` variable gooes to $-1$, that means we have got a closing bracket without a matching opening bracket. So we need to increase our answer by the 1.\n\nTime Complexity per test case: $O(N)$"
      },
      "id": 348,
      "input_format": "<p>The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</p><p>The first line of each test case contains one string S.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For the first test case, we need to add 2 opening brackets: (((())))</p><p>For the second test case, we need to add 1 closing bracket: ()()(())</p><p>For the third test case, we need two add 2 opening and 2 closing brackets: (())(())</p>",
      "output_format": "<p>For each test case, print the minimum number of parentheses you should add to make the parentheses valid.</p>",
      "samples": [
        {
          "input": "3\n(())))\n()()(()\n))((",
          "output": "2\n1\n4\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Valid Parentheses AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given a list of N students with their names and roll number. Sort the list according to their roll numbers.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$1 \\leq N \\leq 10^5$  \n\n$1 \\leq |S| \\leq 100$  \n\n$1 \\leq R \\leq 10^5$  \n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nbool comp(pair<string, int> a, pair<string, int> b) {\n  return a.second < b.second;\n}\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<pair<string, int>> v;\n    for (int i = 0; i < n; ++i) {\n      string s;\n      int r;\n      cin >> s >> r;\n      v.push_back({s, r});\n    }\n    sort(v.begin(), v.end(), comp);\n    for (int i = 0; i < n; ++i) {\n      cout << v[i].first << \" \" << v[i].second << \"\\n\";\n    }\n  }\n  return 0;\n}\n```\n\n",
          "language": "C++14"
        },
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n  int n;\n  cin >> n;\n\n  pair<int, string> arr[n];\n\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i].second >> arr[i].first;\n  }\n\n  sort(arr, arr + n);\n\n  for (int i = 0; i < n; i++) {\n    cout << arr[i].second << \" \" << arr[i].first << \"\\n\";\n  }\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin.tie(0);\n  int _t;\n  cin >> _t;\n  while (_t--) solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:45:58.854564+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Make a vector of pairs and store the name and roll number in it. Sort the vector using comparator function i.e. according to the roll number.\nOr you could also just use a vector or array to store the name and roll number in the following format {roll,name}. We use roll number as the first field because when we use sort function in vector or array it by default sorts based on the first field.So even without using comparator function it would sort it on the basis of roll numbers\n\nTime Complexity per test case: $O(N \\log N)$"
      },
      "id": 352,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer N - the length of the array. \n\nThe second line of each test case contains a string S and an integer R - the name and roll number.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the sorted list according to their roll numbers.",
      "samples": [
        {
          "input": "2\n5\namelia 21\nsophia 12\nemma 11\nava 8\nisabel 1\n3\nalice 34\nbob 20\nhannah 5\n",
          "output": "isabel 1\nava 8\nemma 11\nsophia 12\namelia 21\nhannah 5\nbob 20\nalice 34\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Sort by Roll Number",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of numbers, that might contain duplicates, <strong>print all possible unique permutations in lexicographically increasing order.</strong></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i> ≤ 8<br>0 ≤ a<sub>i</sub> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nmap<int, int> mp;\nvector<int> b;\n\nvoid rec(int l)\n{\n    if (l == n)\n    {\n        for (int i = 0; i < n; i++)\n            cout << b[i] << \" \";\n        cout << endl;\n        return;\n    }\n    for (auto &it : mp)\n    {\n        if (it.second != 0)\n        {\n            b.push_back(it.first);\n            it.second--;\n            rec(l + 1);\n            it.second++;\n            b.pop_back();\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    cin >> n;\n    int a;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a;\n        mp[a]++;\n    }\n    rec(0);\n    return 0;\n}\n\n```\n\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main()\n{\n    // freopen(\"IN\", \"r\", stdin);\n    // freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> nums[i];\n    }\n\n    sort(nums.begin(), nums.end());\n\n    do\n    {\n        for (int u : nums)\n        {\n            cout << u << \" \";\n        }\n        cout << \"\\n\";\n    } while (next_permutation(nums.begin(), nums.end()));\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:17:14.465508+00:00"
      },
      "hints": {
        "hint1": "We can always sort the entire array and then use next_permutation() to generate permutations.   \nCan you try by using recursion and backtracking?",
        "hint2": "",
        "solution_approach": "### Level\nHere we use the length of the sequence generated till now as the level. Once level reaches n we can say that a new permutation has been generated and we can print that sequence\n### Check\nCheck once the sequence reaches the required length, we can go on printing the sequence\n### Choice\nAt each recursion we iterate through the remaining elements which have not been involved in the sequence till now in a sorted manner. For each element we have a choice of taking or not taking that element.\n### Transition\nIf we choose to take an element in our permutation at the current recursion we decrease its count from the remaining elements and also add it to the answer sequence. We increase our sequence length till now by $1$. \nAfter the backtracking is complete we return and make sure to remove that element from the permutation sequence. We add the element to our remaining elements once again so that it can be used in future."
      },
      "id": 475,
      "input_format": "<p>The first line of input contains <i>n </i>- the size of the array.<br>The second line contains <i>n</i> space-separated integers denoting the elements of the array - a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print all permutations in lexicographically increasing order. See the sample output for more clarity.</p>",
      "samples": [
        {
          "input": "3\n1 1 1",
          "output": "1 1 1"
        },
        {
          "input": "3\n1 2 1",
          "output": "1 1 2 \n1 2 1 \n2 1 1 "
        },
        {
          "input": "3\n2 1 3",
          "output": "1 2 3 \n1 3 2 \n2 1 3 \n2 3 1 \n3 1 2 \n3 2 1 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "All Permutations",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p><p>Complete the function:</p><p><i>vector&lt;int&gt; getPreorderTraversal(Node* root)</i></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvoid preorderTraversal(Node* root, vector<int>&ans){\n   if(root==NULL)\n       return;\n   ans.push_back(root->val);\n   preorderTraversal(root->left,ans);\n   preorderTraversal(root->right,ans);\n}\n\nvector<int> getPreorderTraversal(Node* root) {\n   vector<int> ans;\n   if(root==NULL)\n       return ans;\n   preorderTraversal(root, ans);\n   return ans;\n}\n\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        vector<int> ans = getPreorderTraversal(tree);\n        for(auto v:ans){\n            cout<<v<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:32:44.114935+00:00"
      },
      "hints": {
        "hint1": "<p>First, print the value of the current node.</p><p>Then go to the left tree and print the preorder traversal of the left tree.&nbsp;</p><p>Then go to the right tree and print the preorder traversal of the right</p>",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 574,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, &nbsp;the length of the array representing the serialized representation of a tree.</p><p>The next line contains N-space-separated integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<pre><code class=\"language-cpp\">Test case 2- \n 5222\n    \\\n   3819\n    /\n  6801\n\t\nTest case 3 - \n   8901\n   /\n  7891\n   /   \\\n  5407 1720</code></pre>",
      "output_format": "<p>Return the preorder traversal of the tree.</p>",
      "samples": [
        {
          "input": "3\n3\n6004 -1 -1 \n7\n5222 -1 3819 6801 -1 -1 -1 \n9\n8901 7891 5407 -1 -1 1720 -1 -1 -1 ",
          "output": "6004 \n5222 3819 6801 \n8901 7891 5407 1720 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n</fix>\n\nvector<int> getPreorderTraversal(Node* root) {\n    //Complete the function\n}\n\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        vector<int> ans = getPreorderTraversal(tree);\n        for(auto v:ans){\n            cout<<v<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Preorder Traversal",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two numbers $A$ and $B$. Print all **lucky numbers** between $A$ and $B$ **inclusive**.\n\n**Note:**\n\nThe **Lucky number** is any positive number that its decimal representation contains only **$4$** and **$7$**.\n\n**For example**: numbers **$4, 7, 47$** and *$744$* are **lucky** and numbers **$5, 17$** and **$174$** are **not**.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq A \\leq B \\leq 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// O(logn) time\nbool lucky(int n)\n{\n    while (n > 0)\n    {\n        int d = n % 10;\n        if (d != 4 && d != 7)\n            return 0;\n        n /= 10;\n    }\n    return 1;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int a, b;\n    cin >> a >> b;\n    bool found = 0; // variable to check if we found a lucky number or notI\n    for (int i = a; i <= b; i++)\n    //\n    {\n        if (lucky(i))\n        {\n            found = 1;\n            cout << i << \" \";\n        }\n    }\n    if (!found)\n    {\n        cout << \"-1\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:16:35.441552+00:00"
      },
      "hints": {
        "hint1": "Think how you can check if a number is **lucky** or not.",
        "hint2": "",
        "solution_approach": "For checking if a number is **lucky** or not, we can simply extract digits of the number, if all digits are either **$4$** or **$7$**, it is **lucky**. This can be done in $O(log_{10}(N))$ time for a number $N$. We can do this for every number in the range in $O((B-A)log(B))$ time and $O(1) space$. We maintain a boolean variable to check if any number in the range is lucky or not. If no number is lucky, we print $-1$."
      },
      "id": 1209,
      "input_format": "Only one line containing two numbers $A$ and $B$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first sample, **$4$** and **$7$** are the only numbers containing only **$4$'s** and **$7$'s** in their decimal representation.\n\nFor the second sample, there are **no lucky numbers** between $8$ and $15$.",
      "output_format": "Print all **lucky numbers** between $A$ and $B$ **inclusive** separated by a space and in **sorted order**. \nIf there is **no lucky number** print **$-1$**.",
      "samples": [
        {
          "input": "4 20\n",
          "output": "4 7\n"
        },
        {
          "input": "8 15\n",
          "output": "-1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Lucky Numbers",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "An *S-Queen* is a chess piece that combines the power of a knight and a queen.  \nFind the number of ways to place *N S-Queens* on an *N x N* chessboard.\n\n![S-Queen Chess Piece Example](https://lh3.googleusercontent.com/1j2qZhweBjmpmYfhO-V59ry2Lx5c-puKhKQz5pOFp5ri3t5foF5j3-_LkNPMAoOw7roXr2h2NwEXMdvjghGsUpp4sj5ND3s_cihO0xwtaMkEIgYXQvZNT9ygWKhWgcATrlFulcH5)",
      "complete_approach": "",
      "constraints": "<p>2 ≤ <i>N ≤ </i>14</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long int\nint n;\nint ans = 0;\nvector<int> v;\n\nint checker(int x, int y) {\n  for (int i = 0; i < x; i++) {\n    if (v[i] == y || (v[i] + i) == (x + y) || (v[i] - i) == (y - x)) return 0;\n  }\n  if ((x - 1) >= 0) {\n    if (v[x - 1] == y - 2 || v[x - 1] == y + 2) return 0;\n  }\n  if ((x - 2) >= 0) {\n    if (v[x - 2] == y - 1 || v[x - 2] == y + 1) return 0;\n  }\n  return 1;\n}\n\nvoid back_tracking(int level) {\n  if (level == n) {\n    ans++;\n    return;\n  }\n  for (int i = 0; i < n; i++) {\n    if (checker(level, i)) {\n      v.push_back(i);\n      back_tracking(level + 1);\n      v.pop_back();\n    }\n  }\n}\n\nvoid solve() {\n  cin >> n;\n  back_tracking(0);\n  cout << ans << \"\\n\";\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  // int t;cin>>t;while(t--)\n  solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:47:45.949691+00:00"
      },
      "hints": {
        "hint1": "<p>Try to think in the track of N-Queens problems.</p>",
        "hint2": "<p>You only have to maintain one more condition for the knight.</p>",
        "solution_approach": "<p>Change the N-Queens solution discussed in the session.</p>"
      },
      "id": 143,
      "input_format": "<p>The input contains only single integer <i>N </i>denoting the side of the chessboard.&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the number of ways to place <i>N</i> <i>S-Queens </i>on the <i>N x N </i>chessboard.</p>",
      "samples": [
        {
          "input": "3",
          "output": "0"
        },
        {
          "input": "10",
          "output": "4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "N-Queens Revisited",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number N and an array $A$ of $N$ numbers. Print the array after doing the following operations:\n\n$ \\bullet $ Find $\\textbf{minimum}$ number in these numbers.\n$ \\bullet $ Find $\\textbf{maximum}$ number in these numbers.\n$ \\bullet $ Swap $\\textbf{minimum}$ number with $\\textbf{maximum}$ number.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 2 \\leq N \\leq 1000 $ \n$ -10^5 \\leq A[i] \\leq 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n\n        int mi = 0, Mi = 0;\n        for (int i = 1; i < n; i++)\n        {\n            if (arr[mi] > arr[i]) {\n                mi = i;\n            }\n            if (arr[Mi] < arr[i]) {\n                Mi = i;\n            }\n        }\n\n        arr[mi] = arr[mi] + arr[Mi];\n        arr[Mi] = arr[mi] - arr[Mi];\n        arr[mi] = arr[mi] - arr[Mi];\n\n        for (int i = 0; i < n; i++)\n        {\n            cout << arr[i] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:31:48.730825+00:00"
      },
      "hints": {
        "hint1": "Try capturing indexes of minimum and maximum.",
        "hint2": "Now you can swap these values using a third variable.",
        "solution_approach": "Loop across the array and store the maximum and minimum element's index in two variables. Now swap their values using these indexes.\n$temp = A[min]$\n$A[min] = A[max]$\n$A[max] = temp$\nTime Complexity: $O(n)$"
      },
      "id": 1149,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains an integer $ N $, the number of elements in the array.\nThe second line contains $N$ space separated integers denoting the elements of the array.\nIt's $\\textbf{guaranteed}$ that all numbers are distinct.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the array after the $\\textbf{replacement}$ operation.",
      "samples": [
        {
          "input": "1\n5\n4 1 3 10 8\n",
          "output": "4 10 3 1 8 \n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Replace MinMax",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given $n$ bubbles, indexed from $0$ to $n - 1$. Each bubble is painted with a number on it represented by an array $nums$. You are asked to burst all the bubbles.\n\nIf you burst the $i^{th}$ bubble, you will get $nums[i - 1] * nums[i] * nums[i + 1]$ coins. If $i - 1$ or $i + 1$ goes out of bounds of the array, then treat it as if there is a bubble with a $1$ painted on it.\n\nFind the maximum coins you can collect by bursting the bubbles wisely.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 200$\n$1 \\leq n \\leq 200$\n$0 \\leq nums[i] \\leq 100$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvector<vector<int>> dp;\nint rec(int i, int j, vector<int>&nums) {\n\tif (i > j)return 0;\n\tauto &ans = dp[i][j];\n\tif (ans != -1)return ans;\n\tans = 0;\n\tfor (int k = i + 1; k < j; k++) {\n\t\tans = max(ans, rec(i, k, nums) + rec(k, j, nums) + nums[k] * nums[i] * nums[j]);\n\t}\n\treturn ans;\n}\nint maxCoins(vector<int>& nums) {\n\tint n = nums.size();\n\tdp.assign(n + 2, vector<int>(n + 2, -1));\n\tvector<int> nums2(n + 2);\n\tnums2[0] = nums2[n + 1] = 1;\n\tfor (int i = 0; i < n; i++)nums2[i + 1] = nums[i];\n\treturn rec(0, n + 1, nums2);\n}\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<int> v(n);\n\tfor (int i = 0; i < n; i++)cin >> v[i];\n\tcout << maxCoins(v) << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:24:45.601574+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "**State -:** $dp[i][j]:$ coins obtained from bursting all the bubbles between index $i$ and $j$ (not including $i$ or $j$)\n\n**Transition -:** $dp[i][j] = max(nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])$ for $k$ in $(i+1,j))$\n\nIf $k$ is the index of the last bubble burst in $(i, j)$, the coins that burst will get are $nums[i] * nums[k] * nums[j]$, and to calculate $dp[i][j]$, we also need to add the coins obtained from bursting bubbles between $i$ and $k$, and between $k$ and $j$, i.e., $dp[i][k]$ and $dp[k][j]$.\n\nTo Handle Edge case, consider array of size $n+2$ with 1st and last value to be $1$ and rest $1$ to $n$ indexes have same value as $nums$, therefore, final answer will be $dp[0][n+1]$;\n\n**Time Complexity -:** $O(n^3)$."
      },
      "id": 975,
      "input_format": "The First line contains $T$ - the number of test cases.\nThe first line of each test case contains $n$.\nThe second line of each test case contains $n$ elements of the array $nums$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "$nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []$\n\ncoins =  $3*1*5$    +   $3*5*8$   +  $1*3*8$  + $1*8*1$ = $167$",
      "output_format": "For each test case, Output the maximum coins you can collect by bursting the bubbles wisely.",
      "samples": [
        {
          "input": "4\n4\n3 1 5 8\n2\n1 5\n1\n10\n3\n5 0 5\n",
          "output": "167\n10\n10\n30\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Bubbles",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Vivek has built a new classroom with N seats. The seats are located along a straight line at positions x1,x2…..xN.<br>Vivek has to assign seats to K students such that a seat can be assigned to at most 1 student and the minimum distance between any two students is as large as possible. Find the largest minimum distance possible.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nsigned main(){\n   ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n   int t;\n   cin >> t;\n   while(t--) {\n       int n, k;\n       cin >> n >> k;\n       int x[n];\n       for (int i = 0; i < n; ++i) {\n           cin >> x[i];\n       }\n       sort(x, x+n);\n       int l = 1, r = x[n-1]-x[0];\n       int ans = 1;\n       while(l <= r) {\n           int mid = (l+r)/2;\n           int cnt = 1;\n           int prev = x[0];\n           for (int i = 1; i < n; ++i) {\n               if(x[i] >= prev + mid) {\n                   cnt++;\n                   prev = x[i];\n               }\n           }\n           if(cnt >= k) {\n               ans = mid;\n               l = mid + 1;\n           }\n           else {\n               r = mid - 1;\n           }\n       }\n       cout << ans << \"\\n\";\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:59.637867+00:00"
      },
      "hints": {
        "hint1": "If minimum distance, X is possible by assigning seats to K students, then it is possible to have a minimum distance lesser than X as well. That means this is a monotonic function. You can use this to apply binary search.",
        "hint2": "<p>We would be doing binary search on the largest minimum adjacent distance possible. First, we will sort the seat positions given to us. We take the left pointer as L = 1(since it is given that a seat can be assigned to at most 1 student) and R = X[N-1] - X[0]. We take mid = (L+R)/2. Find the number of students that can be seated if the minimum separation should be mid. This can be done by assigning the first seat to student 1 and then assigning seats such that they have separation of at least mid.</p><p>If this number is ≥ K, that means this can be a possible answer and so we continue binary search on L = mid+1 to R. Otherwise, we need to decrease the value of minimum distance to allow more number of students to be seated so we continue binary search on L to R = mid-1.</p><p>Time Complexity per test case: O(N * log<sub>2</sub>(X[N-1] - X[0]))</p>",
        "solution_approach": ""
      },
      "id": 471,
      "input_format": "<p>The first line contains a single integer T (1 ≤ T ≤ 100000) - the number of test cases.</p><p>The first line of each test case contains 2 space-separated integers N, K (2 ≤ N ≤ 100000, 2 ≤ K ≤ N) - the number of seats and the number of students.</p><p>The second line of each test case contains N space-separated integers (0 ≤ xi ≤ 10^9) - the position of the seats. All the given positions are distinct.</p><p>Sum of N across all test cases ≤ 10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the largest minimum distance possible in a new line.</p>",
      "samples": [
        {
          "input": "14\n13 3\n6048 2794 6123 1643 6907 6993 2382 6961 1094 488 7424 6469 6009 \n10 6\n469 706 278 545 711 386 298 242 385 316 \n18 17\n1042 271 839 45 1253 1060 428 676 418 1298 1230 668 665 158 916 659 458 202\n11 10\n16073873 456996657 980038523 123316193 427829862 54109396 319462445 181390046 543060523 490620628 938036110\n6 2\n274592090 858952753 241301573 721888021 806214246 383142174\n12 5\n5940 28062 23820 1965 3005 18306 23749 18322 17322 15504 14570 4481\n17 13\n1905 1798 5250 986 1239 3311 3519 5262 2444 151 5580 5008 1914 2366 5285 1528 331 \n4 3\n792050646 886157889 58701906 576742651\n9 6\n3584 5153 5516 6249 2453 3992 6179 1646 4810\n7 6\n149042184 953621985 987837168 343845676 726735692 6723177 435784762 \n4 3\n149479138 621021707 506424026 519149062 \n2 2\n1557 4228 \n5 2\n4150 9442 5146 9633 3537\n6 4\n160913372 862781533 10044128 722271773 201193061 944524755 ",
          "output": "2306\n70\n8\n38035523\n617651180\n3975\n116\n309415238\n706\n91939086\n114597681\n2671\n6096\n191148933"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "ClassRoom",
      "video_editorial_id": 8209
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two numbers $A$ and $B$. Print $ \\textbf{\"Yes\"} $ if $A$ is $ \\textbf{greater than or equal to } B$. Otherwise print $ \\textbf{\"No\"} $.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq A, B \\leq 100 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int A, B;\n        cin >> A >> B;\n        if (A>=B) cout << \"Yes\";\n        else cout << \"No\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:32:25.530889+00:00"
      },
      "hints": {
        "hint1": "In c++, We use if...else block to check conditional statements. Also we can use conditional operators like '<' for less than and '<=' for less than or equal to.",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 1165,
      "input_format": "The first line contains T. The number of test cases. <br/>\nFor each testcase: The first line contains two space seperated integers $ A $ and $ B $.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For 1st sample, A = 10, B = 9. Since A>=B output is Yes\nIn the 3rd sample, A = 5 and B = 7. Since A>=B is false, output is No.",
      "output_format": "Print \"Yes\" or \"No\" according to the statement.",
      "samples": [
        {
          "input": "1\n10 9\n",
          "output": "Yes\n"
        },
        {
          "input": "1\n5 5\n",
          "output": "Yes\n"
        },
        {
          "input": "1\n5 7\n",
          "output": "No\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Welcome Conditions",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Zenithland has n cities and m roads between them. The goal is to construct new roads so that there is a route between any two cities. A road is bidirectional.\nYour task is to find out the minimum number of roads required.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i> ≤ 10<sup>5</sup><br>1 ≤ <i>m</i> ≤ 2 x 10<sup>5</sup><br>1 ≤ <i>a, b</i> ≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ld long double\nconst int N = 100010;\nint inf = 1e9;\nint mod = 1e9 + 7;\nvector<vector<int>> g;\nvector<int> vis;\nvoid dfs(int node, int num_comp)\n{\n    vis[node] = 1;\n    for (auto x : g[node])\n    {\n        if (vis[x] == 0)\n        {\n            dfs(x, num_comp);\n        }\n    }\n}\nvoid solve()\n{\n    int n, m;\n    cin >> n >> m;\n    g.resize(n + 1);\n    vis.assign(n + 1, 0);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int num_comp = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (vis[i] == 0)\n        {\n            num_comp++;\n            dfs(i, num_comp);\n        }\n    }\n    cout << num_comp - 1 << \"\\n\";\n}\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    // int _t;cin>>_t;while(_t--)\n    solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:33:33.253797+00:00"
      },
      "hints": {
        "hint1": "Find the number of connected components.",
        "hint2": "Apply BFS/DFS to find the number of connected components in the graph, let it be C. Then the answer will be C - 1.",
        "solution_approach": "Apply BFS/DFS to find the number of connected components in the graph, let it be C. Then the answer will be C - 1.\nWe just need to connect the components with each other. One component can be connected with the next component via 1 edge."
      },
      "id": 192,
      "input_format": "The first input line has two integers n and m: the number of cities and roads. The cities are numbered 1, 2, …, n.\nAfter that, there are m lines describing the roads. Each line has two integers a and b: there is a road between those cities.\nA road always connects two different cities, and there is at most one road between any two cities.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "<p>Construct a road between cities 1 and 3.</p>",
      "output_format": "<p>Print the number of minimum roads required.</p>",
      "samples": [
        {
          "input": "4 2\n1 2\n3 4",
          "output": "1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Building Roads",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given two vectors in <i>N</i>-dimension space, let it be <i>V</i> and <i>W</i>.<br><i>V</i> = &lt;<i>V<sub>1</sub></i>, <i>V<sub>2</sub></i>, ..., <i>V<sub>N</sub></i>&gt;<br><i>W</i> = &lt;<i>W<sub>1</sub></i>, <i>W<sub>2</sub></i>, ..., <i>W<sub>N</sub></i>&gt;</p><p>The dot product is defined as <i>V.W</i> = <i>V<sub>1</sub> * W<sub>1</sub> + V<sub>2</sub> * W<sub>2</sub> + ... + V<sub>N</sub> * W<sub>N</sub></i>.</p><p>Now you are allowed to permute numbers in vectors, in order to minimize the dot product. Find the minimum dot product that you can get.</p><p>See sample test cases for more explanation.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int T; cin >> T;\n    while(T--) {\n        int n; cin >> n;\n\n        int v[n], w[n];\n\n        for(int i = 0; i < n; i++) cin >> v[i];\n        for(int i = 0; i < n; i++) cin >> w[i];\n\n        sort(v, v + n);\n        sort(w, w + n);\n\n        ll ans = 0;\n\n        for(int i = 0, j = n - 1; i < n; i++, j--)\n            ans += 1LL * v[i] * w[j];\n\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:24:34.416545+00:00"
      },
      "hints": {
        "hint1": "<p><i>Try to think in a greedy way.</i> Observe that we don't need to permute <i>V</i> vector, we only need to permute on <i>W</i> vector. And we have to match each element of <i>V</i> to elements in <i>W</i> such that the dot product is minimized.</p>",
        "hint2": "<p>Let consider two vectors <i>V</i> = &lt;<i>V<sub>1</sub>, V<sub>2</sub></i>&gt;, <i>W</i> = &lt;<i>W<sub>1</sub>, W<sub>2</sub></i>&gt;. Without loss of generality assume that <i>V<sub>1</sub> &lt; V<sub>2</sub></i> and <i>W<sub>1</sub> &lt; W<sub>2</sub></i>.<br>So now by considering <u>Hint 1</u>, we only have to see two scenarios here.<br>1. <i>V</i> = &lt;<i>V<sub>1</sub>, V<sub>2</sub></i>&gt;, <i>W</i> = &lt;<i>W<sub>1</sub>, W<sub>2</sub></i>&gt; : <i>V.W = V<sub>1</sub> * W<sub>1</sub> + V<sub>2</sub> * W<sub>2</sub></i><br>2. <i>V</i> = &lt;<i>V<sub>1</sub>, V<sub>2</sub></i>&gt;, <i>W</i> = &lt;<i>W<sub>2</sub>, W<sub>1</sub></i>&gt; : <i>V.W = V<sub>1</sub> * W<sub>2</sub> + V<sub>2</sub> * W<sub>1</sub></i><br>Can you prove that the 2nd one is better than the first?</p>",
        "solution_approach": "<p>Observe that we don't need to permute <i>V</i> vector, we only need to permute on <i>W</i> vector. And we have to match each element of <i>V</i> to elements in <i>W</i> such that the dot product is minimized.</p><p>Let <i>V</i> = &lt;<i>V<sub>1</sub>, V<sub>2</sub>, ..., V<sub>N</sub></i>&gt; and <i>W</i> = &lt;<i>W<sub>1</sub>, W<sub>2</sub>, ..., W<sub>N</sub></i>&gt;.<br>Without loss of generality, assume that <i>V<sub>1</sub> </i><span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span><i> V<sub>2</sub> </i><span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span><i> ... </i><span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span><i> V<sub>N</sub></i>. Suppose there exist two indices <i>i</i> and <i>j</i>, such that <i>i &lt; j</i> and <i>W<sub>i</sub> &lt; W<sub>j</sub></i>. We try to see the result when we swap these two indices.</p><ol><li><i>V</i> = &lt;<i>V<sub>1</sub>, V<sub>2</sub>, ..., V<sub>N</sub></i>&gt;, <i>W</i> = &lt;<i>W<sub>1</sub>, W<sub>2</sub>, ..., W<sub>i</sub>, ..., W<sub>j</sub>, ..., W<sub>N</sub></i>&gt;. <i>V.W = V<sub>1</sub> * W<sub>1</sub> + ... + V<sub>i</sub> * W<sub>i</sub> + ... + V<sub>j</sub> * W<sub>j</sub> + ... + V<sub>N</sub> * W<sub>N</sub>.</i></li><li><i>V</i> = &lt;<i>V<sub>1</sub>, V<sub>2</sub>, ..., V<sub>N</sub></i>&gt;, <i>W</i> = &lt;<i>W<sub>1</sub>, W<sub>2</sub>, ..., W<sub>j</sub>, ..., W<sub>i</sub>, ..., W<sub>N</sub></i>&gt;. <i>V.W = V<sub>1</sub> * W<sub>1</sub> + ... + V<sub>i</sub> * W<sub>j</sub> + ... + V<sub>j</sub> * W<sub>i</sub> + ... + V<sub>N</sub> * W<sub>N</sub>.</i></li></ol><p>Compare these two dot-products. <i>V<sub>i</sub> * W<sub>i</sub> + V<sub>j</sub> * W<sub>j</sub> &gt; V<sub>i</sub> * W<sub>j</sub> + V<sub>j</sub> * W<sub>i</sub></i>.<br>We can conclude that 2nd one is better. That means when we swap <i>i</i> and <i>j</i>, we get better results.</p><p>If we apply this result inductively, we get the following algorithm.</p><ol><li>Sort all <i>V<sub>i</sub></i>s in ascending order.</li><li>Sort all <i>W<sub>i</sub></i>s in descending order.</li><li>Find the dot-product. It's the minimum one.</li></ol><p>See the solution code.<br><br><strong>Time complexity:</strong> <i>O(NlogN)</i><br><strong>Space complexity:</strong> <i>O(N) extra space</i></p>"
      },
      "id": 96,
      "input_format": "<p>The first line contains a number <i>T</i> (1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>T</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>5</sup>) - the number of test cases. Then <i>T</i> lines follow.<br>The first line of each test cases contains single integer <i>N</i> (1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>N</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>5</sup>) - the number of dimensions.<br>The second line contains <i>N</i> space-separated integers <i>V<sub>1</sub>, V<sub>2</sub>, ..., V<sub>N</sub></i> (0 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤ </span>|<i>V<sub>i</sub></i>| <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>5</sup>) - the vector <i>V</i>.<br>The third line contains <i>N</i> space-separated integers <i>W<sub>1</sub>, W<sub>2</sub>, ..., W<sub>N</sub></i> (0 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤ </span>|<i>W<sub>i</sub></i>| <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>5</sup>) - the vector <i>W</i>.<br>It is guaranteed that the sum of <i>N</i> over all test cases doesn't exceed 5 x 10<sup>5</sup>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>Consider all possible combinations.</p><ol><li><i>V</i> = &lt;2, 3&gt;, <i>W</i> = &lt;-1, 4&gt;: <i>V.W </i>= 10</li><li><i>V</i> = &lt;2, 3&gt;, <i>W</i> = &lt;4, -1&gt;: <i>V.W</i> = 5</li><li><i>V</i> = &lt;3, 2&gt;, <i>W</i> = &lt;-1, 4&gt;: <i>V.W</i> = 5</li><li><i>V</i> = &lt;3, 2&gt;, <i>W</i> = &lt;4, -1&gt;: <i>V.W</i> = 10</li></ol><p>The minimum dot product that we can get is 5.</p><p><i><strong>Explanation 2:</strong></i><br>We can get minimum dot product when <i>V</i> = &lt;2, 4, -2&gt; and <i>W</i> = &lt;0, -7, 5&gt;, i.e., <i>V.W</i> = -38.</p>",
      "output_format": "<p>For each test case, output a single integer on a new line — the minimum dot product that you can obtain.</p>",
      "samples": [
        {
          "input": "2\n2\n2 3\n-1 4\n3\n2 4 -2\n5 0 -7",
          "output": "5\n-38"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Minimizing Dot Problem",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "A city’s skyline is made up from the outer contour of the city’s silhouette. This silhouette can be seen when a city is viewed from a distance. \n\n<p>&nbsp;</p><figure class=\"image image_resized\" style=\"width:53%;\"><img src=\"https://algozenith.s3.ap-south-1.amazonaws.com/content/25-04-22/99_7b7290d5-9e2b-4752-a37f-fc78168ad6ca.png\"></figure>\n\nGiven the locations and heights of all the buildings, return the skyline formed by these buildings collectively.\n\nThe geometric information of each building is given in the array buildings where $buildings[i] = [l_i, r_i, h_i]$:\n-   $l_i$ is the x coordinate of the left edge of the $i^{th}$ building.\n-   $r_i$ is the x coordinate of the right edge of the $i^{th}$ building.\n-   $h_i$ is the height of the $i^{th}$ building.\n\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height $0$.\n\n\nThe skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form $[[x_1,y_1],[x_2,y_2],...]$. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate $0$ and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n\n#### Note: \nThere must be no consecutive horizontal lines of equal height in the output skyline. For instance, [..., [2 3] , [4 5] , [7 5] , [11 5] , [12 7] ,... ] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [..., [2 3] , [4 5] , [12 7] , ...].",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10$\n$1 \\leq n \\leq 10^{4}$\n$0 \\leq l_i < r_i \\leq 10^{9}$\n$1 \\leq h_i \\leq 10^{6}$\n\n- Buildings in the input are sorted by $l_i$ in non-decreasing order for each test case.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvector<vector<int>> Skyline(vector<vector<int>>& b) {\n    multiset<vector<int>> buff;\n    vector<vector<int>> ans;\n    int curmx = b[0][2], r = b[0][1], idx = 0;\n    ans.push_back({b[0][0], curmx});\n    vector<array<int, 3>> v;\n    for (int i = 0; i < b.size(); i++) {\n        v.push_back({b[i][0], -1, i});\n        v.push_back({b[i][1], 1, i});\n    }\n    sort(v.begin(), v.end());\n    for (auto x : v) {\n        if (x[1] == -1) {\n            int i = x[2];\n            buff.insert({b[i][2], i});\n            if (curmx == b[i][2]) {\n                if (b[i][1] > r)r = b[i][1], idx = i;\n            }\n            else if (curmx < b[i][2]) {\n                curmx = b[i][2];\n                r = b[i][1];\n                idx = i;\n                if (ans.back()[0] == b[i][0])ans.pop_back();\n                ans.push_back({b[i][0], curmx});\n            }\n        }\n        else {\n            int i = x[2];\n            buff.erase(buff.find({b[i][2], i}));\n            if (idx == i) {\n                if (buff.size()) {\n                    auto p = *buff.rbegin();\n                    if (p[0] != curmx) {\n                        if (ans.back()[0] == b[i][1])ans.pop_back();\n                        ans.push_back({b[i][1], p[0]});\n                    }\n                    curmx = p[0];\n                    idx = p[1];\n                    r = b[idx][1];\n                }\n                else {\n                    curmx = 0;\n                    if (ans.back()[0] == b[i][1])ans.pop_back();\n                    ans.push_back({b[i][1], curmx});\n                }\n            }\n        }\n    }\n    return ans;\n}\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<vector<int>> v(n, vector<int>(3));\n    for (int i = 0; i < n; i++) {\n        cin >> v[i][0] >> v[i][1] >> v[i][2];\n    }\n    auto ans = Skyline(v);\n\n    for (auto x : ans)cout << x[0] << \" \" << x[1] << endl;\n    cout << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:24:30.471052+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "The idea is to do a \"**line sweep**\" and just process the buildings only at the start and endpoints.\n\nThe key is to use a priority queue to save all the buildings that are still \"alive\". The queue is sorted by its height and end time (the larger height first and if equal height, the one with a bigger end time first). \n For each iteration, we first find the current process time, which is either the next new building start time or the end time of the top entry of the live queue. \n\nIf the new building's start time is larger than the top one end time, then process the one in the queue first (pop them until it is empty or find the first one that ends after the new building); Otherwise, if the new building starts before the top one ends, then process the new building (just put them in the queue). After processing, output it to the resulting vector if the height changes. \n\nComplexity is the worst-case $O(NlogN)$."
      },
      "id": 966,
      "input_format": "The first line contains $T$- the number of test cases.\nFirst line of each test case contains $n$ - the number of buildings.\nNext $n$ lines of each test case will contains $l_i$, $r_i$, $h_i$ of the $building_i$",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the $[x_i , y_i ]$ coordinates of the skyline formed by these buildings collectively with increasing $x_i$ coordinate in a newline.\nAfter each test case, output a newline.",
      "samples": [
        {
          "input": "3\n5\n2 9 10\n3 7 15\n6 12 12\n13 16 10\n15 17 5\n2\n0 2 3\n2 5 3\n5\n4 9 10\n4 9 15\n4 9 12\n10 12 10\n10 12 8\n",
          "output": "2 10\n3 15\n7 12\n12 0\n13 10\n16 5\n17 0\n\n0 3\n5 0\n\n4 15\n9 0\n10 10\n12 0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Skyline",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a graph of N nodes having N-1 directed edges. If we don't take the direction of edges into consideration then the graph is a tree.</p><p>You have to find all the nodes u, such that it is possible to move from node u to all the other nodes by changing the direction of minimum number of edges.</p><p>Print the minimum number of inversions required such that it is possible to reach all the nodes from a node u. After that print all the possible node u in ascending order in the next line.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:13:24.077462+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 450,
      "input_format": "<p>The first line contains an integer T ( 1 ≤ T ≤ 10^5) - the number of test cases.</p><p>The first line of each test case contains an integer N( 1 ≤ N≤ 10^5).</p><p>The next N-1 lines contain a description of an edge → u<sub>i</sub>, v<sub>i</sub> (1 ≤ u<sub>i</sub>, v<sub>i</sub> ≤ N, u<sub>i</sub>≠v<sub>i</sub>,). Vertices u<sub>i</sub> and v<sub>i</sub> are connected by a directed edge from u<sub>i</sub> to v<sub>i</sub>.</p><p>It is guaranteed that sum of all N over all test cases does not exceed 10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the minimum number of inversions required such that it is possible to reach all the nodes from a node u. After that print all the possible node u in ascending order in the next line.</p>",
      "samples": [
        {
          "input": "2\n8\n1 2\n3 2\n4 3\n4 5\n6 5\n6 7\n8 7\n10\n2 3\n1 8\n9 5\n5 4\n6 10\n4 8\n5 6\n7 6\n5 3",
          "output": "3\n4 6 8 \n3\n9 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Minimum Inversion Of Edges",
      "video_editorial_id": 8207
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two binary trees. We need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the non-null node will be used as the node of new tree.",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:47:05.799503+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 675,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, the length of the array representing the serialized representation of a tree1.</p><p>The next line contains N-space-separated distinct integers.&nbsp;</p><p>The next line contains an integer M, the length of the array representing the serialized representation of a tree2.</p><p>The next line contains M-space-separated distinct integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case return the new merged tree root node.&nbsp;</p>",
      "samples": [
        {
          "input": "1\n11\n1496 5959 -1 -1 5566 1754 -1 -1 8678 -1 -1 \n9\n1358 5601 8697 -1 -1 8984 -1 -1 -1 ",
          "output": "2854 11560 8697 -1 -1 8984 -1 -1 5566 1754 -1 -1 8678 -1 -1 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n</fix>\nNode *getMergedTree(Node * t1, Node * t2)\n{\n    // Complete the function.\n}\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nvoid generateArray(Node* root, vector<int>&ans){\n    if(root==NULL){\n        ans.push_back(-1);\n        return;\n      }\n    ans.push_back(root->val);\n    generateArray(root->left,ans);\n    generateArray(root->right,ans);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree1 = getBinaryTree(arr,&ind);\n        arr.clear();\n        cin>>n;\n        assert(n<=1000000);\n        arr.resize(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        ind = 0;\n        Node* tree2 = getBinaryTree(arr,&ind);\n        Node* mergedTree = getMergedTree(tree1,tree2);\n        vector<int>ans;\n        generateArray(mergedTree,ans);\n        for(auto v:ans)cout<<v<<\" \";\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 3,
      "title": "Merge Two Binary Tree",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$. Print all **prime** numbers between **$1$** and **$N$** inclusive.\n\nA **prime** number is a number that is greater than $1$ and has \nonly two factors which are $1$ and **itself**. In other words : **prime number divisible only by $1$ and itself**. **Be careful that $1$ is not prime**.\n\nThe first few **prime** numbers are $2, 3, 5, 7, 11 ...$",
      "complete_approach": "",
      "constraints": "$ 2 \\leq N \\leq 10^3 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int x){\n    for(int i=2;i<x;i++){\n        if(x%i==0)return 0;\n    }\n    return 1;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    for(int i=2;i<=n;i++){\n        if(isPrime(i)){\n            cout<<i<<\" \";\n        }\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:34:47.188859+00:00"
      },
      "hints": {
        "hint1": "Check each number in **range** is prime or not.",
        "hint2": "To check each number, check if it has a divisor other than 1 and itself.",
        "solution_approach": "Here is the key logic to check\n\n```cpp\nbool isPrime(int x){\n    for(int i=2;i<x;i++){\n        if(x%i==0)return 0;\n    }\n    return 1;\n}\n```"
      },
      "id": 1208,
      "input_format": "Only one line containing a number $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the example above: $2, 3, 5$, and $7$ are the primes within $1$ to $10$.",
      "output_format": "Print all prime numbers between $1$ and $N$ (inclusive) separated by a space.",
      "samples": [
        {
          "input": "10\n",
          "output": "2 3 5 7\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Primes from 1 to n",
      "video_editorial_id": 10691
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$. Determine whether $N$ is power of 2 or not.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N \\leq 10^{18} $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solution()\n{\n    long long n;\n    cin >> n;\n    if (ceil(log2(n)) == floor(log2(n)))\n    {\n        cout << \"YES\" << endl;\n    }\n    else\n    {\n        cout << \"NO\" << endl;\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:37:32.091100+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "A simple method for this is to simply take the log of the number on base 2 and if you get an integer then the number is the power of 2."
      },
      "id": 1228,
      "input_format": "Only one line contains a number $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print \"$\\textbf{YES}$\" if $N$ is power of 2 otherwise, print \"$\\textbf{NO}$\".",
      "samples": [
        {
          "input": "8\n",
          "output": "YES\n"
        },
        {
          "input": "10\n",
          "output": "NO\n"
        },
        {
          "input": "1\n",
          "output": "YES\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Power Of Two",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string $S$. For each word in $S$ reverse its letters then print it.\n\n$\\textbf{Note:}$ words are separated by space.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq |S| \\leq 10^6 $ where $|S|$ is the length of the string and it consists of $\\textbf{lowercase}$ and $\\textbf{uppercase}$ English letters, spaces.",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string s;\n    int flag = 0;\n    while (cin >> s) {\n        reverse(s.begin(), s.end());\n        if (flag) {\n            cout << \" \";\n        }\n        flag = 1;\n        cout << s;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:34:20.383678+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Run a while loop when there is a input otherwise break. first time don't print the space after that print 1 space after every reversed string.\n\nFor reverse you can use reverse() function in c++ and for other language use their respective functions."
      },
      "id": 1198,
      "input_format": "Only one line contains a strings $S$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the answer required above.",
      "samples": [
        {
          "input": "I love you\n",
          "output": "I evol uoy\n"
        },
        {
          "input": "You love me\n",
          "output": "uoY evol em\n"
        },
        {
          "input": "We are a happy family\n",
          "output": "eW era a yppah ylimaf\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Reverse Words",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a name $S$. Print \"Hello, (name)\" without parentheses.",
      "complete_approach": "",
      "constraints": "1 <= |S| <= 100",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    string s;\n    cin >> s;\n    cout << \"Hello, \" << s << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:23:31.145330+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Include necessary C++ libraries.\nCreate the main function as the program's entry point.\nDeclare a string variable to store user input.\nUse cin to read a name from the user.\nPrint a greeting message containing the user's name."
      },
      "id": 1133,
      "input_format": "Only one line containing a string $S$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print \"Hello, \" without quotes, then print name.",
      "samples": [
        {
          "input": "Jane\n",
          "output": "Hello, Jane\n"
        },
        {
          "input": "Peter\n",
          "output": "Hello, Peter\n"
        },
        {
          "input": "Bruce\n",
          "output": "Hello, Bruce\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Say Hello With C++",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$. Print the result of doing the following operation on $N$:\n\n* Convert $N$ to its **binary** representation.\n* Count number of **ones** in the above **binary** representation.\n* Print the equivalent **decimal** number that its **binary** representation has only the number of ones that were counted above.\n\n**For example**: $(10)_{decimal}$ = $(1010)_{binary}$ has $2$ ones \"11\", after converting \"11\" to decimal number it will become $3$.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N \\leq 2^{31}-1$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// O(T) time complexity\n// O(1) space\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        int cnt = 0;\n        // stores how many 1 bits found till current position\n        int val = 0;\n        for (int i = 0; i < 31; i++)\n        // traversing the bits of the binary representation from right to left\n        {\n            if ((n >> i) & 1) // if bit 1\n            {\n                cnt++; // increment counter\n            }\n        }\n        // so the value we are interested in is (11...1) cnt times which is 2^(cnt of 1 bits)-1\n        cout << (1 << cnt) - 1 << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:41:26.999372+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We can simply iterate over the **bits** of the number, and calculate **number of 1 bits** in the binary representation of the number. Let $cnt$ be the number of $1$ bits in $N$. Then the final answer is simply decimal value of $(111...1)$ $cnt$ times in binary which is $2^{cnt}-1$ in decimal. The time complexity of this approach is $O(1)$ per test case and space complexity is $O(1)$."
      },
      "id": 1218,
      "input_format": "First line contains a number $T$, the number of test cases.\nNext $T$ lines will contain a number $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first sample, there are $3$ test cases.\n\nFor the first test case, $10$ in binary is $1010$, it has $2$ ones, so the answer is $3$.\n\nFor the second test case, $7$ in binary is $111$, it has $3$ ones, so the answer is $7$.\n\nFor the third test case, $8$ in binary is $1000$, it has $1$ ones, so the answer is $1$.",
      "output_format": "For each test case print a single line contains the answer according to the required above.",
      "samples": [
        {
          "input": "3\n10\n7\n8\n",
          "output": "3\n7\n1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Convert To Decimal",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given q queries and a multiset A, initially containing only integer 0. There are three types of queries:</p><p>\"+ x\" — add integer x to multiset A.</p><p>\"- x\" — erase one occurrence of integer x from multiset A. It's guaranteed that at least one x is present in the multiset A before this query.</p><p>\"? x\" — you are given integer x and need to compute the value , i.e. the maximum value of bitwise exclusive OR (also know as XOR) of integer x and some integer y from the multiset A.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nclass trieNode {\npublic:\n    int freq;\n    trieNode* left;\n    trieNode* right;\n    trieNode() {\n        freq = 0;\n        left = NULL;\n        right = NULL;\n    }\n};\n\nvoid insert(int n, trieNode* head) {\n    trieNode* cur = head;\n    for (int i = 31; i >= 0; --i) {\n        int bit = (n >> i)&1;\n        if(bit) {\n            if(!cur->right) {\n                cur->right = new trieNode();\n            }\n            cur = cur->right;\n            cur->freq++;\n        }\n        else {\n            if(!cur->left) {\n                cur->left = new trieNode();\n            }\n            cur = cur->left;\n            cur->freq++;\n        }\n    }\n}\n\nvoid erase(int n, trieNode* head) {\n    trieNode* cur = head;\n    for (int i = 31; i >= 0; --i) {\n        int bit = (n >> i)&1;\n        if(bit) {\n            cur->right->freq--;\n            cur = cur->right;\n        }\n        else {\n            cur->left->freq--;\n            cur = cur->left;\n        }\n    }\n}\n\nint findMaxXOR(int n, trieNode* head) {\n    trieNode* cur = head;\n    int ans = 0;\n    for (int j = 31; j >= 0; --j) {\n        int bit = (n >> j)&1;\n        if(bit) {\n            if(cur->left && cur->left->freq > 0) {\n                ans += (1<<j);\n                cur = cur->left;\n            }\n            else {\n                cur = cur->right;\n            }\n        }\n        else {\n            if(cur->right && cur->right->freq > 0) {\n                ans += (1<<j);\n                cur = cur->right;\n            }\n            else {\n                cur = cur->left;\n            }\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int q;\n    cin >> q;\n    trieNode* head = new trieNode();\n    insert(0, head);\n    while(q--) {\n        char c;\n        int x;\n        cin >> c >> x;\n        if(c == '+') {\n            insert(x, head);\n        }\n        else if(c == '-') {\n            erase(x, head);\n        }\n        else {\n            cout << findMaxXOR(x, head) << \"\\n\";\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:37:44.967856+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">For problems involving xor, you should think about the bits of the numbers. We need to maximise the xor, so it will be beneficial to take the number which can result in a higher value of the most significant bit.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">You can make a Trie to insert and erase the numbers. Since duplicates are allowed, you can use the frequency as a parameter to make the code simpler. Whenever you need to insert, you can increase the frequency of the bits present in that number and decrease when you need to erase it.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Whenever you need to find the maximum possible value of xor with a number present in the multiset (or say the trie), you need to start from the maximum bit of the number. Since maximum value is given as 1e9, you can start with 30 since log2(1e9) &lt; 30. If the current bit of the given integer x is 0, you should try to take the number which has current bit as 1, if it is possible since 0^1=1. Similarly if the current bit is 1, you should try to take number with current bit as 0.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity: O(Q*log(max(A<sub>i</sub>))</span></p><p>This is a standard problem of the trie. To support delete operation, you can just keep ‘count’ of every node as well. This stores how many numbers will visit this node when inserting that number in the trie. When you insert, then increase the count of all nodes that the insertion visits, and when deleting an integer, just decrease the count. To find max xor, simply apply the greedy strategy and check the count as well to decide whether the node exists or not.</p>"
      },
      "id": 418,
      "input_format": "<p>First line contains an integer q, 1 ≤ q ≤ 10^5.</p><p>Each of the following q lines of the input contains one of three characters '+', '-' or '?' and an integer xi (1 ≤ xi ≤ 10<sup>9</sup>). It's guaranteed that there is at least one query of the third type.</p><p>Note, that the integer 0 will always be present in set A.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>For each query of the type '?' print one integer — the maximum value of bitwise exclusive OR (XOR) of integer x<sub>i</sub> and some integer from the multiset A.</p>",
      "samples": [
        {
          "input": "12\n? 4\n+ 4\n? 4\n+ 4\n? 3\n- 4\n- 4\n? 3\n+ 4\n? 4\n+ 1\n+ 1",
          "output": "4\n4\n7\n3\n4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "XORMax",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an integer <strong>N</strong>, find its factorial.</p>",
      "complete_approach": "",
      "constraints": "<ul><li>1 ≤ N ≤ 1000</li></ul>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\nvector<int> factorial(int N) {\n    vector<int> ans = {1}; // initialised factorial value as 1.\n    for (int i = 1; i <= N; i++) {\n\n        // multipliying current ans = (i-1)! with i, to get ans = i!\n        int carry = 0;\n        for (int j = 0; j < ans.size(); j++) { //multiplying each digit of ans with i and carrying the value.\n            int p = ans[j] * i + carry;\n            carry = p / 10;\n            ans[j] = p % 10;\n        }\n        // adding the last over carry value.\n        while (carry) {\n            int r = carry % 10;\n            carry /= 10;\n            ans.push_back(r);\n        }\n        // now ans = i!\n    }\n    reverse(ans.begin(), ans.end()); // N! will be stored in reversed way in ans vector.\n    return ans;\n}\nvoid solve() {\n    int n;\n    cin >> n;\n    auto v = factorial(n);\n    for (auto x : v)cout << x;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:22:56.392505+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 860,
      "input_format": "<p>Given an integer <strong>N&nbsp;</strong> in a single line<strong>.</strong></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Output <strong>N! </strong>in a single line.</p>",
      "samples": [
        {
          "input": "5",
          "output": "120"
        },
        {
          "input": "21",
          "output": "51090942171709440000"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Big Factorial",
      "video_editorial_id": 8227
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "$ \\textbf{A  sub-array} $ of array is an array composed from a contiguous block of the original array's elements.\n$ \\textbf{In  other  words} $ A sub-array $ A[i-j]$, where $(1 \\leq i \\leq j \\leq N)$, is a sequence of integers $ A[i], A[i + 1], ..., A[j] $.\n\nFor Example :\nIf array = $ \\textbf{[1,6,3,7]}$ then the $\\textbf{subarrays}$ are $\\textbf{[1], [6], [3], [7], [1,6], [6,3],[3,7], [1,6,3], [6,3,7], [1,6,3,7]}$ .\nSomething like $ \\textbf{[1,3]} $ would not be a sub-array as it's not a contiguous subsection of the original array.\n\nGiven a number N and an array A of N numbers. Print the number of sub-arrays which are $ \\textbf{non-decreasing}$.\n\n$\\textbf{Note:}$\nA sub-array $ A[i-j] $ is $ \\textbf{non-decreasing} $ if $ A[i]  \\leq  A[i + 1]  \\leq  A[i + 2]  \\leq  ...  \\leq  A[j] $.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N \\leq 3*10^5 $ \n$ -10^5 \\leq A[i] \\leq 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n + 1];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n        arr[n] = -1e6;\n\n        int l = 0;\n        int r = 1;\n        int ans = 0;\n        while (r < n + 1)\n        {\n            if (arr[r - 1] > arr[r])\n            {\n                ans += (r - l) * (r - l + 1) / 2;\n                l = r;\n            }\n            r++;\n        }\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:31:37.234654+00:00"
      },
      "hints": {
        "hint1": "A non decreasing subarray ends when the next element is less than the previous element.",
        "hint2": "Number of subarrays between l and r is $(r-l+1)*(r-l+2)/2$.",
        "solution_approach": "Try to place two pointers l and r for contiguous subarrays and count the number of non-decreasing subarrays using the formula.\nIncrease the r value if $a[r] > a[r-1]$, when the last element is greater than its previous. Otherwise, count the subarrays in answer and update l to r, also increase r after this.\nPrint the answer.\nTime Complexity: $O(n)$, because r and l both always increase. In a worse case, the array will only be traversed twice. But that is still $O(n)$"
      },
      "id": 1147,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains $ N $, the number of elements.\nThe second line contains $N$ space separated integers each denoting an element of the array $A$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "First example:\nAll valid sub-arrays are :\n- $[1] , [1,4] , [4] , [2] , [3] , [5] , [2,3] , [3,5] , [2,3,5]$\n\nSecond example:\nOnly single sub-array $[5]$ is non-decreasing.\n$ \\textbf{Note that singleton sub-arrays ( have only one element) are identically non-decreasing.} $",
      "output_format": "For each test case print a single line contains the number of sub-arrays which are $ \\textbf{non-decreasing}$..",
      "samples": [
        {
          "input": "2\n5\n1 4 2 3 5\n1\n5\n",
          "output": "9\n1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Count Subarrays",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given two positive integers <i>n </i>and <i>k.</i> Your task is to print all balanced parenthesis of length <i>n </i>in lexicographic order (https://en.wikipedia.org/wiki/Lexicographic_order) with depth <strong>exactly</strong> <i>k.</i>&nbsp;</p><p>Balanced parentheses mean that each opening symbol has a corresponding closing symbol and the pairs of parentheses are properly nested.</p><p>Note:</p><ol><li>depth(\"\") = 0.</li><li>depth('(' + A + ')) = depth(A) + 1, where A is a balanced paranthesis sequence.</li><li>depth(A + B) = max(depth(A), depth(B)), where A and B are both balanced paranthesis sequence.</li><li>depth(\"(\") = depth(\")\") = 0</li></ol>",
      "complete_approach": "",
      "constraints": "<p>2 ≤ <i>n</i> ≤ 24<br>1 ≤ <i>k</i> ≤ <i>n</i> / 2<br>It is guaranteed that <i>n</i> is an even number.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nstring ans = \"\";\n\nvoid dfs(int curLen, int totalLen, int openCnt, int depth, int k) {\n    if(curLen == totalLen) {\n        assert(openCnt == 1);\n        ans += \")\";\n        if(depth == k) cout << ans << \"\\n\";\n        ans.pop_back();\n        return;\n    }\n\n    if(!openCnt) {\n        ans += \"(\";\n        dfs(curLen + 1, totalLen, openCnt + 1, max(depth, openCnt + 1), k);\n        ans.pop_back();\n    }\n    else {\n        int remLen = totalLen - curLen + 1;\n        if(remLen > openCnt && openCnt < k) {\n            ans += \"(\";\n            dfs(curLen + 1, totalLen, openCnt + 1, max(depth, openCnt + 1), k);\n            ans.pop_back();\n        }\n        ans += \")\";\n        dfs(curLen + 1, totalLen, openCnt - 1, max(depth, openCnt - 1), k);\n        ans.pop_back();\n    }\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n, k;\n    cin >> n >> k;\n\n    dfs(1, n, 0, 0, k);\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:17:12.657762+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 485,
      "input_format": "<p>The only line of input contains two numbers number <i>n </i>and <i>k.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print all balanced parenthesis of length <i>n </i>with depth <i>k </i>in lexicographic order.</p>",
      "samples": [
        {
          "input": "6 2",
          "output": "(()())\n(())()\n()(())"
        },
        {
          "input": "4 2",
          "output": "(())"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Generate Balanced Parenthesis - medium version",
      "video_editorial_id": 8211
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string $s$, find the minimum number of characters that need to be inserted into the string to make it a palindrome.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$\n$1 \\leq |s| \\leq 1000$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint dp[1001][1001], n;\nstring s;\nint rec(int i, int j) {\n    if (i == -1)return n - j;\n    if (j == n)return i + 1;\n    auto &ans = dp[i][j];\n    if (ans != -1)return ans;\n    ans = 1e9;\n    if (s[i] == s[j])ans = min(ans, rec(i - 1, j + 1));\n    else ans = min({ans, 1 + rec(i - 1, j), 1 + rec(i, j + 1)});\n    return ans;\n}\nvoid solve() {\n    cin >> s;\n    n = s.size();\n    memset(dp, -1, sizeof(dp));\n    int ans = 1e9;\n    for (int i = 0; i < n; i++)ans = min({ans, rec(i - 1, i + 1), rec(i - 1, i), rec(i, i + 1)});\n    cout << ans << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:23:29.307393+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "####Approach I\n\nThis question requires us to find the minimum number of insertions to create a palindrome from a given string.\n\n$DP[i][j]$ = Number if insertions required for the string $S[j..i]$.\n\nLet's say you have the string: “xxa”\n\nYou can either insert a character at the beginning, which will be the same character as the end, i.e “a”, or you can insert a character at the end, which will be the same character as at the beginning, i.e “x”. If you add an “a” at the beginning, then you have to see how many insertions are required to make “xx” a palindrome, otherwise, if you add “x” at the end, you will need to calculate how many insertions are required to make “xa” a palindrome. Hence, finding the answer for substrings, “xx”, and “xa”, are the smaller subproblems.\n\n####Approach II\n\nWe can easily get the number of chars not in the palindrome sequence by getting the inverse of the original string, finding out the Longest Common Substring, which makes a palindrome, and using the total length of the original string subtracting the length of LCS.\n\n**Time Complexity** : $O(N^{2})$ per test case."
      },
      "id": 915,
      "input_format": "First line contains $T$ - the number of test cases.\nFirst line of each test case contains the string $s$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the minimum number of characters that need to be inserted into the string to make it a palindrome.",
      "samples": [
        {
          "input": "4\nalgozenith\nabba\ngoomgle\nfft\n",
          "output": "9\n0\n3\n1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Make Palindrome",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers, find the number of subarrays with a sum less than equal to <i>K</i>.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ll testcases;\n    cin >> testcases;\n    while (testcases--)\n    {\n        ll n, k;\n        cin >> n >> k;\n        ll arr[n];\n        for (ll i = 0; i < n; i++)\n            cin >> arr[i];\n        ll ans = 0;\n        ll start = 0;\n        ll current = 0;\n        ll currSum = 0;\n        while (current < n)\n        {\n            currSum += arr[current];\n            while (start <= current and currSum > k)\n            {\n                currSum -= arr[start];\n                start++;\n            }\n            ans += (current - start + 1);\n            current++;\n        }\n        cout << ans << \"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:13:12.545363+00:00"
      },
      "hints": {
        "hint1": "The problem can be solved using a two-pointer approach. where one pointer will keep track of the starting index of the subarray and the other pointer will keep moving to the right and add the elements to the current sum until the sum is greater than K. At this point, we will increment the starting pointer until the sum is less than or equal to K again. We will count the number of subarrays as we move along and return the count as the answer.",
        "hint2": "The problem can be solved using a two-pointer approach, where one pointer will keep track of the starting index of the subarray. The other pointer will keep moving to the right and add the elements to the current sum until the sum is greater than K. At this point, we will increment the starting pointer until the sum is less than or equal to K again. We will count the number of subarrays as we move along and return the count as the answer.",
        "solution_approach": "We initialize two pointers - start and current to 0. We also initialize the current sum to 0 and the answer to 0.\n\nWe start iterating through the array using the current pointer and add each element to the current sum. If the current sum is greater than K, we start incrementing the start pointer and subtracting the elements from the current sum until the sum is less than or equal to K. We count the number of subarrays using the formula (current-start+1) and increment the answer. Finally, we return the answer as the number of subarrays with a sum less than or equal to $K$.\n\n**Time complexity : O(N), where N is the size of the array.**  \nThe time complexity of the algorithm is O(N), as we are iterating through the array only once, and each element is processed once."
      },
      "id": 59,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases <i>(1&lt;=T&lt;=10)</i>.</p><p>The first line of each test case contains two space-separated integers <i>N, K</i> where <i>1&lt;=N&lt;=10^5, 0&lt;=K&lt;=10^9</i>.</p><p>Next line contains <i>N</i> space-separated integers <i>(0&lt;=Ai&lt;=1e4)</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For the first test case, number of subarray with sum &lt;=5 -&gt; (1),(1,2),(2),(2,3),(3)</p><p>For the second test case, all the subarrays have sum &lt;=6.</p>",
      "output_format": "<p>For each test case print the number of subarrays with a sum less than <i>K</i> in a newline.</p>",
      "samples": [
        {
          "input": "5\n3 5\n1 2 3\n3 6\n3 2 1\n5 0\n2 1 0 4 5\n7 6\n1 2 3 0 1 5 2\n10 10\n1 0 1 1 10 2 3 7 5 9",
          "output": "5\n6\n1\n18\n18"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Number of Subarray with sum at most K",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given the boundaries of 2 intervals. Print the boundaries of their $\\textbf{intersection}$.\n\n$\\textbf{Note: Boundaries}$ mean the two ends of an interval which are the starting number and the ending number. \n\nFor any interval $[l,r]$ , if $l > r$, print $-1$.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq l1,l2,r1,r2 \\leq 10^9 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solution()\n{\n    int l1, r1, l2, r2;\n    cin >> l1 >> r1 >> l2 >> r2;\n    if (r2 < l1 || l2 > r1)\n    {\n        cout << -1 << endl;\n        return;\n    }\n    if (r1 < l2 || l1 > r2)\n    {\n        cout << -1 << endl;\n        return;\n    }\n    int l = max(l1, l2);\n    int r = min(r1, r2);\n    cout << l << \" \" << r << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:14.501385+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "At first check the segments intersect or not if not print -1 and if intersects then find the left intersection point by max(l1, l2) and right intersection point by min(r1, r2)."
      },
      "id": 1183,
      "input_format": "Only one line contains two intervals $[l1,r1], [l2,r2]$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "If there is an $\\textbf{intersection}$ between these $2$ intervals print its boundaries, otherwise print $-1$.",
      "samples": [
        {
          "input": "1 15 5 27\n",
          "output": "5 15\n"
        },
        {
          "input": "2 5 6 12\n",
          "output": "-1\n"
        },
        {
          "input": "3 9 5 6\n\n",
          "output": "5 6\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Two Intervals",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given matrix A of size $N*M$ and matrix B of size $M*P$. You have to find the matrix multiplication of A and B.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤ 10</p><p>1 ≤ N, M, P ≤ 100</p><p>-10<sup>3</sup> ≤ A<sub>ij</sub>, B<sub>ij</sub> ≤ 10<sup>3</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <iostream>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n#define int long long\n\nsigned main() {\n    IOS\n    int t; cin >> t;\n    while (t--) {\n        int n, m, p;\n        cin >> n >> m >> p;\n        int a[n][m], b[m][p];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                cin >> a[i][j];\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < p; ++j) {\n                cin >> b[i][j];\n            }\n        }\n        int c[n][p];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < p; ++j) {\n                c[i][j] = 0;\n                for (int k = 0; k < m; ++k) {\n                    c[i][j] += a[i][k] * b[k][j];\n                }\n                cout << c[i][j] << \" \";\n            }\n            cout << \"\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:38:52.932800+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p>Matrix multiplication of two matrices, A and B is C<sub>ij</sub> = Σ (A<sub>ik</sub> * B<sub>kj</sub>) (k=1 to m)</p><p>Time Complexity per test case: O(N*M*P)</p>"
      },
      "id": 329,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains three space-separated integers, N, M and P.\n\nEach of the next N lines contain M space-separated integers - matrix A.\n\nEach of the next M lines contain P space-separated integers - matrix B.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the matrix multiplication of A and B.",
      "samples": [
        {
          "input": "2\n2 3 2\n1 2 3\n2 5 1\n3 1\n-2 1\n0 -1\n1 4 1\n1 2 1 -5\n3\n0\n2\n4\n",
          "output": "-1 0 \n-4 6 \n-15\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Matrix Multiplication AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n\nYou have the following three operations permitted on a word:\n\n1. Insert a character\n2. Delete a character\n3. Replace a character",
      "complete_approach": "",
      "constraints": "$ 1 \\leq word1.length, word2.length \\leq 500 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solution()\n{\n    string word1, word2;\n    cin >> word1 >> word2;\n    int n = word1.size(), m = word2.size();\n    int dp[n + 1][m + 1];\n    for (int i = 0; i <= n; i++)\n    {\n        dp[i][0] = i; // remove this many characters to convert word1 to word2\n    }\n    for (int j = 0; j <= m; j++)\n    {\n        dp[0][j] = j; // insert this many characters to convert word1 to word2\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= m; j++)\n        {\n            if (word1[i - 1] == word2[j - 1])\n            {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            else\n            {\n                dp[i][j] = 1 + min({dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]});\n                // insert     // remove     // replace\n            }\n        }\n    }\n    cout << dp[n][m] << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:40:34.551180+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "To apply DP, we define the state $dp[i][j]$ to be the minimum number of operations to convert $word1[0..i)$ to $word2[0..j)$.\n\nFor the base case, that is, to convert a string to an empty string, the minimum number of operations (deletions) is just the length of the string. So we have $dp[i][0] = i$ and $dp[0][j] = j$.\n\nFor the general case to convert $word1[0..i)$ to $word2[0..j)$, we break this problem down into sub-problems. Suppose we have already known how to convert $word1[0..i - 1)$ to $word2[0..j - 1)$ $(dp[i - 1][j - 1])$, if $word1[i - 1] == word2[j - 1]$, then no more operation is needed and $dp[i][j] = dp[i - 1][j - 1]$.\n\nIf $word1[i - 1] != word2[j - 1]$, we need to consider three cases.\n\nReplace $word1[i - 1]$ by $word2[j - 1] (dp[i][j] = dp[i - 1][j - 1] + 1);$\nIf $word1[0..i - 1) = word2[0..j)$ then delete $word1[i - 1] (dp[i][j] = dp[i - 1][j] + 1);$\n$If $word1[0..i) + word2[j - 1] = word2[0..j)$ then insert $word2[j - 1]$ to $word1[0..i) (dp[i][j] = dp[i][j - 1] + 1)$.\n\nSo when $word1[i - 1] != word2[j - 1]$, $dp[i][j]$ will just be the minimum of the above three."
      },
      "id": 1262,
      "input_format": "Input contains 2 strings word1 and word2.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Output the minimum number of operations required to convert $word1$ to $word2$.",
      "samples": [
        {
          "input": "horse\nros\n",
          "output": "3\n"
        },
        {
          "input": "intention\nexecution\n",
          "output": "5\n"
        },
        {
          "input": "catsanddogs \nad\n",
          "output": "9\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Edit Distance",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a string S consisting of the lowercase character of length N. Score of a string is the number of distinct characters present in the string. Like the score of \"character\" is 6.</p><p>Find the sum of the score of all substring of S.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nsigned main(){\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);;\n    ll testcases;\n    cin>>testcases;\n    while(testcases--){\n        ll n;\n        cin>>n;\n        string s;\n        cin>>s;\n        ll prev[26];\n        for(ll i=0;i<26;i++)\n            prev[i] = -1;\n        long long ans = 26*((n*(n+1))/2);\n        for(ll i=0;i<n;i++){\n            ll lenNotWithChar = i - prev[s[i]-'a']-1;\n            ans = ans - ((lenNotWithChar*(lenNotWithChar+1))/2);\n            prev[s[i]-'a'] = i;\n        }\n        for(ll i=0;i<26;i++){\n            ll lenNotWithChar = n - prev[i]-1;\n            ans = ans - ((lenNotWithChar*(lenNotWithChar+1))/2);\n        }\n        cout<<ans<<\"\\n\";\n    }\n    \n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:46:11.797908+00:00"
      },
      "hints": {
        "hint1": "Since the strings are made of only lowercase alphabets, we can calculate the contribution of each letter from ‘a’ to ‘z’ to the final answer.",
        "hint2": "We need to calculate the contribution of each letter from ‘a’ to ‘z’ to the final answer. For the answer, we will consider the case for ‘a’, you need to do the same for each letter from ‘a’ to ‘z’. If the count of ‘a’ is anything more than 0 in a subarray, it would contribute 1 to the final answer (since we are taking count of distinct characters). So, we can first add the total number of subarrays, N*(N+1)/2 to the final answer and then subtract those subarrays which don’t have the character ‘a’ in it. This would give us the contribution for ‘a’ in the final answer. Do the same for all characters from ‘a’ to ‘z’.\n\nTime Complexity per test case: O(N)",
        "solution_approach": ""
      },
      "id": 62,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases <i>(1&lt;=T&lt;=10)</i>.</p><p>The first line of each test case contains an integers <i>N, </i>size of the string, <i>1&lt;=N&lt;=10^5.</i></p><p>The second line of each test case contains a string <i>S</i> of length <i>N</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "<p><strong>For the 1st test case:</strong><br>Substring and score = (\"a\",1), (\"c\",1) (\"ac\",2).<br>Total score = 4</p><p><strong>For the 2nd test case:</strong><br>Substring and score = (\"a\",1), (\"aa\",1), (\"aac\",2), (\"a\",1), (\"ac\",2), (\"c\",1).<br>Total score = 8</p>",
      "output_format": "<p>For each test case print the sum of the score of all substring of <i>S</i> in a newline.</p>",
      "samples": [
        {
          "input": "5\n2\nac\n3\naac\n5\nabode\n5\naaaaa\n10\njdnbfjdhzw",
          "output": "4\n8\n35\n15\n207"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Count Distinct Char in Substrings",
      "video_editorial_id": 8137
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Let us consider a set of fractions $x / y$, such that $0 \\leq x / y \\leq 1$, $y \\leq n$, and $\\text{gcd}(x, y) = 1$.\n\nFor example, say $n = 5$. Then we have the following set in increasing order:  \n$0/1, 1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5, 1/1$.\n\nYou are given $n$, $a$, and $b$. The task is to find the rank of $a / b$ in the set of fractions, as stated above, which is in increasing order.\n\n**Note:** Fractions should be finite.",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nll get_fractions_less_than_eq(ll n, ll a, ll b){\n    ll ans = 0,arr[n + 1];\n\n    for(ll i = 1; i <= n; i++)\n        arr[i] = (a * i) / b;\n\n    for(ll i = 1; i <= n; i++){\n        for(ll j = i * 2; j <= n;j += i)\n            arr[j] -= arr[i];\n        ans += arr[i];\n    }\n    return ans;\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int T; cin >> T;\n    while(T--) {\n        int n, a, b;\n        cin >> n >> a >> b;\n        cout << get_fractions_less_than_eq(n, a, b) + 1 << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:47:29.752984+00:00"
      },
      "hints": {
        "hint1": "One way to approach this problem is to count the number of fractions which are less than or equal to the given fraction $\\dfrac{a}{b}$ in the given set. Once we know the count of such fractions, we can easily find the rank of $\\dfrac{a}{b}$ in the set by adding 1 to this count.",
        "hint2": "To count the number of fractions less than or equal to $\\dfrac{a}{b}$, we can make use of the following observation:\n\nFor any given denominator $y$, the fractions $\\dfrac{x}{y}$ which satisfy the condition $gcd(x,y)=1$ and $0\\leq \\dfrac{x}{y} \\leq 1$ form a Farey sequence of order $y$, denoted as $F_y$. The set of all fractions satisfying the given conditions can be obtained by taking the union of all Farey sequences of order $y$, where $1 \\leq y \\leq n$.  \n\nNow, we can count the number of fractions less than or equal to $\\dfrac{a}{b}$ in each Farey sequence of order $y$, and add them up to get the total count of fractions less than or equal to $\\dfrac{a}{b}$ in the given set. To count the number of fractions less than or equal to $\\dfrac{a}{b}$ in a Farey sequence of order $y$, we can make use of the following property:\n\nIf $\\dfrac{a}{b}$ is a fraction in a Farey sequence of order $y$, then the fractions $\\dfrac{2a}{2b}$, $\\dfrac{3a}{3b}$, ..., $\\dfrac{(y-1)a}{(y-1)b}$ are not in the sequence.\n\nUsing this property, we can count the number of fractions less than or equal to $\\dfrac{a}{b}$ in a Farey sequence of order $y$, by first calculating the number of fractions $\\dfrac{x}{y}$ in the sequence for each $y \\leq n$, and then subtracting the number of fractions which are not in the sequence using the property mentioned above.",
        "solution_approach": "The above approach can be implemented using a simple algorithm as follows:\n\nInitialize $ans = 0$ and an array arr of size n+1 to store the count of fractions $\\dfrac{x}{y}$ less than or equal to $\\dfrac{a}{b}$ for each denominator y.\n\nFor each denominator y ≤ n, calculate the number of fractions $\\dfrac{x}{y}$ less than or equal to $\\dfrac{a}{b}$, by setting $arr[y] = ⌊(ay)/b⌋$, where ⌊.⌋ denotes the floor function. This is because the fraction $\\dfrac{x}{y}$ is less than or equal to $\\dfrac{a}{b}$ if and only if x ≤ ⌊(ay)/b⌋.\n\nFor each denominator $y \\leq n$, subtract the count of fractions which are not in the Farey sequence of order y, by iterating over all multiples of y less than or equal to n, and subtracting arr[i] for each such i.\n\nAdd up the counts of fractions less than or equal to $\\dfrac{a}{b}$ for each denominator$y \\leq n$ to get the total count, and add $1$ to get the rank of $\\dfrac{a}{b}$ in the given set.\n\nThe time complexity of the above algorithm is $O(n \\log n)$, since we need to iterate over all denominators $y \\leq n$, and for each denominator y, we need to subtract the counts of non-Farey fractions, which takes $O(\\log y)$ time using the above property.\n\nThus, the above algorithm efficiently solves the given problem."
      },
      "id": 79,
      "input_format": "The first line contains a number $T$ ($1 \\leq T \\leq 20$) - the number of test cases. Then $T$ lines follow.  \n\nIn each of the $T$ lines, you are given $n$, $a$, $b$ ($1 \\leq n \\leq 100000$, $a \\leq b \\leq n$) such that $\\text{gcd}(a, b) = 1$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>For <i>n</i> = 5, we have the following set in increasing order: 0/1, 1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5, 1/1<br>So the rank of 3 / 4 is 9.</p>",
      "output_format": "<p>Print <i>T</i> lines. The <i>i</i>th line contains the rank of a fraction <i>a / b</i> for a given <i>n, a</i> and <i>b</i> in the <i>(i + 1)</i>th line of input.</p>",
      "samples": [
        {
          "input": "5\n5 3 4\n8 5 7\n123 23 32\n500 99 123\n1000 501 611",
          "output": "9\n17\n3332\n61269\n249428"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Fraction Rank",
      "video_editorial_id": 8142
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Given an unsigned 32-bit integer N, reverse its bits and print the reversed number.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤ 10<sup>4</sup></p><p>1 ≤ N &lt; 2<sup>32</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nunsigned int reverseBits(unsigned int n)\n{\n    n = (n >> 16) | (n << 16);\n    n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\n    n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\n    n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\n    n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\n    return n;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        unsigned int n;\n        cin >> n;\n        cout << reverseBits(n) << '\\n';\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:37:01.882527+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Iterate through the bits in the reverse order using a for loop.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Try using bit manipulation to solve this without a single loop.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">This problem can be solved without the use of loops in 2 ways. In the first method we divide the number into bytes and then reverse the individual bytes using memoization, which caches the previously calculated values hence avoiding recalculation. This method does not have any loops but uses some extra space for caching. To do this without any extra space we use masking and shifting. The idea can be considered as a strategy of <i><strong>divide and conquer</strong></i>, where we divide the original 32-bits into blocks with fewer bits via <strong>bit masking</strong>, then we reverse each block via <strong>bit shifting</strong>, and at the end we merge the result of each block to obtain the final result.</span></p><p><span style=\"background-color:transparent;color:#000000;\">We can implement the algorithm in the following steps:</span><br><span style=\"background-color:transparent;color:#000000;\">1). First, we break the original 32-bit into 2 blocks of 16 bits, and switch them.</span><br><span style=\"background-color:transparent;color:#000000;\">2). We then break the 16-bits block into 2 blocks of 8 bits. Similarly, we switch the position of the 8-bits blocks.</span><br><span style=\"background-color:transparent;color:#000000;\">3). We then continue to break the blocks into smaller blocks, until we reach the level with the block of 1 bit.</span><br><span style=\"background-color:transparent;color:#000000;\">4). At each of the above steps, we merge the intermediate results into a single integer which serves as the input for the next step.</span></p>"
      },
      "id": 632,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains a single integer T - the number of test cases.</span><br><span style=\"background-color:transparent;color:#000000;\">T lines follow each containing a single integer N.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">1 (<strong>00000000000000000000000000000001</strong>) =&gt; 2147483648 (<strong>10000000000000000000000000000000</strong>)</span></p><p>2 (<strong>00000000000000000000000000000010</strong>) =&gt; 1073741824 (<strong>01000000000000000000000000000000</strong>)</p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case print the reversed number in a new line.</span></p>",
      "samples": [
        {
          "input": "4\n1\n2\n10\n15",
          "output": "2147483648\n1073741824\n1342177280\n4026531840"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nunsigned int reverseBits(unsigned int n)\n{\n    //add code here\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        unsigned int n;\n        cin >> n;\n        cout << reverseBits(n) << '\\n';\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "REVBIT",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an <strong>n x n</strong> 2-D matrix as input. You need to rotate the matrix 90 degrees in the clockwise direction. Print the resultant matrix.</span><br><span style=\"background-color:transparent;color:#000000;\">Try to do the rotation in place, i.e, in constant extra space.</span></p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 1000\n-1000 &lt;= v[i][j] &lt;= 1000</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid RotateMatrix(vector<vector<int>> &v)\n{\n    int n = (int)v.size();\n    for (int i = 0; i < (n + 1) / 2; i++)\n    {\n        for (int j = 0; j < n / 2; j++)\n        {\n            int temp = v[n - 1 - j][i];\n            v[n - 1 - j][i] = v[n - i - 1][n - j - 1];\n            v[n - i - 1][n - j - 1] = v[j][n - i - 1];\n            v[j][n - i - 1] = v[i][j];\n            v[i][j] = temp;\n        }\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    vector<vector<int>> v(n, vector<int>(n));\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n            cin >> v[i][j];\n    }\n\n    RotateMatrix(v);\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n            cout << v[i][j] << \" \";\n        cout << \"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:19:05.791878+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">We observe that the cells move in groups of 4 after the matrix is rotated 90 degrees in the clockwise direction.</span><br><span style=\"background-color:transparent;color:#000000;\">Those four cells are:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">v(i, j)</span></li><li>v(n-1-i, j)</li><li>v(n-1-i, n-1-j)</li><li>v(i, n-j)</li></ol>"
      },
      "id": 610,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of input contains the length of the grid <strong>n</strong>. Then n lines follow, each line containing n spaced integers representing the input matrix.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">We rotate the input matrix by 90 degrees in the clockwise direction.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the resultant matrix obtained by rotating the given matrix.</span></p>",
      "samples": [
        {
          "input": "3\n1 2 3\n4 5 6\n7 8 9",
          "output": "7 4 1\n8 5 2\n9 6 3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nvoid RotateMatrix(vector<vector<int>> &v)\n{\n    // Complete the function\n}\n\n<fix>\nint main()\n{\n    int n;\n    cin >> n;\n\n    vector<vector<int>> v(n, vector<int>(n));\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n            cin >> v[i][j];\n    }\n\n    RotateMatrix(v);\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n            cout << v[i][j] << \" \";\n        cout << \"\\n\";\n    }\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Matrix Rotation",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an integer N. You have to find all the permutations of N in lexicographic order.",
      "complete_approach": "",
      "constraints": "<p>1≤ N ≤ 10</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int n;\n  cin >> n;\n  vector<int> v;\n  for (int i = 1; i <= n; ++i) {\n    v.push_back(i);\n  }\n  do {\n    for (int i = 0; i < n; ++i) {\n      cout << v[i] << \" \";\n    }\n    cout << \"\\n\";\n  } while (next_permutation(v.begin(), v.end()));\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:33:18.440522+00:00"
      },
      "hints": {
        "hint1": "Use `next_permutation()` to solve the problem.",
        "hint2": "",
        "solution_approach": "The next possible permutation of the array can be found using `next_permutation()` function provided in STL. It returns 0 when there is no next permutation.\n\nTime Complexity per test case: $O(N \\times N!)$ . The time complexity will become clear when you learn about backtracking where you will learn how to design the stl function `next_permutation()`."
      },
      "id": 366,
      "input_format": "The first and only line of the input contains one integer N.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print all the permutations of N in lexicographic order.",
      "samples": [
        {
          "input": "3",
          "output": "1 2 3 \n1 3 2 \n2 1 3 \n2 3 1 \n3 1 2 \n3 2 1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Generating Permutations AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array <i>A</i> of <i>N</i> positive integers, find the maximum of bitwise ANDs of all subsequences of <i>A</i> with length equal to <i>X</i>.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main()\n{\n   ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\n   int testCase;\n   cin>>testCase;\n   while(testCase--){\n       int n,x;\n       cin>>n>>x;\n       vector < int > arr(n);\n       for(int i=0;i<n;i++)\n           cin>>arr[i];\n       int ans = 0;\n       for(int i=29;i>=0;i--){\n           vector < int > elementBitSet;\n           for(auto v:arr){\n               if(v&(1LL<<i))\n                   elementBitSet.push_back(v);\n           }\n           if(elementBitSet.size()>=x){\n               ans+=(1LL<<i);\n               arr = elementBitSet;\n           }\n       }\n       cout<<ans<<\"\\n\";\n   }\n\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:31:45.228104+00:00"
      },
      "hints": {
        "hint1": "<p>Check whether a subsequence of length X with the most significant bit set is present or not. If it is present then it is always optimal to consider that subsequence as 2^(highestBit set) &gt; (2^0+2^1+2^2......2^(highestBit-1)).</p>",
        "hint2": "<p>Take all the numbers with highestBit set if the count is &gt;=X. Add 1&lt;&lt;(highestBit) in your answer. Now your problem reduces to the array of elements with highestBit set and highestBit-1 be the next bit to be considered. If the subsequence of length X is not present then calculate the answer for the same array with highestBit-1 as the new highestBit possible.</p>",
        "solution_approach": "<p>Check the solution approach.</p>"
      },
      "id": 54,
      "input_format": "<p>The first line of the input contains a single integer <i>T</i> denoting the number of test cases, <i>(1&lt;=T&lt;=100)</i>.</p><p>The first line of each test case contains two space-separated integer <i>N</i>, <i>X</i>, <i>(2&lt;=N&lt;=100000), (1&lt;=X&lt;=N)</i>.</p><p>The second line contains <i>N</i> space-separated integers A<sub>1</sub>,A<sub>2</sub>,…,A<sub>N</sub>, <i>(1&lt;=Ai&lt;=10^9)</i>.</p><p>&nbsp;</p><p>Sum of N over all test cases does not exceed 10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "<p><strong>1st test case -</strong> all subsequence of length X and AND value:<br>(1,2) - 0<br>(1,3) - 1<br>(1,4) - 0<br>(1,5) - 1<br>(2,3) - 2<br>(2,4) - 0<br>(2,5) - 0<br>(3,4) - 0<br>(3,5) - 1<br>(4,5) - 4<br>Maximum AND value of all subsequences with length X = 4</p>",
      "output_format": "<p>For each test case print the maximum of bitwise ANDs of all subsequences of <i>A</i> with length equal to <i>X</i>.</p>",
      "samples": [
        {
          "input": "6\n5 2\n1 2 3 4 5\n5 3\n2 4 4 2 4\n3 2\n1 2 3\n4 3\n1 2 2 4\n10 3\n989098 987656790 989098765 234543 3456543 234567543 1234567 5678 56789 8909876\n10 2\n123 1234543 2345 6776 8787 8765467 234567 98765444 1234 4561",
          "output": "4\n4\n2\n0\n147862020\n8454144"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Max AND Subsequences",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>A sudoku solution must satisfy <strong>all of the following rules</strong>:</p><ol><li>Each of the digits 1-9 must occur exactly once in each row.</li><li>Each of the digits 1-9 must occur exactly once in each column.</li><li>Each of the digits 1-9 must occur exactly once in each of the 9's 3x3 sub-boxes of the grid.</li></ol><p>The <strong>“.”</strong> character indicates empty cells.</p>",
      "complete_approach": "",
      "constraints": "<ul><li>9x9 sudoku board, filled with digits 1-9 or having <strong>“.”</strong> as empty cells.</li><li>It is <strong>guaranteed</strong> that the input board has only one solution.</li></ul>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvector<vector<int>> grid;\nbool check(int i, int j, int val) {\n    for (int k = 0; k < 9; k++) { // checking row i and column j.\n        if (grid[i][k] == val || grid[k][j] == val)return false;\n    }\n    int l = (i / 3) * 3, r = (j / 3) * 3;\n    for (int a = l; a < l + 3; a++) {  // checking the 3*3 square having (i,j).\n        for (int b = r; b < r + 3; b++)if (grid[a][b] == val)return false;\n    }\n    return true;\n}\n\nvoid sudoku_solver(int i, int j) {\n    if (i == 9) {\n        // output the valid sudoku.\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++)cout << grid[i][j];\n            cout << endl;\n        }\n        exit(0);\n        return;\n    }\n\n    if (grid[i][j] == 0) {\n        for (int val = 1; val <= 9; val++) {\n            if (check(i, j, val)) {\n                grid[i][j] = val;\n                if (j == 8)sudoku_solver(i + 1, 0);\n                else sudoku_solver(i, j + 1);\n                grid[i][j] = 0; // backtrack.\n            }\n        }\n    }\n    else {\n        if (j == 8)sudoku_solver(i + 1, 0);\n        else sudoku_solver(i, j + 1);\n    }\n}\nvoid solve() {\n    grid.assign(9, vector<int>(9, 0));\n    for (int i = 0; i < 9; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < 9; j++) {\n            if (s[j] == '.')grid[i][j] = 0;\n            else grid[i][j] = s[j] - '0';\n        }\n    }\n    sudoku_solver(0, 0);\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:28:17.844751+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 863,
      "input_format": "<p>Given 9x9 sudoku board, filled with digits <strong>1-9</strong> or having <strong>“.”</strong> as empty cells.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the unique valid filled 9x9 Sudoku.</p>",
      "samples": [
        {
          "input": "9....3...\n..4..6.23\n.28..519.\n....52...\n..3...4..\n.5....3..\n.4.1.9..5\n....642..\n.69......",
          "output": "976213548\n514986723\n328745196\n481352967\n293678451\n657491382\n842139675\n735864219\n169527834"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Sudoku Solver",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given $k$ lists containing integers. Each list is sorted in non-decreasing order. You need to find the smallest range that includes at least one number from each of the $k$ lists.\n\n**Note:-** We define the range $[a, b]$ is smaller than range $[c, d]$ if $b - a < d - c$ or $a < c$ if $b - a == d - c$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$.\n$1 \\leq k \\leq 1000$.\n$1 \\leq n \\leq 50$.\n$-10^{5} \\leq list[i][j] \\leq 10^{5}$.\n\nIn each list, all integers are unique and are in non-decreasing order.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvector<int> smallestRange(vector<vector<int>>& nums) {\n    int k = nums.size(), ans = 1e9;\n    pair<int, int> range = { -1e9, 1e9};\n    vector<int> ptr(k, 1);\n    multiset<array<int, 2>> s;\n    for (int i = 0; i < k; i++)s.insert({nums[i][0], i});\n    while (1) {\n        auto x = *s.begin(), y = *s.rbegin();\n        if (ans > y[0] - x[0])ans = y[0] - x[0], range = {x[0], y[0]};\n        else if (ans == y[0] - x[0])range = min(range, {x[0], y[0]});\n        if (ptr[x[1]] == nums[x[1]].size())break;\n        s.erase(s.find(x));\n        s.insert({nums[x[1]][ptr[x[1]]], x[1]});\n        ptr[x[1]]++;\n    }\n    return {range.first, range.second};\n}\nvoid solve() {\n    int k;\n    cin >> k;\n    vector<vector<int>> v;\n    while (k--) {\n        int n;\n        cin >> n;\n        vector<int> t;\n        for (int i = 0; i < n; i++) {\n            int x;\n            cin >> x;\n            t.push_back(x);\n        }\n        v.push_back(t);\n    }\n    auto ans = smallestRange(v);\n    cout << ans[0] << \" \" << ans[1] << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:28:23.782609+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "#### Algorithm :  \n\n1. Create an Min heap to store $k$ elements, one from each array and a variable minrange initialized to a maximum value and also keep a variable max to store the maximum integer.\n2. Initially put the first element of each element from each list and store the maximum value in max.\n3. Repeat the following steps until atleast one list exhausts : \n    -   To find the minimum value or min, use the top or root of the Min heap which is the minimum element.\n    -   Now update the minrange if current (max-min) is less than minrange.\n    -   Remove the top or root element from priority queue and insert the next element from the list which contains the min element and update the max with the new element inserted.\n\n#### Complexity Analysis: \n**Time complexity :** $O(n * k *log k)$.\n\nTo find the maximum and minimum in an Min Heap of length k the time required is $O(log k)$, and to traverse all the k arrays of length $n$ (in worst case), the time complexity is $O(n*k)$, then the total time complexity is $O(n * k *log k)$.\n\n**Space complexity:** $O(k)$.\n\nThe priority queue will store k elements so the space complexity is $O(k)$."
      },
      "id": 965,
      "input_format": "The first line contains $T$- the number of test cases.\nThe First line of each test case contains the integer $k$ - number of lists.\nThe next $k$ lines of each test case will contain information regarding the $k$ lists, where for each line, the first integer $n$ will denote the size of the list followed by $n$ integers belonging to that list.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, Output the smallest range that includes at least one number from each of the $k$ lists on a newline.",
      "samples": [
        {
          "input": "4\n3\n5 -2 7 9 12 15\n5 0 8 10 14 20\n6 -1 6 12 16 30 50\n3\n2 4 7\n2 1 2\n2 20 40\n3\n5 4 10 15 24 26\n4 0 9 12 20\n4 5 18 22 30\n3\n3 1 2 3\n3 1 2 3\n3 1 2 3\n",
          "output": "-2 0\n2 20\n20 24\n1 1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "K Lists Range",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You have been given a tree with N nodes and N - 1 edges. You want to colour each node, such that no two adjacent nodes (directly connected by an edge) and no two nearly-adjacent nodes (both directly connected to a common node with edges) has the same colour. \nYour task is to find the minimum number of colours required to accomplished this.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>N</i> ≤ 10<sup>5</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <iostream>\nusing namespace std;\n\nint N,a,b;\nint d[100000];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    cin >> N;\n    for(int i=1;i<N;i++)\n    {\n        cin >> a >> b;\n        d[a-1]++, d[b-1]++;\n    }\n    int D = 0;\n    for(int i=0;i<N;i++)\n        if(d[i] > D)\n            D = d[i];\n    cout << D+1 << '\\n';\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:16:14.065921+00:00"
      },
      "hints": {
        "hint1": "<p>This problem asks us to colour the vertices of a tree with the minimum number of colours, such that no two nodes of the same colour are adjacent or separated by only two edges. So if some node has <i>d</i> neighbours, then all <i>d</i> neighbours of the node, as well as the node itself, must receive pairwise distinct colours. Hence, if the maximum degree in the tree is <i>D</i>, then we need at least <i>D </i>+ 1 colours.</p>",
        "hint2": "It turns out that D+1 colours are always sufficient. Can you prove it?",
        "solution_approach": "<p>This problem asks us to colour the vertices of a tree with the minimum number of colours, such that no two nodes of the same colour are adjacent or separated by only two edges. So if some node has <i>d</i> neighbours, then all <i>d</i> neighbours of the node, as well as the node itself, must receive pairwise distinct colours. Hence, if the maximum degree in the tree is <i>D</i>, then we need at least <i>D </i>+ 1 colours.</p><p>It turns out that <i>D</i>+1 colours are always sufficient; in fact, we'll show how to construct a valid (<i>D</i>+1)-colouring. Root the tree at an arbitrary vertex, and assign it colour 1. The root has at most <i>D</i> children, so they can be assigned distinct colours in {2,…,<i>D</i>+1}. Now we have at most <i>D</i> child subtrees, with the root of each subtree coloured. Every node which has not been coloured has distance 3 or more from any node in a different subtree, so we can colour the subtrees independently.</p><p>Pick a child <i>c</i> of the root, and suppose that it has colour <i>i</i>≠1. There are at most <i>D</i>−1 children of <i>c</i>, so they can be assigned distinct colours in {2,…,<i>i</i>−1,<i>i</i>+1,…,<i>D</i>+1}. Once again, the at most <i>D</i>−1 subtrees can now be coloured independently.</p><p>This process continues until the tree is completely coloured. In general, any non-root node <i>u</i> has at most <i>D</i>−1 children, which can be assigned distinct colours in {1,…,<i>D</i>+1} which avoid the colour of <i>u</i>, and the colour of <i>u</i>'s parent. This ensures that the colouring condition is satisfied: among any two adjacent nodes, one is a child of the other, and the child is assigned a different colour from the parent. For any two nodes separated by at most two edges, there are two cases. If the nodes are siblings, then they are assigned distinct colours simultaneously. Otherwise, one node is the grand-child of the other, and so avoids the colour of its grandparent.</p><p>Thus, the final algorithm is quite simple: compute the degree of every node, find the maximum, and add one.</p>"
      },
      "id": 416,
      "input_format": "The first line of input contains N. Each of the remaining N−1 lines describes an edge in terms of the two nodes it connects.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>We require 4 different colours, colour(1) = 1, colour(2) = 2, colour(3) = 3, colour(4) = 1.</p>",
      "output_format": "<p>Print the minimum number of colours require.</p>",
      "samples": [
        {
          "input": "4\n1 2\n4 3\n2 3",
          "output": "3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Colour Tree",
      "video_editorial_id": 8201
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a permutation $A$ of $n$ integers $1, 2, ... n$, you want to get a permutation $B$.\n\nYou are given some $m$ good pairs given in a form of 2D matrix $C$ of size $m \\times 2$  where $(C[i][0], C[i][1])$ denotes that two indexes of the permutation $A$.\n\nIn one operation he can swap $A_x$ and $A_y$ only if $(x, y)$ is a good pair.\n\nYou have to tell whether you can obtain permutation $B$ by performing the above operation any number of times on permutation $A$.\n\nIf the permutation $B$ can be obtained, output *\"Yes\"* else output *\"No\"*.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^4$\n$2 \\leq n \\leq  10^5$\n$1 \\leq m \\leq n*(n-1)/2 \\leq  10^5$\n$1 \\leq A[i], B[i] \\leq n$\n$A[i]$ and $B[i]$ are all distinct.\n$1 \\leq C[i][0] , C[i][1] \\leq n$\nSum of $n$ over all test cases is $\\leq 10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint n, cc;\nvector<vector<int>> adj;\nvector<int> vis, comp;\nvoid dfs(int v) {\n\tvis[v] = true;\n\tcomp[v] = cc;\n\tfor (auto x : adj[v]) {\n\t\tif (!vis[x])dfs(x);\n\t}\n}\nint permutation(vector<int> &A, vector<int> &B, vector<vector<int> > &C) {\n\tn = A.size();\n\tvis.assign(n + 1, false);\n\tcomp.assign(n + 1, -1);\n\tadj.assign(n + 1, vector<int>());\n\tfor (auto x : C) {\n\t\tadj[x[0] - 1].push_back(x[1] - 1);\n\t\tadj[x[1] - 1].push_back(x[0] - 1);\n\t}\n\tcc = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!vis[i]) {\n\t\t\tcc++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tmap<int, int> m;\n\tfor (int i = 0; i < n; i++)m[A[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (comp[i] != comp[m[B[i]]])return 0;\n\t}\n\treturn 1;\n}\nvoid solve() {\n\tint m;\n\tcin >> n >> m;\n\tvector<vector<int>> c(m, vector<int>(2));\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> c[i][0] >> c[i][1];\n\t}\n\tvector<int> a(n), b(n);\n\tfor (int i = 0; i < n; i++)cin >> a[i];\n\tfor (int i = 0; i < n; i++)cin >> b[i];\n\tint ans = permutation(a, b, c);\n\tif (ans)cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:46:51.377048+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Let's consider indices as vertices of some graph and allowed pairs as 2-ways edges. Then our graph can be divided into connected components.\n\nThe key observation: we can get any permutation of elements in one connected component. And obviously, there is no way to swap elements that belong to different components. Thus we get a simple solution:\n\nFind connected components in our graph.\nFor each component compare elements in permutations A and B. If these elements differ for at least one component then the answer is \"No\" otherwise answer is \"Yes\".\n\nTime Complexity : $O(n+m)$ per test case."
      },
      "id": 995,
      "input_format": "First line contains $T$ - the number of test cases.\nFirst line of each test case contains $n$ and $m$.\nNext $m$ lines contains $C[i][0]$ and $C[i][1]$.\nNext line contains $n$ elements of permutation $A$.\nNext line contains $n$ elements of permutation $B$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "If the permutation $B$ can be obtained, output *\"Yes\"* else output *\"No\"*.",
      "samples": [
        {
          "input": "3\n4 1\n2 4\n1 3 2 4\n1 4 2 3\n4 1\n3 4\n1 3 2 4\n1 4 2 3\n2 1\n1 2\n1 2\n1 2\n",
          "output": "Yes\nNo\nYes\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Swaps and Permutation",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Write a function to detect if two trees are isomorphic. Two trees are called isomorphic if one of them can be obtained from other by a series of flips, i.e. by swapping left and right children of a number of nodes. Any number of nodes at any level can have their children swapped. Two empty trees are isomorphic.",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:17:07.101708+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 676,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, the length of the array representing the serialized representation of a tree1.</p><p>The next line contains N-space-separated distinct integers.&nbsp;</p><p>The next line contains an integer M, the length of the array representing the serialized representation of a tree2.</p><p>The next line contains M-space-separated distinct integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Return true/false.</p>",
      "samples": [
        {
          "input": "3\n11\n35111 -1 38067 -1 11935 -1 42935 -1 83239 -1 -1 \n11\n35111 38067 11935 -1 42935 -1 83239 -1 -1 -1 -1 \n9\n2139 98225 -1 -1 45038 -1 99680 -1 -1 \n7\n52567 13977 -1 -1 43379 -1 -1 \n21\n86370 -1 19958 -1 24504 -1 84868 -1 28556 -1 60837 -1 83207 -1 32194 -1 37682 -1 90797 -1 -1 \n21\n58627 76571 99757 61217 47021 8172 39465 16247 84989 20852 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 ",
          "output": "yes\nno\nno"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n</fix>\nbool isIsomorphic(Node * t1, Node * t2)\n{\n    // Complete the function.\n}\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nvoid generateArray(Node* root, vector<int>&ans){\n    if(root==NULL){\n        ans.push_back(-1);\n        return;\n      }\n    ans.push_back(root->val);\n    generateArray(root->left,ans);\n    generateArray(root->right,ans);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree1 = getBinaryTree(arr,&ind);\n        arr.clear();\n        cin>>n;\n        assert(n<=1000000);\n        arr.resize(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        ind = 0;\n        Node* tree2 = getBinaryTree(arr,&ind);\n        if(isIsomorphic(tree1,tree2)){\n            cout<<\"yes\\n\";\n        }\n        else\n            cout<<\"no\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Isomorphic Tree",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a number k, find the minimum number of fibonacci numbers</p><p>whose sum is equal to k. You can use any of the fibonacci numbers &nbsp;</p><p>any number of times.</p><p>Fibonacci Numbers:</p><p><code>F(1) = 1</code></p><p><code>F(2) = 1</code></p><p><code>F(n) = F(n-1) + F(n-2) : for n&gt;=3</code></p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "<p>T ≤ 100</p><p>1 ≤ k ≤ 10<sup>9</sup></p><p>&nbsp;</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t, i, j;\n\n    cin >> t;\n\n    long long fib[50];\n    fib[1]=fib[2]=1;\n    for(i=3;i<50;i++) fib[i]=fib[i-1]+fib[i-2];\n\n    while (t--)\n    {\n        int k;\n        cin>>k;\n        int take=49,ans=0;\n        while(k>0)\n        {\n            if(k>=fib[take])\n            {\n                k-=fib[take];\n                ans++;\n            }\n            take--;\n        }\n        cout<<ans<<'\\n';\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:23:59.393645+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">There are less than 50 Fibonacci numbers upto 10^9.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Zeckendorf’s theorem states that every positive integer has a unique representation as a sum of Fibonacci numbers such that no two numbers are equal or consecutive Fibonacci numbers.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">The problem can be solved greedily by taking the maximum Fibonacci number ≤ current number and subtracting this number from the current number. Repeat this till the current number reaches 0.</span></p><p><span style=\"background-color:transparent;color:#000000;\">We don’t take adjacent Fibonacci numbers because, F[i] = F[i-1] + F[i-2] and we don’t take duplicate Fibonacci numbers because, 2*F[i] = F[i+1] + F[i-2].</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(log K)</span></p>"
      },
      "id": 224,
      "input_format": "<p>First line of input contains T, number of test cases.</p><p>The only line of each test case contains an integer k.</p><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>7 can be formed using 2 + 5, where 2, 5 are fibonacci numbers.</p>",
      "output_format": "<p>For each test case output one integer: The minimum number of fibonacci numbers needed.</p>",
      "samples": [
        {
          "input": "1\n\n7",
          "output": "2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Fibonacci Breakdown",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given Q queries and have to perform the following operations:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">add x - add element x at the top of Priority Queue</span></li><li><span style=\"background-color:transparent;color:#000000;\">remove - delete top element of the Priority Queue, if Priority Queue is not empty</span></li><li><span style=\"background-color:transparent;color:#000000;\">print - print the element at top of the Priority Queue, if Priority Queue is not empty, otherwise print 0</span></li></ol>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ Q ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ X ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of Q over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>6.</sup></span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int q;\n    cin >> q;\n    priority_queue<int> p;\n    while (q--) {\n      string s;\n      cin >> s;\n      if (s == \"add\") {\n        int x;\n        cin >> x;\n        p.push(x);\n      } else if (s == \"remove\") {\n        if (!p.empty()) {\n          p.pop();\n        }\n      } else {\n        if (!p.empty()) {  // print\n          cout << p.top() << \"\\n\";\n        } else {\n          cout << \"0\\n\";\n        }\n      }\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:33:16.446334+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "### ADD\nUse push() for inserting element at top of stack\n### REMOVE\nUse pop() for deleting element at top of stack\n### PRINT\nUse top() for printing element at top of stack\n\nTime Complexity per test case: $O(\\log N)$"
      },
      "id": 364,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer Q - the number of queries.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Each of the next Q ines contains queries.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<ol><li><span style=\"background-color:transparent;color:#000000;\">Priority Queue becomes [4]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Priority Queue becomes [4, 5]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Priority Queue becomes [3, 4, 5]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Element at top = 5</span></li><li><span style=\"background-color:transparent;color:#000000;\">Priority Queue becomes [3, 4]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Element at top = 4</span></li></ol>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the required queries.</span></p>",
      "samples": [
        {
          "input": "1\n6\nadd 4\nadd 5\nadd 3\nprint\nremove\nprint\n",
          "output": "5\n4\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Priority Queue AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are <i>N</i> objects, and each object has some price. The price of <i>i</i>th object is<i> A<sub>i</sub></i>.<br>You have total money <i>M</i>, and you want to buy as many objects as possible.<br>Find the maximum objects that you can buy?</p>",
      "complete_approach": "",
      "constraints": "<p>1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>T</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>5</sup><br>1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>N</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>5</sup><br>1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>A<sub>i</sub></i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>8</sup><br>1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>M</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>8</sup><br>Sum of <i>N</i> over all test cases <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 5 * 10<sup>5</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main() {\n  // freopen(\"IN\", \"r\", stdin);\n  // freopen(\"OUT\", \"w\", stdout);\n\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  int T;\n  cin >> T;\n  while (T--) {\n    int n, m;\n    cin >> n >> m;\n    int a[n];\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n      if (a[i] > m) break;\n      cnt++;\n      m -= a[i];\n    }\n    cout << cnt << \"\\n\";\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:32:27.379079+00:00"
      },
      "hints": {
        "hint1": "Try to think in a greedy way!",
        "hint2": "Sort the objects with respect to price, and start buying objects in a greedy fashion.",
        "solution_approach": "It's always better to buy an object which has a smaller price. So that we can be left with a greater remaining budget. Sort all objects with respect to their prices. And start buying objects in increasing order of price.\n\nTime complexity: $O(N \\log N)$\nSpace complexity: $O(1)$ extra space"
      },
      "id": 75,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases.<br>The first line of each test case contains <i>N</i>, the number of objects, and <i>M</i>, the money you have.<br>The second line of each test case contains <i>N</i> space-separated integers <i>A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub></i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>Buy Objects with prices 1, 2.</p><p><i><strong>Explanation 2:</strong></i><br>Buy Objects with prices 1, 2, 3, 4.</p><p><i><strong>Explanation 3:</strong></i><br>Buy all objects.</p>",
      "output_format": "<p>For each test case, print a single number representing the maximum objects that you can buy.</p>",
      "samples": [
        {
          "explanation": "**Test Case 1**: Using money 5, we can buy at max 2 objects. E.g. 1st and 2nd, total cost is 1 + 3 = 4.\n**Test Case 2**: Using money 10, we can buy at max 4 objects. E.g. 1st, 2nd, 3rd and 4th, total cost is 1 + 3 + 2 + 4 = 10.\n**Test Case 3**: Using money 20, we can buy all 5 objects.",
          "input": "3\n5 5\n1 3 2 4 5\n5 10\n1 3 2 4 5\n5 20\n1 3 2 4 5",
          "output": "2\n4\n5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Buy Maximum Objects I",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given **N** integers, the price of a given stock on each day. You can buy and sell any number of stocks. You cannot buy a stock before you sell the previous stock and you cannot sell a stock before you buy one. You have to find the maximum profit you can make by buying and selling stocks.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤ 100<br>1 ≤ N ≤ 10<sup>5</sup><br>0 ≤ Ai ≤ 10<sup>5</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nlong long BuyAndSellStock(vector<int> &a) \n{\n    int n = (int)a.size();\n    long long ans = 0;\n    for (int i = 1; i < n; ++i) {\n        ans += max(0, a[i] - a[i-1]);\n    }\n    return ans;\n}\n\nint main(){\n   IOS\n   \n   int t;\n   cin>>t;\n   \n   while(t--){\n       int n;\n       cin>>n;\n       \n       vector<int> a(n);\n\n       for (int i = 0; i < n; ++i) {\n           cin>>a[i];\n       }\n       \n       cout << BuyAndSellStock(a) << \"\\n\";\n   }\n\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:14:54.912145+00:00"
      },
      "hints": {
        "hint1": "For each day, if the price of the stock one day before is smaller than the current price, we buy a stock one day before and sell it on the current day.",
        "hint2": "Suppose, the given stock prices are: 1 4 5. If you buy on day 1 and sell on day 3 or if you buy on day 1, sell on day 2 and again buy on day 2 and sell on day3, both will result in the same amount of profit. This is because: (day3) - (day1) = (day3) - (day2) + (day2) - (day1).",
        "solution_approach": "While traversing through the array, update the minimum price. If the current price is greater than the price a day before, update the profit. While calculating the profit in this way, we made sure that there was no better price to buy from the past\n\nFor stock prices that are strictly decreasing, you don’t do any transaction.\n\nTime Complexity per test case: O(N)"
      },
      "id": 277,
      "input_format": "The first line of the input contains one integer **T** - the number of test cases. Then **T** test cases follow.\nThe first line of each test case contains one integer **N** - the length of the array. \nThe second line of each test case contains **N** space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, you can buy stock on day 1 and sell on day 2 and again buy on day 3 and sell on day 4. Profit = (5-1) + (6-2) = 4+4 = 8\n\nFor the second test case, you can buy stock on day 1 and sell on day 4. Profit = 4-1 = 3\n\nFor the third test case, you don’t buy and sell any stock. Profit = 0",
      "output_format": "For each test case, print the maximum profit you can make by buying and selling stocks.",
      "samples": [
        {
          "input": "3\n5\n1 5 2 6 3\n4\n1 2 3 4\n4\n5 3 2 1",
          "output": "8\n3\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n</fix>\n\nlong long BuyAndSellStock(vector<int> &a) \n{\n    //Complete the function\n}\n\n<fix>\nint main(){\n   IOS\n   \n   int t;\n   cin>>t;\n   \n   while(t--){\n       int n;\n       cin>>n;\n       \n       vector<int> a(n);\n\n       for (int i = 0; i < n; ++i) {\n           cin>>a[i];\n       }\n       \n       cout << BuyAndSellStock(a) << \"\\n\";\n   }\n\n   return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 3,
      "title": "Buy and Sell Stock - 2",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a weighted tree of <i>N</i> nodes. <i>D(u,v)</i> is defined as the minimum weight of edge in the simple path from <i>u</i> to <i>v</i>.&nbsp; Find the summation of <i>D(u,v)</i> for all <i>1≤u≤N, 1≤v≤N</i>, where <i>u&lt;v</i>.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstruct UnionFind {\n  int n, set_size, *parent, *rank;\n  UnionFind() {}\n  UnionFind(int a) {\n    n = set_size = a;\n    parent = new int[n + 1];\n    rank = new int[n + 1];\n    for (int i = 1; i <= n; ++i) parent[i] = i, rank[i] = 1;\n  }\n  int find(int x) {\n    if (x != parent[x]) return parent[x] = find(parent[x]);\n    return x;\n  }\n  void merge(int x, int y) {\n    int xroot = find(x), yroot = find(y);\n    if (xroot != yroot) {\n      if (rank[xroot] >= rank[yroot]) {\n        parent[yroot] = xroot;\n        rank[xroot] += rank[yroot];\n      } else {\n        parent[xroot] = yroot;\n        rank[yroot] += rank[xroot];\n      }\n      set_size -= 1;\n    }\n  }\n  void reset() {\n    set_size = n;\n    for (int i = 1; i <= n; i++) parent[i] = i, rank[i] = 1;\n  }\n  int size() { return set_size; }\n  void print() {\n    for (int i = 1; i <= n; ++i) cout << i << \" -> \" << parent[i] << \"\\n\";\n  }\n};\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int testcases;\n  cin >> testcases;\n  while (testcases--) {\n    int n;\n    cin >> n;\n    vector<pair<int, pair<int, int>>> edges;\n    UnionFind uf(n);\n    for (int i = 1; i <= n - 1; i++) {\n      int u, v, weight;\n      cin >> u >> v >> weight;\n      edges.push_back(make_pair(weight, make_pair(u, v)));\n    }\n    sort(edges.begin(), edges.end());\n    reverse(edges.begin(), edges.end());\n    long long ans = 0;\n    for (auto edge : edges) {\n      int u = edge.second.first;\n      int v = edge.second.second;\n      int weight = edge.first;\n      int rootU = uf.find(u);\n      int rootV = uf.find(v);\n      assert(rootU != rootV);\n      ans = ans + 1LL * uf.rank[rootU] * uf.rank[rootV] * weight;\n      uf.merge(u, v);\n    }\n    cout << ans << \"\\n\";\n  }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:33:09.051240+00:00"
      },
      "hints": {
        "hint1": "Try to find for each edge 'e' how many pairs of nodes $(u,v)$ exist such that $D(u,v)$ = weight of the edge e.",
        "hint2": "The main idea behind this solution is to use a modified version of the Union-Find data structure to calculate the summation of $D(u,v)$ efficiently.",
        "solution_approach": "Iterate over the sorted edges and process them one by one. For each edge (u, v) with weight w, we find the root of the tree that contains node u (rootU) and the root of the tree that contains node v (rootV) using the find operation of the Union-Find data structure.\n\nIf rootU and rootV are different (i.e., u and v belong to different trees), we calculate the contribution of this edge to the final answer. The contribution is equal to the product of the sizes of the trees rooted at rootU and rootV, multiplied by the weight of the edge. We add this contribution to the final answer.\n\nThe size of a tree is determined by the rank value in the Union-Find data structure. The rank represents an upper bound on the height of the tree. By merging smaller trees into larger trees, we can keep the height of the tree small.\nBy processing the edges in descending order of their weights and using the Union-Find data structure, we ensure that we are considering the minimum weight edge in the simple path between two nodes. This allows us to calculate the desired summation efficiently."
      },
      "id": 38,
      "input_format": "<p>The first line of input contains one integer <i>T</i> (1 ≤ <i>T</i> ≤ 10<sup>5</sup>) — the number of test cases. Then <i>T</i> test cases follow.<br>The first line of each test case contains an integer <i>N</i> - the number of nodes in the tree (1 ≤ <i>N</i> ≤ 10<sup>5</sup>).<br>The next <i>N-1</i> line of each test case contains 3 space-separated integers <i>u, v, w<sub> &nbsp;</sub></i>denoting that there is an edge between node u and node v of weight w. (<i>1 ≤ u,v<sub> </sub>≤ N</i>),&nbsp;(<i>1 ≤ w ≤ 10<sup>9</sup></i> ).</p><p>It is guaranteed that the sum of <i>N </i>over all test cases does not exceed 10<sup>6</sup>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "**For the 1st test case:**\n\n$D(1,2) = D(1,3) = D(1,4) = D(1,5) = 1$  \n\n$D(2,3) = 5$, $D(2,4) = 3$, $D(2,5) = 2$  \n\n$D(3,4) = 3$, $D(3,5) = 2$  \n\n$D(4,5) = 2$  \n\nSummation = $21$  \n\n**For the second test case:**\n\n$D(1,2) = 5$, $D(1,3) = 4$, $D(1,4) = 1$, $D(1,5) = 2$  \n\n$D(2,3) = 4$, $D(2,4) = 1$, $D(2,5) = 2$  \n\n$D(3,4) = 1$, $D(3,5) = 2$  \n\n$D(4,5) = 1$  \n\nSummation = $23$",
      "output_format": "<p>For each test case print the summation of <i>D(u,v)</i> for all <i>1≤u≤N, 1≤v≤N</i>, where <i>u&lt;v </i>in a new line.</p>",
      "samples": [
        {
          "input": "5\n5\n1 2 1\n2 3 5\n3 4 3\n4 5 2\n5\n1 2 5\n1 3 4\n2 4 1\n3 5 2\n5\n1 2 3\n2 3 4\n2 4 6\n3 5 1\n8\n1 2 4\n2 3 6\n2 4 1\n2 5 3\n3 6 1\n3 7 3\n3 8 1\n10\n1 2 10\n1 3 5\n1 4 9\n1 5 7\n2 6 10\n2 7 11\n3 8 9\n3 9 11\n3 10 15",
          "output": "21\n23\n27\n53\n316"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Min Edge Weight",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Using characters: . (dot) and * (asterisk) print a grid-like pattern as shown in the sample test case.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^4$\n\n$1 \\leq N, M \\leq 1000$\n\nIt is guaranteed that the sum of $N \\times M$ for all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < 3*n+1; ++i) {\n            for (int j = 0; j < 3*m + 1; ++j) {\n                if(i%3==0 || j%3 == 0) cout << \"*\";\n                else cout << \".\";\n            }\n            cout << \"\\n\";\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:47.126280+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "An index will have *(asterisk) if its row/column number is a multiple of 3(0-indexing), otherwise character would be .(dot).\n\nTime Complexity per test case: O(N*M)"
      },
      "id": 317,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains two space-separated integers N, M.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the required pattern.",
      "samples": [
        {
          "input": "3\n3 4\n4 2\n3 3",
          "output": "*************\n*..*..*..*..*\n*..*..*..*..*\n*************\n*..*..*..*..*\n*..*..*..*..*\n*************\n*..*..*..*..*\n*..*..*..*..*\n*************\n*******\n*..*..*\n*..*..*\n*******\n*..*..*\n*..*..*\n*******\n*..*..*\n*..*..*\n*******\n*..*..*\n*..*..*\n*******\n**********\n*..*..*..*\n*..*..*..*\n**********\n*..*..*..*\n*..*..*..*\n**********\n*..*..*..*\n*..*..*..*\n**********"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Pattern Problem 1 AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You all know the <i>Bubble Sort</i>! The classical sorting algorithm.</p><p>In this problem, you have to find the parity of the number of swaps that will perform in the standard bubble sort algorithm on the given input array.</p><p>For more details about Bubble Sort refer this: <i><u>https://en.wikipedia.org/wiki/Bubble_sort</u></i></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nlong long solve(vector<int> &A, int l, int r) {\n    if(l > r) return 0;\n    if(l == r) return 0;\n    if(r - l == 1) {\n        if(A[r] < A[l]) {\n            swap(A[r], A[l]);\n            return 1;\n        }\n        return 0;\n    }\n\n    int mid = (l + r) / 2;\n\n    long long ans = solve(A, l, mid) + solve(A, mid + 1, r);\n\n    int ptr = mid + 1;\n    for(int i = l; i <= mid; i++) {\n        while(ptr <= r && A[ptr] < A[i])\n            ptr++;\n        ans += 1LL * (ptr - mid - 1);\n    }\n    vector<int> temp;\n    for(int i = l; i <= r; i++)\n        temp.push_back(A[i]);\n    sort(temp.begin(), temp.end());\n    for(int i = l; i <= r; i++)\n        A[i] = temp[i - l];\n    return ans;\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int T; cin >> T;\n    while(T--) {\n        int n; cin >> n;\n        vector<int> A(n);\n        for(int i = 0; i < n; i++) cin >> A[i];\n        cout << solve(A, 0, n - 1) % 2 << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:46:15.581317+00:00"
      },
      "hints": {
        "hint1": "<p>There is a relation between inversion count and the swaps in bubble sort. <i>Can you find it?</i></p>",
        "hint2": "<p>Observe that the particular element will be going to swap the elements which are smaller than this and present at the higher index.</p>",
        "solution_approach": "<p><strong>The particular element eventually going to swap elements that are smaller and present in at the higher index.</strong> This observation will lead us to the important conclusion that the number of swaps in bubble sort equals to the Inversion Count of the array. <i>Interesting?</i></p><p>And now we can find the parity from this result.</p><p><strong>Time Complexity:</strong> <i>O(NlogN)</i><br><strong>Space Complexity:</strong> <i>O(N) extra space</i></p><p>&nbsp;</p>"
      },
      "id": 24,
      "input_format": "<p>The first line of input contains one integer <i>T</i> (1 ≤ <i>T</i> ≤ 10<sup>5</sup>) — the number of test cases. Then <i>T</i> test cases follow.<br>The first line of each test case contains <i>N</i> (2 ≤ <i>N</i> ≤ 10<sup>5</sup>), the number of elements in an array <i>A</i>.<br>The second line contains <i>N</i> space-separated integers <i>A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>, </i>(0 ≤ <i>A<sub>i</sub></i><sub> </sub>≤ 10<sup>9</sup>).<br>It is guaranteed that the sum of <i>N</i> does not exceed 5 x 10<sup>5</sup>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i></p><figure class=\"table\"><table><tbody><tr><td>First Iteration</td><td>4 2 1 8</td><td>3 swaps</td></tr><tr><td>Second Iteration</td><td>&nbsp;2 1 4 8&nbsp;</td><td>2 swaps</td></tr><tr><td>Third Iteration&nbsp;</td><td>1 2 4 8&nbsp;</td><td>1 swap</td></tr></tbody></table></figure><p>Total Swaps: 6, so the parity is 0.</p><p>&nbsp;</p><p><i><strong>Explanation 2:</strong></i></p><figure class=\"table\"><table><tbody><tr><td>First Iteration</td><td>1 2 3</td><td>1 swap</td></tr></tbody></table></figure><p>Total Swaps: 1, so the parity is 1.</p><p>&nbsp;</p><p><i><strong>Explanation 3:</strong></i></p><p>The given array is already sorted, so 0 swaps and hence, 0 parity.</p>",
      "output_format": "<p>For each test case, print the answer on a new line denoting the parity of number swaps in the <i>Bubble Sort</i>.</p>",
      "samples": [
        {
          "input": "3\n4\n8 4 2 1\n3\n2 1 3\n6\n1 2 3 4 5 5",
          "output": "0\n1\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Bubble Sort Swap Parity",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><i>Baburao Ganpatrao Apte</i> a.k.a “<i>Babu Bhaiya</i>” created a new strong password for his locker, to save his money from <i>Raju</i>, who is promising to double his money in 21 days! :P</p><p>The new password <strong>z </strong>is a positive integer of at most 19 digits. <i>Babu Bhaiya</i> is bad at remembering passwords and doesn't want to take risks ( as he says <i>“ bilkul ricks nhi lena ka ”</i> ), so he divided his integer password into 2 positive integers <strong>a</strong> and <strong>b, </strong>such that <strong>z = a + b</strong>, and wrote down <strong>a&amp;b</strong> and <strong>a|b</strong> values in his diary.</p><p>As expected, he forgot his password after a few days. Help him to retrieve his password <strong>z.</strong>&nbsp;</p><p>It is given that <strong>a&amp;b</strong> should be a sub-mask of <strong>a|b.</strong></p>",
      "complete_approach": "",
      "constraints": "<ul><li><strong>z </strong>is a positive integer of at most 19 digits and less than LLONG_MAX.</li><li><strong>a&amp;b</strong> should be a sub-mask of <strong>a|b.</strong></li></ul>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvoid solve() {\n\tll x, y;\n\tcin >> x >> y;\n\tcout << x + y << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\tint t = 1;\n\t// int i = 1;\n\t// cin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:47:11.725235+00:00"
      },
      "hints": {
        "hint1": "<p>Can you retrieve <strong>a</strong> and <strong>b</strong> values from <strong>a&amp;b</strong> and <strong>a|b </strong>values? &nbsp;&nbsp;</p>",
        "hint2": "<p>Try to write <strong>a&amp;b</strong> and <strong>a|b</strong> values for some <strong>a</strong> and <strong>b</strong>, and try to observe some relationship b/w them.</p>",
        "solution_approach": "<p>Identity: &nbsp;<strong>a&amp;b + a|b = a + b ( Observation )</strong></p><p>using above identity, we get <strong>z = a&amp;b + a|b.</strong></p><p><strong>Time Complexity: O(1)</strong></p>"
      },
      "id": 810,
      "input_format": "<p>The input contains a single line having <strong>a&amp;b </strong>and<strong> a|b</strong> values.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Output a single integer <strong>z, </strong>the password.&nbsp;</p>",
      "samples": [
        {
          "explanation": "Since &nbsp;a&amp;b =1 and a|b = 7, then a=3 and b=5, therefore z = a + b = 8.</p>",
          "input": "1 7",
          "output": "8"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Bilkul ricks nhi lena ka",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "*Monkey D. Luffy*, on his journey of becoming the *\"King of Pirates\"* and to conquer the *\"One Piece\"*, wants to travel across the Grand Line. \nGrand Line is a mysterious sea, and is in the shape of a $N*M$ grid $S$ with each cell denoting the wind direction. The sign of $S[i][j]$ can be:\n\n- $1$ which means wind in the cell flows to the right. (i.e from $S[i][j]$ to $S[i][j + 1]$)\n- $2$ which means wind in the cell flows to the left. (i.e from $S[i][j]$ to $S[i][j - 1]$)\n- $3$ which means wind in the cell flows downwards. (i.e from $S[i][j]$ to $S[i + 1][j]$)\n- $4$ which means wind in the cell flows upwards. (i.e from $S[i][j]$ to $S[i - 1][j]$)    \n\nNotice that there could be some signs on the cells of the grid $S$ that point outside the Grand Line sea grid.\n\n- Luffy's ship *\"Merry\"* can only sail along the wind direction and can't go outside the Grand Line sea grid $S$ at any point. \n- Luffy can also modify the wind's direction on a cell with $cost = 1$. *( can modify the sign on a cell one time only )*\n\nFind the minimum cost to make Luffy's Voyage from the top left corner of the Grand line i.e $S[1][1]$ to its bottom right corner i.e $S[N][M]$  possible.",
      "complete_approach": "",
      "constraints": "$ 2 ≤ N , M ≤ 1000$\n$N$ and $M$ are integers.\n1 ≤ $S_{i,j}$ ≤ 4.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll int64_t\r\n#define endl '\\n'\r\n\r\nint dx[4] = {0, 0, 1, -1};\r\nint dy[4] = {1, -1, 0, 0};\r\nint minCost(vector<vector<int>>& grid) {\r\n\tint n = grid.size(), m = grid[0].size();\r\n\tvector<vector<int>> dist(n, vector<int> (m, 1e9)); // defining distance matrix.\r\n\t// 01 BFS.\r\n\tdeque<pair<int, int>> dq;\r\n\tdq.push_back({0, 0});\r\n\tdist[0][0] = 0;\r\n\twhile (!dq.empty()) {\r\n\t\tint x = dq.front().first, y = dq.front().second;\r\n\t\tdq.pop_front();\r\n\t\tfor (int k = 0; k < 4; k++) {\r\n\t\t\tint i = dx[k] + x, j = dy[k] + y;\r\n\t\t\tint w = (k + 1 == grid[x][y]) ? 0 : 1; // important step.\r\n\t\t\tif (i >= 0 && i < n && j >= 0 && j < m && dist[i][j] > dist[x][y] + w) {\r\n\t\t\t\tdist[i][j] = dist[x][y] + w;\r\n\t\t\t\tif (w)dq.push_back({i, j});\r\n\t\t\t\telse dq.push_front({i, j});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn dist[n - 1][m - 1];\r\n}\r\nvoid solve() {\r\n\tint n, m;\r\n\tcin >> n >> m;\r\n\tvector<vector<int>> v(n, vector<int>(m));\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tfor (int j = 0; j < m; j++)cin >> v[i][j];\r\n\t}\r\n\tcout << minCost(v);\r\n}\r\nint main() {\r\n\tios_base :: sync_with_stdio(0);\r\n\tcin.tie(nullptr); cout.tie(nullptr);\r\n\r\n#ifdef Mastermind_\r\n\tfreopen(\"input.txt\", \"r\", stdin); \\\r\n\tfreopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n\tint t = 1;\r\n\t// int i = 1;\r\n\t// cin >> t;\r\n\twhile (t--) {\r\n\t\t// cout << \"Case #\" << i << \": \";\r\n\t\tsolve();\r\n\t\t// i++;\r\n\t}\r\n\treturn 0;\r\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:43:22.245094+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "This problem is a basic shortest path problem. We need to reach $(m - 1, n - 1)$ from $(0, 0)$ using a path with minimum cost. Every field in the grid is reachable from any position including the target. Therefore the default algorithm of choice to solve the problem would be Dijkstra's with a time complexity of $O(E + V log V)$.\n\nIf we look at the problem conditions we can notice that the edges between neighboring nodes are binarily weighted: We can reach the neighbor of a node with a cost of 0 if the sign of the node points to the neighbor. Otherwise, we need to modify the sign and the cost for that is 1.\nThat allows us to use the more efficient 0-1 BFS algorithm that uses a double-ended queue instead of a heap and has a time complexity of $O(E + V)$:\n\n- We always pop the node at the left of the queue.\n- Neighbors with a cost of 0 have the same total cost as the current node. Therefore they are appended to the left of the queue.\n- Neighbors with a cost of 1 have the maximum cost of all nodes in the queue. Therefore they are appended to the right of the queue.\n- The maximum cost difference between the left-most and the right-most node in the queue is 1. Nodes with a higher cost difference will only be added to the queue when the first node with a difference of 1 is being visited. At that point all nodes with a difference of 0 have been processed. Therefore 1 is the new 0.\n\n####  Time complexity:\n\n$V = n * m$\n$E = 4 * V$\n$O(E + V) = O(5 * V) = O(V) = O(n * m)$"
      },
      "id": 902,
      "input_format": "Input is given from Standard Input in the following format: \n\n$N$  $M$ \n$S_{1,1}$ . . . $S_{1,M}$\n:\n:\n$S_{N,1}$ . . . $S_{N,M}$",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For Sample 1, You will start at point $(0, 0)$.\nThe path to $(3, 3)$ is as follows. $(0, 0)$ --> $(0, 1)$ -->$(0, 2)$ --> $(0, 3)$ change the arrow to down with $cost = 1$ --> $(1, 3)$ --> $(1, 2)$ --> $(1, 1)$ --> $(1, 0)$ change the arrow to down with $cost = 1$ --> $(2, 0)$ --> $(2, 1)$ --> $(2, 2)$ --> $(2, 3)$ change the arrow to down with $cost = 1$ --> $(3, 3)$\nThe total cost = 3.",
      "output_format": "Print the answer.",
      "samples": [
        {
          "input": "4 4\n1 1 1 1\n2 2 2 2\n1 1 1 1\n2 2 2 2 \n",
          "output": "3\n"
        },
        {
          "input": "3 3\n1 1 3\n3 2 2\n1 1 4\n",
          "output": "0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "One Piece",
      "video_editorial_id": 8238
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given N marbles in different colours. You have to remove marbles till there are no marbles left. Each time you can choose continuous marbles with the same color, remove them and get k*k points (where ‘k’ is the length of the continuous marbles removed). Find the maximum points you can get.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ N ≤ 100</p><p>0 ≤ Ai ≤ 100</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint dp[100][100][100];\nint a[100];\n\nint dfs(int l,int r,int k){\n       if (l > r) return 0;\n       if (dp[l][r][k]) return dp[l][r][k];\n\n       while (l < r && a[r] == a[r-1]) {\n           r--;\n           k++;\n       }\n       dp[l][r][k] = dfs(l,r-1,0) + (k+1) * (k+1);\n       for (int i = l; i < r; ++i) {\n           if (a[i]==a[r]) {\n               dp[l][r][k] = max(dp[l][r][k], dfs(l,i,k+1) + dfs(i+1,r-1,0));\n           }\n       }\n       return dp[l][r][k];\n   }\n\nsigned main(){\n   ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n   int t = 1;\n   while (t--) {\n       int n;\n       cin >> n;\n       for (int i = 0; i < n; ++i) {\n           cin >> a[i];\n       }\n       memset(dp, 0, sizeof(dp));\n       cout << dfs(0, n-1, 0) << \"\\n\";\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:34:10.966957+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Divide the problem into subproblems. For this problem, a similar approach can be used. f(i,j) = max(f(i,k)+f(k+1,j)) i&lt;=k&lt;j</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">You have to remove all subarrays with different colors as the end box, then remove all the boxes with the same color as the end boxes.</span></p>",
        "solution_approach": "<p>Use DP[i][j][k] which denotes the largest number we can get using i-th to j-th marbles with k same coloured marbles. The DP transition will be DP[i][j][k] = max(dp[i][p][k+1]+dp[p+1][j-1][0]).</p><p>Time Complexity: O(N^4)</p><p>Complete solution discussed in the live session.</p>"
      },
      "id": 267,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains one integer N - the length of the array.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">The second line contains N space-separated integers - the colours of the marbles.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case of the example, remove 1, then 3 and then 2, we get 1*1+1*1+2*2 = 6.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case of the example, remove 1, then 3, then 4 and 2, we get 2*2+1*1+2*2+1*1 = 10.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the maximum points you can get in a new line.</span></p>",
      "samples": [
        {
          "input": "4\n2 1 3 2",
          "output": "6"
        },
        {
          "input": "6\n4 3 1 1 4 2",
          "output": "10"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Remove Marbles",
      "video_editorial_id": 8177
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Sort an array A, of size N, containing only 0, 1, 2 as elements. Can you sort them **in-place**?",
      "complete_approach": "",
      "constraints": "<p>1 ≤ N ≤ 10<sup>6</sup><br>0 ≤ A[i] ≤ 2</p>",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid sort(int a[], int n)\n{\n    int lo = -1, mid = 0, hi = n;\n    while (mid < hi)\n    {\n        if (a[mid] == 0)\n        {\n            swap(a[lo + 1], a[mid]);\n            lo++;\n            mid++;\n        }\n        else if (a[mid] == 1)\n        {\n            mid++;\n        }\n        else\n        {\n            swap(a[hi - 1], a[mid]);\n            hi--;\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    sort(a, n);\n    for (int i : a)\n    {\n        cout << i << ' ';\n    }\n    cout << '\\n';\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:13:32.948367+00:00"
      },
      "hints": {
        "hint1": "Can you solve this problem in linear time and constant auxiliary space?",
        "hint2": "Maintain a count of the elements.",
        "solution_approach": "This problem can be solved in two ways. One is the naive way where you maintain the count of the individual elements and then fill the elements in the array. This will be in linear time and constant space but will take two traversals of the array. We can do it in one traversal by the <strong><u>Dutch National Flag Algorithm</u></strong>. We divide the array into 4 parts:\nA[1….lo] - filled with 0’s\nA[lo+1…mid-1] - filled with 1’s\nA[mid...hi-1] - unknown\nA[hi….n] - filled with 2’s\nWe run the algorithm till mid<hi. Every iteration we check the value at A[mid]. If it is 0 we swap A[lo+1] with A[mid] and increment mid by 1. If it is 1 increment mid by 1. If it 2 we swap it with A[hi-1] and decrement hi by 1."
      },
      "id": 630,
      "input_format": "The first line contains a single integer N - the size of the array.\nThe second line contains N integers - the elements of the array.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the sorted array.",
      "samples": [
        {
          "input": "6\n2 0 1 0 1 2",
          "output": "0 0 1 1 2 2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid sort(int a[], int n)\n</fix>\n{\n    //add code here\n}\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    sort(a, n);\n    for (int i : a)\n    {\n        cout << i << ' ';\n    }\n    cout << '\\n';\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "COLORSORT",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You've given an array <i>A</i> of <i>N</i> integers. Your task is to support the following queries.</p><ul><li>0 <i>x</i> <i>y</i> : Modify the number at index <i>x</i> to <i>y</i>.</li><li>1 <i>l r</i> : Print the count the number of even numbers in range <i>l</i> to <i>r</i> inclusive.</li><li>2 <i>l r</i> : Print the count the number of odd numbers in range <i>l</i> to <i>r</i> inclusive.</li></ul>",
      "complete_approach": "",
      "constraints": "- $1 \\leq N, Q \\leq 10^5$\n- $1 \\leq l \\leq r \\leq N$\n- $0 \\leq A_i \\leq 10^9$\n- $1 \\leq x \\leq N$\n- $0 \\leq y \\leq 10^9$",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 200010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nstruct ST{\n    int even, odd;\n    ST(int even = 0, int odd = 0) :\n        even(even), odd(odd) {}\n};\n\nST operator + (const ST &A, const ST &B) {\n    return ST(A.even + B.even, A.odd + B.odd);\n}\n\nstruct segtree {\n    vector<ST> tree;\n    segtree(int n = N) {\n        tree.resize(4 * n);\n    }\n\n    void update(int node, int start, int end, int idx, int val) {\n        if(start == end) {\n            if(val % 2 == 1) tree[node] = ST(0, 1);\n            else tree[node] = ST(1, 0);\n        }\n        else {\n            int mid = (start + end) >> 1;\n            if(idx <= mid) update(2 * node, start, mid, idx, val);\n            else update(2 * node + 1, mid + 1, end, idx, val);\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\n        }\n    }\n\n    int query(int node, int start, int end, int l, int r, bool even) {\n        if(start > r || end < l) return 0;\n        if(start >= l && end <= r) {\n            if(even) return tree[node].even;\n            return tree[node].odd;\n        }\n        int mid = (start + end) / 2;\n        return query(2 * node, start, mid, l, r, even) + query(2 * node + 1, mid + 1, end, l, r, even);\n    }\n};\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n, q;\n    cin >> n;\n\n    segtree T(n);\n\n    for(int i = 0; i < n; i++) {\n        int x; cin >> x;\n        T.update(1, 0, n - 1, i, x);\n    }\n\n    cin >> q;\n\n    for(int i = 0; i < q; i++) {\n        int t, x, y;\n        cin >> t >> x >> y;\n        if(!t) {\n            x--;\n            T.update(1, 0, n - 1, x, y);\n        }\n        else if(t == 1) {\n            x--; y--;\n            cout << T.query(1, 0, n - 1, x, y, true) << \"\\n\";\n        }\n        else {\n            x--; y--;\n            cout << T.query(1, 0, n - 1, x, y, false) << \"\\n\";\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:02.397459+00:00"
      },
      "hints": {
        "hint1": "<p>Segment Tree…</p>",
        "hint2": "<p>Think of what you need to store at each node of the segment tree, and then how should merge logic will happen (i.e. how you update the parent node from the children nodes)</p>",
        "solution_approach": "<p>Lets store the count of <i>even</i> and <i>odd</i> numbers at each node belonging to the range for that node. The parent nodes value of <i>even</i> count is just the sum of even counts of two children nodes. Same of odd counts.</p><p>For clarification please go through the editorial code, and try to understand the merge logic.</p>"
      },
      "id": 405,
      "input_format": "The first input line has an integer N, the number of elements.\nThe second line has N integers A<sub>1</sub>, A<sub>2</sub>, …, A<sub>N</sub>: the array values.\nThe third line has an integer Q, the number of queries.\nEach of the next Q lines contains the query of one of the three types described in the statement.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the output of query of type 1 and 2 on a new line.</p>",
      "samples": [
        {
          "input": "6\n1 2 3 4 5 6\n4\n1 2 5\n2 1 4\n0 5 4\n1 1 6",
          "output": "2\n2\n4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Even and Odd Queries",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given a positive even integer <i>n.</i> Your task is to print all balanced parenthesis of length <i>n </i>in lexicographic order (https://en.wikipedia.org/wiki/Lexicographic_order)<i>.</i>&nbsp;</p><p>Balanced parentheses mean that each opening symbol has a corresponding closing symbol and the pairs of parentheses are properly nested.</p>",
      "complete_approach": "",
      "constraints": "<p>2 ≤ <i>n ≤ </i>24<br>It is guaranteed that <i>n </i>is even.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nstring ans = \"\";\n\nvoid dfs(int curLen, int totalLen, int openCnt)\n{\n    if (curLen == totalLen)\n    {\n        assert(openCnt == 1);\n        ans += \")\";\n        cout << ans << \"\\n\";\n        ans.pop_back();\n        return;\n    }\n\n    if (!openCnt)\n    {\n        ans += \"(\";\n        dfs(curLen + 1, totalLen, openCnt + 1);\n        ans.pop_back();\n    }\n    else\n    {\n        int remLen = totalLen - curLen + 1;\n        ;\n        if (remLen > openCnt)\n        {\n            ans += \"(\";\n            dfs(curLen + 1, totalLen, openCnt + 1);\n            ans.pop_back();\n        }\n        ans += \")\";\n        dfs(curLen + 1, totalLen, openCnt - 1);\n        ans.pop_back();\n    }\n}\n\nsigned main()\n{\n    // freopen(\"IN\", \"r\", stdin);\n    // freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    dfs(1, n, 0);\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:44:53.814933+00:00"
      },
      "hints": {
        "hint1": "The problem requires generating all balanced parenthesis of length n . To do this, you can use a recursive approach, where you keep track of the current length, the total length, and the number of opening parentheses.",
        "hint2": "The solution approach involves using a recursive approach that generates all the balanced parentheses of length n. At each step, you have two choices: either add an opening parenthesis or a closing parenthesis. However, you have to make sure that the resulting sequence is still balanced.",
        "solution_approach": "### Level\nWe need to keep track of current length, the total length, and the number of opening parentheses.  \n\n### Choice\nWe have two choices: either add an opening parenthesis or a closing parenthesis. However, you have to make sure that the resulting sequence is still balanced.\nIf you are adding a opening bracket increase the opening bracket count by 1, else for closing bracket decrease the opening bracket count by 1.\n\n### Check\nCheck if after adding a bracket the sequence is still valid or not.\n\n### Transition\nAfter taking an opening bracket call the DFS with the updated sequence, length, and number of opening parentheses. \nIf the length of the sequence is n, then print the sequence. Otherwise, backtrack."
      },
      "id": 484,
      "input_format": "<p>The only line of input contains a number <i>n.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print all balanced parenthesis of length <i>n </i>in lexicographic order.</p>",
      "samples": [
        {
          "input": "2",
          "output": "()"
        },
        {
          "input": "4",
          "output": "(())\n()()"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Generate Balanced Parenthesis - easy version",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a dice with different values on each face. Find the integer at the top of the face after the sequence of commands to roll the dice is performed. The dice is initially located as shown.</p><figure class=\"image\"><img src=\"https://algozenith.s3.ap-south-1.amazonaws.com/content/11-09-21/4_1631341137464.png\"></figure><p>&nbsp;</p><figure class=\"image\"><img src=\"https://algozenith.s3.ap-south-1.amazonaws.com/content/11-09-21/4_1631341147479.png\"></figure>",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^6$  \n\n$1 \\leq A_i \\leq 10^7$  \n\n$1 \\leq |S| \\leq 10^6$  \n\nIt is guaranteed that the sum of $|S|$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int a[7]; // Using 1-based indexing for ease of understanding.\n        for (int i = 0; i < 6; ++i) {\n            cin >> a[i+1];\n        }\n        string s;\n        cin >> s;\n        for (int i = 0; i < s.size(); ++i) {\n            if (s[i] == 'N') {\n                int t = a[1];\n                a[1] = a[2];\n                a[2] = a[6];\n                a[6] = a[5];\n                a[5] = t;\n            } else if (s[i] == 'S') {\n                int t = a[1];\n                a[1] = a[5];\n                a[5] = a[6];\n                a[6] = a[2];\n                a[2] = t;\n            } else if (s[i] == 'E') {\n                int t = a[1];\n                a[1] = a[4];\n                a[4] = a[6];\n                a[6] = a[3];\n                a[3] = t;\n            } else { // Assuming 'W' for West\n                int t = a[1];\n                a[1] = a[3];\n                a[3] = a[6];\n                a[6] = a[4];\n                a[4] = t;\n            }\n        }\n        cout << a[1] << \"\\n\"; // Output the top face of the dice\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:15:20.698864+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "The dice is represented such that `a[1]` is the top face, and the other numbers represent the sides and bottom face. The rotations are simulated according to the instructions given in the input string `s`. Each rotation adjusts the indices of the array `a` to reflect the new top face after the rotation. The time complexity of processing each test case is proportional to the length of the instruction string, making it efficient for strings of varying lengths.\n\n**Time Complexity per test case:** \\(O(|S|)\\), where \\(|S|\\) is the length of the string.\n"
      },
      "id": 333,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains six space-separated integers Ai - values on each face.\n\nThe second line of each test case contains a string S - the sequence of commands.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, initially 1 is at top, rotating N, 2 is at top, rotating E, 4 is at top.\n\nFor the second test case, initially 2 is at top, rotating S, 1 is at top, rotating W, 5 is at top, rotating N, 2 is at top.\n\nFor the third test case, initially 3 is at top, rotating S, 7 is at top, rotating S, 8 is at top, rotating E, 6 is at top, rotating N, 7 is at top.",
      "output_format": "For each test case, print the integer at the top of the face after the sequence of commands to roll the dice is done.",
      "samples": [
        {
          "input": "3\n1 2 3 4 5 6\nNE\n2 4 5 3 1 7\nSWN\n3 4 5 6 7 8\nSSEN\n",
          "output": "4\n2\n7\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Dice Simulation AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Give a special singly linked list of length <i>N</i> with an additional random pointer that points to any node, including itself or <i>null</i>. Make a new linked list, which is exactly the same as the given linked list. Each node should point to the next and random pointer node in the same way as the original list. <strong>None of the pointers in the new list should point to nodes in the original list.</strong></p><p>For example, if there are two nodes <i>X</i> and <i>Y</i> in the original list, where <i>X.random → Y</i>, then for the corresponding two nodes <i>x</i> and <i>y</i> in the copied list, <i>x.random → y</i>.</p><p>Return the head of the copied linked list.</p><p>Complete the function</p><p><strong>ListNode* copyRandomList(ListNode* head)</strong></p>",
      "complete_approach": "",
      "constraints": "<p>0 ≤ <i>N</i> ≤ 10<sup>5</sup><br>0 ≤ Value of the Node ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode *random;\n    ListNode() : val(0), next(nullptr), random(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr), random(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next), random(nullptr) {}\n    ListNode(int x, ListNode *next, ListNode *random) : val(x), next(next), random(random) {}\n};\n\nListNode* copyRandomList(ListNode* head) {\n    if(head == NULL) return NULL;\n    ListNode* cur = head;\n    while(cur != NULL) {\n        ListNode* temp = cur->next;\n        cur->next = new ListNode(cur->val);\n        cur->next->next = temp;\n        cur = temp;\n    }\n    cur = head;\n    while(cur != NULL) {\n        cur->next->random = cur->random?cur->random->next:cur->random;\n        cur = cur->next->next;\n    }\n    \n    ListNode* original = head, *copy = head->next;\n    ListNode* ans = copy;\n    while(copy != NULL && original != NULL) {\n        original->next = original->next->next;\n        copy->next = copy->next?copy->next->next:copy->next;\n        original = original->next;\n        copy = copy->next;\n    }\n    return ans;\n}\n\nListNode* GetList(vector<pair<int,int>> &num) {\n    int n = (int)num.size();\n    vector<ListNode*> copy(n);\n\n    ListNode* head = NULL;\n    ListNode* cur = NULL;\n\n    for(int i = 0; i < n; i++) {\n        ListNode* temp = new ListNode(num[i].first);\n        copy[i] = temp;\n        if(!head) {\n            head = temp;\n            cur = temp;\n        }\n        else {\n            cur->next = temp;\n            cur = cur->next;\n        }\n    }\n\n    for(int i = 0; i < n; i++) {\n        if(num[i].second == -1) continue;\n        copy[i]->random = copy[num[i].second];\n    }\n\n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<pair<int,int>> num(n);\n\n    for(int i = 0; i < n; i++) {\n        cin >> num[i].first >> num[i].second;\n    }\n\n    ListNode* head = GetList(num);\n\n    ListNode* ans = copyRandomList(head);\n\n    while(ans) {\n        cout << ans->val << \" \";\n        if(ans->random) cout << ans->random->val << \"\\n\";\n        else cout << \"-1\\n\";\n        ans = ans->next;\n    }\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:28:29.991101+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<h2><span style=\"background-color:transparent;color:#000000;\">Solution 1 (Extra Space)</span></h2><p><span style=\"background-color:transparent;color:#000000;\">Iterate through the given linked list and maintain a hashmap, say m to store the key as the original node and its value as the new node. The new node should have the same value as the original node. Don’t assign the next and random pointers at this point. Now traverse the linked list again and assign the next and random pointers using the hashmap. Note that you should use Nodes as the key and value pair and not their values.</span></p><p><span style=\"background-color:transparent;color:#000000;\"><i>Time Complexity:</i> The linked list is iterated twice, the time complexity is O(n) where n is the number of nodes in the linked list.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Space Complexity:</i> Since a hashmap of size n is made, the space complexity is O(n).</span></p><p>&nbsp;</p><h2><span style=\"background-color:transparent;color:#000000;\">Solution 2 (Optimal)</span></h2><p><span style=\"background-color:transparent;color:#000000;\">If the linked list is: 1 → 2 → 3 → 4 → null, you need to copy each node and insert it right after the current node. Doing this will change the linked list to: 1 → 1’ → 2 → 2’ → 3 → 3’ → 4 → 4’ → null. Now we need to assign the random pointers. It can be noticed that the random pointer of node 1’ will be the same as the next pointer of the random pointer of node 1. The same can be done for each node. Now you just need to reassign the next pointers of the copy of the linked list.</span></p><p><span style=\"background-color:transparent;color:#000000;\"><i>Time Complexity:</i> The linked list is iterated thrice, the time complexity is O(n) where n is the number of nodes in the linked list.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Space Complexity:</i> Since constant extra memory is used, the space complexity is O(1).</span></p>"
      },
      "id": 540,
      "input_format": "<p>The first line of input contains <i>N</i> - the number of nodes in the linked list.<br>Each of the next lines contains the node value and the random index in the list to which the random pointer is pointing. If the random index is -1, then the random pointer is pointing at <i>null.</i></p><p>The following function parses the input</p><p><strong>ListNode* GetList(vector&lt;pair&lt;int,int&gt;&gt; List)</strong></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<figure class=\"image\"><img src=\"https://lh3.googleusercontent.com/NXeg7u-zICehupo9p7yKWuSpsNTeud1J89Pap-ch3aHYfsJO6VyzZzvU3J1pNw3sO9eWqTCfEl2orbYCSFW6S0iSRbidWFFYVGVi5lbOPTTNk0ZNiqs1hoJ_CqBuQ6Gfzf4jr0Ws\"></figure>",
      "output_format": "",
      "samples": [
        {
          "input": "5\n1 2\n6 -1\n3 -1\n4 1\n5 3",
          "output": "1 3\n6 -1\n3 -1\n4 6\n5 4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode *random;\n    ListNode() : val(0), next(nullptr), random(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr), random(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next), random(nullptr) {}\n    ListNode(int x, ListNode *next, ListNode *random) : val(x), next(next), random(random) {}\n};\n</fix>\n\nListNode* copyRandomList(ListNode* head) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(vector<pair<int,int>> &num) {\n    int n = (int)num.size();\n    vector<ListNode*> copy(n);\n\n    ListNode* head = NULL;\n    ListNode* cur = NULL;\n\n    for(int i = 0; i < n; i++) {\n        ListNode* temp = new ListNode(num[i].first);\n        copy[i] = temp;\n        if(!head) {\n            head = temp;\n            cur = temp;\n        }\n        else {\n            cur->next = temp;\n            cur = cur->next;\n        }\n    }\n\n    for(int i = 0; i < n; i++) {\n        if(num[i].second == -1) continue;\n        copy[i]->random = copy[num[i].second];\n    }\n\n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<pair<int,int>> num(n);\n\n    for(int i = 0; i < n; i++) {\n        cin >> num[i].first >> num[i].second;\n    }\n\n    ListNode* head = GetList(num);\n\n    ListNode* ans = copyRandomList(head);\n\n    while(ans) {\n        cout << ans->val << \" \";\n        if(ans->random) cout << ans->random->val << \"\\n\";\n        else cout << \"-1\\n\";\n        ans = ans->next;\n    }\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Copy List with Random Pointer",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">There are <strong>n </strong>people standing in a circle waiting to be executed. The counting out begins at the person standing at the 1st position and proceeds around the circle in increasing order (after n we get 1). In each step, <strong>k-1</strong> people are skipped and the <strong>kth</strong> person is executed. The elimination proceeds around the circle (which is becoming smaller and smaller as the executed people are removed), until only the last person remains, who is given freedom. Given the total number of </span>person<span style=\"background-color:transparent;color:#000000;\"> <strong>n</strong> and a number <strong>k</strong> which indicates that <strong>k-1</strong> persons are skipped and <strong>kth</strong> person is killed in the circle. The task is to choose the place in the initial circle so that you are the last one remaining and so survive.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1 &lt;= n &lt;= 10<sup>5</sup></span><br><span style=\"background-color:transparent;color:#000000;\">1 &lt;= k &lt;= n</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \nint josephus(int n, int k) {\n    if (n == 1)\n        return 1;\n    return ((josephus(n - 1, k) + k - 1) % n + 1);\n}\n \nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n, k;\n    cin >> n >> k;\n    cout << josephus(n, k);\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:45:30.665458+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Can you think of a recursive solution?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">After the first elimination, the problem is reduced to a sub-problem with n decreased by 1 and the starting position shifted.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">We make a function <strong>josephus(n, k)</strong> which returns the safe position.</span></p><p><span style=\"background-color:transparent;color:#000000;\">In the first turn, the kth person is eliminated and n-1 people are left. Now, the problem is to find the safe position when n-1 people are there starting from k+1 th person and every kth one being eliminated. So we can call <strong>josephus(n-1, k) </strong>to solve the subproblem. But for this subproblem the starting position is k%n+1 so we need to adjust the value returned. Since k-1 elements were skipped we add k-1 to the value returned.</span></p>"
      },
      "id": 586,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The only line of input contains two integers <strong>n</strong> and <strong>k</strong>.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">Let's represent the circle as an array.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Starting point for the next turn is in bold.</span></p><p><span style=\"background-color:transparent;color:#000000;\">[<strong>1</strong>, 2, 3, 4, 5, 6]</span></p><p><span style=\"background-color:transparent;color:#000000;\">1) First 3 is eliminated. [1, 2, <strong>4</strong>, 5, 6]</span></p><p><span style=\"background-color:transparent;color:#000000;\">2) 6 is eliminated. [<strong>1</strong>, 2, 4, 5]</span></p><p><span style=\"background-color:transparent;color:#000000;\">3) 4 is eliminated. [1, 2, <strong>5</strong>]</span></p><p><span style=\"background-color:transparent;color:#000000;\">4) 2 is eliminated. [1, <strong>5</strong>]</span></p><p><span style=\"background-color:transparent;color:#000000;\">5) 5 is eliminated so&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\"><strong>1 </strong>is the safe position.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Output a single integer <strong>x (1 &lt;= x &lt;= n) </strong>which is the position at which you can survive.</span></p>",
      "samples": [
        {
          "input": "6 3",
          "output": "1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Josephus Problem",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given two integers <i>N</i> and <i>S</i>. Find the number of positive integers <i>X</i> less than equal to <i>N</i>, such that the difference between <i>X</i> and the sum of its digits (in decimal representation) is not less than <i>S</i>.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nsigned main()\n{\n   ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n   ll testcases;\n   cin>>testcases;\n   while(testcases--){\n       ll n,s;\n       cin>>n>>s;\n       ll low = 1,high = n;\n       ll ans = 0;\n       while(low<=high)\n       {\n           ll mid = (low+high)/2;\n           ll temp = mid;\n           ll sumOfDigit = 0;\n           while(temp>0)\n           {\n               sumOfDigit+=temp%10;\n               temp/=10;\n           }\n           if(mid-sumOfDigit>=s)\n               high = mid-1;\n           else\n               ans=mid,low = mid+1;\n       }\n       cout<<n-ans<<\"\\n\";\n   }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:45:32.466011+00:00"
      },
      "hints": {
        "hint1": "If for a number X, the difference between X and the sum of its digits is not less than S, then for X+1 also difference will not be less than S. Can you prove it?\nIf this claim is true then use this monotone property.",
        "hint2": "<p>Prove: Let F(X) represents the sum of digits of X.</p><p>Since F(X+1) is not greater than F(X)+1,&nbsp;<br>F(X+1) ≤ F(X)+1<br>X + F(X+1) ≤ F(X) + 1 + X , adding X both side<br>X - F(X) ≤ X + 1 - F(X+1)</p><p>then X + 1 - F(X+1) ≥ X - F(X).&nbsp;</p><p>and if X - F(X) ≥ S,&nbsp;</p><p>then X + 1 - F(X+1) ≥ S.</p>",
        "solution_approach": "This observation allows us to use binary search to find the minimum number X, such that the difference between X and the sum of its digits is not less than S. It follows the monotone property that initially all numbers less than X have difference less than equal to S. So “NO”  instance holds for numbers less than X. Then for all numbers ≥X “YES” instance hold. Using binary search we can find the smallest value X such that the “YES” instance holds. And if X ≤ N, then all numbers in the segment [X, N] have difference not less than S."
      },
      "id": 26,
      "input_format": "<p>The first line of input contains one integer <i>T</i> (1 ≤ <i>T</i> ≤ 10<sup>4</sup>) — the number of test cases. Then <i>T</i> test cases follow.</p><p>The first line of each test case contains two space-separated integer <i>N</i>, <i>S</i> where 1&lt;=<i>N</i>&lt;=10^18, 0&lt;=<i>S</i>&lt;=10^18.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the number of positive integers <i>X</i> in a new line.</p>",
      "samples": [
        {
          "input": "10\n5 4\n100 5\n20 3\n40 19\n32 15\n69 12\n1000000000000000 0\n1000000000000000000 10000000\n9999999999999 9999999999882\n13465751690089037 981448507916936",
          "output": "0\n91\n11\n11\n13\n50\n1000000000000000\n999999999989999991\n10\n12484303182172038"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Number & Sum of Digit",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an array of <strong>n</strong> elements where each element is at most <strong>k </strong>away from its target position in the sorted array. The task is to print the array in sorted order.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Complete the function</span></p><pre><code class=\"language-plaintext\">void NearlySort(vector&lt;int&gt; &amp;A, int k)</code></pre>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-cpp\">1 &lt;= n &lt;= 100000\n0 &lt;= k &lt; n</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid NearlySort(vector<int> &A, int k)\n{\n\tint n = (int)A.size();\n\n\tpriority_queue<int> pq;\n\n\tfor (int i = 0; i <= k; i++)\n\t\tpq.push(-A[i]);\n\n\tint j = 0;\n\n\tfor (int i = k + 1; i < n; i++)\n\t{\n\t\tA[j++] = -pq.top();\n\t\tpq.pop();\n\t\tpq.push(-A[i]);\n\t}\n\n\twhile (!pq.empty())\n\t{\n\t\tA[j++] = -pq.top();\n\t\tpq.pop();\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint n, k;\n\tcin >> n >> k;\n\n\tvector<int> v(n);\n\n\tfor (auto &i : v)\n\t\tcin >> i;\n\n\tNearlySort(v, k);\n\n\tfor (int i = 0; i < n; i++)\n\t\tcout << v[i] << \" \";\n\n\tcout << \"\\n\";\n\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:32:03.821780+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Can you utilize the fact that each number is at most k away from its target position?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">For each index, there are k possible candidate numbers. For each point we can find minimum of these k numbers.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">We can sort the array in O(n log n) but we can use the special nature of the array to reduce the complexity. We use a priority queue to solve the problem in O(n log k).&nbsp;</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">We insert the first k+1 elements into the priority queue.</span></li><li><span style=\"background-color:transparent;color:#000000;\">One by one we remove the minimum element from the priority queue and add it to the result array and the new element into the priority queue.</span></li></ol><p><span style=\"background-color:transparent;color:#000000;\">As we maintain a window of k+1 numbers, the current element is always the minimum element in the priority queue. We do not need more numbers in the priority queue because the number at a position in the resultant array can be at most k away in the input array.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Since the size of the priority queue is k, addition, and removal take O(log k) time and thus a total complexity of O(n log k).</span></p>"
      },
      "id": 605,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of input contains two integers <strong>n </strong>and <strong>k.</strong></span><br><span style=\"background-color:transparent;color:#000000;\">The second line contains <strong>n</strong> integers which represents the input array.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">The array in sorted order is 10 11 14 15 20 64 70.</span><br><span style=\"background-color:transparent;color:#000000;\">10 did not move.</span><br><span style=\"background-color:transparent;color:#000000;\">11 moved by 1 place.</span><br><span style=\"background-color:transparent;color:#000000;\">14 moved by 1 place.</span><br><span style=\"background-color:transparent;color:#000000;\">20 moved by 1 place.</span><br><span style=\"background-color:transparent;color:#000000;\">64 moved by 1 place.</span><br><span style=\"background-color:transparent;color:#000000;\">15 moved by 2 places.</span><br><span style=\"background-color:transparent;color:#000000;\">70 did not move.</span><br><span style=\"background-color:transparent;color:#000000;\">So we can see that each number was not more than 2 away from their target position.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Output the input array in sorted order.</span></p>",
      "samples": [
        {
          "input": "7 2\n10 14 11 20 64 15 70",
          "output": "10 11 14 15 20 64 70"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nvoid NearlySort(vector<int> &A, int k)\n{\n\t//Complete the function\n}\n\n<fix>\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint n, k;\n\tcin >> n >> k;\n\n\tvector<int> v(n);\n\n\tfor (auto &i : v)\n\t\tcin >> i;\n\n\tNearlySort(v, k);\n\n\tfor (int i = 0; i < n; i++)\n\t\tcout << v[i] << \" \";\n\n\tcout << \"\\n\";\n\n\treturn 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Nearly Sorted Arrays",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two integers $a$ and $b$, return the sum of the two integers without using the operators $+$ and $-$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 2 \\times 10^{6} $\n$-1000 \\leq a,b \\leq 1000 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint Sum(int a, int b) {\n    while (b) {\n        unsigned int c = (a & b); // carry.\n        a ^= b;\n        b = (c << 1);\n    }\n    return a;\n}\n\nvoid solve() {\n    int a, b;\n    cin >> a >> b;\n    cout << Sum(a, b) << endl;\n    assert(a + b == Sum(a, b));\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:23:34.942677+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Eg: Let's try this with our hand 3 + 2 = 5 , the carry will be with in the brackets i.e \"()\"\n\n3 => 011 \n2=>  010\n     ____\n     1(1)01\nHere we will forward the carry at the second bit to get the result.\nSo which bitwise operator can do this ? A simple observation says that XOR can do that,but it just falls short in dealing with the carry properly, but correctly adds when there is no need to deal with carry.\nFor Eg:\n\n1   =>  001 \n2   =>  010 \n1^2 =>  011 (2+1 = 3) \nSo now when we have carry, to deal with, we can see the result as :\n\n3  => 011 \n2  => 010 \n3^2=> 001  \n\nHere we can see XOR just fell short with the carry generated at the second bit.\nSo how can we find the carry ? The carry is generated when both the bits are set, i.e (1,1) will generate carry but (0,1 or 1,0 or 0,0) won't generate a carry, so which bitwise operator can do that ? AND gate ofcourse.\n\nTo find the carry we can do\n\n3    =>  011 \n2    =>  010 \n3&2  =>  010\nnow we need to add it to the previous value we generated i.e ( 3 ^ 2), but the carry should be added to the left bit of the one which generated it.\nso we left shift it by one so that it gets added at the right spot.\n\nHence (3&2)<<1 => 100\nso we can now do\n\n3 ^2        =>  001 \n(3&2)<<1    =>  100 \n\nNow xor them, which will give 101(5) , we can continue this until the carry becomes zero.\n\nRefer to the editorial code for the implementation."
      },
      "id": 926,
      "input_format": "First-line contains $T$ - the number of test cases.\nThe first line of each test case contains two integers $a$ and $b$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case in a newline, output the sum of $a$ and $b$.",
      "samples": [
        {
          "input": "2\n2 1\n-1 1\n",
          "output": "3\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Tricky Sum",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Vivek has an array that consists of <i><strong>n</strong></i> integers. In one second Vivek can swap two neighboring array elements. Now Vivek is wondering if he can obtain an array where any two neighboring elements would be distinct in a <strong>finite</strong> time.</p><p>Help Vivek.</p>",
      "complete_approach": "",
      "constraints": "<p>1  ≤  <i>n</i>  ≤  10<sup>6</sup><br>0  ≤  <i>a<sub>i</sub></i>  ≤  10<sup>6</sup></p>",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:33:57.373866+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 746,
      "input_format": "<p>The first line contains integer <i><strong>n</strong></i> - the number of elements in the array. The second line contains <i><strong>n</strong></i> integers <i><strong>a</strong></i><strong><sub>1</sub>, </strong><i><strong>a</strong></i><strong><sub>2</sub>, ..., </strong><i><strong>a<sub>n</sub></strong></i> - the array elements.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>In the single line print \"<strong>YES</strong>\" (without the quotes) if Vivek can obtain the array he needs, and \"<strong>NO</strong>\" (without the quotes) otherwise.</p>",
      "samples": [
        {
          "input": "1\n1\n",
          "output": "YES\n"
        },
        {
          "input": "3\n1 1 2\n",
          "output": "YES\n"
        },
        {
          "input": "4\n7 7 7 7\n",
          "output": "NO\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Array and Swaps",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given a directed graph with $n$ vertices and $m$ edges.\n\nYou need to find if there exists a mother vertex in the given graph. Output *\"Yes\"* if it exists, otherwise output *\"No\"*.\n\nA mother vertex is defined as a vertex from which all the vertices in the graph are accessible by a directed path.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^4$\n$1 \\leq n \\leq 10^5$\n$0 \\leq m \\leq 10^5$\n$1 \\leq u,v \\leq n$\nThere can be duplicate edges or self-loops in the input graph.\nThe Sum of $n$ over all test cases is $\\leq 10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvector<vector<int>> adj;\nvector<bool> vis;\nint cnt, mother;\nvoid dfs(int v) {\n\tvis[v] = true;\n\tcnt++;\n\tfor (auto x : adj[v]) {\n\t\tif (!vis[x])dfs(x);\n\t}\n\tmother = v;\n}\nbool motherVertex(int n, vector<vector<int> > &B) {\n\tvis.assign(n + 1, false);\n\tadj.assign(n + 1, vector<int>());\n\tfor (auto x : B) {\n\t\tadj[x[0]].push_back(x[1]);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i])dfs(i);\n\t}\n\tvis.assign(n + 1, false);\n\tcnt = 0;\n\tdfs(mother);\n\treturn cnt == n;\n}\nvoid solve() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> adj(m, vector<int>(2));\n\tfor (int i = 0; i < m; i++)cin >> adj[i][0] >> adj[i][1];\n\tint ans = motherVertex(n, adj);\n\tif (ans)cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:34:38.076137+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We can find a mother vertex in $O(V+E)$ time. The idea is based on Kosaraju’s Strongly Connected Component Algorithm. In a graph of strongly connected components, mother vertices are always vertices of the source component in the component graph. The idea is based on the below fact.\nIf there exists a mother vertex (or vertices), then one of the mother vertices is the last finished vertex in DFS. (Or a mother vertex has the maximum finish time in DFS traversal).\nA vertex is said to be finished in DFS if a recursive call for its DFS is over, i.e., all descendants of the vertex have been visited. \n\n**How does the above idea work?**\nLet the last finished vertex be $v$. Basically, we need to prove that there cannot be an edge from another vertex $u$ to $v$ if $u$ is not another mother vertex (Or there cannot exist a non-mother vertex u such that $u→v$ is an edge). There can be two possibilities.\n\nRecursive DFS call is made for $u$ before $v$. If an edge $u→v$ exists, then $v$ must have finished before $u$ because $v$ is reachable through $u$ and a vertex finishes after all its descendants.\nRecursive DFS call is made for $v$ before $u$. In this case also, if an edge $u→v$ exists, then either $v$ must finish before $u$ (which contradicts our assumption that $v$ is finished at the end) OR $u$ should be reachable from $v$ (which means $u$ is another mother vertex).\n\n**Algorithm:** \n\n1. Do DFS traversal of the given graph. While doing traversal keep track of the last finished vertex ‘v’. This step takes $O(V+E)$ time.\n2. If there exists a mother vertex (or vertices), then $v$ must be one (or one of them). Check if $v$ is a mother vertex by doing DFS/BFS from $v$. This step also takes $O(V+E)$ time."
      },
      "id": 996,
      "input_format": "First-line contains $T$ - the number of test cases.\nThe first line of each test case contains $n$ and $m$.\nThe next $m$ lines of each test case contain $m$ directed edges of the graph, each from $u$ to $v$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, Output *\"Yes\"* if Mother Vertex exists, otherwise output *\"No\"*.",
      "samples": [
        {
          "input": "4\n5 5\n2 1\n1 4\n4 5\n1 3\n3 2\n3 3\n1 3\n2 3\n1 3\n3 3\n1 3\n2 3\n3 2\n1 0\n",
          "output": "Yes\nNo\nYes\nYes\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Mother Vertex",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You manage a database consisting of huge strings. Each string in the database has an associated **id**, which is an integer. You need to generate a **compressed string** using the id of the string in the database.\n\nThe strings can consist of:\n\n1. A lowercase alphabet [`'a'` to `'z'`] - total 26 characters.  \n2. An uppercase alphabet [`'A'` to `'Z'`] - total 26 characters.  \n3. A digit [`'0'` to `'9'`] - total 10 characters.  \n\nSo there are a total of **62** possible characters.\n\nYour task is to convert the integer (id of the string) to a 62-base number where digits of the 62-base are:\n\n1. `0-25` → `'a'` to `'z'`  \n2. `26-51` → `'A'` to `'Z'`  \n3. `52-61` → `'0'` to `'9'`",
      "complete_approach": "",
      "constraints": "<p>1 &lt;= n &lt;= 10<sup>18</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tvector <char> dig(62);\n\tfor (int i = 0; i < 26; i++) {\n\t\tdig[i] = (char)('a' + i);\n\t}\n\tfor (int i = 0; i < 26; i++) {\n\t\tdig[26 + i] = (char)('A' + i);\n\t}\n\tfor (int i = 0; i < 10; i++) {\n\t\tdig[52 + i] = (char)('0' + i);\n\t}\n\tstring ans = \"\";\n\tlong long int n;\n\tcin >> n;\n\twhile (n) {\n\t\tchar cur = dig[n % 62];\n\t\tn = n / 62;\n\t\tans += cur;\n\t}\n\treverse(ans.begin(), ans.end());\n\tcout << ans;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:18:48.450876+00:00"
      },
      "hints": {
        "hint1": "Can you relate this problem to Decimal-Binary conversion?",
        "hint2": "In binary representation, the base is 2. Here, the base is 62.",
        "solution_approach": "In decimal-to-binary conversion, the base is $2$. Here, the base is $62$, and the digits are described in the statement.\n\nAny number in base $62$ can be represented as:\n\n$\nd_k \\cdot 62^k + d_{k-1} \\cdot 62^{k-1} + \\dots + d_0\n$\n\nWe can obtain $d_0$ by taking $(n \\mod 62)$.\n\nThe number left is:\n\n$\nd_k \\cdot 62^k + d_{k-1} \\cdot 62^{k-1} + \\dots + d_1 \\cdot 62\n$\n\nWe can divide $n$ by $62$ to obtain:\n\n$\nd_k \\cdot 62^{k-1} + d_{k-1} \\cdot 62^{k-2} + \\dots + d_1\n$\n\nAgain, we get $d_1$ by taking $mod$ with $62$.\n\nSimilarly, we can get all the digits of the number in base $62$.\n"
      },
      "id": 595,
      "input_format": "The only line of input contains a single integer n which is the id associated with the string you want to compress.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>1) ‘o’ * 62<sup>2</sup> + ‘i’ * 62 + j = 54321</p>",
      "output_format": "You need to output the compressed string which is the representation of the integer n in base 62.",
      "samples": [
        {
          "input": "54321",
          "output": "oij"
        },
        {
          "input": "1071819",
          "output": "eEZz"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "String Compression",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given a list of <strong>n</strong> integers. The <strong>super frequent </strong>number of the array is the number that is present in the array more than <strong>⌊n / 2⌋ </strong>times. You need to print the super frequent number of the array. Assume that such a number is always present in the input array.</span><br><span style=\"background-color:transparent;color:#000000;\">Try to solve the problem in linear time and constant extra space.</span></p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 100000\n1 &lt;= v[i] &lt;= 100000</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint SuperFrequentElement(vector<int> &v)\n{\n    int n = (int)v.size();\n\n    int cnt = 0;\n    int ans;\n    for (int i = 0; i < n; i++)\n    {\n        if (cnt == 0)\n            ans = v[i];\n        if (v[i] == ans)\n            cnt++;\n        else\n            cnt--;\n    }\n\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(NULL);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (auto &i : v)\n        cin >> i;\n\n    cout << SuperFrequentElement(v) << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:43:24.179980+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">This problem can be solved using Hashmaps in O(n) space. Can you think of a solution that uses constant extra space?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Boyer-Moore Voting Algorithm</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">We maintain a <strong>candidate</strong> for our super frequent element and a <strong>count </strong>which is incremented whenever we see an instance of our current candidate for the super frequent element and decremented whenever we see anything else.</span><br><span style=\"background-color:transparent;color:#000000;\">Whenever count equals 0, we effectively forget about everything in the array up to the current index and consider the current number as the candidate for super frequent element.</span><br><span style=\"background-color:transparent;color:#000000;\">Since we forget the prefix when the count becomes zero, we never remove more super frequent elements than other elements so the super frequent element of the array is still the super frequent element for the current suffix.</span><br><span style=\"background-color:transparent;color:#000000;\">Therefore, given that it is impossible to discard more super frequent elements than other elements, we are safe in discarding the prefix and attempting to recursively solve the super frequent element problem for the suffix. Eventually, a suffix will be found for which count does not hit 0, and the super frequent element of that suffix will necessarily be the same as that of the overall array.</span></p>"
      },
      "id": 591,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains a single integer <strong>n.</strong></span><br><span style=\"background-color:transparent;color:#000000;\">The next line contains n integers representing the input array.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\"><strong>4</strong> is present more than n/2 times in the array. So it is the super frequent number.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the <strong>super frequent </strong>element of the array.</span></p>",
      "samples": [
        {
          "input": "7\n4 1 4 1 1 4 4",
          "output": "4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint SuperFrequentElement(vector<int> &v)\n{\n    // Complete the function\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(NULL);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (auto &i : v)\n        cin >> i;\n\n    cout << SuperFrequentElement(v) << \"\\n\";\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Super Frequent Number",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(39,50,57);\"><strong>Construct Tree from given Inorder and Postorder traversals</strong></span></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:34:38.075002+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 663,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, &nbsp;the length of the array representing the serialized representation of a tree.</p><p>The next line contains N-space-separated distinct integers representing the Inorder Traversal of the tree.&nbsp;</p><p>The next line contains N-space-separated distinct integers representing the Postorder Traversal of the tree.&nbsp;</p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case find the Binary Tree and return the Root Node of the binary tree. Complete this function -&nbsp;</p><p>Node* getBinaryTree(vector&lt;int&gt;&amp;inorder,vector&lt;int&gt;&amp;preorder)<br>{</p><p>}</p><p>A function in the main converts the Binary Tree Root returned into serialized array structure and prints it.</p>",
      "samples": [
        {
          "input": "7\n4\n5096 3880 9002 8750 \n8750 9002 3880 5096 \n8\n213 1746 332 4793 7083 1732 384 7576 \n1746 213 4793 332 1732 7083 7576 384 \n4\n5400 3001 339 7702 \n5400 339 7702 3001 \n2\n7466 5992 \n5992 7466 \n4\n5156 7626 2362 2601 \n5156 7626 2362 2601 \n10\n6402 3772 1983 7765 4414 2719 8960 1670 2682 3815 \n6402 1983 7765 2719 4414 1670 3815 2682 8960 3772 \n1\n7859 \n7859 ",
          "output": "<p>5096 -1 3880 -1 9002 -1 8750 -1 -1&nbsp;</p><p>384 7083 332 213 -1 1746 -1 -1 4793 -1 -1 1732 -1 -1 7576 -1 -1&nbsp;</p><p>3001 5400 -1 -1 7702 339 -1 -1 -1&nbsp;</p><p>7466 -1 5992 -1 -1&nbsp;</p><p>2601 2362 7626 5156 -1 -1 -1 -1 -1&nbsp;</p><p>3772 6402 -1 -1 8960 4414 7765 1983 -1 -1 -1 2719 -1 -1 2682 1670 -1 -1 3815 -1 -1&nbsp;</p><p>7859 -1 -1&nbsp;</p>"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n</fix>\nNode* getBinaryTree(vector<int>&inorder,vector<int>&postorder)\n{\n  // Complete the function.\n}\n<fix>\nvoid generateArray(Node* root, vector<int>&ans){\n    if(root==NULL){\n        ans.push_back(-1);\n        return;\n      }\n    ans.push_back(root->val);\n    generateArray(root->left,ans);\n    generateArray(root->right,ans);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr1(n);\n        for(int i=0;i<n;i++)\n            cin>>arr1[i];\n        vector<int>arr2(n);\n        for(int i=0;i<n;i++)\n            cin>>arr2[i];\n        Node* tree = getBinaryTree(arr1,arr2);\n        vector<int>ans;\n        generateArray(tree,ans);\n        for(auto v:ans)cout<<v<<\" \";\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 3,
      "title": "Tree from inorder and postoder",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two person names.\n\nEach person has {\"the first name\" + \"the second name\"}\n\nDetermine whether they are brothers or not.\n\nNote: The two persons are brothers if they $\\textbf{share the same second name}$.",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string f1, s1, f2, s2;\n    cin >> f1 >> s1;\n    cin >> f2 >> s2;\n    if (s1 == s2) {\n        cout << \"ARE Brothers\" << endl;\n    } else {\n        cout << \"NOT\" << endl;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:33:40.858980+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Check S1 and S2 strings are equal or not if equal then print $\\textbf{\"ARE Brothers\"}$ otherwise print $\\textbf{\"NOT\"}$."
      },
      "id": 1179,
      "input_format": "First line will contain two Strings $F1, S1$ which donates the first and second name of the $1st$ person.\nSecond line will contain two Strings $F2, S2$ which donates the first and second name of the $2nd$ person.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print $\\textbf{\"ARE Brothers\"}$ if they are brothers otherwise print $\\textbf{\"NOT\"}$.",
      "samples": [
        {
          "input": "narendra modi\ngiorgia meloni\n",
          "output": "NOT\n"
        },
        {
          "input": "salman khan\namir khan\n",
          "output": "ARE Brothers\n"
        },
        {
          "input": "sunny leone\nsunny deol\n",
          "output": "NOT\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "The Brothers",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array A of N integers. You have to choose a contiguous arithmetic subarray with equal difference between consecutive integers, that has the maximum length. Find the maximum possible length.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$2 \\leq N \\leq 10^5$  \n\n$-10^7 \\leq A_i \\leq 10^7$  \n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        int cur = 2, diff = a[1] - a[0];\n        int ans = 2;\n        for (int i = 2; i < n; ++i) {\n            if(a[i] - a[i-1] == diff) {\n                cur++;\n            } else {\n                cur = 2;\n                diff = a[i] - a[i-1];\n            }\n            ans = max(ans, cur);\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:15:51.350767+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "If the consecutive difference between elements is the same, increment your current answer, else start again with a new difference.\n\nTime Complexity per test case: O(N)"
      },
      "id": 340,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer N - the length of the array.\n\nThe second line of each test case contains N space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, **1 2 3** 5\n\nFor the second test case, 1 4 **7 4 1 -2**\n\nFor the third test case, **1 8**",
      "output_format": "For each test case, print the maximum possible length.",
      "samples": [
        {
          "input": "3\n4\n1 2 3 5\n6\n1 4 7 4 1 -2\n2\n1 8\n",
          "output": "3\n4\n2\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Longest AP AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a rotated sorted array. Find the index of the minimum element in the array.</p><p><strong>All the elements are distinct.</strong></p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> arr;\n\nbool check(int i){\n   if(arr[i]<arr[0])return 1;\n   else return 0;\n}\n\nvoid solve(){\n   cin>>n;\n   arr.resize(n);\n   for(int i=0;i<n;i++){\n       cin>>arr[i];\n   }\n\n   int lo = 1;\n   int hi = n-1;\n   int ans = 0;\n   while(lo<=hi){\n       int mid = (lo+hi)/2;\n       if(check(mid)){\n           ans = mid;\n           hi = mid - 1;\n       }else{\n           lo = mid + 1;\n       }\n   }\n   cout<<ans<<endl;\n}  \n\nsigned main(){\n   ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n   int _t;cin>>_t;while(_t--)\n   solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:42:19.817101+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">The array was sorted in ascending order originally. When it is rotated, there would be a point in the array where the element is smaller than the element before it, i.e. A[i-1] &gt; A[i]. You need to find this point.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">You can use the fact that all numbers to the left of the inflection point (where the element is smaller than the element before it) are greater than the first number and all numbers to the right of the inflection point are smaller than the first number.</span></p>",
        "solution_approach": "<p>We will use binary search on the given array in a different way since the array is not sorted. We take the left pointer as L = 0 and the right pointer as R = N-1. If at any point, we get A[L] ≤ A[R], that means the array from L to R is sorted and the smallest number would be A[L]. We take mid = (L+R)/2.</p><p>If A[L] ≤ A[mid], that means the array is sorted from L to mid, mid+1 could be a possible answer and then we continue binary search from L = mid+1 to R. Otherwise, A[L] &gt; A[mid], that means the minimum number would be somewhere between L to mid, because if the array is not increasing in this range there will be an inflection point where the element is smaller than the element before it, so we continue binary search from L to R = mid.</p><p>Time Complexity per test case: O(N + log<sub>2</sub>N) (since we are performing binary search on the length of the given array)</p>"
      },
      "id": 108,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases (<i>1&lt;=T&lt;=10000</i>).</p><p>The first line contains an integer <i>N</i> where 1<i>&lt;=N&lt;=10^5</i>.</p><p>The second line contains <i>N</i> space-separated integers A<sub>1</sub>,A<sub>2</sub>....A<sub>N</sub> where <i>-1e9&lt;=Ai&lt;=1e9</i>.</p><p>Sum of <i>N</i> over all test cases <i>≤10^6</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the index of the minimum element in the array.</p><p><strong>0-indexed.</strong></p>",
      "samples": [
        {
          "input": "5\n5\n3 4 5 1 2\n5\n4 5 1 2 3\n5\n5 1 2 3 4\n5\n1 2 3 4 5\n5\n2 3 4 5 1",
          "output": "3\n2\n1\n0\n4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Rotated Sorted Array",
      "video_editorial_id": 10697
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given <i>N</i> distinct points on the number line in a sorted array <i>A</i>. You can place at most <i>K</i> more points on the Line (Integer coordinates only). You have to make the maximum separation between any two consecutive points in the final configuration as minimum as possible. Output this minimal value. &nbsp;</p><p>Note - You can place the points anywhere you like, but you cannot place more than one point at the same position on the line.&nbsp;</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nint arr[100001];\nint n, k;\n\nbool check(int maxDiffAllowed) {\n    int pointsRequired = 0;\n    int i = 1;\n    while (i < n) {\n        pointsRequired += (arr[i] - arr[i - 1] + maxDiffAllowed - 1) / maxDiffAllowed - 1;\n        i++;\n    }\n    return pointsRequired <= k;\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int testcases;\n    cin >> testcases;\n\n    while (testcases--) {\n        cin >> n >> k;\n        for (int i = 0; i < n; i++) {\n            cin >> arr[i];\n        }\n\n        int low = 1, high = 1e9;\n        int ans = high;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (check(mid)) {\n                ans = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        cout << ans << \"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:45:23.389368+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">If maximum separation, X is possible by placing at most K more points, then it is possible to have maximum separation lesser than X as well. That means this is a monotonic function and we can apply binary search.</span></p>",
        "hint2": "<p>We would be doing binary search on the minimum answer possible. We take the left pointer as L = 1(since it is given that all the numbers have to be distinct) and R = A[N-1] - A[0]. We take mid = (L+R)/2. We find the number of points we need to place to have the answer as mid. This can be done by placing the K points in between any two given points (array A) greedily since we want the distance between any two points to be at most mid. If there are two points, x and y present in the original array, we will place points x + mid, x + 2*mid, … x + X*mid in between them such that x + X*mid &lt; y.</p><p>If the number of points we need to place to have the answer as mid is ≤ K, that means it could be a possible answer and so we continue binary search from L to R = mid-1(since we want to minimize the answer). Otherwise, we need to increase the value of the answer and hence we continue binary search from L = mid+1 to R.</p><p>Time Complexity per test case: O(N * log2(A[N-1] - A[0]))</p>",
        "solution_approach": ""
      },
      "id": 46,
      "input_format": "<p>The first line contains an integer <i>T</i>, the number of test cases <i>(1&lt;=T&lt;=10000)</i>.</p><p>The first line of each test case contains two space-separated integers <i>N, K</i>, 2<i>&lt;=N&lt;=10^5</i>, <i>0&lt;=K&lt;=10^9</i>.</p><p>Next line contains <i>N</i> space-separated distinct integers (<i>0&lt;=A<sub>i</sub>&lt;=1e9</i>).</p><p>Sum of N across all test cases &lt;= 10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "<p>For the first test case - do not place any additional points or place points at 6,7.</p><p>For the third test case - place the points at 133, 166. So final configuration = [100, 133, 166, 200, 230] and maximum difference between two consecutive numbers = 34.</p><p>For fourth test case - place the points at 2, 4, 6, 8, 10. So final configuration = [1,2,3,4,5,6,7,8,9,10,11] and maximum difference between two consecutive numbers = 1.</p>",
      "output_format": "<p>For each test case output the minimum maximum separation between any two consecutive points possible in a new line.</p>",
      "samples": [
        {
          "input": "5\n5 5\n1 2 3 4 5\n5 0\n2 5 7 8 10\n3 2\n100 200 230\n6 5\n1 3 5 7 9 11\n6 4\n1 4 8 13 19 26",
          "output": "1\n3\n34\n1\n4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Minimise Max Diff",
      "video_editorial_id": 10680
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Find the LCA of two nodes of a BBST. <span style=\"background-color:rgb(255,255,255);color:rgb(39,50,57);\">You may assume that both the values exist in the tree.</span><br>BBST - Balanced Binary Search Tree (height of BST is around O(logN)).</p><p><span style=\"background-color:rgb(249,249,249);color:rgb(39,50,57);\"><i>Let T be a rooted tree. The lowest common ancestor between two nodes n1 and n2 is defined as the lowest node in T that has both n1 and n2 as descendants (where we allow a node to be a descendant of itself).</i></span></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:43:45.492952+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 674,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, Q the length of the array representing the serialized representation of a tree, the number of queries.</p><p>The next line contains N-space-separated distinct integers.&nbsp;</p><p>The next Q lines contain 2-space-separated integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each query return the LCA node of two nodes.</p>",
      "samples": [
        {
          "input": "1\n19 9\n677 260 180 -1 -1 386 -1 -1 848 680 -1 -1 897 890 -1 -1 913 -1 -1 \n897 890\n890 386\n180 386\n890 260\n897 890\n890 677\n848 913\n677 890\n848 260",
          "output": "897 677 260 677 897 677 848 677 677"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n</fix>\nNode *getLCANode(Node* root, int n1, int n2)\n{\n    // Complete the function.\n}\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n,q;\n        cin>>n>>q;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++){\n            cin>>arr[i];\n        }\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        for(int i=0;i<q;i++){\n            int k1,k2;\n            cin>>k1>>k2;\n            cout<<getLCANode(tree,k1,k2)->val<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 3,
      "title": "BBST LCA",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given **N** integers, the price of a given stock on each day. You can buy and sell at most one stock. You cannot sell a stock before you buy one. You have to find the maximum profit you can make by buying and selling stocks.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤ 100</p><p>2 ≤ N ≤ 10<sup>5</sup></p><p>0 ≤ Ai ≤ 10<sup>5</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint BuyAndSellStock(vector<int> &a) \n{\n    int n = (int)a.size();\n    int m = a[0], ans = 0;\n    for (int i = 1; i < n; ++i) {\n        ans = max(ans, a[i] - m);\n        m = min(m, a[i]);\n    }\n    return ans;\n}\n\nint main(){\n   IOS\n   \n   int t;\n   cin>>t;\n   \n   while(t--){\n       int n;\n       cin>>n;\n       \n       vector<int> a(n);\n\n       for (int i = 0; i < n; ++i) {\n           cin>>a[i];\n       }\n       \n       cout << BuyAndSellStock(a) << \"\\n\";\n   }\n\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:14:49.170671+00:00"
      },
      "hints": {
        "hint1": "For each day, find the minimum price of the stock before the current day.",
        "hint2": "You can maintain the minimum price in a variable while traversing through the array.",
        "solution_approach": "While traversing through the array, update the minimum price. If the current price is greater than the minimum price, update the profit. While calculating the profit in this way, we made sure that there was no better price to buy from the past\n\nFor stock prices that are strictly decreasing, you don’t do any transaction.\n\nTime Complexity per test case: O(N)"
      },
      "id": 175,
      "input_format": "The first line of the input contains one integer **T** - the number of test cases. Then **T** test cases follow.\nThe first line of each test case contains one integer **N** - the length of the array. \nThe second line of each test case contains **N** space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, you can buy stock on day 1 and sell on day 4. Profit = 6-1 = 5\n\nFor the second test case, you can buy stock on day 1 and sell on day 4. Profit = 4-1 = 3\n\nFor the third test case, you don’t buy and sell any stock. Profit = 0",
      "output_format": "For each test case, print the maximum profit you can make by buying and selling stocks.",
      "samples": [
        {
          "input": "3\n5\n1 5 2 6 3\n4\n1 2 3 4\n4\n5 3 2 1",
          "output": "5\n3\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n</fix>\n\nint BuyAndSellStock(vector<int> &a) \n{\n    // Complete the function\n}\n\n<fix>\nint main(){\n   IOS\n   \n   int t;\n   cin>>t;\n   \n   while(t--){\n       int n;\n       cin>>n;\n       \n       vector<int> a(n);\n\n       for (int i = 0; i < n; ++i) {\n           cin>>a[i];\n       }\n       \n       cout << BuyAndSellStock(a) << \"\\n\";\n   }\n\n   return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Buy and Sell Stock - 1",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "There is a town divided into a grid of cells with $H$ rows and $W$ columns. The cell at the $i^{th}$ row from the top and $j^{th}$ column from the left is a passable space if $S_{i,j}$ is **'.'** and a block if $S_{i,j}$ is **'#'**.\n\nSaitama will go from his house to a fish market. His house is in the cell at the top-left corner, and the fish market is in the cell at the bottom-right corner.\n\nSaitama can move one cell *up, down, left, or right* to a passable cell. He cannot leave the town. He cannot enter a block, either. However, his physical strength allows him to destroy all blocks in a square region with $2×2$ cells of his choice with **one punch**, making these cells passable.\n\nFind the minimum number of punches needed for Saitama to reach the fish market.",
      "complete_approach": "",
      "constraints": "$ 2 ≤ H , W ≤ 1000$\n$H$ and $W$ are integers.\n$S_{i,j}$ is '.' or '#'.\n$S_{1,1}$ and $S_{H,W}$ are **'.'**",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll int64_t\r\n#define endl '\\n'\r\n\r\nint n, m;\r\nint dx[4] = {0, 0, -1, 1};\r\nint dy[4] = { -1, 1, 0, 0};\r\nvoid solve() {\r\n\tcin >> n >> m;\r\n\tchar grid[n][m];\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tfor (int j = 0; j < m; j++)cin >> grid[i][j];\r\n\t}\r\n\tvector<vector<int>> dist(n + 1, vector<int>(m + 1, 1e9));\r\n\tdeque<array<int, 2>> dq;\r\n\tdq.push_front({0, 0});\r\n\tdist[0][0] = 0;\r\n\twhile (!dq.empty()) {\r\n\t\tauto v = dq.front();\r\n\t\tdq.pop_front();\r\n\t\tfor (int i = 0; i < 4; i++) {\r\n\t\t\tint x = dx[i] + v[0], y = dy[i] + v[1];\r\n\t\t\tif (x >= 0 && x < n && y >= 0 && y < m) {\r\n\t\t\t\tif (grid[x][y] == '.') {\r\n\t\t\t\t\tif (dist[x][y] > dist[v[0]][v[1]]) {\r\n\t\t\t\t\t\tdist[x][y] = dist[v[0]][v[1]];\r\n\t\t\t\t\t\tdq.push_front({x, y});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tfor (int p = x - 1; p <= x + 1; p++) {\r\n\t\t\t\t\t\tfor (int q = y - 1; q <= y + 1; q++) {\r\n\t\t\t\t\t\t\tif (p >= 0 && p < n && q >= 0 && q < m) {\r\n\t\t\t\t\t\t\t\tif (dist[p][q] > dist[v[0]][v[1]] + 1) {\r\n\t\t\t\t\t\t\t\t\tdist[p][q] = dist[v[0]][v[1]] + 1;\r\n\t\t\t\t\t\t\t\t\tdq.push_back({p, q});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout << dist[n - 1][m - 1];\r\n}\r\nint main() {\r\n\tios_base :: sync_with_stdio(0);\r\n\tcin.tie(nullptr); cout.tie(nullptr);\r\n\r\n#ifdef Mastermind_\r\n\tfreopen(\"input.txt\", \"r\", stdin); \\\r\n\tfreopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n\tint t = 1;\r\n\t// int i = 1;\r\n\t// cin >> t;\r\n\twhile (t--) {\r\n\t\t// cout << \"Case #\" << i << \": \";\r\n\t\tsolve();\r\n\t\t// i++;\r\n\t}\r\n\treturn 0;\r\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:13:54.585790+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "This problem can be solved with a **0-1 BFS (Breadth-First Search)**.\n\nAssuming that he does not punch until needed, we can assume that a 2×2 region of destroying blocks is adjacent to the square Saitama is at.\n\nWhen Saitama is in the square labelled T in the diagram below, after a single punch he can move to any square labelled *, regardless of the previous state of the squares.\n```\n.***.\n*****\n**T**\n*****\n.***.\n```\nTherefore, we can assume that a move on foot to an adjacent square costs 0 and moving to any * square after a punch costs 1, and perform a 01-BFS to solve the problem. The computational complexity is $O(HW)$."
      },
      "id": 901,
      "input_format": "Input is given from Standard Input in the following format: \n$H$  $W$ \n$S_{1,1}$ . . . $S_{1,W}$\n:\n:\n$S_{H,1}$ . . . $S_{H,W}$",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "In sample 1, He can reach the fish market by, for example, destroying the blocks in the square region with 2×2 cells marked * below.\n```\n..#..\n#.**#\n##**#\n#.#.#\n..#..\n```\nIt is not required that all of the 2×2 cells in the region to punch are blocks.",
      "output_format": "Print the answer.",
      "samples": [
        {
          "input": "5 5\n..#..\n#.#.#\n##.##\n#.#.#\n..#..\n",
          "output": "1\n"
        },
        {
          "input": "5 7\n.......\n######.\n.......\n.######\n.......\n",
          "output": "0\n"
        },
        {
          "input": "8 8\n.#######\n########\n########\n########\n########\n########\n########\n#######.\n",
          "output": "5\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "One Punch Man",
      "video_editorial_id": 8237
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers, find the length of the smallest sub-array that contains all the distinct elements of the array.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nsigned main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll testcases;\n    cin>>testcases;\n    while(testcases--){\n        ll n;\n        cin>>n;\n        ll arr[n];\n        ll freq[100001] = {0};\n        for(ll i=0;i<n;i++)cin>>arr[i],freq[arr[i]]++;\n        ll distinctElement = 0;\n        for(ll i=0;i<=100000;i++){\n            distinctElement+=(freq[i]>0);\n            freq[i] = 0;\n        }\n        ll ans = n;\n        ll start = 0;\n        ll current = 0;\n        ll currSum = 0;\n        while(current<n){\n            freq[arr[current]]++;\n            if(freq[arr[current]]==1)\n                currSum++;\n            while(start<=current and currSum==distinctElement){\n                ans = min(ans,current-start+1);\n                if(freq[arr[start]]==1)\n                    currSum--;\n                freq[arr[start]]--;\n                start++;\n            }\n            current++;\n        }\n        cout<<ans<<\"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:13:06.980798+00:00"
      },
      "hints": {
        "hint1": "First, find the number of distinct elements in the entire subarray and then find the shortest subarray with that number of distinct elements.",
        "hint2": "If a subarray from L to R has K number of distinct elements, it is possible that a shorter subarray from X to R (L < X) also has K number of distinct elements.",
        "solution_approach": "We would be using two pointers to solve this problem. We start both the pointers from the beginning i.e. L = 0 and R = 0. We would be maintaining a frequency count array for the elements in the current subarray. To find the number of distinct elements in the current subarray, when increasing the frequency, if we get it as 1, that means a new element has been added to the current subarray,  the number of distinct elements in the subarray increases, and when decreasing the frequency, if we get it as 0, that means the element is no more present in the subarray and the number of distinct elements in the subarray decreases.\n\nWe start from the beginning of the array and keep increasing the right pointer, R till the number of distinct elements is less than or equal to K. If the subarray from L to R has a number of distinct elements = K, it is possible that a shorter subarray from X to R (L < X) also has K number of distinct elements. Find the length of this subarray, i.e. the penalty, and take the minimum of all such penalties. When the number of distinct elements becomes equal to K, we start moving the left pointer, until the number of distinct elements is less than K. We continue doing this till R < N.\n\nTime Complexity per test case: O(N)"
      },
      "id": 57,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases <i>(1&lt;=T&lt;=10)</i>.</p><p>The first line contains an integer <i>N, 1&lt;=N&lt;=10^5</i>.</p><p>Next line contains <i>N</i> space-separated integers <i>(0&lt;=Ai&lt;=1e5)</i>.</p><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "<p>For first test case → smallest subarray -&gt; (1,3,2).</p><p>For second test case → smallest subarray -&gt; (1,2,3,4,5).</p><p>For third test case → smallest subarray -&gt; (1 2 2 3 3 4).</p>",
      "output_format": "<p>For each test case print length of the smallest sub-array that contains all the distinct elements of array in a newline.</p>",
      "samples": [
        {
          "input": "6\n5\n1 1 3 2 3\n5\n1 2 3 4 5\n6\n1 2 2 3 3 4\n6\n1 2 1 3 2 4\n5\n1 1 1 1 1\n1\n1",
          "output": "3\n5\n6\n4\n1\n1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Shortest Subarray",
      "video_editorial_id": 8134
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$ and a string $S$ of size $N$. Print $S$ after sorting it.\n\n$\\textbf{Note}$ : Don't use built-in function and it's recommended to not solve this problem with python language.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N \\leq 10^7 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    int n; cin >> n;\n    int freq[26] = {};\n    for (int i = 0; i < n; i++) {\n        char c; cin >> c;\n        freq[c - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n        while (freq[i] != 0) {\n            cout << (char)(i + 97);\n            freq[i]--;\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:34:18.403299+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Lowercase alphabets are only 26 so we can maintain a 26 sized freq array and then traverse the string and find every elements frequence then print the characters if that element is present in the freq array."
      },
      "id": 1196,
      "input_format": "The first line contains a number $N$ size of string $S$.\nThe second line contains a string $S$ consists of lowercase English letters.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print $S$ after sorting it.",
      "samples": [
        {
          "input": "4\ndeab\n",
          "output": "abde\n"
        },
        {
          "input": "5\negypt\n",
          "output": "egpty\n"
        },
        {
          "input": "8\ndontsort\n",
          "output": "dnoorstt\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Sort Strings",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "There are 𝑁 items numbered from $1$ to $N$. The 𝑖𝑡ℎ item has a weight of $w_i$ and a value of $v_i$.\n\nYou have to choose some items out of the $N$ items and carry them home in a knapsack. The capacity of the knapsack is $W$ which donate the $ \\textbf{maximum} $ weight that can be carried inside the knapsack. In other words, $W$ means the total summation of all weights of items that can be carried in the knapsack.\n\nPrint $ \\textbf{maximum} $ possible sum of values of items that you can take home.\n\n$ \\textbf{Note:} $ Solve this problem using recursion.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N \\leq 20 $\n$ 1 \\leq W \\leq 100 $\n$ 1 \\leq w_i \\leq 50 $\n$ 1 \\leq v_i \\leq 1000 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint knapsack(int W, int wt[], int val[], int n) {\n    if (n == 0 || W == 0) {\n        return 0;\n    }\n    if (wt[n - 1] > W) {\n        return knapsack(W, wt, val, n - 1);\n    }\n    return max(val[n - 1] + knapsack(W - wt[n - 1], wt, val, n - 1), \n               knapsack(W, wt, val, n - 1));\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int N, W;\n        cin >> N >> W;\n        \n        int w[N], v[N];\n        for (int i = 0; i<N; i++) {\n            int wi, vi; cin >> wi >> vi;\n            w[i] = wi;\n            v[i] = vi;\n        }\n        \n        cout << knapsack(W, w, v, N) << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:40:50.782290+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 1169,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains two space separated integers $ N $ and $ W $.\nNext N lines contains two space separated integers $ w_i $ and $ v_i $.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print $ \\textbf{maximum} $ possible sum of values of items that you can take home.",
      "samples": [
        {
          "input": "1\n3 8\n3 30\n4 50\n5 60\n",
          "output": "90\n"
        },
        {
          "input": "1\n6 15\n6 5\n5 6\n6 4\n6 6\n3 5\n7 2\n",
          "output": "17\n"
        },
        {
          "input": "1\n4 60\n10 60\n20 100\n30 120\n40 180\n",
          "output": "280\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Knapsack",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given N assignments and each assignment has a specific start time and end time within which you have to finish the assignment. Find the maximum number of assignments that you can finish. If an assignment finishes at a time x, you cannot start another assignment at the same time x.",
      "complete_approach": "",
      "constraints": "<p><i>1 ≤ N ≤ 10<sup>5</sup></i></p><p><i>1 ≤ s ≤ t ≤ 10<sup>8</sup></i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ii pair<int, int>\n#define ff first\n#define ss second\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    ii a[n];\n    for (int i = 0; i < n; i++)\n        cin >> a[i].ss >> a[i].ff;\n    sort(a, a + n); //sorting according to the end times\n    int ans = 0, curr = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (a[i].ss > curr)\n            ans++, curr = a[i].ff;\n    }\n    cout << ans << '\\n';\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:30:44.704304+00:00"
      },
      "hints": {
        "hint1": "Greedily select the assignment which can be finished earliest.",
        "hint2": "Sort according to the end times.",
        "solution_approach": "We greedily choose the assignment whose end time is the least, and start time is more than the previously selected assignment. For this sort the assignments according to the end time. Select the first assignment. For the remaining ones, if the start time is greater than the end time of the previously selected one, select it and update the answer."
      },
      "id": 611,
      "input_format": "The first line of each test case contains a single integer N - the number of assignments.\nN lines follow each containing a pair of integers s and t - the start and end time of each assignment.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "You can finish the assignments 1, 2, 4 and 5.",
      "output_format": "Print the maximum number of assignments that you can finish.",
      "samples": [
        {
          "input": "6\n1 2\n3 4\n0 6\n5 7\n8 9\n5 9",
          "output": "4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Finish in Time",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given $3$ strings $s1$, $s2$ and $s3$, the task is to find the length of the longest common sub-sequence in all three given strings.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$\n$1 \\leq |s1| \\leq 100$\n$1 \\leq |s2| \\leq 100$\n$1 \\leq |s3| \\leq 100$",
      "editorial_code": [
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\n\nint dp[101][101][101];\nstring s1, s2, s3;\nint rec(int i, int j, int k) {\n    if (i == s1.size() || j == s2.size() || k == s3.size())return 0;\n    auto &ans = dp[i][j][k];\n    if (ans != -1)return ans;\n    ans = max({rec(i + 1, j, k), rec(i, j + 1, k), rec(i, j, k + 1)});\n    if (s1[i] == s2[j] && s3[k] == s2[j])ans = max(ans, 1 + rec(i + 1, j + 1, k + 1));\n    return ans;\n}\nvoid solve() {\n    cin >> s1 >> s2 >> s3;\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0, 0, 0) << endl;\n}\n\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```\n\n",
          "language": "C++14"
        },
        {
          "code": "\n```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\n\nint dp[101][101][101], n1, n2, n3;\nstring s1, s2, s3;\nvoid solve() {\n    cin >> s1 >> s2 >> s3;\n    memset(dp, 0, sizeof(dp));\n    n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\n    for (int i = 1; i <= n1; i++) {\n        for (int j = 1; j <= n2; j++) {\n            for (int k = 1; k <= n3; k++) {\n                auto &ans = dp[i][j][k];\n                if (s1[i - 1] == s2[j - 1] && s2[j - 1] == s3[k - 1])ans = max(ans, 1 + dp[i - 1][j - 1][k - 1]);\n                ans = max({ans, dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1]});\n            }\n        }\n    }\n    cout << dp[n1][n2][n3] << endl;\n}\n\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:24:41.797357+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "The idea is to take a 3D array to store the length of common subsequence in all 3 given sequences i. e., $L[m + 1][n + 1][o + 1]$.\n\n1- If any of the string is empty then there is no common subsequence at all then $L[i][j][k] = 0$.\n\n2- If the characters of all sequences match (or $X[i] == Y[j] ==Z[k]$) then $L[i][j][k] = 1 + L[i-1][j-1][k-1]$.\n\n3- If the characters of both sequences do not match (or $X[i] != Y[j] || X[i] != Z[k] || Y[j] !=Z[k]$) then $L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])$\n\n**Time Complexity** - $O(|s1|*|s2|*|s3|)$.\n**Space Complexity** - $O(|s1|*|s2|*|s3|)$."
      },
      "id": 911,
      "input_format": "First-line contains $T$ - the number of test cases.\nEach test case contains $3$ strings in a single line.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the length of the longest common subsequence in all the $3$ given strings, in a new line.",
      "samples": [
        {
          "input": "3\nabc abc bbc\nalgozenith algo algorithm\nalgo zenith zen\n",
          "output": "2\n4\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "LCS of 3 Strings",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given the head of the singly connected linked list, your task is to reorder it as follows.</p><p>Original list:</p><pre><code class=\"language-plaintext\">L1 -&gt; L2 -&gt; L3 -&gt; ...... -&gt; Ln-2 -&gt; Ln-1 -&gt; Ln</code></pre><p>Reorder list:</p><pre><code class=\"language-plaintext\">L1 -&gt; L3 -&gt; L5 -&gt; ..... -&gt; L6 -&gt; L4 -&gt; L2</code></pre><p>Complete the function</p><pre><code class=\"language-plaintext\">void reorderList(ListNode* head)</code></pre><p><i>head </i>is the pointer to the beginning of the linked list.</p><p>You may not modify the values in the list's nodes. Only nodes themselves may be changed.</p>",
      "complete_approach": "",
      "constraints": "<p>0 ≤ Length of the linked list ≤ 10<sup>6</sup><br>0 ≤ Value stored in the node ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\npair<ListNode*,ListNode*> recurseReorderList(ListNode* head) {\n    if(!head) return {head, head};\n    if(head->next == NULL) return {head, head};\n\n    ListNode* F = head;\n    ListNode* L = head->next;\n\n    pair<ListNode*,ListNode*> temp = recurseReorderList(head->next->next);\n\n    ListNode* F1 = temp.first;\n    ListNode* L1 = temp.second;\n\n    if(!F1) {\n        L->next = NULL;\n        return {F, L};\n    }\n\n    F->next = F1;\n    L1->next = L;\n    L->next = NULL;\n\n    return {F, L};\n}\n\nvoid reorderList(ListNode* head) {\n    recurseReorderList(head);    \n}\n\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    ListNode* head = GetList(num);\n\n    reorderList(head);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:42:34.221663+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 538,
      "input_format": "",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "1\n3",
          "output": "3"
        },
        {
          "input": "5\n1 2 3 4 5",
          "output": "1 3 5 4 2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\nvoid reorderList(ListNode* head) {\n    //Complete the function    \n}\n\n<fix>\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    ListNode* head = GetList(num);\n\n    reorderList(head);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Reorder List II",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given Q queries and have to perform the following operations:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">add x y - add student name X (string in lowercase alphabets) with marks y (integer). If it already exists, update.</span></li><li><span style=\"background-color:transparent;color:#000000;\">erase x - erase marks of student with name x, if the entry exists</span></li><li><span style=\"background-color:transparent;color:#000000;\">print x - print marks of student with name x, if entry is not there for x, print 0.</span></li></ol>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ Q ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ |S| ≤ 50</span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ Y ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of Q over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>5</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int q;\n    cin >> q;\n    map<string, int> m;\n    while (q--) {\n      string s;\n      cin >> s;\n      if (s == \"add\") {\n        string x;\n        int y;\n        cin >> x >> y;\n        m[x] = y;\n      } else if (s == \"erase\") {\n        string x;\n        cin >> x;\n        if (m.find(x) != m.end()) {\n          m.erase(x);\n        }\n      } else {\n        string x;\n        cin >> x;\n        if (m.count(x)) {\n          cout << m[x] << \"\\n\";\n        } else {\n          cout << \"0\\n\";\n        }\n      }\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:29:03.325952+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Add entry x, y using m[x]=y or using insert({x,y}).\nUse `erase(x)` for deleting entry of student with name x but first check using `find(x)` if the element x is in the map or not\nUse `count(x)` for checking if entry with name x exists\nPrint by accessing the entry using m[x]\nTime Complexity per test case: $O(Q \\times\\ log N)$ where $N$ is the size of the map."
      },
      "id": 359,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer Q - the number of queries.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Each of the next Q ines contains queries.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<ol><li><span style=\"background-color:transparent;color:#000000;\">Map becomes: [alice: 24]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Map becomes: [alice: 24, bob: 21]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Value of key alice is 24</span></li><li><span style=\"background-color:transparent;color:#000000;\">Map becomes: [bob: 21]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Key alice does not exist</span></li></ol>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the required queries.</span></p>",
      "samples": [
        {
          "input": "1\n5\nadd alice 24\nadd bob 21\nprint alice\nerase alice\nprint alice\n",
          "output": "24\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Map AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Find the number of ways to Tile NxM rectangle with dominoes. A domino is 2 * <i>1 or 1 </i>* 2 rectangle.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint dp[13][(1<<12)];\nint n, m;\n\nvoid dfs(int x, int y, int vis, int nvis) {\n    if(x == n) {\n        return ;\n    }\n    if(y >= m) {\n        dp[x+1][nvis] += dp[x][vis];\n        return ;\n    }\n    int mask = 1<<y;\n    if(vis & mask) {\n        dfs(x, y+1, vis, nvis);\n    }\n    else {\n        dfs(x, y+1, vis, nvis | mask);\n        if(y + 1 < m && !(vis & mask) && !(vis & (mask << 1))) {\n            dfs(x, y+2, vis, nvis);\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        cin >> n >> m;\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = 1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < (1<<m); ++j) {\n                dfs(i, 0, j, 0);\n            }\n        }\n        cout << dp[n][0] << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:51.449054+00:00"
      },
      "hints": {
        "hint1": "If the number of columns and number of rows is odd, the answer would be 0 since each domino occupies an area of 2. You can consider each column as a binary number which gives the information whether the i-th bit in that column is filled with a domino or not.",
        "hint2": "We make the DP array as DP[pos][vis] (1-based indexing for pos) which denotes the number of ways to fill the grid where pos is the current row and vis denotes the blocks filled in the current row. All the blocks before the pos row must be completely filled. One way to make the transition would be to find DP[pos][vis] from DP[pos-1][n_vis] by using the different possible values of n_vis for which there exists a filling of pos-th row with the same set of filled blocks. But you will get TLE in this since the time complexity will be O(N * 2^(2*M))",
        "solution_approach": "<p>Instead of finding all the different possible masks of the previous rows, we can find the different possible masks for the current row to get the answer. This means that we need to find the number of ways to fill the current row with blocks filled as vis. We can make the following cases:</p><p>1. If the current block is already filled, we go on to the next block.</p><p>2. If the current block is not filled, we can place the block as either 1*2 or 2*1 form and go on to the next block after updating the blocks visited for the current row and the next row (for 1*2 domino)</span></p><p>Whenever we fill the current row completely, a new set of blocks are marked in the next row because of the 1*2 dominos, so we need to add that to the answer for the next row. For i = 0, filling 0 cells is possible so the base case is DP[0][0] = 1. We need to fill all the n rows such that the columns visited for the next row is 0 and all rows before n are completely filled, so the final answer would be DP[n][0].</p><p>Time Complexity per test case: O(N^2 * M * 2^M)</p>"
      },
      "id": 455,
      "input_format": "<p>The first line contains an integer T (1 ≤ T ≤ 100) - the number of testcases.</p><p>The first line of each test case contains two space-separated integers N, M. 1 ≤ N, M ≤ 12.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "7\n10 3\n10 5\n2 3\n10 1\n2 4\n5 4\n9 11",
          "output": "571\n185921\n3\n1\n5\n95\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Tiling",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(85,85,85);\">For a given </span><strong>n</strong><span style=\"background-color:rgb(255,255,255);color:rgb(85,85,85);\">, find the number of even and odd numbers among the set, </span><strong>{ <sup>n</sup>C<sub>0</sub>, <sup>n</sup>C<sub>1</sub>,... <sup>n</sup>C<sub>n </sub>}.</strong></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nsigned main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\n\tint T; cin >> T;\n\twhile(T--) {\n\t\tll n; cin >> n;\n\t\tll ans = 1;\n\t\tfor(ll i = 0; i < 64; i++) {\n\t\t\tif((n >> i) & 1) {\n\t\t\t\tans *= 2;\n\t\t\t}\n\t\t}\n\t\tcout << n + 1 - ans << \" \" << ans << \"\\n\";\n\t}\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:34:36.234860+00:00"
      },
      "hints": {
        "hint1": "<p>Have you heard of Lucas Theorem (<a href=\"https://en.wikipedia.org/wiki/Lucas%27s_theorem\">https://en.wikipedia.org/wiki/Lucas%27s_theorem</a>)?</p>",
        "hint2": "<p>Can you find the generalize results for p = 2 in Lucas Theorem?</p>",
        "solution_approach": "<p>Using Lucas Theorem (<a href=\"https://en.wikipedia.org/wiki/Lucas%27s_theorem\">https://en.wikipedia.org/wiki/Lucas%27s_theorem</a>) we can find that <i><strong>iff x &amp; y = y, then xCy will be odd. Otherwise even.</strong></i><strong> </strong>That's it! Find the number of integers in the submask in <strong>n.</strong><br>See the solution code for more implementation.</p>"
      },
      "id": 204,
      "input_format": "<p>First-line<span style=\"background-color:rgb(255,255,255);color:rgb(85,85,85);\"> contains <strong>T</strong></span><strong> (1 ≤ T ≤ 10<sup>5</sup>), </strong><span style=\"background-color:rgb(255,255,255);color:rgb(85,85,85);\">the number of test cases. Next T lines contain one integer per line, denoting </span><strong>n (0 ≤ n ≤ 10<sup>12</sup>)</strong><span style=\"background-color:rgb(255,255,255);color:rgb(85,85,85);\">.&nbsp;</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For 3, values are: <strong>1 3 3 1</strong>. All are odd. Hence <strong>0 4.</strong><br>For 4, values are: <strong>1 4 6 4 1</strong>. Hence <strong>3 2.</strong></p>",
      "output_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(85,85,85);\">For each test case, output two </span>space-separated<span style=\"background-color:rgb(255,255,255);color:rgb(85,85,85);\"> integers specifying the number of even numbers and odd numbers respectively.</span></p>",
      "samples": [
        {
          "input": "2\n3\n4",
          "output": "0 4\n3 2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Learn This Thing",
      "video_editorial_id": 8169
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers and <i>Q</i> queries. In each query, you are given two parameters <i>L</i> and <i>R</i>; you have to find the following:</p><p>1. Smallest integer <i>X<sub>1</sub></i> such that the value of <i>(A<sub>L</sub> XOR X<sub>1</sub>) + (A<sub>L+1</sub> XOR X<sub>1</sub>) + ... + (A<sub>R</sub> XOR X<sub>1</sub>)</i> is maximum possible.</p><p>2. Smallest integer <i>X<sub>2</sub></i> such that the value of <i>(A<sub>L</sub> OR X<sub>2</sub>) + (A<sub>L+1</sub> OR X<sub>2</sub>) + ... + (A<sub>R</sub> OR X<sub>2</sub>)</i> is maximum possible.</p><p>3. Smallest integer <i>X<sub>3</sub></i> such that the value of <i>(A<sub>L</sub> AND X<sub>3</sub>) + (A<sub>L+1</sub> AND X<sub>3</sub>) + ... + (A<sub>R</sub> AND X<sub>3</sub>)</i> is maximum possible.</p><p>Range of <i>X<sub>1</sub>, X<sub>2</sub>, X<sub>3</sub></i> allowed → <i>0 &lt;= X<sub>1</sub>, X<sub>2</sub>, X<sub>3</sub> &lt; 2^31.</i></p><p>Print the sum of X1, X2, X3 for each query in a newline.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint prefSum[1000001][31];\nint main()\n{\n   ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n   int testcases;\n   cin>>testcases;\n   while(testcases--)\n   {\n       int n,q;\n       int i;\n       cin>>n;\n       for(i=0;i<=n;i++)\n         for(int j = 0;j<31;j++)\n           prefSum[i][j]=0;\n       for(i=1;i<=n;i++)\n       {\n         int a;\n         cin>>a;\n         int cnt = 0;\n         while(a>0)\n         {\n           prefSum[i][cnt]=a%2;\n           a/=2;\n           cnt++;\n         }\n       }\n       for(i=1;i<=n;i++)\n       {\n         for(int j=0;j<31;j++)\n           prefSum[i][j]+=prefSum[i-1][j];\n       }\n       cin>>q;\n       while(q--)\n       {\n         int l,r;\n         cin>>l>>r;\n         double total=(r-l+1.0)/(2);\n         long long x1 = 0,x2 = 0,x3 = 0;\n         for(i=0;i<31;i++)\n         {\n           int p = prefSum[r][i]-prefSum[l-1][i];\n           if(p<total)\n             x1+=(1LL<<i);\n           if(p!=(r-l+1))\n             x2+=(1LL<<i);\n           if(p)\n             x3+=(1LL<<i);\n         }\n         long long ans = x1+x2+x3;\n         cout<<ans<<\"\\n\";\n       }\n   }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:38:53.744939+00:00"
      },
      "hints": {
        "hint1": "Always remember that **BIT EXPRESSIONS ARE SUM INDEPENDENT ON EACH BIT.**\n\nIf $i^{th}$ bit is set in $X_1$,  then $i^{th}$ bit will be set in $A_i$ XOR $X_1$, if $i^{th}$ bit is not set in $A_i$ and,  \n  $i^{th}$ bit will not be set in $A_i$ XOR $X_1$, if $i^{th}$ bit is set in $A_i$.   \n  So if the $i^{th}$ bit is set in less than $\\dfrac{(R-L+1)}{2}$ numbers then $i^{th}$ bit should be set in $X_1$ otherwise not. So try to think when $i^{th}$ bit will be set in the $X_1$.",
        "hint2": "If $i^{th}$ bit is set in 'cntSet' numbers and not set in 'cntNotSet' numbers in the range [L,R], then -\n\n1. $i^{th}$ bit is set in $X_1$ then contribution of $i^{th}$ bit = cntNotSet*(1LL<< i).\n\n2. $i^{th}$ bit is not set in $X_1$ then contribution of $i^{th}$ bit = cntSet*(1LL<< i).\n\nSo according to the value of cntSet and cntNotSet, $i^{th}$ bit is decided. If cntSet = cntNotSet, then $i^{th}$ bit should not be set as the minimum value of $X_1$ is required.\n\nValue of cntSet and cntNotSet can be found for every query in O(1) using prefix sum.",
        "solution_approach": "$X_2$ - If the $i^{th}$ bit is set in all the numbers in the range [L, R], then it must not be set in the X2. Otherwise, it must be set.\n\n$X_3$ - If the $i^{th}$ bit is not set in all the numbers in the range[L, R], then it must not be set in the X3. Otherwise, it must be set."
      },
      "id": 50,
      "input_format": "<p>The first line of the input contains a single integer <i>T</i> denoting the number of test cases, <i>(1&lt;=T&lt;=100)</i>.</p><p>The first line of each test case contains a single integer <i>N</i>, <i>(2&lt;=N&lt;=100000)</i>.</p><p>The second line contains <i>N</i> space-separated integers A<sub>1</sub>,A<sub>2</sub>,…,A<sub>N</sub>, <i>(1&lt;=A<sub>i</sub>&lt;=10^9)</i>.</p><p>The third line contains an integer <i>Q</i>, <i>(1&lt;=Q&lt;=10^5)</i>.</p><p>The next <i>Q</i> lines contain two space-separated integers <i>L</i>, <i>R</i> <i>(1&lt;=L&lt;=R&lt;=N)</i>.</p><p>Sum of <i>Q</i> over all test cases does not exceed <i>10^6</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each query print the value of X<sub>1 &nbsp;</sub>+ X<sub>2 </sub>+ X<sub>3</sub> &nbsp;in a new line.</p><p>&nbsp;</p>",
      "samples": [
        {
          "input": "5\n5\n1 2 3 4 5\n5\n1 5\n2 5\n3 4\n2 4\n3 3\n3\n1 2 2\n3\n1 2\n2 3\n1 3\n4\n1 2 2 4\n5\n1 2\n2 3\n3 4\n2 4\n3 4\n10\n123 234565 3456765 3456 09888 433534 908767 125698 545676 23456\n10\n1 4\n1 6\n1 9\n1 10\n3 7\n3 9\n4 7\n6 9\n4 9\n7 9\n10\n23456 3456 987 8765 3456 34565 9876 654555 234566 87654344\n10\n1 8\n1 6\n1 9\n1 10\n2 7\n2 9\n4 7\n8 9\n9 9\n7 9",
          "output": "4294967300\n4294967294\n4294967294\n4294967299\n4294967291\n4294967294\n4294967292\n4294967295\n4294967294\n4294967292\n4294967294\n4294967298\n4294967294\n4298580736\n4298580736\n4299121201\n4299120657\n4298857985\n4299120753\n4295712255\n4295106335\n4295958639\n4295222095\n4295618668\n4295028860\n4295751805\n4382781565\n4295010408\n4295751784\n4295002150\n4294863804\n4294732728\n4295640583\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "XOR AND OR Query",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Find the K-th smallest element in an unordered list.</p><p>Complete the function</p><p><i>int quickSelect(vector&lt;int&gt; num, int K)</i></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>K</i> ≤ <i>N</i> ≤ 10<sup>6</sup><br>0 ≤ <i>A<sub>i</sub></i> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint quickselect(vector<int> A, int k) \n{\n    sort(A.begin(), A.end());\n    return A[k - 1];\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> A;\n    \n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        A.push_back(x);\n    }\n\n    cout << quickselect(A, k) << \"\\n\";\n\n    return 0;\n}\n```\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint partition(vector<int> &A, int l, int r)\n{\n    int x = A[r], i = l;\n    for (int j = l; j <= r - 1; j++) {\n        if (A[j] <= x) {\n            swap(A[i], A[j]);\n            i++;\n        }\n    }\n    swap(A[i], A[r]);\n    return i;\n}\n \nint kthSmallest(vector<int> &A, int l, int r, int k)\n{\n    if (k > 0 && k <= r - l + 1) {\n        int index = partition(A, l, r);\n\n        if (index - l == k - 1)\n            return A[index];\n \n        if (index - l > k - 1)\n            return kthSmallest(A, l, index - 1, k);\n \n        return kthSmallest(A, index + 1, r, k - index + l - 1);\n    }\n \n    return -1;\n}\n\nint quickselect(vector<int> A, int k) \n{\n    return kthSmallest(A, 0, (int)A.size() - 1, k);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> A;\n    \n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        A.push_back(x);\n    }\n\n    cout << quickselect(A, k) << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:15:10.169202+00:00"
      },
      "hints": {
        "hint1": "<p>Sort the elements.</p>",
        "hint2": "<p>Can we do it in O(N)? We can use the approach used in QuickSort. The same algorithm, but implemented in a different way, can give us the average runtime of O(N).</p>",
        "solution_approach": "\n**Solution 1 (Sorting)**\n\nSort the array in O(NlogN), and print the Kth smallest element.\n\n**Solution 2 (Quickselect)**\n\nQuickselect algorithm is similar to quicksort. The difference is, instead of recurring for both sides (after finding pivot), it recurs only for the part that contains the Kth smallest element. \n\nPartition in quick select picks a pivot (either randomly or first/last element). Then it rearranges the list in a way that all elements less than the pivot are on the left side of the pivot and others on right. It then returns the index of the pivot element.\n\nNow here we are finding Kth smallest element. After partition cases are:\n\nK == pivot. Then you have already found Kth smallest. This is because of the way the partition is working. There are exactly K - 1 elements that are smaller than the Kth element.\nK < pivot. Then Kth smallest is on the left side of the pivot.\nK > pivot. Then Kth smallest is on the right side of the pivot. And to find it you actually have to find K - pivot smallest number on right.\nThis reduces the expected complexity from O(NlogN) to O(N), with a worst-case of O(N2).\n\nTo get understanding the average complexity of quickselect, please go through this link: **https://stackoverflow.com/questions/5945193/average-runtime-of-quickselect/25796762**"
      },
      "id": 541,
      "input_format": "<p>The first line of input contains <i>N </i>and<i> K.</i><br>The second line contains <i>N</i> space-separated integers - <i>A<sub>0</sub>, A<sub>1</sub>, …, A<sub>N</sub></i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the <i>K</i>th smallest element.</p>",
      "samples": [
        {
          "input": "1 1\n5",
          "output": "5"
        },
        {
          "input": "5 3\n1 8 7 6 9",
          "output": "7"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n</fix>\n\nint quickselect(vector<int> A, int k) \n{\n    // Complete the function\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> A;\n    \n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        A.push_back(x);\n    }\n\n    cout << quickselect(A, k) << \"\\n\";\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Quickselect",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>A number is said to be a palindrome if it remains the same when it is read backward. A number is called special-palindromic if it contains a palindrome with an odd length greater than 1 and an even palindrome of length greater than 1 as a substring.</p><p>For example, the number 8857775 is special-palindromic because it contains the palindrome of odd length 57775 and even length 88. The number 111 is a special-palindrome as it contains the palindrome of odd length 111 and even length 11.<br>You are given two numbers l, r. Find the number of special-palindromic numbers in the range [l,r].</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤ 100</p><p>100 ≤ l ≤ r ≤ 10<sup>18</sup></p>",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:45.392075+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 307,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\n\nThe first line of each test case contains two space-separated integers $l$, $r$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case output the number of special-palindrome in the range [l,r] in a new line.</p>",
      "samples": [
        {
          "input": "5\n318661263196762255 862815711794150362\n81911993087269085 451708830417250256\n533442590027279954 541470499312103755\n53352857120044807 479628472267433970\n763787750602078367 838624921227800849",
          "output": "365535445019098517\n249116249428192823\n5271193801698071\n285832399729012956\n50869536601549418"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Palindromic Number",
      "video_editorial_id": 10696
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "There are $88418$ paths in a $7 \\times 7$ grid from the upper-left square to the lower-left square. Each path corresponds to a $48$-character description consisting of characters **D** (down), **U** (up), **L** (left), and **R** (right).\n\nFor example, the path:\n\n![Grid Path Example](https://lh5.googleusercontent.com/W5SQNDF90l8RCGOD1OKdoK8uHRDbgc_SeGwwVW8iWo3fPQnmj0X4UxekYO1bs4EAWRv99Mg_srUpGbOFf_Malf7BBuWMs3eQ0AEu26f9mzIVhj7EqbNjJMcGgU1lLZBSM329Nwf8)\n\ncorresponds to the description:\n\nDRURRRRRDDDLUULDDDLDRRURDDLLLLLURULURRUULDLLDDDD.\n\nYou are given a description of a path which may also contain characters **?** (any direction). Your task is to calculate the number of paths that match the description.",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n#define lli long long int\n#define li long int\n#define ld long double\nusing namespace std;\nconst lli mod = 1e9 + 7;\nconst int n = 7;\nbool visited[n][n];\nint reserved[49];\n\nvoid move(int r, int c, int &ans, int &steps)\n{\n    if (r == n - 1 && c == 0)\n    {\n        ans += (steps == n * n - 1);\n        return;\n    }\n\n    // if you hit a wall or a path (can only go left or right); return\n    if (((r + 1 == n || (visited[r - 1][c] && visited[r + 1][c])) && c - 1 >= 0 && c + 1 < n && !visited[r][c - 1] && !visited[r][c + 1]) ||\n        ((c + 1 == n || (visited[r][c - 1] && visited[r][c + 1])) && r - 1 >= 0 && r + 1 < n && !visited[r - 1][c] && !visited[r + 1][c]) ||\n        ((r == 0 || (visited[r + 1][c] && visited[r - 1][c])) && c - 1 >= 0 && c + 1 < n && !visited[r][c - 1] && !visited[r][c + 1]) ||\n        ((c == 0 || (visited[r][c + 1] && visited[r][c - 1])) && r - 1 >= 0 && r + 1 < n && !visited[r - 1][c] && !visited[r + 1][c]))\n        return;\n\n    visited[r][c] = true;\n\n    if (reserved[steps] != -1)\n    {\n        switch (reserved[steps])\n        {\n        case 0:\n            if (r - 1 >= 0)\n            {\n                if (!visited[r - 1][c])\n                {\n                    steps++;\n                    move(r - 1, c, ans, steps);\n                    steps--;\n                }\n            }\n            break;\n\n        case 1:\n            if (c + 1 < n)\n            {\n                if (!visited[r][c + 1])\n                {\n                    steps++;\n                    move(r, c + 1, ans, steps);\n                    steps--;\n                }\n            }\n            break;\n\n        case 2:\n            if (r + 1 < n)\n            {\n                if (!visited[r + 1][c])\n                {\n                    steps++;\n                    move(r + 1, c, ans, steps);\n                    steps--;\n                }\n            }\n            break;\n\n        case 3:\n            if (c - 1 >= 0)\n            {\n                if (!visited[r][c - 1])\n                {\n                    steps++;\n                    move(r, c - 1, ans, steps);\n                    steps--;\n                }\n            }\n            break;\n        }\n        visited[r][c] = false;\n        return;\n    }\n\n    // move down\n    if (r + 1 < n)\n    {\n        if (!visited[r + 1][c])\n        {\n            steps++;\n            move(r + 1, c, ans, steps);\n            steps--;\n        }\n    }\n\n    // move right\n    if (c + 1 < n)\n    {\n        if (!visited[r][c + 1])\n        {\n            steps++;\n            move(r, c + 1, ans, steps);\n            steps--;\n        }\n    }\n\n    // move up\n    if (r - 1 >= 0)\n    {\n        if (!visited[r - 1][c])\n        {\n            steps++;\n            move(r - 1, c, ans, steps);\n            steps--;\n        }\n    }\n\n    // move left\n    if (c - 1 >= 0)\n    {\n        if (!visited[r][c - 1])\n        {\n            steps++;\n            move(r, c - 1, ans, steps);\n            steps--;\n        }\n    }\n    visited[r][c] = false;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    string path;\n    cin >> path;\n    for (int i = 0; i < path.length(); i++)\n    {\n        if (path[i] == '?')\n            reserved[i] = -1;\n        else if (path[i] == 'U')\n            reserved[i] = 0;\n        else if (path[i] == 'R')\n            reserved[i] = 1;\n        else if (path[i] == 'D')\n            reserved[i] = 2;\n        else if (path[i] == 'L')\n            reserved[i] = 3;\n    }\n    int ans = 0, steps = 0;\n    move(0, 0, ans, steps);\n    cout << ans;\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:47:50.835051+00:00"
      },
      "hints": {
        "hint1": "<p>Generate all paths and try to check which one is matching with the given string.&nbsp;</p>",
        "hint2": "<p>Complete brute force will not pass the test cases. You have to prune your algorithm. There are several ways to do that. But you've to avoid travelling through the path, which we can guarantee that will never lead us to the correct path.</p>",
        "solution_approach": "<p>Do complete space search of the grid. But this would be slow. You have to optimize your code.</p><p>Some of the optimizations that you can do.</p><ol><li>In any solution, we first move one step down or right. There are always two paths that are symmetric about the diagonal of the grid after the first step.</li><li>If the path reaches the lower-right square before it has visited all other squares of the grid, it is clear that it will not be possible to complete the solution.</li><li>If the path touches a wall and can turn either left or right, the grid splits into two parts that contain unvisited squares.</li><li>The idea of Optimization 3 can be generalized: if the path cannot continue forward but can turn either left or right, the grid splits into two parts that both contain unvisited squares.</li></ol><p><i>Note: The editorial solution uses different optimization tricks. You can look into it.</i></p>"
      },
      "id": 276,
      "input_format": "The only input line contains a 48-character string of characters **?**, **D**, **U**, **L**, and **R**.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "Print one integer: the total number of paths.",
      "samples": [
        {
          "input": "??????R??????U??????????????????????????LD????D?",
          "output": "201"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Count Valid Grid Paths",
      "video_editorial_id": 8180
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Your task is to place eight queens on a chessboard so that no two queens are attacking each other. As an additional challenge, each square is either free or reserved, and you can only place queens on the free squares. However, the reserved squares do not prevent queens from attacking each other.\n\nHow many possible ways are there to place the queens?",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n#define lli long long int\n#define li long int\n#define ld long double\nusing namespace std;\nconst lli mod = 1e9 + 7;\nint ans = 0;\nbool takencols[8], takendiag1[16], takendiag2[16];\n\nvoid place(string board[8], int r, int &ans)\n{\n    if (r == 8)\n    {\n        ans++;\n        return;\n    }\n    for (int c = 0; c < 8; c++)\n    {\n        if (board[r][c] == '.')\n        {\n            if (!takencols[c] && !takendiag1[r - c + 8 - 1] && !takendiag2[r + c])\n            {\n                takencols[c] = takendiag1[r - c + 8 - 1] = takendiag2[r + c] = true;\n                place(board, r + 1, ans);\n                takencols[c] = takendiag1[r - c + 8 - 1] = takendiag2[r + c] = false;\n            }\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    string s;\n    string board[8];\n    int ans = 0;\n    for (int i = 0; i < 8; i++)\n    {\n        cin >> board[i];\n    }\n    place(board, 0, ans);\n    cout << ans;\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:46:26.886421+00:00"
      },
      "hints": {
        "hint1": "This is a classic problem of placing eight queens on a chessboard so that no two queens are attacking each other. In this variation, some squares are reserved, and queens can only be placed on the free squares.",
        "hint2": "We can use backtracking to solve this problem. We can try placing a queen in each row and backtrack if we find that it conflicts with any of the previously placed queens. We can keep track of the columns, diagonal 1, and diagonal 2 that are already occupied by previously placed queens. We can use these arrays to check if a new queen conflicts with any of the previous queens.",
        "solution_approach": "### Level\nWe can keep track of the board at each step by using an array of strings which represents each cell of the board. Also we can pass rows in which we wish to place a queen as one of our recursive parameter. Here the row number acts as a level. When we reach row $8$ it means we have successfully placed $8$ queens from row $0$ to row $7$ and hence we increment our answer by $1$\n### Check\nAfter placing a queen at any cell (r,c) check if the diagonal passing from the top left to the right bottom does not contain any previous queen. Same thing for the diagonal passing from the top right to the bottom left corner. Also keep a check which cell is reserved and a queen cannot be placed at that cell.\n### Choice\nAt each recursive step, iterate over columns 0 to 7 to decide which cell (r,c) to pick to place a queen.\n### Transition\nAfter placing a queen move to the next row, and now repeat."
      },
      "id": 272,
      "input_format": "The input has eight lines, and each of them has eight characters. Each square is either free (.) or reserved (*).",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "Print one integer: the number of ways you can place the queens.",
      "samples": [
        {
          "input": "........\n........\n..*.....\n........\n........\n.....**.\n...*....\n........",
          "output": "65"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Queens On Chessboard",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are a total of <strong>n </strong>courses that you can take. The courses are labeled from 0 to n-1.<br>You are also given a <strong>prerequisites</strong> array where prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>] indicates that you <strong>must</strong> take course a<sub>i </sub>first if you want to take course b<sub>i</sub>.</p><p>For example, the pair [1, 2] indicates that in order to take course 2 you have to first take course 1.</p><p>You have to determine if you can finish all the courses following <strong>all </strong>the prerequisites given.</p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 100000\n0 &lt;= m &lt;= min(100000, n(n-1)/2)\n0 &lt;= ai,bi &lt; n\nEach pair (a, b) is distinct.</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector <int> top;\nvector <vector <int>> adj(100005);\nvector <int> vis(100005);\n\nvoid dfs(int u) {\n\tfor (auto i : adj[u]) {\n\t\tif (!vis[i]) {\n\t\t\tvis[i] = 1;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\ttop.push_back(u);\n}\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint n, m;\n\tcin >> n >> m;\n\tvector <pair<int, int>> edges;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tedges.push_back({u, v});\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!vis[i]) {\n\t\t\tvis[i] = 1;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\treverse(top.begin(), top.end());\n\tvector <int> pos(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tpos[top[i]] = i;\n\t}\n\tint f = 0;\n\tfor (auto i : edges) {\n\t\tif (pos[i.second] <= pos[i.first]) {\n\t\t\tf = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (f)\n\t\tcout << \"No\";\n\telse\n\t\tcout << \"Yes\";\n\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:43:37.345285+00:00"
      },
      "hints": {
        "hint1": "We visualize a graph with the courses as the nodes and the prerequisites as directed edges from a to b.",
        "hint2": "We need to find if an ordering of the nodes (courses) exists such that for each directed edge from a to b, a occurs before b.",
        "solution_approach": "We need to check if a Topological Sorting of the graph exists or not. We can do all the courses following all the prerequisites if and only if there is no cycle in the directed graph.\nIf there is a cycle, there will always be a conflict.\nWe can check if the graph is acyclic by finding the topological sort of the graph.\nAfter finding the ordering, for each edge (a→b) we check if the position a in the ordering is before b. If we find any edge for which this condition is violated, the graph has a cycle and we cannot finish all the courses.\nBeware that the graph can have self-loops (a→a)."
      },
      "id": 637,
      "input_format": "<p>The first line contains two space-separated integers <strong>n</strong> and <strong>m</strong> - the total number of courses and the number of prerequisites.<br>Then m lines follow. The i-th line contains a pair of integers denoting the i-th prerequisite.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "1. We can take the courses in the following order : 0 1 2.\nAll prerequisites are followed.\n2. Course 0 needs course 1 as a prerequisite whereas course 1 needs course 0 as a prerequisite which is not possible.",
      "output_format": "<p>Print ‘<strong>Yes</strong>’ if you can finish all the courses and ‘<strong>No</strong>’ otherwise.</p>",
      "samples": [
        {
          "input": "3 3\n0 1\n1 2\n0 2",
          "output": "Yes"
        },
        {
          "input": "2 2\n0 1\n1 0",
          "output": "No"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Course Scheduling",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an integer array **nums** with **n** integers in it. You have to move all the zeros present in the array to the end of the array while maintaining the relative order of the rest of the elements. \nSolve this problem using constant extra space.\nTry to solve the problem using minimum number of swap operations.",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 100000\n-100000 &lt;= nums[i] &lt;= 100000</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid MovingZeros(vector <int>& nums) {\n\tint n = nums.size();\n\tint lastnonzero = 0;\n\tint cur = 0;\n\twhile (cur < n) {\n\t\tif (nums[cur] != 0) {\n\t\t\tswap(nums[lastnonzero++], nums[cur]);\n\t\t}\n\t\tcur++;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint n;\n\tcin >> n;\n\tvector <int> nums(n);\n\tfor (auto &i : nums)\n\t\tcin >> i;\n\tMovingZeros(nums);\n\tfor (auto i : nums)\n\t\tcout << i << \" \";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:15:39.002460+00:00"
      },
      "hints": {
        "hint1": "<p>If the current element is non-0, its' correct position can at best be its current position or a position earlier.</p>",
        "hint2": "The i-th non zero element of the array will be at the i-th index in the resultant array.",
        "solution_approach": "We use a two-pointer approach to solve this problem. \nThe first pointer is the slow pointer (lastnonzero) which represents the number of non-zero elements found.\nThe second pointer (cur) represents the current number.\nThe i-th non zero element of the array will be at the i-th index in the resultant array.\nIf the current number is non-zero we swap it with the number present at the slow pointer because that is the index where this number should end up.\n\nThe code will maintain the following invariant:\n\n1. All elements before the slow pointer (lastnonzero) are non-zeroes.\n2. All elements between the current and slow pointer are zeroes.\n\nIf the current number is zero, we just move to the next index."
      },
      "id": 597,
      "input_format": "Implement the **MovingZeros** function that takes the array **nums**.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "The relative ordering of the non-zeros elements is maintained and the zeros are moved to the end of the array.",
      "output_format": "The function should make changes in the array itself. No need to return anything.",
      "samples": [
        {
          "input": "6\n0 2 0 0 1 3",
          "output": "2 1 3 0 0 0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nvoid MovingZeros(vector <int>& nums) {\n\n}\n\n<fix>\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint n;\n\tcin >> n;\n\tvector <int> nums(n);\n\tfor (auto &i : nums)\n\t\tcin >> i;\n\tMovingZeros(nums);\n\tfor (auto i : nums)\n\t\tcout << i << \" \";\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Moving Zeros",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are hosting a party and have invited N guests. The guests may or may not know each other. You are expecting a famous celebrity to show up. A celebrity is a person who doesn’t know anyone else but everyone else knows him. Find the celebrity if present.\n\nTry to solve it in O(N) time with constant extra space.",
      "complete_approach": "",
      "constraints": "<p><i>2 ≤ N ≤ 1000</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint FindCeleb(vector<vector<int>> &a)\n{\n    int n = (int)a.size();\n\n    int celeb = 0;\n\n    for (int i = 1; i < n; i++)\n    {\n        if (a[celeb][i])\n            celeb = i;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        if (i == celeb)\n            continue;\n\n        if (a[celeb][i] || !a[i][celeb])\n        {\n            celeb = -1;\n            break;\n        }\n    }\n\n    if (celeb != -1)\n        celeb++;\n\n    return celeb;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<vector<int>> a(n, vector<int>(n));\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            cin >> a[i][j];\n\n    cout << FindCeleb(a) << '\\n';\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:44:50.021662+00:00"
      },
      "hints": {
        "hint1": "Recursion",
        "hint2": "Eliminate n-1 guests who cannot be the celebrity",
        "solution_approach": "\nThis problem can be very easily solved by brute forcing in $O(N^{2})$. But here we present a much more elegant solution. We eliminate $n-1$ guest who cannot be the celebrity using the following strategy:\n\n1. If A knows B then A cannot be the celebrity.\n2. If B knows A then B cannot be the celebrity.\n\nWe can do it using recursion by checking this for the $i^{th}$ person and the assumed celebrity for previous $i-1$ persons. This can also be done iteratively. Finally check if the last remaining guest is a celebrity in linear time.\n\n**Time Complexity -** $O(N)$\n"
      },
      "id": 594,
      "input_format": "The first line of each test case contains $N$ - the number of guests attending the party.\n\nThe next $N$ lines contain $N$ integers. The $j^{th}$ integer of the $i^{th}$ line is 1 if the $i^{th}$ person knows the $j^{th}$ person, otherwise its 0. $(i^{th}$ integer of the $i^{th}$ line is always 0)$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "In the first test case the $2^{\\text{nd}}$ person does not know anyone, but everyone knows him.  \nIn the second test case both of the guests know each other and so there is no guest.",
      "output_format": "Print index of the person who is a celebrity if present, else print -1.",
      "samples": [
        {
          "input": "3\n0 1 0\n0 0 0\n0 1 0",
          "output": "2"
        },
        {
          "input": "2\n0 1\n1 0",
          "output": "-1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint FindCeleb(vector<vector<int>> &a)\n{\n    // Complete the solution\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<vector<int>> a(n, vector<int>(n));\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            cin >> a[i][j];\n\n    cout << FindCeleb(a) << '\\n';\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "CELEB",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string S. Determine whether this string is $\\textbf{Good}$ or $\\textbf{Bad}$.\n\n$\\textbf{Note:}$ The string is $\\textbf{Good}$ if and only if it has $\\textbf{\"010\"}$ or $\\textbf{\"101\"}$ as one of its sub-strings and it's not necessary to have both of them.\n\n$\\textbf{A substring}$ of a string is a contiguous subsequence of that string. So, string \"forces\" is substring of string \"codeforces\", but string \"coder\" is not.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 100 $ </br>\n$ 1 \\leq |S| \\leq 105 $ where |S| is the length of the string.\n$\\textbf{It's guaranteed that S contains only '1s' and '0s'.}$",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string s; cin >> s;\n    if ((s.find(\"010\") != string::npos) || (s.find(\"101\") != string::npos)) {\n        cout << \"Good\" << endl;\n    } else {\n        cout << \"Bad\" << endl;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    int t; cin >> t;\n    while (t--) {\n        solution();\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:42:57.908600+00:00"
      },
      "hints": {
        "hint1": "Learn how KMP algorithm works.",
        "hint2": "Do you know string.find() stl in c++?",
        "solution_approach": "So if \"010\" or \"101\" any string is present in the actual string then our string is good for this we can use .find() stl to find that any of this 2 strings are present or not if present then print Good otherwise print Bad."
      },
      "id": 1189,
      "input_format": "The first line contains a number T number of test cases.\nEach of the T following lines contains a string S.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Output a single line for each testcase representing the answer of the query.",
      "samples": [
        {
          "input": "2\n11111110\n10101010101010\n",
          "output": "Bad\nGood\n"
        },
        {
          "input": "5\n1000000001\n010101\n00000000001\n110110110\n10\n",
          "output": "Bad\nGood\nBad\nGood\nBad\n"
        },
        {
          "input": "1\n0000000001000000000\n",
          "output": "Good\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Good Or Bad",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given a bracket sequence <i>s<sub>1</sub>, s<sub>2</sub>, …, s<sub>n </sub></i>or in other words, a string <i>s</i> of length <i>n</i>, consisting of characters '(' and ')'.&nbsp;<br>You've been asked <i>Q</i> queries. The <i>i</i>th query is of the form <i>l<sub>i</sub></i> and <i>r<sub>i</sub></i>. The answer to the <i>i</i>-th query is the length of the maximum correct bracket <strong>subsequence</strong> of sequence <i>s<sub>li</sub></i>, <i>s<sub>li</sub></i><sub> + 1</sub>, ..., <i>s<sub>ri</sub></i>.<br>Find the correct answer to all queries.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i> ≤ 10<sup>6</sup><br>1 ≤ <i>Q</i> ≤ 10<sup>5</sup><br>1 ≤ <i>l<sub>i</sub></i> ≤ <i>r<sub>i</sub></i> ≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 200010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nstruct ST{\n    int L, O, C;\n    ST(int L = 0 , int O = 0, int C = 0) :\n        L(L), O(O), C(C) {}\n};\n\nST operator + (const ST &A, const ST &B) {\n    int t = min(A.O, B.C);\n    int L = A.L + B.L + 2 * t;\n    int O = A.O + B.O - t;\n    int C = A.C + B.C - t;\n    return ST(L, O, C);\n}\n\nstruct segtree {\n    vector<ST> tree;\n    string s;\n    segtree(string s) : s(s) {\n        int n = (int)s.length();\n        tree.resize(4 * n);\n    }\n\n    void build(int node, int start, int end) {\n        if(start == end) {\n            if(s[start] == '(') tree[node] = ST(0, 1, 0);\n            else tree[node] = ST(0, 0, 1);\n            return;\n        }\n        int mid = (start + end) / 2;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        tree[node] = tree[2 * node] + tree[2 * node + 1];\n    }\n\n    ST query(int node, int start, int end, int l, int r) {\n        if(start > r || end < l) return ST(0, 0, 0);\n        if(start >= l && end <= r) return tree[node];\n        int mid = (start + end) / 2;\n        return query(2 * node, start, mid, l, r) + query(2 * node + 1, mid + 1, end, l, r);\n    }\n};\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    string s;\n    cin >> s;\n\n    segtree T(s);\n\n    int n = (int)s.length();\n\n    T.build(1, 0, n - 1);\n\n    int q; cin >> q;\n    while(q--) {\n        int l, r; cin >> l >> r;\n        l--; r--;\n        cout << T.query(1, 0, n - 1, l, r).L << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:08.233196+00:00"
      },
      "hints": {
        "hint1": "<p>Segment Tree…</p>",
        "hint2": "<p>Lets store at each node three different pieces of information.</p><ol><li>Maximum length correct bracket subsequences that is possible in the range corresponding to the node.</li><li>Number of total open brackets that are not in the maximum length correct bracket subsequences.</li><li>Number of total close brackets that are not in the maximum length correct bracket subsequences.</li></ol><p>Now think of how you can merge two nodes with this information.</p>",
        "solution_approach": "\nWe will support the segments tree. At each vertex will be stored:\n\n1. $L_v$ — the maximum length of the bracket subsequence.\n2. $O_v$ — how many open brackets that sequence doesn't contain.\n3. $C_v$ — how many closed brackets that sequence doesn't contain.\n\nIf we want to combine two vertices with parameters $(L_1, O_1, C_1)$ and $(L_2, O_2, C_2)$, we can use the following rules:\n\n- $t = \\min(O_1, C_2)$\n- $L = L_1 + L_2 + 2 \\times t$\n- $O = O_1 + O_2 - t$\n- $C = C_1 + C_2 - t$\n\n*If we add an update query also, can you do it now?*\n"
      },
      "id": 406,
      "input_format": "<p>The first line contains a sequence of characters <i>s</i><sub>1</sub>, <i>s</i><sub>2</sub>, ..., <i>s<sub>n</sub></i> without any spaces. Each character is either a \"(\" or a \")\".&nbsp;<br>The second line contains integer <i>Q</i> — the number of queries.&nbsp;<br>Each of the next <i>Q</i> lines contains a pair of integers. The <i>i</i>-th line contains integers <i>l<sub>i</sub></i>, <i>r<sub>i</sub></i> — the description of the <i>i</i>-th query.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each query, print the answer on a new line.</p>",
      "samples": [
        {
          "input": "()\n1\n1 2",
          "output": "2"
        },
        {
          "input": "())(())(())(\n7\n1 1\n2 3\n1 2\n1 12\n8 12\n5 11\n2 10",
          "output": "0\n0\n2\n10\n4\n6\n6"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Bracket Queries",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a sorted linked list, delete all duplicates such that each element appears only once.</p><p>Complete the function</p><pre><code class=\"language-plaintext\">ListNode* deleteDuplicates(ListNode* head)</code></pre><p><i>head </i>points to the beginning of the linked list.</p>",
      "complete_approach": "",
      "constraints": "<p>0 ≤ Length of the linked list ≤ 10<sup>6</sup><br>0 ≤ Values stored in nodes ≤ 10<sup>9</sup><br>It's guaranteed that the linked list is sorted.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* deleteDuplicates(ListNode* head) {\n    struct ListNode *cur = head;\n    while(head)\n    {\n        if(head -> next)\n        {\n            if(head -> next -> val == head -> val)\n            {\n                struct ListNode *temp = head -> next;\n                head -> next = head -> next -> next;\n                free(temp);\n                continue;\n            }\n        }\n        head = head -> next;\n    }\n    return cur;\n}\n\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    ListNode* head = GetList(num);\n\n    head = deleteDuplicates(head);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:28:28.104928+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 532,
      "input_format": "",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "3\n1 1 2",
          "output": "1 2"
        },
        {
          "input": "6\n1 1 1 2 3 3",
          "output": "1 2 3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\nListNode* deleteDuplicates(ListNode* head) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    ListNode* head = GetList(num);\n\n    head = deleteDuplicates(head);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Remove Duplicates",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two strings $X$ and $Y$. Print the $\\textbf{smallest lexicographical}$ one.\n\n$\\textbf{Note: Lexicographical}$ is the way of ordering the words based on the alphabetical order of their component letters.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq |X|, |Y| \\leq 20 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    string x, y;\n    cin >> x >> y;\n    int size_x = x.size();\n    int size_y = y.size();\n    int size_min = min(size_x, size_y);\n    int flag = 0;\n    for (int i = 0; i < size_min; i++)\n    {\n        if (y[i] > x[i])\n        {\n            cout << x << endl;\n            flag = 0;\n            break;\n        }\n        else if (y[i] < x[i])\n        {\n            cout << y << endl;\n            flag = 0;\n            break;\n        }\n        else\n        {\n            flag = -1;\n        }\n    }\n    if (flag == -1)\n    {\n        if (size_x < size_y)\n        {\n            cout << x << endl;\n        }\n        else\n        {\n            cout << y << endl;\n        }\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:33:48.551474+00:00"
      },
      "hints": {
        "hint1": "The code is comparing two strings lexicographically, and it prints the string that comes first in lexicographical order. It considers the characters of the strings one by one until a difference is found or the end of the shorter string is reached.",
        "hint2": "The variable flag is used to track whether a difference has been found during the comparison loop. If flag is -1 after the loop, it means the strings are equal up to the length of the shorter string. The code then prints the shorter string.",
        "solution_approach": "Iterate from i = 0 to i = size_min - 1. If y[i] is greater than x[i], print x and set flag to 0. Break out of the loop. If y[i] is less than x[i], print y and set flag to 0. Break out of the loop. If y[i] is equal to x[i], set flag to -1. After the loop, check the value of flag If flag is -1, it means the strings are equal up to the length of the shorter string. If size_x is less than size_y, print x otherwise, print y."
      },
      "id": 1185,
      "input_format": "Only one line contains two strings $X$ and $Y$ consists of lowercase English letters.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the $\\textbf{smallest lexicographical}$ string.",
      "samples": [
        {
          "input": "acm\nacpc\n",
          "output": "acm\n"
        },
        {
          "input": "arijit\nbiswas\n",
          "output": "arijit\n"
        },
        {
          "input": "shubham\npatil\n",
          "output": "patil\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Compare",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a tree of N nodes and Q queries -&nbsp;</p><p>. In each query, three nodes are given x, y, z → find the lowest common ancestor of node x and y if z is a root of the tree.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\nconst int MOD = 1e9 + 7;\n\nvector<vector<int>> adj;\nvector<vector<int>> par;\nvector<int> depth;\n\nvoid dfs(int node, int prev)\n{\n    depth[node] = prev == 0 ? 0 : depth[prev] + 1;\n    par[node][0] = prev;\n    for (int i = 1; i <= 20; ++i) {\n        if(par[node][i-1] != 0){ // Ensure the ancestor is not root\n            par[node][i] = par[par[node][i - 1]][i - 1];\n        }\n    }\n    for (auto v : adj[node]) {\n        if (v != prev) {\n            dfs(v, node);\n        }\n    }\n}\n\nint lca(int u, int v) // returns lca of u and v when root is = 1, O(logN)\n{\n    if (depth[u] < depth[v]) swap(u, v);\n\n    // Try to bring u and v to the same level\n    for (int i = 20; i >= 0; --i) {\n        if ((depth[u] - depth[v]) & (1 << i)) {\n            u = par[u][i];\n        }\n    }\n\n    if (u == v) return u;\n\n    for (int i = 20; i >= 0; --i) {\n        if (par[u][i] != par[v][i]) {\n            u = par[u][i];\n            v = par[v][i];\n        }\n    }\n\n    return par[u][0];\n}\n\nvoid solve()\n{\n    int n, q;\n    cin >> n;\n    adj.assign(n + 1, vector<int>());\n    depth.assign(n + 1, 0);\n    par.assign(n + 1, vector<int>(21, 0));\n    \n    for (int i = 1; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    dfs(1, 0); // Assuming 1 as the root\n\n    cin >> q;\n    while(q--){\n        int u, v, z;\n        cin >> u >> v >> z;\n        int x = lca(u, v), a = lca(u, z), b = lca(v, z);\n        if (a == x) cout << b << \"\\n\";\n        else if (b == x) cout << a << \"\\n\";\n        else cout << x << \"\\n\";\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int T = 1;\n    cin >> T;\n\n    while(T--){\n        solve();\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:45:08.436002+00:00"
      },
      "hints": {
        "hint1": "This problem requires finding the lowest common ancestor (LCA) of two nodes in a tree when a third node is given as the root. One way to approach this problem is to first find the LCA of the two nodes assuming the root of the tree is the actual root, and then modify this LCA based on the given root.\nBut as you can understand finding LCA of all nodes in a tree with changing root would be time heavy.",
        "hint2": "",
        "solution_approach": "Suppose we want to find the LCA of two nodes u and v in a tree T, with root x. Now, suppose we want to find the LCA of u and v with respect to a new root node z.\n\nTo do this, we can take advantage of the fact that we already know the LCA of u and v with respect to the original root node x. Let's call this node l.\n\nThe first step is to find the LCA of u and z, and the LCA of v and z, using the standard LCA algorithm. Let's call these nodes a and b, respectively.\n\nLCA(u,v) = l  \nLCA(u,z) = a  \nLCA(v,z) = b  \n\nNow, there are two possible cases:\n\n### Case 1\nIf either a or b is equal to l, then z must lie in the branch of the other node. Specifically, if a == l, then z lies in the branch of v, so we return b as the new LCA of u and v with respect to z. Similarly, if b == l, then z lies in the branch of u, so we return a as the new LCA of u and v with respect to z.\n\n### Case 2\n\nIf neither a nor b is equal to l, then z lies outside the branches of both u and v. In this case, the LCA of u and v with respect to z is simply l, since l is the lowest common ancestor of u and v with respect to the original root node x.\n\n\nThis approach allows us to efficiently calculate the LCA of u and v with respect to any new root node z, without having to rebuild the entire LCA data structure from scratch."
      },
      "id": 345,
      "input_format": "<p>The first line contains an integer T (1 ≤ T ≤ 10000) - the number of test cases.</p><p>The second line of each test case contains two space-separated integers N (1 ≤ N ≤ 10^5).</p><p>The next N-1 lines contain two space-separated integers u, v (1 ≤ u, v ≤ N, u≠v) denoting there is an undirected edge between node u and node v.</p><p>The next line contains an integer Q (1 ≤ Q ≤ 10^5).</p><p>The next Q lines contain three space-separated integers x, y, z (1 ≤ x, y, z ≤ N).</p><p>Sum of N+Q across all test cases ≤ 2*10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each query print the output in a new line.</p>",
      "samples": [
        {
          "input": "2\n8\n8 7\n2 1\n4 1\n6 4\n7 4\n3 2\n5 2\n43\n7 6 8\n8 5 8\n7 3 4\n1 8 2\n3 4 4\n2 2 3\n5 7 6\n2 2 5\n2 5 6\n1 6 3\n2 5 5\n6 3 4\n2 2 4\n5 4 8\n5 4 4\n8 8 8\n6 4 7\n5 4 7\n7 6 3\n5 6 4\n3 2 8\n5 7 2\n6 6 6\n5 4 3\n5 3 2\n2 5 3\n5 8 3\n1 5 7\n3 1 2\n8 1 2\n1 7 4\n1 8 7\n2 8 3\n6 7 8\n7 4 1\n6 2 3\n5 6 1\n6 8 5\n1 4 2\n2 7 4\n8 5 5\n2 1 4\n4 3 6\n15\n7 3\n10 3\n11 3\n13 11\n15 11\n9 7\n12 9\n2 1\n3 1\n4 1\n5 1\n8 6\n14 6\n6 2\n19\n1 13 4\n6 5 9\n11 6 10\n1 6 6\n13 5 10\n12 4 7\n1 14 1\n7 7 2\n9 10 4\n7 14 12\n15 10 1\n3 5 12\n6 4 13\n8 3 13\n13 9 10\n10 9 3\n4 1 5\n4 13 8\n2 2 1",
          "output": "7\n8\n4\n1\n4\n2\n4\n2\n2\n1\n5\n4\n2\n4\n4\n8\n4\n4\n4\n4\n2\n2\n6\n2\n2\n2\n2\n1\n2\n1\n4\n7\n2\n7\n4\n2\n1\n4\n1\n4\n5\n1\n4\n1\n1\n3\n6\n3\n7\n1\n7\n3\n7\n3\n3\n1\n3\n3\n3\n1\n1\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "LCA Twist",
      "video_editorial_id": 8208
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Among the sequences $P$ that are permutations of $(1,2,…,N)$ and satisfy the condition below, find the lexicographically smallest sequence.\n\n- For each $i=1,…,M$, $A_i$ appears earlier than $B_i$​ in $P$.\n\nIf there is no such $P$, print -1.",
      "complete_approach": "",
      "constraints": "$2 \\leq N \\leq 2×10^{5}$\n$1 \\leq M \\leq 2×10^{5}$\n$ 1\\leq$ $A_i$, $B_i \\leq $  $N$\n$A_i$ $\\ne$ $B_i$ \nAll values in input are integers.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\n\nvoid solve() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> adj[n + 1], in_deg(n + 1, 0), ans;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tin_deg[v]++;\n\t}\n\tpriority_queue < int , vector<int>, greater<int>> pq;\n\tfor (int i = 1; i <= n; i++)if (in_deg[i] == 0)pq.push(i);\n\twhile (!pq.empty()) {\n\t\tint v = pq.top();\n\t\tpq.pop();\n\t\tans.push_back(v);\n\t\tfor (auto x : adj[v]) {\n\t\t\tin_deg[x]--;\n\t\t\tif (in_deg[x] == 0)pq.push(x);\n\t\t}\n\t}\n\tif (ans.size() != n) {\n\t\tcout << -1 << endl;\n\t\treturn;\n\t}\n\tfor (auto x : ans)cout << x << \" \";\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\t// cin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:17:50.409505+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Considering an $N$-vertex directed graph that has for each $i  ( 1 ≤ i ≤ M )$ an edge from Vertex $A_i$ to Vertex $B_i$, the answer is the lexicographically smallest sequence of topologically sorted vertices.\n\nOne of the common approaches for problems concerning the lexicographical order is to determine the elements in the order of appearances. For example, the following algorithm is possible to find the topologically sorted result in an order.\n\n1. Prepare an empty array $S$.\n2. While there exists a vertex with in-degree 0, repeat the following procedures.\n2.1 Choose a vertex with degree 0, denoted by $u$.\n2.2 Push $u$ to the tail of $S$.\n2.3 Remove $u$ and edges going out from $u$.\n3. When the algorithm has ended, if one or more vertices remain in the graph, then it is impossible to sort topologically. If no vertices remain, $S$ is the result of the topologically sorted vertex.\n\nIf we always choose the vertex with the smallest index and indegree 0, we obtain the lexicographically smallest $S$."
      },
      "id": 898,
      "input_format": "Input is given from Standard Input in the following format:\n$N $  $ M$\n$A_1$  $B_1$ \n:\n:\n$A_M$ $B_M$",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the answer.",
      "samples": [
        {
          "input": "4 3\n2 1\n3 4\n2 4\n",
          "output": "2 1 3 4\n"
        },
        {
          "input": "2 3\n1 2\n1 2\n2 1\n",
          "output": "-1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Smallest Permutation",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a tree consisting of <i>n</i> nodes. <i>d(u, v)</i> is the distance between nodes <i>u</i> and <i>v</i>, or number of edges in between the path connecting two nodes <i>u</i> and <i>v</i>. Your task is to find the sum of distances over all possible pairs of nodes.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n </i>≤ 2 x 10<sup>5</sup><br>1 ≤ <i>a</i>, <i>b </i>≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 200010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nvector<int> graph[N];\n\nll ans = 0;\n\nint dfs(int cur, int par, int n) {\n  int sum = 0;\n  for (int u : graph[cur]) {\n    if (u == par) continue;\n    sum += dfs(u, cur, n);\n  }\n  sum++;\n  ans += 1LL * sum * (n - sum);\n  return sum;\n}\n\nsigned main() {\n  // freopen(\"IN\", \"r\", stdin);\n  // freopen(\"OUT\", \"w\", stdout);\n\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  int n;\n  cin >> n;\n\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  dfs(1, -1, n);\n\n  cout << ans << \"\\n\";\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:40:06.139160+00:00"
      },
      "hints": {
        "hint1": "Use contribution of each edge to the final answer.",
        "hint2": "The main idea is to use the contribution of each edge to the final answer. Consider two sets A and B connected to each other via just an edge e. In this case, how many times would we encounter e in the final answer? If we try to choose just two nodes, one from set A and the other from set B, we are sure to encounter the edge e in the shortest path between the two nodes.\n\nSo, our task is to find the number of nodes on the side of a node using Depth First Search (DFS).",
        "solution_approach": "Now, let's consider the contribution of each edge to the final answer. Suppose we have an edge e connecting two subtrees T1 and T2. Then, every pair of nodes (u, v) such that u belongs to T1 and v belongs to T2, will contribute twice to the sum of distances: once for the distance from u to v, and once for the distance from v to u.\n\nTherefore, for each edge e, we need to calculate the number of nodes in the two subtrees T1 and T2, and add the product of these two numbers to the final answer.\n\nTo calculate the number of nodes in a subtree rooted at a node u, we can use Depth First Search (DFS) to traverse all the nodes in the subtree. During the DFS, for each node v, we can calculate the number of nodes in the subtree rooted at v, as well as the sum of distances from v to all the nodes in the subtree rooted at v.\n\nUsing these values, we can calculate the contribution of each edge to the final answer as follows:\n\nLet sum1 be the number of nodes in subtree T1, and sum2 be the number of nodes in subtree T2, where T1 and T2 are the subtrees connected by the edge e.\n\nThen, the product sum1 * sum2 gives the number of pairs of nodes (u, v) such that u belongs to T1 and v belongs to T2. Therefore, we can add the product sum1 * sum2 to the final answer for each edge e.\n\nFinally, we can sum up the contributions of all the edges to get the final answer."
      },
      "id": 430,
      "input_format": "The first input line contains an integer n: the number of nodes. The nodes are numbered 1, 2, …, n.\nThen there are n − 1 lines describing the edges. Each line contains two integers a and b: there is an edge between nodes a and b.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<ul><li>d(1, 1) = 0, d(1, 2) = 1, d(1, 3) = 1, d(1, 4) = 2, d(1, 5) = 2</li><li>d(2, 2) = 0, d(2, 3) = 2, d(2, 4) = 3, d(2, 5) = 3</li><li>d(3, 3) = 0, d(3, 4) = 1, d(3, 5) = 1</li><li>d(4, 4) = 0, d(4, 5) = 2</li><li>d(5, 5) = 0</li></ul>",
      "output_format": "<p>Print the sum as mentioned in the problem statement.</p>",
      "samples": [
        {
          "input": "5\n1 2\n1 3\n3 4\n3 5",
          "output": "18"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Sum of Distances",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given an integer $n$, find the $n^{th}$ positive number whose binary representation is a palindrome.\n\n**Note:**\nDo not consider the leading zeros, while considering the binary representation.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^6$\n$1 \\leq n \\leq 10^6$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nlong long nth_palindrome(int n) {\n    int64_t cnt = 1, p = 1, l = 0;\n    while (1) {\n        l++;\n        if (cnt + p > n) break;\n        cnt += p;\n        l++;\n        if (cnt + p > n) break;\n        cnt += p;\n        p *= 2;\n    }\n\n    int off = n - cnt;\n    vector<bool> bits(l, 0);\n    bits[0] = bits[l - 1] = 1;\n    int mid = l / 2;\n    for (int i = 0; off && i < mid; i++)\n    {\n        if (l & 1) {\n            bits[mid + i] = bits[mid - i] = (off & 1);\n        }\n        else {\n            bits[mid - i - 1] = bits[mid + i] = (off & 1);\n        }\n        off /= 2;\n    }\n    int64_t ans = 0, x = 1;\n    assert(l <= 63);\n    for (int i = 0; i < l; i++) {\n        ans += bits[i] * x;\n        x <<= 1;\n    }\n\n    return ans;\n\n}\nvoid solve() {\n    int n;\n    cin >> n;\n    ll x = nth_palindrome(n);\n    cout << x << endl;\n    int msb = __lg(x);\n    for (int i = 0; i < msb / 2; i++) {\n        assert(((x >> i) & 1) == ((x >> (msb - i)) & 1));\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:35:59.582105+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We can construct the nth binary palindrome in its binary representation directly using the below approach. \nIf we observe the first few binary palindromes \n\n\nGroup 0\n    \n    1 --->  1 (1)\n    \n\nGroup 1 (Will have binary representation of length 2*(1) and 2*(1) + 1)\n\n    Fix the first and last bit as 1 and insert nothing\n    (|) in between. Length is 2*(1)\n    2 --->  1|1 (3)     \n\n    Fix the first and last bit as 1 and insert bit 0\n    in between. Length is 2*(1) + 1\n    3 --->  101 (5)    \n\n    Fix the first and last bit as 1 and insert bit 1 \n    in between. Length is 2*(1) + 1 \n    4 --->  111 (7)    \n    \n\nGroup 2 (Will have binary representation of length 2*(2) and 2*(2) + 1).  \n    \n    Fix the first and last \n    bit as 1 and insert nothing (|) at middle. \n    And put 0 in binary format in both directions \n    from middle. Length is 2*(2)\n    5 --->  10|01       \n    \n    Fix the first and last bit as 1 and insert \n    nothing (|) at middle. And put 1 in binary \n    format in both directions from middle. \n    Length is 2*(2)\n    6 --->  11|11      \n    \n    7 --->  10001      \n    8 --->  10101     \n    9 --->  11011     \n    10 --->  11111      \n    \nGroup 3 (Will have binary representation of length 2*(3) and 2*(3) + 1)\n    \n    11 ---> 100|001    \n    12 ---> 101|101    \n    13 ---> 110|011    \n    14 ---> 111|111  \n    \n    15 ---> 1000001  \n    16 ---> 1001001  \n    17 ---> 1010101  \n    18 ---> 1011101  \n    19 ---> 1100011  \n    20 ---> 1101011  \n    21 ---> 1110111    \n    22 ---> 1111111 \n\n\n**Algorithm:**\n\n1. We can divide the set of palindrome numbers into some groups. \n2. n-th group will have $(2^{n-1} + 2^n = 3 * 2^{n-1} )$ number of binary palindromes \n3. With the given number, we can find the group to which it belongs and the offset in that group. \n4. As the leading zeros are not to be considered, we should use bit 1 as the starting bit and the ending bit of the number in binary representation \n5. And we will fill other bits based on the groupno and groupoffset \n6. Based on the offset, we can find which bit should be inserted at the middle (|(nothing) or 0 or 1) and which number(in binary form) (1 or 2 or 3 or 4 or ..) should be placed in both directions from the middle.\n\n**Time Complexity** : $O(log(n))$ per test case."
      },
      "id": 984,
      "input_format": "The first line contains $T$ - the number of test cases.\nFirst line of each test case contains $n$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the $n^{th}$ positive number whose binary representation is a palindrome.",
      "samples": [
        {
          "input": "5\n1\n2\n1000000\n10\n11\n",
          "output": "1\n3\n249410884119\n31\n33\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Binary Palindrome",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a mathematical expression. The expression will be one of the following expressions:\n\n$A + B = C$, $A - B = C$ and $A *  B = C$\n\nwhere $A, B, C$ are three numbers, $S$ is the sign between $A$ and $B$, and $Q$ the '=' sign\n\nPrint \"Yes\" If the expression is $\\textbf{Right}$ , Otherwise print the $\\textbf{right answer of the expression}$.",
      "complete_approach": "",
      "constraints": "$ 0 \\leq A,B \\leq 100 $\n$ -105 \\leq C \\leq 105 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    int a, b, c;\n    char s, q;\n    cin >> a >> s >> b >> q >> c;\n    int ans;\n    if (s == '+') {\n        ans = a + b;\n    } else if (s == '-') {\n        ans = a - b;\n    } else if (s == '*') {\n        ans = a * b;\n    } else {\n        ans = a / b;\n    }\n    if (ans == c) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:22.179501+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "\nTake integers in int input and characters in char input then check is the expression correct or not if correct then print Yes and if not correct then print the correct ans.\n"
      },
      "id": 1180,
      "input_format": "Only one line containing the expression: A, S, B, Q, C respectively and S can be ('+', '-', '\\*', '/') without the quotation.\n**Note**: Division sign ('/') means integer division operator.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Output a single line for each testcase representing the answer of the query.",
      "samples": [
        {
          "input": "5 + 10 = 15",
          "output": "Yes"
        },
        {
          "input": "3 - 1 = 2\n",
          "output": "Yes"
        },
        {
          "input": "2 * 10 = 19\n",
          "output": "20\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Mathematical Expression",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are assigned the task of filling a delivery truck with boxes of vaccines. You are given the description of <i>N</i> boxes -&nbsp; the number of each type of box and the vials of vaccine it contains. Find the maximum number of vials you can load onto the truck given that each box takes unit space and the truck has a maximum capacity of <i>M</i>.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Complete the function</span></p><pre><code class=\"language-plaintext\">int MaxVials(vector&lt;pair&lt;int,int&gt;&gt; &amp;a, int m)</code></pre>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\"><i>1 ≤ N, M ≤ 10<sup>6</sup></i></span></p><p><span style=\"background-color:transparent;color:#000000;\"><i>1≤ xi, yi ≤ 1000</i></span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint MaxVials(vector<pair<int,int>> &a, int m)\n{\n    int n = (int)a.size();\n    \n    sort(a.begin(), a.end(), [](pair<int,int> P1, pair<int,int> P2) {\n\t\treturn P1.second > P2.second;\n    });\n    \n    int ans = 0;\n    for (int i = 0; i < n && m > 0; i++)\n    {\n        if (m >= a[i].first)\n        {\n            ans += a[i].second * a[i].first;\n            m -= a[i].first;\n        }\n        else\n        {\n            ans += a[i].second * m;\n            m = 0;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    \n    vector<pair<int, int>> a(n);\n    \n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i].first >> a[i].second;\n    }\n    \n    cout << MaxVials(a, m) << '\\n';\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:43:31.216329+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">What will be the most profitable strategy to choose the boxes?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Sort the boxes according to the number of vials.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">It can be seen that if we choose the box with the most number of vials to be loaded onto the truck it is always profitable. So we sort the boxes in descending order according to the number of vials and load the boxes as long as the truck’s capacity does not run out.</span></p>"
      },
      "id": 608,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains two integers <i>N</i> and <i>M</i> - the number of boxes and the truck’s capacity.</span><br><span style=\"background-color:transparent;color:#000000;\">The <i>i<sup>th</sup></i> of the next <i>N</i> lines contains two integers <i>xi</i> and <i>yi</i> - the number of boxes of type <i>i</i> and the number of vials that type of box contains.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">There are:</span><br><span style=\"background-color:transparent;color:#000000;\">- 1 box of the first type that contains 3 vials each.</span><br><span style=\"background-color:transparent;color:#000000;\">- 2 boxes of the second type that contain 2 vials each.</span><br><span style=\"background-color:transparent;color:#000000;\">- 3 boxes of the third type that contain 1 vial each.</span><br><span style=\"background-color:transparent;color:#000000;\">You can take all the boxes of the first and second types, and one box of the third type.</span><br><span style=\"background-color:transparent;color:#000000;\">The total number of vials will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the maximum number of vials that can be loaded onto the truck.</span></p>",
      "samples": [
        {
          "input": "3 4\n1 3\n2 2\n3 1",
          "output": "8"
        },
        {
          "input": "4 10\n5 10\n2 5\n4 7\n3 9",
          "output": "91"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint MaxVials(vector<pair<int,int>> &a, int m)\n{\n    // Complete the function\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    \n    vector<pair<int, int>> a(n);\n    \n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i].first >> a[i].second;\n    }\n    \n    cout << MaxVials(a, m) << '\\n';\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Max Vials",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array *A* of size *N* and a positive integer *K* ($\\leq N$). The elements of the array are $A_1, A_2, \\dots, A_N$.\n\nLet $B_i = \\max(A_i, A_{i+1}, \\dots, A_{i+K-1})$, for $1 \\leq i \\leq N - K + 1$.  \n\nFind $B_i$ values for all $i$ such that $1 \\leq i \\leq N - K + 1$.",
      "complete_approach": "",
      "constraints": "- $1 \\leq T \\leq 100,000$\n- $1 \\leq K \\leq N \\leq 100,000$\n- $-10^9 \\leq A_i \\leq 10^9$\n- Sum of $N$ over all test cases $\\leq 5 \\times 10^5$",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main() {\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, k;\n        cin >> n >> k;\n        int A[n];\n\n        for (int i = 0; i < n; i++)\n            cin >> A[i];\n\n        multiset<int> M;\n\n        for (int i = 0; i < k; i++)\n            M.insert(A[i]);\n\n        for (int i = 0; i <= n - k; i++) {\n            cout << *(M.rbegin()) << \" \";\n            M.erase(M.find(A[i]));\n            if(i + k < n) M.insert(A[i + k]);\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nvoid add(deque<int> &d, int x) {\n    while(!d.empty() && d.back() < x)\n        d.pop_back();\n    d.push_back(x);\n    return;\n}\n\nvoid rem(deque<int> &d, int x) {\n    assert(!d.empty());\n    if(d.front() == x) d.pop_front();\n    return;\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int T; cin >> T;\n    while(T--) {\n        int n, k; cin >> n >> k;\n        int A[n];\n\n        for(int i = 0; i < n; i++)\n            cin >> A[i];\n\n        deque<int> d;\n\n        for(int i = 0; i < k; i++)\n            add(d, A[i]);\n\n        for(int i = 0; i <= n - k; i++) {\n            cout << d.front() << \" \";\n            rem(d, A[i]);\n            if(i + k < n) add(d, A[i + k]);\n        }\n\n        cout << \"\\n\";\n    }\n    return 0;\n}",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:37:35.840411+00:00"
      },
      "hints": {
        "hint1": "<p>Solving with brute force in <i>O(N * K)</i> is easy, but it's not enough to pass within a time limit.<br>Observe that <i>B<sub>i</sub></i> and <i>B<sub>i+1</sub></i> differs by only two elements. <i>A<sub>i</sub></i> is present in <i>B<sub>i</sub></i> while <i>A<sub>i</sub></i> is absent in <i>B<sub>i+1</sub></i>.<br>Similarly for <i>A<sub>i+K</sub></i> is present in <i>B<sub>i+1</sub></i> and absent in <i>B<sub>i</sub></i>.</p>",
        "hint2": "<p>Maintain one multiset with a sliding window. <i>That's it!</i> <i>Can you do it in O(N)</i>? How about using a Double-ended queue?</p>",
        "solution_approach": "<p><strong>Solution 1:</strong><br><i>B<sub>i</sub> = max (A<sub>i</sub>, ..., A<sub>i+K-1</sub>)</i><br><i>B<sub>i+1</sub> = max (A<sub>i+1</sub>, ..., A<sub>i+K</sub>)</i><br>If we maintain a multiset <i>M</i> initialize with {<i>A<sub>i</sub>, ..., A<sub>K</sub></i>}.<br>For <i>B<sub>1</sub></i>, the answer is the max number present in the current multiset <i>M</i>.<br>For <i>B<sub>2</sub></i>, as mentioned in hints add remove <i>A<sub>1</sub></i> and add <i>A<sub>K+1</sub></i> in the multiset <i>M</i>, and now find the max number in the current multiset <i>M</i>.<br>Keep on doing this for all <i>B<sub>i</sub></i>s.<br><strong>Time complexity:</strong> <i>O(N*logK)</i><br><strong>Space complexity:</strong> <i>O(K) extra space</i></p><p><strong>Solution 2:</strong><br>Create a Deque, <i>Q</i> of capacity <i>K</i>, that stores only useful elements of the current window of <i>k</i> elements.<br>An element is useful if it is in the current window and is greater than all other elements on the left side of it in the current window.<br>Process all array elements one by one and maintain <i>Q</i> to contain useful elements of the current window and these useful elements are maintained in sorted order.<br>The element at front of the <i>Q</i> is the largest and element at the rear of <i>Q</i> is the smallest of the current window.<br><i><u>Algorithm:</u></i></p><ol><li>Create a deque to store <i>K</i> elements.</li><li>Run a loop and insert the first K elements in the deque. While inserting the element if the element at the back of the queue is smaller than the current element removes all those elements and then insert the element.</li><li>Now, run a loop from <i>K</i> to end of the array.</li><li>Print the front element of the array</li><li>Remove the element from the front of the queue if they are out of the current window.</li><li>Insert the next element in the deque. While inserting the element if the element at the back of the queue is smaller than the current element removes all those elements and then insert the element.</li><li>Print the maximum element of the last window.</li></ol><p><strong>Time complexity:</strong> <i>O(N)</i><br><strong>Space complexity:</strong> <i>O(K) extra space.</i></p>"
      },
      "id": 77,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases.&nbsp;<br>The first line of each test case contains <i>N</i>, the number of integers in an array <i>A</i> and <i>K</i>.<br>The second line of each test case contains <i>N</i> space-separated integers <i>A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub></i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br><i>B<sub>1</sub></i> = max(1, 2, 3) = 3<br><i>B<sub>2</sub></i> = max(2, 3, 1) = 3<br><i>B<sub>3</sub></i> = max(3, 1, 4) = 4<br><i>B<sub>4</sub></i> = max(1, 4, 5) = 5<br><i>B<sub>5</sub></i> = max(4, 5, 2) = 5<br><i>B<sub>6</sub></i> = max(5, 2, 3) = 5<br><i>B<sub>7</sub></i> = max(2, 3, 6) = 6</p><p><i><strong>Explanation 2:</strong></i><br><i>B<sub>1</sub></i> = max(1, -4, 3, -3, -9) = 3</p>",
      "output_format": "<p>For each test case, print array <i>B</i> as <i>B<sub>1</sub> B<sub>2</sub> ... B<sub>N-K+1</sub></i> in a new line.</p>",
      "samples": [
        {
          "input": "4\n9 3\n1 2 3 1 4 5 2 3 6\n5 5\n1 -4 3 -3 -9\n4 1\n-3 1 -8 3\n5 2\n-1 -1 -1 -1 -1",
          "output": "3 3 4 5 5 5 6\n3\n-3 1 -8 3\n-1 -1 -1 -1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Maximum in Window",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are two piles of stones in front of you. Perform the following operation continuously until at least one pile is empty.</p><ul><li>Choose the pile with the maximum number of stones (if two piles have the same number of stones, choose any pile then).</li><li>Remove stones from the chosen pile as many the other pile has. The other pile remains unchanged.</li></ul><p>In the last one pile becomes empty. You have to find the number of stones in the other non-empty pile in the end.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty."
        ],
        "last_updated": "2024-06-22T02:44:57.596734+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 211,
      "input_format": "<p>The first line contains a single integer <strong>T</strong> <strong>(1 ≤ T ≤ 10<sup>5</sup>)</strong> &nbsp;- the number of test cases. The description of the test cases follows.<br>The only line of each test case contains two integers <strong>a, b (1 ≤ a, b ≤ 10<sup>18</sup>) -</strong> denoting the number of stones in the first and second pile respectively.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><strong>Explanation 1:</strong> (1, 3) → (1, 2) → (1, 1) → (1, 0).<br><strong>Explanation 2:</strong> (4, 6) → (4, 2) → (2, 2) → (2, 0).</p>",
      "output_format": "<p>For each test case, output the number of stones in the non-empty pile in the end.</p>",
      "samples": [
        {
          "input": "2\n1 3\n4 6",
          "output": "1\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Piles of stones",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two numbers $N, Q$ and a string $S$ of size $N$. Followed by $Q$ lines of the following queries:\n\n1. $\\textbf{pop\\_back}$ : remove the last character in the string.\n2. $\\textbf{front}$ : print the first character in the string.\n3. $\\textbf{back}$ : print the last character in the string.\n4. $\\textbf{sort l r}$ : where $(1 \\leq l, r \\leq |S|)$ sort all characters of $S$ from $l$ to $r$.\n5. $\\textbf{reverse l r}$ : where $(1 \\leq l, r \\leq |S|)$ reverse all characters of $S$ from $l$ to $r$.\n6. $\\textbf{print pos}$ : where $(1 \\leq pos \\leq |S|)$ print the character in the $index$ pos.\n7. $\\textbf{substr l r}$ : where $(1 \\leq l, r \\leq |S|)$ print sub-string of $S$ from $l$ to $r$.\n8. $\\textbf{push\\_back x}$ : add character $x$ in the end of the string.\n\nNote: $ \\text{if } l > r \\text{ then swap them} $\n\nFor each query, print the answer associated with it in a single line.\n\n$\\textbf{It's guaranteed that in the first 7 types of the query, the string is not empty.}$\n\n$\\textbf{it's recommended to use built-in functions of String.}$",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N, Q \\leq 10^3 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    int size, query;\n    cin >> size >> query;\n    string s; cin >> s;\n    int l, r;\n    while (query--) {\n        string type; cin >> type;\n        if (type == \"pop_back\") {\n            s.pop_back();\n        } else if (type == \"front\") {\n            cout << s.front() << endl;\n        } else if (type == \"back\") {\n            cout << s.back() << endl;\n        } else if (type == \"sort\") {\n            cin >> l >> r;\n            if (l > r) {\n                swap(l, r);\n            }\n            sort(s.begin() + l - 1, s.begin() + r);\n        } else if (type == \"reverse\") {\n            cin >> l >> r;\n            if (l > r) {\n                swap(l, r);\n            }\n            reverse(s.begin() + l - 1, s.begin() + r);\n        } else if (type == \"print\") {\n            int pos; cin >> pos;\n            cout << s[pos - 1] << endl;\n        } else if (type == \"substr\") {\n            cin >> l >> r;\n            if (l > r) {\n                swap(l, r);\n            }\n            string substr = s.substr(l - 1, r - l + 1);\n            cout << substr << endl;\n        } else {\n            char c; cin >> c;\n            s.push_back(c);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:41.848464+00:00"
      },
      "hints": {
        "hint1": "$l > r$ might be possible keep in mind.",
        "hint2": "",
        "solution_approach": "Just use c++ stl for other language use respective library."
      },
      "id": 1193,
      "input_format": "The first line contains two integers $N, Q$. $N$ denoting the size of the string and Q number of queries.\nThe second line contains the string $S$ consists of only lowercase English letters.\nNext $Q$ lines contain the queries.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Output a single line for each testcase representing the answer of the query.",
      "samples": [
        {
          "input": "18 8\nassiutinupperegypt\nsubstr 1 6\nsort 5 8\npop_back\nback\nreverse 1 6\nfront\npush_back i\nprint 4\n",
          "output": "assiut\np\nn\ns\n"
        },
        {
          "input": "10 8\nalgozenith\nsubstr 5 6\nsort 5 8\npop_back\nback\nreverse 5 6\nfront\npush_back a\nprint 5\n",
          "output": "ze\nt\na\ni\n"
        },
        {
          "input": "10 5\nalgozenith\nsort 5 8\nreverse 3 6\nsort 2 5\npush_back a\nsubstr 1 10\n",
          "output": "aeilognzth\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "String Functions",
      "video_editorial_id": 10663
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">There are <i>N</i> balls on the <i>X</i>-axis and <i>M</i> balls on the <i>Y</i>-axis. At the time, <i>t=0</i>, each ball on <i>X</i>-axis is thrown parallel to the <i>Y</i>-axis in the positive <i>Y</i> direction. Similarly, each ball on <i>Y</i>-axis is thrown parallel to the <i>X</i>-axis in the positive <i>X</i> direction. At any time, if two balls collide, they disappear. A collision can only happen between the ball thrown from <i>X</i>-axis and the ball </span>thrown<span style=\"background-color:transparent;color:#000000;\"> from <i>Y</i>-axis. <strong>No two balls from </strong><i><strong>X</strong></i><strong>-axis or </strong><i><strong>Y</strong></i><strong>-axis can collide.</strong> A ball can take part in at max one collision. You have to find the total number of collisions.&nbsp;</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ <i>T</i> ≤ 100</span><br><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ <i>N, M</i> ≤ 10<sup>5</sup></span><br><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ <i>X<sub>i</sub>, U<sub>i</sub>, Y<sub>i</sub>, V<sub>i</sub></i><sub> </sub>≤ 10<sup>9</sup></span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n#define int long long\n\nsigned main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n, m;\n    cin >> n >> m;\n    int ans = 0;\n    map<int, int> m1;\n    for (int i = 0; i < n; ++i) {\n      int x, u;\n      cin >> x >> u;\n      m1[x * u]++;\n    }\n    for (int i = 0; i < m; ++i) {\n      int y, v;\n      cin >> y >> v;\n      if (m1.count(y * v)) {\n        ans++;\n        m1[y * v]--;\n        if (m1[y * v] == 0) {\n          m1.erase(y * v);\n        }\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:41:53.618045+00:00"
      },
      "hints": {
        "hint1": "Two balls collide when they reach a position at the same time.",
        "hint2": "Use, Speed $= \\dfrac{distance}{time}$.",
        "solution_approach": "To solve this problem, we can start by observing that two balls will collide only if they meet at the same position at the same time. Since the balls move in straight lines, the only point where they can meet is the intersection of their paths. Therefore, we can check for collisions by finding the intersection points of the paths of all pairs of balls.\n\nLet's consider two balls, one from the X-axis and one from the Y-axis, with positions `(x, u)` and `(y, v),` respectively. Here, `u` and `v` are the velocities of the balls on the X-axis and Y-axis, respectively. The two balls will collide if they reach the point `(x, y)` at the same time. The time taken by the ball on the X-axis to reach `(x, y)` is given by $\\frac {y}{u} $, and the time taken by the ball on the Y-axis to reach `(x, y)` is given by $\\frac {x}{v}$. Therefore, the two balls will collide if $\\frac {y}{u}  = \\frac {x}{v}$, which can be simplified to $y \\times v = x \\times u$. If this condition is satisfied, the two balls will collide at the point `(x, y)`.\n\nThe given solution uses a map to keep track of the number of times the product x * u appears in the input from the X-axis. This product corresponds to the time at which the ball fired from X-axis reaches the position `(x, y)` on the grid.\n\nThen, for each ball fired from the Y-axis, the solution checks if there is a ball fired from the X-axis that will reach the same position at the same time, using the product $y \\times v$. If there is a ball, the solution increments the ans counter to keep track of the total number of collisions.\n\nTo handle the case where a ball fired from X-axis can collide with more than one ball fired from Y-axis, the solution uses a map to keep track of the frequency of each product $x \\times u$. When a collision is found, the frequency is decremented, and if the frequency becomes $0$, the product is removed from the map.\n\n### Time complexity \n $O(N \\log N)$, where N is the total number of balls fired from the X-axis and Y-axis combined. This is because the solution uses a map, and the time complexity of map operations is $O(\\log N)$."
      },
      "id": 82,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer <i>T</i> - the number of test cases. Then <i>T</i> test cases follow.</span><br><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains two space-separated integers <i>N</i> and <i>M</i> - the number of balls on the <i>X</i>-axis and <i>Y</i>-axis respectively.</span><br><span style=\"background-color:transparent;color:#000000;\">For each test case, <i>N</i> lines follow. The <i>i</i>-th of the line contains two space-separated integers <i>X<sub>i</sub></i> and <i>U<sub>i</sub></i>, the position and speed of the <i>i</i>-th ball respectively.</span><br><span style=\"background-color:transparent;color:#000000;\">For each test case, <i>M</i> lines follow. The <i>i</i>-th of the line contains two space-separated integers <i>Y<sub>i</sub></i> and <i>V<sub>i</sub></i>, the position and speed of the <i>i</i>-th ball respectively.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">In the first test case of the example, at <i>t=1</i> the balls collide. The number of collisions is 1.</span></p><p><span style=\"background-color:transparent;color:#000000;\">In the second test case of the example, at <i>t=1</i>, the first ball on <i>X</i>-axis and the first ball on <i>Y</i>-axis collide and disappear. The number of collisions is 1.</span></p><p><span style=\"background-color:transparent;color:#000000;\">In the third test case of the example, at <i>t=⅓</i>, the second ball on <i>X</i>-axis and the first ball on <i>Y</i>-axis collide and disappear. At <i>t=1</i>, the first ball on <i>X</i>-axis and the second ball on <i>Y</i>-axis collide and disappear. The number of collisions is 2.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the number of collisions on a separate line.</span></p>",
      "samples": [
        {
          "input": "3\n1 1 \n1 3 \n3 1 \n2 1 \n1 4 \n1 3 \n4 1 \n2 3 \n1 2 \n2 3 \n1 6 \n2 1 \n6 1",
          "output": "1\n1\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Collisions",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers, <i>Q</i> queries, and an integer <i>K</i>. In each query two integers <i>L</i>, <i>R</i> is given, you have to find (<i>A[L] + A[L+1] * K + A[L+2] * K^2 + …. A[R] * K^(R-L)</i>)% 10^9+7.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\ntypedef long long ll;\nll power(ll x,ll y)\n{\n    ll res = 1;\n    while(y)\n    {\n        if(y&1) \n            res = (res*x)%mod;\n        y=y/2,x=(x*x)%mod;\n    }\n    return res%mod;\n}\nconst int N = 1000001;\nll powerK[N];\nll arr[N];\nll prefixSum[N];\nsigned main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,q,k;\n    cin>>n>>q>>k;\n    powerK[0] = 1;\n    for(int i=1;i<=n;i++)\n        powerK[i] = k*powerK[i-1]%mod;\n    for(int i=1;i<=n;i++){\n        cin>>arr[i];\n        arr[i] = arr[i]*powerK[i]%mod;\n        if(arr[i]<0)\n            arr[i]+=mod;\n    }\n    prefixSum[0] = 0;\n    for(int i=1;i<=n;i++){\n        prefixSum[i] = prefixSum[i-1]+arr[i];\n        if(prefixSum[i]>=mod)\n            prefixSum[i]-=mod;\n    }\n    while(q--){\n        ll l,r;\n        cin>>l>>r;\n        ll ans = prefixSum[r]-prefixSum[l-1];\n        if(ans<0)\n            ans+=mod;\n        ans = ans*power(powerK[l],mod-2)%mod;\n        cout<<ans<<\"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:38:16.294616+00:00"
      },
      "hints": {
        "hint1": "<p>If you transform your array as A[I] = A[I]*(K^I) then calculate prefixSum array where prefixSum[I] = (A[1] + A[2] + A[3].....A[I]), then you can easily calculate the answer for a query.</p>",
        "hint2": "<p>For each query answers will be (prefixSum[R]-prefixSum[L-1])*inverse(K^L).</p><p>Take the modulus properly.</p>",
        "solution_approach": "<p>Check the video solution - GP on Prefix Sum.</p>"
      },
      "id": 21,
      "input_format": "<p>The first line contains three space-separated integers <i>N</i>, <i>Q</i>, <i>K</i> where 1&lt;=<i>N</i>&lt;=10^6, 1&lt;=<i>Q</i>&lt;=10^6, 1&lt;=<i>K</i>&lt;=10^9.</p><p>Next line contains <i>N</i> space-separated integers (-1e9&lt;=<i>A<sub>i</sub></i>&lt;=1e9).</p><p>Next <i>Q</i> lines contain two space-separated integers <i>L</i>, <i>R</i> where 1&lt;=<i>L</i>&lt;=<i>R</i>&lt;=<i>N</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>For each query print the value of (<i>A[L] + A[L+1] * K + A[L+2] * K^2 + …. A[R] * K^(R-L)</i>)% 10^9+7 in a new line.</p>",
      "samples": [
        {
          "input": "10 10 234565\n12 -23 -123 2345 2345 44 345 -93945 -5353 1\n1 5\n1 8\n1 10\n2 2\n6 6\n4 8\n2 9\n4 10\n3 6\n5 9",
          "output": "644011223\n645979052\n534876628\n999999984\n44\n725883751\n503173837\n859246404\n845338365\n605774687"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "LR Power Sum Query",
      "video_editorial_id": 8127
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a number X, you can perform two operations:</p><ul><li><strong>Double</strong>: Multiply the number on the display by 2, or;</li><li><strong>Decrement</strong>: Subtract 1 from the number on the display.</li></ul><p>Return the minimum number of operations needed to convert number X to Y.</p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 ≤ T ≤ 10^6.\n1 ≤ X,Y ≤ 10^18</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n\n# include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\nusing lli =  int long long;\n//#define ld long double;\n\nconst int tot = 1e5+5;\nconst lli mod = 1e9+7;\n\n\nint main(){\n  \n    #ifndef ONLINE_JUDGE\n    // for getting input from input.txt\n    freopen(\"input.txt\", \"r\", stdin);\n    // for writing output to output.txt\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    \n    IOS\n\n    lli t;\n    cin >> t;\n    while(t--){\n      lli x,y;\n      cin >> x >> y;\n      lli ans=0;\n\n      //As long as y is greater than x , add+1 (for odd)to make even , then divide by 2 till y<=x\n      while(y>x){\n        if(y%2==1){\n          y=y+1;\n          ans++;\n        }\n        else{\n          y=y/2;\n          ans++;\n        }\n      }\n      // Finally add (x-y) moves to get the number x from y\n      ans+=(x-y);\n\n      cout << ans << \"\\n\";\n    }\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:34:45.343049+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Consider the different scenarios of x and y. Clearly , x &gt; y , you can only apply x → x-1 move. So the number of moves then becomes (x-y). But about x&lt;y ?&nbsp;</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">The greedy approach to this problem would be to consider how to make x from y (instead of y from x ). So the moves become y → y/2 and y → y+1.</span></p><p><span style=\"background-color:transparent;color:#000000;\">This is due to the fact that we always greedily divide by two.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">Consider 2 scenarios :&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">For y = even, then if we perform 2 additions and one division, we could instead perform one division and one addition for less operations [(Y+2) / 2 vs Y/2 + 1].</span></p><p><span style=\"background-color:transparent;color:#000000;\">y → y+1 → y+2 → (y+2)/2= y/2+1</span></p><p><span style=\"background-color:transparent;color:#000000;\">y → y/2 → y/2+1</span></p><p><span style=\"background-color:transparent;color:#000000;\">For y=odd &nbsp; then if we perform 3 additions and one division, we could instead perform 1 addition, 1 division, and 1 addition for less operations [(Y+3) / 2 vs (Y+1) / 2 + 1].</span></p><p><span style=\"background-color:transparent;color:#000000;\">y → y+1 → y+2 →y+3 → (y+3)/2= (y+1)/2+1</span></p><p><span style=\"background-color:transparent;color:#000000;\">y → y+1 →(y+1)/2 → (y+1)/2+1</span></p><p><span style=\"background-color:transparent;color:#000000;\">Clearly, in both cases, we see that dividing by 2&nbsp; requires a minimum number of steps to reach the same value than the addition of 1.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Using the above greedy approach, the question can be easily divided into stages.</span></p><p><span style=\"background-color:transparent;color:#000000;\">If y &gt; x and it is odd then first add 1 to make it even, then divide by 2 and continue.</span></p><p><span style=\"background-color:transparent;color:#000000;\">If y &gt; x and it is already even, then divide by 2.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Continue till y &lt;= x</span></p><p><span style=\"background-color:transparent;color:#000000;\">Then lastly , (x-y) addition moves are required to reach the desired answer,</span></p><p><span style=\"background-color:transparent;color:#000000;\">EXAMPLE RUN :&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span></p><p><span style=\"background-color:transparent;color:#000000;\">10 15</span></p><p><span style=\"background-color:transparent;color:#000000;\">X = 10 Y=15</span></p><p><span style=\"background-color:transparent;color:#000000;\">15&gt;10 and it is odd</span></p><p><span style=\"background-color:transparent;color:#000000;\">15 → 16 → 8 # moves = 2</span></p><p><span style=\"background-color:transparent;color:#000000;\">Now y&lt;x&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\"># moves = 2+(10-8) = 4 .</span></p>"
      },
      "id": 489,
      "input_format": "<p>The first line contains an integer T (number of test cases), 1 ≤ T ≤ 10^6.</p><p>The next T lines contain 2 space-separated integers X, Y where 1 ≤ X,Y ≤ 10^18.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">TEST CASE 1: X=10 Y=15</span></p><p><span style=\"background-color:transparent;color:#000000;\">MOVES : 10 → 9 → 8 → 16 → 15 &nbsp; &nbsp; #Moves = 4</span><br>&nbsp;</p><p><span style=\"background-color:transparent;color:#000000;\">TEST CASE 2: X=21 Y =14</span></p><p><span style=\"background-color:transparent;color:#000000;\">MOVES : 21 → 20 → 19 → 18 → 17 → 16 → 15 → 14&nbsp; &nbsp; # moves = 7</span><br>&nbsp;</p><p><span style=\"background-color:transparent;color:#000000;\">TEST CASE 3: X=10 Y=22</span></p><p><span style=\"background-color:transparent;color:#000000;\">MOVES : 10 → 9 → 8 → 7 → 6 → 12 → 11 → 22 # moves = 7</span></p>",
      "output_format": "<p>For each test case print the minimum number of operations required in a new line.</p>",
      "samples": [
        {
          "input": "3\n10 15\n21 14\n10 22",
          "output": "4\n7\n7"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Minimum Operation Conversion",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a non-empty singly linked list, find a middle node of the linked list.</p><p>Complete the function</p><pre><code class=\"language-cpp\">ListNode* middleNode(ListNode* head)</code></pre><p><i>head </i>is the pointer to the beginning of the linked list.</p><p>If there are even nodes, then there would be two middle nodes, find the second middle element.</p>",
      "complete_approach": "",
      "constraints": "<p>Size of linked list ≤ 100000<br>Each node in the linked list stores values between 0 to 10<sup>9</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* middleNode(ListNode* head) {\n    if(head->next == NULL) {\n        return head;\n    }\n\t\n    ListNode* fast = head->next;\n    \n    while(true) {\n        head = head->next;\n        fast = fast->next;\n        if(fast == NULL || fast->next == NULL) {\n            break;\n        }\n        fast = fast->next;\n    }\n\n    return head;\n}\n\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    ListNode* head = GetList(num);\n\n    ListNode* mid = middleNode(head);\n\n    cout << mid->val << \"\\n\";\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:17:46.853663+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 526,
      "input_format": "",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "1\n5",
          "output": "5"
        },
        {
          "input": "2\n1 8",
          "output": "8"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\nListNode* middleNode(ListNode* head) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    ListNode* head = GetList(num);\n\n    ListNode* mid = middleNode(head);\n\n    cout << mid->val << \"\\n\";\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Middle of the Linked List",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a singly linked list, reverse the nodes and return its head.</p><p>Complete the function</p><pre><code class=\"language-plaintext\">ListNode* reverseList(ListNode* head)</code></pre>",
      "complete_approach": "",
      "constraints": "<p>0 ≤ Length of the linked list ≤ 10<sup>6</sup><br>0 ≤ Values stored in nodes ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* reverseList(ListNode* head) {\n    ListNode* current = head;\n    ListNode *prev = NULL, *next = NULL;\n\n    while (current != NULL) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    head = prev;\n    return head;\n}\n\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    ListNode* head = GetList(num);\n\n    head = reverseList(head);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:46:13.679432+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 533,
      "input_format": "",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "1\n1",
          "output": "1"
        },
        {
          "input": "5\n1 2 3 4 5",
          "output": "5 4 3 2 1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\n\nListNode* reverseList(ListNode* head) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    ListNode* head = GetList(num);\n\n    head = reverseList(head);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Reverse List - easy version",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an array A. One random element is removed from A to form array B and one random element is removed from B to form array C. You have to find the missing element in B and the missing element in C.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1 </span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:#ffffff;color:#000000;\">2 ≤ N ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of </span><span style=\"background-color:#ffffff;color:#000000;\">N</span><span style=\"background-color:transparent;color:#000000;\"> over all the test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>6</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p><p><span style=\"background-color:transparent;color:#000000;\">0 </span><span style=\"background-color:#ffffff;color:#000000;\">≤ A<sub>i</sub> ≤ 10<sup>9</sup></span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        long long s1 = 0, s2 = 0, s3 = 0;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            cin >> x;\n            s1 += x;\n        }\n        for (int i = 0; i < n-1; ++i) {\n            int x;\n            cin >> x;\n            s2 += x;\n        }\n        for (int i = 0; i < n-2; ++i) {\n            int x;\n            cin >> x;\n            s3 += x;\n        }\n        cout << s1 - s2 << \" \" << s2 - s3 << \"\\n\";\n    }\n    return 0;\n}\n```\n\n",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:24:39.965170+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Take the sum of the given three arrays. Sum of A - Sum of B would give the missing element in B and similarly Sum of B - Sum of C would give the missing element in C.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N)</span></p>"
      },
      "id": 320,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer N - the length of the array.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">The second line of each test case contains N space-separated integers - array A.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The third line of each test case contains (N-1) space-separated integers - array B.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The fourth line of each test case contains (N-2) space-separated integers - array C.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the missing element in B and the missing element in C.</span></p>",
      "samples": [
        {
          "input": "3\n4\n1 3 5 2\n5 1 3\n5 1\n5\n1 3 5 1 0\n3 1 1 5\n1 1 5\n3\n1 2 3\n3 1\n1",
          "output": "2 3\n0 3\n2 3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "The Missing Number AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given an array of <i>K </i>singly linked lists. <i>head[i]</i> is the head of <i>i</i>th linked list. Each linked list is sorted in ascending order.</p><p>Merge all the linked-lists into one sorted linked-list and return it.</p><p>Complete the function</p><pre><code class=\"language-plaintext\">ListNode* mergeKLists(vector&lt;ListNode*&gt; head)</code></pre><p>Do it in O(1) extra space.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>K</i> ≤ 10<sup>2</sup><br>0 ≤ <i>N<sub>i</sub></i> ≤ 10<sup>3</sup><br>0 ≤ Values of the node ≤ 10<sup>9</sup><br>It's guaranteed that each linked list is sorted.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode *merge2List(ListNode *head1, ListNode *head2)\n{\n    if (!head1)\n        return head2;\n    if (!head2)\n        return head1;\n    if (head1->val < head2->val)\n    {\n        head1->next = merge2List(head1->next, head2);\n        return head1;\n    }\n    else\n    {\n        head2->next = merge2List(head1, head2->next);\n        return head2;\n    }\n}\n\nListNode *mergeKLists(vector<ListNode *> heads, int l, int r)\n{\n    if (l > r)\n        return NULL;\n    if (l == r)\n        return heads[l];\n    int mid = (l + r) / 2;\n    ListNode *head1 = mergeKLists(heads, l, mid);\n    ListNode *head2 = mergeKLists(heads, mid + 1, r);\n    return merge2List(head1, head2);\n}\n\nListNode *mergeKLists(vector<ListNode *> heads)\n{\n    int n = heads.size();\n    return mergeKLists(heads, 0, n - 1);\n}\n\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nvector<ListNode*> GetList(int K, vector<vector<int>> &num) {\n    vector<ListNode*> head(K);\n    for(int i = 0; i < K; i++) {\n        head[i] = GetList(num[i]);\n    }\n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int K;\n    cin >> K;\n\n    vector<vector<int>> num(K);\n\n    for(int i = 0; i < K; i++) {\n        int n;\n        cin >> n;\n        for(int j = 0; j < n; j++) {\n            int x;\n            cin >> x;\n            num[i].push_back(x);\n        }\n    }\n\n    vector<ListNode*> head = GetList(K, num);\n\n    ListNode* mergeHead = mergeKLists(head);\n\n    while(mergeHead) {\n        cout << mergeHead->val << \" \";\n        mergeHead = mergeHead->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:38:26.952231+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<h2><span style=\"background-color:transparent;color:#000000;\"><strong>Solution 1 (Extra Space)&nbsp;</strong></span></h2><p><span style=\"background-color:transparent;color:#000000;\">Push all the node values in a vector and sort the vector. Make another linked list to store the sorted vector values as nodes and return </span>them<span style=\"background-color:transparent;color:#000000;\">.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Time Complexity:</i> All the nodes are stored in a vector and sorted, the time complexity is O(n log(n)) where n is the total number of nodes in the linked list.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Space Complexity: </i>Since a vector of size n and a new linked list of n nodes is made, the space complexity is O(n) where n is the total number of nodes in the linked list.</span></p><h2><span style=\"background-color:transparent;color:#000000;\"><strong>Solution 2 (Extra Space)&nbsp;</strong></span></h2><p><span style=\"background-color:transparent;color:#000000;\">The solution is similar to Solution 1, here </span>a min-heap<span style=\"background-color:transparent;color:#000000;\"> will be used to store the pair of </span>values<span style=\"background-color:transparent;color:#000000;\"> and the linked list pointer. Store the first number from each vector in the </span>min-heap<span style=\"background-color:transparent;color:#000000;\">. Make a new linked list for storing the values from the priority queue</span></p><p><span style=\"background-color:transparent;color:#000000;\"><i>Time Complexity: </i>At most k nodes are present in the priority queue at a time, the time complexity is O(n log(k)) where n is the total number of nodes in the linked list and k is the number of linked lists.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Space Complexity: </i>Since a priority queue of at most k size and a new linked list of n nodes is made, the space complexity is O(n) where n is the total number of nodes in the linked list.</span></p><h2><span style=\"background-color:transparent;color:#000000;\"><strong>Solution 3&nbsp;</strong></span></h2><p><span style=\"background-color:transparent;color:#000000;\">Merge the k linked lists by merging two linked lists at a time. This has to be done (k-1) times since there would be (k-1) pairs of linked lists.</span></p><p><span style=\"background-color:transparent;color:#000000;\"><i>Time Complexity: </i>The time complexity is O(k*n) where n is the number of nodes in the linked list and k is the number of lists.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Space Complexity: </i>Since constant extra memory is used, the space complexity is O(1).</span></p><h2><span style=\"background-color:transparent;color:#000000;\"><strong>Solution 4 (Optimal)&nbsp;</strong></span></h2><p><span style=\"background-color:transparent;color:#000000;\">The approach here is a modification of Solution 3. Use divide and conquer. Recursively split the k lists into halves until the count becomes 1. Merge two lists to get the sorted list of twice the size.</span></p><p><span style=\"background-color:transparent;color:#000000;\"><i>Time Complexity: </i>The time complexity is O(n log(k)) where n is the number of nodes in the linked list and k is the number of lists.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Space Complexity: </i>Since constant extra memory is used, the space complexity is O(1).</span></p>"
      },
      "id": 535,
      "input_format": "<p>The first line of input contains <i>K </i>- the number of linked lists.<br>2<i>i</i>th line contains <i>N<sub>i </sub></i>- the number of nodes in <i>i</i>th linked list.<br>(2<i>i</i> + 1)th line contains <i>N<sub>i</sub></i> space-separated integers denoting the nodes in the <i>i</i>th linked list in ascending order.</p><p>The following function parses the input</p><pre><code class=\"language-plaintext\">vector&lt;ListNode*&gt; GetList(int K, vector&lt;vector&lt;int&gt;&gt; &amp;num)</code></pre>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "3\n3\n3 5 6\n3\n1 2 9\n3\n4 7 8",
          "output": "1 2 3 4 5 6 7 8 9"
        },
        {
          "input": "3\n2\n1 5\n0\n\n1\n4",
          "output": "1 4 5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\nListNode* mergeKLists(vector<ListNode*> head) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nvector<ListNode*> GetList(int K, vector<vector<int>> &num) {\n    vector<ListNode*> head(K);\n    for(int i = 0; i < K; i++) {\n        head[i] = GetList(num[i]);\n    }\n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int K;\n    cin >> K;\n\n    vector<vector<int>> num(K);\n\n    for(int i = 0; i < K; i++) {\n        int n;\n        cin >> n;\n        for(int j = 0; j < n; j++) {\n            int x;\n            cin >> x;\n            num[i].push_back(x);\n        }\n    }\n\n    vector<ListNode*> head = GetList(K, num);\n\n    ListNode* mergeHead = mergeKLists(head);\n\n    while(mergeHead) {\n        cout << mergeHead->val << \" \";\n        mergeHead = mergeHead->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "Merge K Sorted Lists",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a singly linked list and an integer <i>K</i>, reverse the nodes of the list <i>K</i> at a time and returns its head.</p><p>It's guaranteed that the <i>K </i>is divisible by the length of the linked list.</p><p>Complete the function</p><pre><code class=\"language-plaintext\">ListNode* reverseList(ListNode* head, int K)</code></pre>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>N</i> ≤ 10<sup>6</sup><br>1 ≤ <i>K</i> ≤ <i>N</i><br>0 ≤ Values stored in nodes ≤ 10<sup>9</sup><br>It's guaranteed that the <i>N</i> is divisible by <i>K</i>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* reverseList(ListNode* head, int K) {\n    ListNode *cur = head, *prev = head;\n    head = head -> next;\n    for(int i = 1; i < K; i++)\n    {\n        if(head == NULL) break;\n        ListNode *temp = head -> next;\n        head -> next = prev;\n        prev = head;\n        head = temp;\n    }\n    if(head == NULL) \n    {\n        cur -> next = NULL;\n        return prev;\n    }\n    cur -> next = reverseList(head, K);\n    return prev;\n}\n\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    int K;\n    cin >> K;\n\n    ListNode* head = GetList(num);\n\n    head = reverseList(head, K);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:18:05.078922+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 534,
      "input_format": "<p>The first line of input contains <i>N </i>- the length of the linked list.<br>The second line contains <i>N </i>space-separated integers denoting the sequence of elements in the linked list.<br>The third line contains an integer <i>K.</i></p><p>The following functions read the input</p><pre><code class=\"language-plaintext\">ListNode* GetList(vector&lt;int&gt; &amp;num)</code></pre>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "6\n1 2 3 4 5 6\n3",
          "output": "3 2 1 6 5 4"
        },
        {
          "input": "3\n1 3 2\n3",
          "output": "2 3 1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\nListNode* reverseList(ListNode* head, int K) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    int K;\n    cin >> K;\n\n    ListNode* head = GetList(num);\n\n    head = reverseList(head, K);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Reverse List - hard version",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Alice read <i>N</i> books. The <i>i</i>-th book has <i>A<sub>i</sub></i> pages. After every book Alice reads, you have to tell the largest integer <i>B</i> such that Alice has read <i>B</i> books that have at least <i>B</i> pages.</p>",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$  \n\n$1 \\leq N \\leq 10^5$  \n\n$1 \\leq A_i \\leq 10^5$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n \nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while(t--) {\n        int n;\n        cin >> n;\n        multiset<int> s;\n        int b = 1;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            cin >> x;\n            if(x > b) {\n                s.insert(x);\n            }\n            while(!s.empty() && *s.begin() <= b) {\n                s.erase(s.begin());\n            }\n            if(s.size() > b) {\n                b++;\n            }\n            cout << b << \" \";\n \n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n \nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while(t--) {\n        int n;\n        cin >> n;\n        int freq[100001] = {};\n        int b = 0, cnt = 0;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            cin >> x;\n            freq[x]++;\n            if(x > b) {\n                cnt++;\n            }\n            if(cnt > b) {\n                b++;\n                cnt -= freq[b];\n            }\n            cout << b << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:46:47.857302+00:00"
      },
      "hints": {
        "hint1": "<p>You need to store those integers which contain numbers greater than the current <i>B</i> books which have at least <i>B</i> pages and remove the rest. Think about how you can store these integers.</p>",
        "hint2": "Think of a data structure that can efficiently remove and insert integers.",
        "solution_approach": "Initially, the number of books read is 0. After each book is read, we need to update the answer. We can use priority queue/multiset to store the number of books. For each book read, you have to do the following:\n\n1. If the number of pages is greater than the current answer, add it in the priority queue/multiset.\n2. Remove the books which have pages not greater than the current answer.\n3. If the size of priority queue/multiset is greater than the current answer, increment the answer by 1.\n\n**Time Complexity per test case:** O(N*logN)\n\nA solution with linear time complexity is possible if we store the number of pages in each book in a frequency array. Initially, the number of books read is 0. For each book read, you have to do the following:\n\n1. Increase the frequency of the number of pages.\n2. If the number of pages is greater than the current answer, increase the count of books that have a greater number of pages than the current answer.\n3. If the count of books that have a greater number of pages than the current answer is greater than the current answer, increment the current answer by 1. This is because now we have more than cur books with at least cur number of pages. (here cur denotes the current answer). Reduce the frequency of the current answer from the count of books that have a greater number of pages than the current answer.\n\n**Time Complexity per test case:** O(N)"
      },
      "id": 84,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\nThe first line of each test case contains one integer N - the length of the array. \nThe second line of each test case contains N space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 1024000,
      "note": "In the first test case of the example, Alice reads N=4 books.\nAfter reading the 1st book, she has read 1 book with at least 1 page i.e. book with page 2.\nAfter reading the 2nd book, the answer remains the same as she has read 1 book with at least 1 page.\nAfter reading the 3rd book, she has read 2 books with at least 2 pages i.e. book with pages 2 and 4.\nAfter reading the 4th book, the answer remains the same as she has read 2 books with at least 2 pages.\n\nIn the third test case of the example, Alice reads N=5 books.",
      "output_format": "<p>For each test case, print <i>N</i> integers, <i>A<sub>1</sub>, A<sub>2</sub>, ... A<sub>N</sub></i>, where <i>A<sub>i</sub></i> is the largest integer <i>B</i> such that Alice has read <i>B</i> books that have at least <i>B</i> pages after reading the <i>i</i>-th book.</p>",
      "samples": [
        {
          "input": "4\n4\n2 1 4 4\n2\n5 1\n5\n1 3 2 3 5\n4\n3 3 3 3",
          "output": "1 1 2 2\n1 1\n1 1 2 2 3\n1 2 3 3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 10,
      "title": "Alice and Books",
      "video_editorial_id": 8143
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are <i>N</i> persons standing in the queue. They are numbered from 1 to <i>N</i>. <i>H<sub>i</sub></i> is the height of the person <i>i</i>. <i>P<sub>i</sub></i> is the number of persons who are taller than <i>i</i> and standing in front of <i>i</i>.&nbsp;<br>Given these two arrays <i>H</i> and <i>P</i>, your task is to find the actual order of the queue.&nbsp;<br>It is guaranteed that the height of each person will be unique.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>N</i> ≤ 10<sup>5</sup><br>1 ≤ <i>H<sub>i</sub></i> ≤ 10<sup>9</sup><br>0 ≤ <i>P<sub>i</sub></i> ≤ <i>N</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nint tree[4 * N];\n\nvoid build(int node, int start, int end) {\n    if(start == end) {\n        tree[node] = 1;\n        return;\n    }\n    int mid = (start + end) / 2;\n    build(2 * node, start, mid);\n    build(2 * node + 1, mid + 1, end);\n    tree[node] = tree[2 * node] + tree[2 * node + 1];\n    return;\n}\n\nvoid update(int node, int start, int end, int idx, int val) {\n    if(start == end) {\n        tree[node] = val;\n        return;\n    }\n    int mid = (start + end) / 2;\n    if(idx <= mid) update(2 * node, start, mid, idx, val);\n    else update(2 * node + 1, mid + 1, end, idx, val);\n    tree[node] = tree[2 * node] + tree[2 * node + 1];\n    return;\n}\n\nint query(int node, int start, int end, int x) {\n    if(start == end) {\n        assert(tree[node] == x);\n        return start;\n    }\n    int mid = (start + end) / 2;\n    if(tree[2 * node] >= x) return query(2 * node, start, mid, x);\n    return query(2 * node + 1, mid + 1, end, x - tree[2 * node]);\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n; cin >> n;\n\n    pair <int,int> p[n];\n    for(int i = 0; i < n; i++) {\n        cin >> p[i].first;\n        p[i].second = i;\n    }\n\n    int P[n];\n    for(int i = 0; i < n; i++) {\n        cin >> P[i];\n    }\n\n    sort(p, p + n);\n\n    build(1, 0, n - 1);\n\n    int ans[n];\n\n    for(int i = 0; i < n; i++) {\n        int h = p[i].first;\n        int j = p[i].second;\n\n        int pos = query(1, 0, n - 1, P[j] + 1);\n\n        ans[pos] = j;\n        update(1, 0, n - 1, pos, 0);\n    }\n\n    for(int i = 0; i < n; i++) {\n        cout << ans[i] + 1 << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:10.003913+00:00"
      },
      "hints": {
        "hint1": "<p>What can you say about the position of the shortest person? If the position of the shortest person is <i>i</i>, how many people would be in front of the shortest person?<br>Once you fix the position of the shortest person, what can you say about the position of the second shortest person?</p>",
        "hint2": "Sort people by heights. Then iterate from shortest to tallest. In each step, you need an efficient way to put the next person to the correct position. Notice that people we’ve already placed are not taller than the current person. And the people we place after are taller than the current. So we have to find a place such that the number of empty positions in the front is equal to the P value of this person.",
        "solution_approach": "<p>Please read Hint 2.<br>To make that approach more efficiently maintain a <i>K</i>th segment tree. This particular variation of the segment tree is already discussed in the module. Please go through them.</p>"
      },
      "id": 408,
      "input_format": "<p>The first line of input contains <i>N</i> - the number of persons.<br>The second line of input contains <i>N</i> space-separated numbers <i>H<sub>1</sub>, H<sub>2</sub>, …, H<sub>N</sub></i>.<br>The third line of input contains <i>N</i> space-separated numbers <i>P<sub>1</sub>, P<sub>2</sub>, …, P<sub>N</sub></i>.<br>It is guaranteed that the answer will always exist.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print <i>N</i> space-separated integers <i>p<sub>1</sub>, p<sub>2</sub>, …, p<sub>N</sub></i> - representing the actual order of the queue, where <i>p<sub>i</sub></i> is the person number standing at the <i>i</i>th position in the queue.</p>",
      "samples": [
        {
          "input": "6\n5 3 2 6 1 4\n0 1 2 0 3 2",
          "output": "1 2 3 5 4 6"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Order of Heights",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>For each prefix of a given string <i><strong>S</strong></i> with <i><strong>N</strong></i> characters consisting of lowercase characters, we want to know whether the prefix is a periodic string. That is, for each <i><strong>i (2 &lt;= i &lt;= N)</strong></i> we want to know the largest <i><strong>K &gt; 1</strong></i> (if there is one) such that the prefix of <i><strong>S</strong></i> with length <i><strong>i </strong></i>can be written as <i><strong>A<sup>K</sup></strong></i> , that is <i><strong>A</strong></i> concatenated <i><strong>K</strong></i> times, for some string <i><strong>A</strong></i>. Of course, we also want to know the period <i><strong>K</strong></i>. If there are multiple A<sup>K </sup>print the <strong>maximum value of K.</strong></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint abc = 1;\nint pi[100005];\n\nvoid prefix(string s) {\n    int n = s.size();\n    pi[0] = 0;\n    for (int i = 1; i < n; ++i) {\n        int j = pi[i-1];\n        while(j > 0 && s[i] != s[j]) {\n            j = pi[j-1];\n        }\n        if(s[i] == s[j]) {\n            j++;\n        }\n        pi[i] = j;\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        cout << \"Test case #\" << abc++ << \"\\n\";\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        prefix(s);\n        for (int i = 1; i < n; ++i) {\n            if((i+1)%(i+1-pi[i]) == 0 && (i+1)/(i+1-pi[i]) > 1) {\n                cout << i+1 << \" \" << (i+1)/(i+1-pi[i]) << \"\\n\";\n            }\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:28:19.718412+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Use the KMP algorithm for finding prefix function for the given string.</span></p>",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">If the prefix function for substring with length i is p[i], we would consider the period length as (i - p[i]). If this value is a multiple of the length i, then K = i / (i - p[i]). We can combine the prefix of length (i - p[i]) K times to get the prefix of length i.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time complexity per test case: O(N)</span></p>"
      },
      "id": 423,
      "input_format": "<p>The first line contains an integer <i>T, ( 1 ≤ T ≤ 10000)</i> - the number of test cases.</p><p>The first line of each test case contains an integer <i>N, ( 2 ≤ N ≤ 100000).</i></p><p>The second line contains a string <i>S</i> of length <i>N</i>.</p><p><i><strong>Sum of N across all test cases ≤ 10^6.</strong></i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(85,85,85);\">For each test case, output “Test case #” and the consecutive test case number on a single line; then, <strong>for each prefix with length </strong></span><strong>i</strong><span style=\"background-color:rgb(255,255,255);color:rgb(85,85,85);\"><strong> that has a period </strong></span><strong>K</strong><span style=\"background-color:rgb(255,255,255);color:rgb(85,85,85);\"><strong> &gt; 1, output the prefix size </strong></span><strong>i</strong><span style=\"background-color:rgb(255,255,255);color:rgb(85,85,85);\"><strong> and the largest period </strong></span><strong>K</strong><span style=\"background-color:rgb(255,255,255);color:rgb(85,85,85);\"><strong> separated by a single space;</strong> the prefix sizes must be in increasing order. Print a blank line after each test case.</span></p>",
      "samples": [
        {
          "input": "2\n9\nabababaab\n6\nffffff",
          "output": "Test case #1\n4 2\n6 3\n\nTest case #2\n2 2\n3 3\n4 4\n5 5\n6 6\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Period of a string",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given the heads of two singly linked-lists <i>headA</i> and <i>headB</i>, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return NULL.</p><p>Complete the function&nbsp;</p><pre><code class=\"language-plaintext\">ListNode* getIntersectionNode(ListNode* headA, ListNode* headB)</code></pre>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>N, M</i> ≤ 10<sup>5</sup><br>-1 ≤ <i>skipA </i>&lt; <i>N</i><br>-1 ≤ <i>skipB</i> &lt; <i>M</i><br>0 ≤ Value of the node ≤ 10<sup>9</sup><br>It's guaranteed that the input is valid.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    ListNode* l1 = headA, *l2 = headB;\n    while(l1 != l2) {\n        l1 = (l1 == NULL) ? headB : l1->next;\n        l2 = (l2 == NULL) ? headA : l2->next;\n    }\n    return l1;\n}\n\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\npair<ListNode*, ListNode*> GetList(vector<int> listA, vector<int> listB, int skipA, int skipB) {\n    ListNode* headA = GetList(listA);\n    \n    if(skipA == -1 && skipB == -1) {\n        ListNode* headB = GetList(listB);\n        return {headA, headB};    \n    }\n\n    vector<int> temp;\n    for(int i = 0; i < skipB; i++) {\n        temp.push_back(listB[i]);\n    }\n\n    ListNode* headB = GetList(temp);\n\n    ListNode* curA = headA;\n    for(int i = 0; i < skipA; i++) {\n        curA = curA->next;\n    }\n\n    if(!headB) headB = curA;\n    else {\n        ListNode* curB = headB;\n        while(curB->next) {\n            curB = curB->next;\n        }\n        curB->next = curA;\n    }\n\n    return {headA, headB};\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> listA(n);\n\n    for(int i = 0; i < n; i++) {\n        cin >> listA[i];\n    }\n\n    int m;\n    cin >> m;\n\n    vector<int> listB(m);\n\n    for(int i = 0; i < m; i++) {\n        cin >> listB[i];\n    }\n\n    int skipA, skipB;\n    cin >> skipA >> skipB;\n\n    pair<ListNode*,ListNode*> temp = GetList(listA, listB, skipA, skipB);\n\n    ListNode* headA = temp.first;\n    ListNode* headB = temp.second;\n\n    ListNode* ansHead = getIntersectionNode(headA, headB);\n\n    if(ansHead) {\n        cout << ansHead->val << \"\\n\";\n    }\n    else {\n        cout << \"-1\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:42:32.441588+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<h2><span style=\"background-color:transparent;color:#000000;\">Solution 1 (Brute Force)</span></h2><p><span style=\"background-color:transparent;color:#000000;\">Use a nested loop to iterate through both the linked lists and if they are equal at some point, return that node. If no node is found, return null.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Time Complexity:</i> Both the lists are iterated in a nested loop, the time complexity is O(n*m) where n, m are the number of nodes in the two linked lists.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Space Complexity:</i> Since constant extra memory is used, the space complexity is O(1).</span></p><p>&nbsp;</p><h2><span style=\"background-color:transparent;color:#000000;\">Solution 2 (Optimal Solution - 1)</span></h2><p><span style=\"background-color:transparent;color:#000000;\">Calculate the length of both the linked lists, say n and m. Let’s say n ≤ m(swap the linked lists if this is not the case), moves (m - n) steps from the head of the second linked list. At this point, both the nodes have the same number of nodes left, i.e. n. Simultaneously move both the head pointers until they are equal at some point. If no such node is found, return null.</span></p><p><span style=\"background-color:transparent;color:#000000;\"><i>Time Complexity:</i> Both the lists are iterated twice, the time complexity is O(n + m) where n, m are the number of nodes in the two linked lists.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Space Complexity:</i> Since constant extra memory is used, the space complexity is O(1).</span></p><p>&nbsp;</p><h2><span style=\"background-color:transparent;color:#000000;\">Solution 3 (Optimal Solution - 2)</span></h2><p><span style=\"background-color:transparent;color:#000000;\">In Solution 1, we were traversing both Linked Lists, A and B simultaneously. If we align the two linked lists like A+B and B+A. Here, the length of both the linked lists will be the same and so only one traversal through them can result in the answer.</span></p><p><span style=\"background-color:transparent;color:#000000;\">If A = [2,3,1,4] and B = [8,1,4]. The intersection point will be 1. The linked lists A+B and B+A can be represented as:</span></p><figure class=\"image\"><img src=\"https://lh4.googleusercontent.com/B7mkzCki_7xufyQR4Ol6kp-QAgifpfWq1GVkKy5f7-JKYaMH69dUArhCpts9HGreKG4pEio1pHmJSwfSGhv0deb1AsYXUS_yGm0N9fWds1CNh87PyJmbDDjDHcQim4nYqTGLcpgh\"></figure><p><span style=\"background-color:transparent;color:#000000;\"><i>Time Complexity:</i> Both the lists are iterated once, the time complexity is O(n + m) where n, m are the number of nodes in the two linked lists.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Space Complexity:</i> Since no extra memory is used, the space complexity is O(1).</span></p>"
      },
      "id": 537,
      "input_format": "<p>The first line of input contains <i>N </i>- the number of nodes in the first linked list.<br>The second line contains <i>N</i> space-separated numbers denoting the elements of the linked list.<br>The third line contains <i>M</i> - the number of nodes in the second linked list.<br>The fourth line contains <i>M</i> space-separated numbers denoting the elements of the linked list.<br>The last line of input contains <i>skipA</i> and <i>skipB</i>. If <i>skipA </i>= <i>skipB</i> = -1, then there is no intersection of two lists. Otherwise <i>listA</i>[<i>skipA + i</i>] == <i>listB</i>[<i>skipB + i</i>] for <i>i</i> = 1 to <i>N</i> - <i>skipA. </i>It's guaranteed that when <i>skipA</i> ≠ -1 and <i>skipB</i> ≠ -1, then <i>N - skipA</i> == <i>M - skipB</i>.</p><p>The following function parses the input</p><pre><code class=\"language-plaintext\">pair&lt;ListNode*, ListNode*&gt; GetList(vector&lt;int&gt; listA, vector&lt;int&gt; listB, int skipA, int skipB)</code></pre>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For the first test case:</p><figure class=\"image\"><img src=\"https://lh4.googleusercontent.com/R-xTVTBgbyu4nwesAjNaaR0pN81J7aOkb_dqKH6hOu8cgA4JiXqQwSrkcedBfx33obzgZd_XG1ugwSfT4C7EWNEZw-OeBx391w-zC6VI2uDWWLP88yHAWiF2ZOk0H3CMipIQ1POE\"></figure>",
      "output_format": "",
      "samples": [
        {
          "input": "5\n2 3 1 4 5\n6\n9 6 8 1 4 5\n2 3",
          "output": "1"
        },
        {
          "input": "4\n1 2 5 3\n3\n6 5 3\n2 1",
          "output": "5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\npair<ListNode*, ListNode*> GetList(vector<int> listA, vector<int> listB, int skipA, int skipB) {\n    ListNode* headA = GetList(listA);\n    \n    if(skipA == -1 && skipB == -1) {\n        ListNode* headB = GetList(listB);\n        return {headA, headB};    \n    }\n\n    vector<int> temp;\n    for(int i = 0; i < skipB; i++) {\n        temp.push_back(listB[i]);\n    }\n\n    ListNode* headB = GetList(temp);\n\n    ListNode* curA = headA;\n    for(int i = 0; i < skipA; i++) {\n        curA = curA->next;\n    }\n\n    if(!headB) headB = curA;\n    else {\n        ListNode* curB = headB;\n        while(curB->next) {\n            curB = curB->next;\n        }\n        curB->next = curA;\n    }\n\n    return {headA, headB};\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> listA(n);\n\n    for(int i = 0; i < n; i++) {\n        cin >> listA[i];\n    }\n\n    int m;\n    cin >> m;\n\n    vector<int> listB(m);\n\n    for(int i = 0; i < m; i++) {\n        cin >> listB[i];\n    }\n\n    int skipA, skipB;\n    cin >> skipA >> skipB;\n\n    pair<ListNode*,ListNode*> temp = GetList(listA, listB, skipA, skipB);\n\n    ListNode* headA = temp.first;\n    ListNode* headB = temp.second;\n\n    ListNode* ansHead = getIntersectionNode(headA, headB);\n\n    if(ansHead) {\n        cout << ansHead->val << \"\\n\";\n    }\n    else {\n        cout << \"-1\\n\";\n    }\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Intersection of Two Lists",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><strong>Pumbaa</strong> stores some secret information about a farm with <strong>n∗m </strong>apples represent a rectangle. Each apple has its own number. The order of apples on the farm is changing. That's why <strong>Pumbaa</strong> receives the following instructions:</p><ul><li>The instruction to swap two rows of the farm;</li><li>The instruction to swap two columns of the farm;</li><li>The instruction to obtain the number of the apple that exists in some cell.</li></ul><p>As poor <strong>Pumbaa</strong> is not clever, he asked clever <strong>Timon</strong> to execute these instructions.</p>",
      "complete_approach": "",
      "constraints": "<ul><li>1 ≤ n , m ≤ 1000</li><li>1 ≤ k ≤10<sup>6</sup></li><li>0 ≤ p ≤ 99</li><li>1 ≤ x , y ≤ m, n&nbsp;</li></ul>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvoid solve() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    int grid[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    int r[n], c[m]; // stores row's and column's indexes.\n\n    // initialising indexes of rows and columns.\n    for (int i = 0; i < n; i++)r[i] = i;\n    for (int j = 0; j < m; j++)c[j] = j;\n\n    // input and answer each query.\n    while (q--) {\n        int x, y;\n        char t;\n        cin >> t >> x >> y;\n        x--, y--; // 0-based indexing.\n        if (t == 'g') {\n            cout << grid[r[x]][c[y]] << endl;\n        }\n        else if (t == 'r') {\n            swap(r[x], r[y]); // swapping rows.\n        }\n        else {\n            swap(c[x], c[y]); // swapping columns.\n        }\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:30:11.812178+00:00"
      },
      "hints": {
        "hint1": "<p>For each query, you can't iterate over rows or columns to swap their values, it will exceed the Time limit, <strong>O(N) for each query.</strong><br>Try to optimize the operation per query.</p>",
        "hint2": "<p>Think about how can you perform each query in <strong>O(1)</strong> .</p>",
        "solution_approach": "<p>Create an array that stores the current row and column indices for the original row and column indices.<br>During row and column swaps operations, just swaps the respective row or column values in the indices array.<br>To answer ‘get’ query, use the current indices value present in the row and column indices.</p><p>See Editorial's Code for the Implementation.</p><p><strong>Time Complexity : O(max(N*M, K)) overall, O(1) per query.</strong></p>"
      },
      "id": 733,
      "input_format": "<p>The first line contains three space-separated integers <strong>n</strong>, <strong>m,</strong> and <strong>k</strong> - the number of farm rows and columns and the number of instructions, correspondingly.</p><p>Next <strong>n</strong> lines contain <strong>m</strong> space-separated numbers each — the initial state of the farm. Each number <strong>p</strong> in the table is an integer and satisfies the inequality.</p><p>Next <strong>k</strong> lines contain instructions in the format \"<strong>s<sub>i</sub></strong> <strong>x<sub>i</sub></strong> <strong>y<sub>i </sub></strong>\", where <strong>s<sub>i</sub></strong> is one of the characters \"<strong>с</strong>\", \"<strong>r</strong>\" or \"<strong>g</strong>\", and <strong>x<sub>i</sub></strong>, <strong>y<sub>i</sub></strong> are two integers.</p><p>-If <strong>s<sub>i</sub></strong> = \"<strong>c</strong>\", then the current instruction is to swap columns with indexes <strong>x<sub>i</sub></strong> and <strong>y<sub>i&nbsp;</sub></strong></p><p>-If <strong>s<sub>i</sub></strong> = \"<strong>r</strong>\", then the current instruction is to swap rows with indexes <strong>x<sub>i</sub></strong> and <strong>y<sub>i</sub></strong></p><p>-If <strong>s<sub>i</sub></strong> = \"<strong>g</strong>\", then the current instruction is to obtain the number located in the <strong>x<sup>th</sup></strong> row and in the <strong>y<sup>th</sup></strong> column.</p><p>The farm rows are considered to be indexed from top to bottom from 1 to <strong>n</strong>, and the farm columns — from left to right from 1 to <strong>m</strong>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>Let's see how the farm changes in the second test case.</p><p>After the first instruction is fulfilled, the table looks like that:</p><p>2 1 4</p><p>1 3 5</p><p>After the second instruction is fulfilled, the table looks like that:</p><p>1 3 5</p><p>2 1 4</p><p>So the answer to the third instruction (the number located in the first row and in the third column) will be 5.</p>",
      "output_format": "<p>For each instruction to obtain a number (<strong>s<sub>i</sub></strong>=\"<strong>g</strong>\") print the required number. Print the answers to the instructions in the order of the instruction in the input.</p>",
      "samples": [
        {
          "input": "3 3 5\n1 2 3\n4 5 6\n7 8 9\ng 3 2\nr 3 2\nc 2 3\ng 2 2\ng 3 2",
          "output": "8\n9\n6"
        },
        {
          "input": "2 3 3\n1 2 4\n3 1 5\nc 2 1\nr 1 2\ng 1 3",
          "output": "5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Hakuna Matata !",
      "video_editorial_id": 8220
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a tree with <i>n</i> vertices and a positive number <i>k</i>. Find the number of distinct pairs of the vertices that have a distance of exactly <i>k</i> between them. Note that pairs (<i>v</i>, <i>u</i>) and (<i>u</i>, <i>v</i>) are considered to be the same pair.</p><p>The <i>distance</i> between two vertices of a tree is the length (in edges) of the shortest path between these vertices.</p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:47.945601+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 449,
      "input_format": "- The first line contains an integer $T$ ($1 \\leq T \\leq 10^5$) - the number of test cases.\n\n- The first line of each test case contains two space-separated integers $N$, $K$ ($1 \\leq N \\leq 10^5$, $1 \\leq K \\leq 500$).\n\n- The next $N-1$ lines contain a description of an edge → $u_i$, $v_i$ ($1 \\leq u_i, v_i \\leq N$, $u_i \\neq v_i$). Vertices $u_i$ and $v_i$ are connected by an undirected edge.\n\n- It is guaranteed that the **sum** of all $N$ over all test cases does not exceed $10^5$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the number of distinct pairs of the tree's vertices which have a distance of exactly $k$ between them in a new line.",
      "samples": [
        {
          "input": "2\n10 3\n2 1\n3 1\n4 3\n5 4\n6 5\n7 1\n8 6\n9 2\n10 6\n10 2\n2 1\n3 1\n4 3\n5 4\n6 5\n7 1\n8 6\n9 2\n10 6",
          "output": "8\n10"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Tree Distance",
      "video_editorial_id": 8206
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Sort a singly linked list in O(NlogN) using merge sort. Here, N is the length of the linked list.</p><p>Complete the function</p><pre><code class=\"language-plaintext\">ListNode* mergesort(ListNode* head)</code></pre><p><i>head </i>is the pointer to the beginning of the list.</p>",
      "complete_approach": "",
      "constraints": "<p>0 ≤ N ≤ 10<sup>5</sup><br>0 ≤ Values stored in nodes ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* merge(ListNode* head1, ListNode* head2)\n{\n    ListNode* newhead = NULL;\n    ListNode* ans = NULL;\n    \n    while(head1 && head2) {\n        if(head1 -> val < head2 -> val) {\n            if(!newhead) {\n                newhead = head1;\n                ans = newhead;\n            }\n            else newhead -> next = head1, newhead = newhead -> next;\n            head1 = head1 -> next;\n            newhead -> next = NULL;\n        }\n        else {\n            if(!newhead) {\n                newhead = head2;\n                ans = newhead;\n            }\n            else newhead -> next = head2, newhead = newhead -> next;\n            head2 = head2 -> next;\n            newhead -> next = NULL;\n        }\n    }\n\n    while(head1) {\n        if(!newhead) {\n            newhead = head1;\n            ans = newhead;\n        }\n        else newhead -> next = head1, newhead = newhead -> next;\n        head1 = head1 -> next;\n        newhead -> next = NULL;\n    }\n\n    while(head2) {\n        if(!newhead) {\n            newhead = head2;\n            ans = newhead;\n        }\n        else newhead -> next = head2, newhead = newhead -> next;\n        head2 = head2 -> next;\n        newhead -> next = NULL;\n    }\n    return ans;\n}\n\nListNode* mergesort(ListNode* head) {\n    if(!head) return head;\n\n    ListNode *cur = head, *mid = head;\n    int cnt = 0;\n\n    while(cur) {\n        if(cnt & 1) mid = mid -> next;\n        cur = cur -> next;\n        cnt++;\n    }\n    \n    if(cnt == 1) return head;\n    \n    cur = head;\n    \n    while(cur -> next != mid) cur = cur -> next;\n    \n    cur -> next = NULL;\n    \n    ListNode *head1 = mergesort(head);\n    ListNode *head2 = mergesort(mid);\n    \n    return merge(head1, head2);\n}\n\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    ListNode* head = GetList(num);\n\n    head = mergesort(head);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:17:59.751741+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 531,
      "input_format": "",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "1\n2",
          "output": "2"
        },
        {
          "input": "5\n1 3 6 1 7",
          "output": "1 1 3 6 7"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\nListNode* mergesort(ListNode* head) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    ListNode* head = GetList(num);\n\n    head = mergesort(head);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Merge Sort on Linked List",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Find the Inorder Successor in BBST.\n\n*BBST - Balanced Binary Search Tree (height of BST is around $O(logN))$, where $N$ is the number of nodes in the tree.*\n\nIn Binary Tree, the Inorder successor of a node is the next node in the Inorder traversal of the Binary Tree. Inorder Successor is *NULL* for the last node in Inorder traversal. \n\nIn Binary Search Tree, the Inorder Successor of an input node can also be defined as the node with the smallest key greater than the key of the input node. So, finding the next node in sorted order is sometimes important.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$\nSum of $N$ across all test cases $\\leq 10^7$.",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node\n{\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n\nint successor(Node* curr, int k)\n{\n    if(curr==NULL)\n        return INT_MAX;\n    if(curr->val<=k)\n    {\n        return successor(curr->right,k);\n    }\n    return min(successor(curr->left,k),curr->val);\n}\n\nint getInorderSuccessor(Node* node, int k)\n{\n    int val = successor(node,k);\n    if(val==INT_MAX)\n        return -1;\n    return val;\n}\n\n\nNode *getBinaryTree(vector<int> &num, int *ind)\n{\n    if (num[*ind] == -1)\n        return NULL;\n    Node *node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num, ind);\n    (*ind)++;\n    node->right = getBinaryTree(num, ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n, q;\n        cin >> n >> q;\n        assert(n <= 1000000);\n        vector<int> arr(n);\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n        int ind = 0;\n        Node *tree = getBinaryTree(arr, &ind);\n        for (int i = 0; i < q; i++)\n        {\n            int k;\n            cin >> k;\n            cout << getInorderSuccessor(tree, k) << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:36:11.549917+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 673,
      "input_format": "The first line contains an integer $T$, the number of test cases.\nThe first line of each test case contains an integer $N$, $Q$ - the length of the array representing the serialized representation of a tree, and the number of queries.\nThe next line contains $N$-space-separated distinct integers. \nThe next line contains $Q$-space-separated integers. \n\nThe input is given as a serialized representation of a tree.\n\nThe following function parses the input:\n**Node* getBinaryTree(vector<int> &num, int*ind)**",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each query, print the inorder successor. If inorder successor does not exist, return $-1$.",
      "samples": [
        {
          "input": "1\n15 7\n333 218 71 -1 -1 323 -1 -1 657 545 -1 -1 715 -1 -1 \n813 58 148 224 851 594 880\n",
          "output": "-1 71 218 323 -1 657 -1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node\n{\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n</fix>\n\n\nint getInorderSuccessor(Node *node, int k)\n{\n    // Complete the function\n}\n\n<fix>\nNode *getBinaryTree(vector<int> &num, int *ind)\n{\n    if (num[*ind] == -1)\n        return NULL;\n    Node *node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num, ind);\n    (*ind)++;\n    node->right = getBinaryTree(num, ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n, q;\n        cin >> n >> q;\n        assert(n <= 1000000);\n        vector<int> arr(n);\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n        int ind = 0;\n        Node *tree = getBinaryTree(arr, &ind);\n        for (int i = 0; i < q; i++)\n        {\n            int k;\n            cin >> k;\n            cout << getInorderSuccessor(tree, k) << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Inorder Successor in BST",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given an $n \\times m$ $matrix$, Output a new matrix $answer$ where $answer[i][j]$ is the *rank* of $matrix[i][j]$.\n\nThe *rank* is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:\n\n1. The *rank* is a positive integer.\n2. If two elements $p$ and $q$ are in the same row or column, then: \n2.1 If $p < q$ then $rank(p) < rank(q)$.\n2.2 If $p == q$ then $rank(p) == rank(q)$.\n2.3 If $p > q$ then $rank(p) > rank(q)$.\n3. The *rank* should be as small as possible.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$\n$1 \\leq n, m \\leq 200$\n$-10^9 \\leq matrix[i][j] \\leq 10^9$\nThe Sum of $n \\times m$ over all test cases is $\\leq 10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvector<int> value;\nstruct DSU {\n\tunordered_map<int, int> parent;\n\tint Find(int u) {\n\t\tif (parent.count(u) == 0)parent[u] = -1; // using this make DSU at every step faster.\n\t\tif (parent[u] < 0)return u;\n\t\tparent[u] = Find(parent[u]);\n\t\treturn parent[u];\n\t}\n\tvoid Union(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u != v) {\n\t\t\tif (-parent[u] < -parent[v]) swap(u, v);\n\t\t\tparent[u] += parent[v];\n\t\t\tparent[v] = u;\n\t\t\tvalue[u] = max(value[u], value[v]);\n\t\t}\n\t}\n};\nvector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {\n\tmap<int, vector<vector<int>>> m;\n\tint r = matrix.size(), c = matrix[0].size();\n\tfor (int i = 0; i < r; i++) {\n\t\tfor (int j = 0; j < c; j++)m[matrix[i][j]].push_back({i, j});\n\t}\n\tvalue.assign(r + c, 0);\n\tvector<vector<int>> ans(r, vector<int>(c));\n\tfor (auto x : m) {\n\t\tDSU u;\n\t\tfor (auto y : x.second)u.Union(y[0], y[1] + r);\n\t\tfor (auto y : x.second) {\n\t\t\tans[y[0]][y[1]] = value[u.Find(y[0])] + 1;\n\t\t}\n\t\tfor (auto y : x.second) {\n\t\t\tvalue[y[0]] = max(value[y[0]], ans[y[0]][y[1]]);\n\t\t\tvalue[y[1] + r] = max(value[y[1] + r], ans[y[0]][y[1]]);\n\t\t}\n\t}\n\treturn ans;\n}\nvoid solve() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> mat(n, vector<int>(m));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++)cin >> mat[i][j];\n\t}\n\tauto ans = matrixRankTransform(mat);\n\tfor (auto x : ans) {\n\t\tfor (auto y : x)cout << y << \" \";\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:36:30.109098+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Let's build the rank based on values of elements in the matrix, starting from the smallest value.\nSo let group elements by their values, then sort in increasing order by their values.\n\n**Observation 1:** For cells with the same value, if there is a common in rows or columns then they must have the same rank, we need to group them together. We can use the UnionFind structure to group them together.\n\n**Observation 2:** The rank of elements in each group must be the maximum rank (plus one) of all included rows and columns.\nThus, we will find the maximum rank of all included rows and columns, then plus one.\n- Plus one because the rank is increasing, update all elements in the same group to a new rank.\n\n**Complexity**\n\nTime: $O(m*n*log(m*n))$, where $n \\leq 200$ is number of rows, $m \\leq 200$ is number of columns in the $matrix$.\n\nSpace: $O(m*n)$."
      },
      "id": 998,
      "input_format": "First line contains $T$ - the number of test cases.\nFirst line of each test case contains $n$ and $m$.\nNext $n$ lines of each test case contains $n \\times m$ $matrix$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, Output a new matrix $answer$ where $answer[i][j]$ is the *rank* of $matrix[i][j]$.\nAlso, Output a new line after every test case.",
      "samples": [
        {
          "input": "4\n\n4 4\n4 4 4 4 \n4 4 4 4\n4 4 4 4\n4 4 4 4\n\n2 2\n1 2\n3 4\n\n4 5\n-1 1  9 2 3\n 0 1 -1 5 6\n-1 5  9 0 3\n 5 6 -1 5 6\n\n 1 1\n 10\n",
          "output": "1 1 1 1 \n1 1 1 1 \n1 1 1 1 \n1 1 1 1 \n\n1 2 \n2 3 \n\n1 3 7 4 5 \n2 3 1 5 7 \n1 6 7 2 5 \n5 7 1 5 7 \n\n1 \n\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Matrix Rank Transform",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given N blocks. You have to build towers by placing blocks on top of each other with the condition that the upper block must be smaller than the lower block. You have to process the blocks in the given order. Find the minimum possible number of towers you can create.</p>",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$1 \\leq N \\leq 10^5$  \n\n$1 \\leq A_i \\leq 10^9$  \n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n#define int long long\n\nsigned main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    multiset<int> s;\n    for (int i = 0; i < n; ++i) {\n      int x;\n      cin >> x;\n      auto it = s.upper_bound(x);\n      if (it == s.end()) {\n        s.insert(x);\n      } else {\n        s.erase(it);\n        s.insert(x);\n      }\n    }\n    cout << s.size() << \"\\n\";\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:46:05.857809+00:00"
      },
      "hints": {
        "hint1": "Store the blocks in a multiset as you iterate through the array and find the maximum block which is strictly smaller than the current block. If it exists, put the current block there, otherwise, start a new tower.",
        "hint2": "",
        "solution_approach": "The key idea here is that we want to maintain a set of blocks that can be used as the top of a tower. Initially, the set is empty, so any block can be used to start a new tower. For each subsequent block, we want to find the smallest block in the set that is just greater than the current block. If such a block exists, we can add the current block to the top of that tower by replacing the old block in the set with the new block. Otherwise, we must start a new tower with the current block and insert this number in the set. By maintaining this set, we can ensure that we always use the smallest possible block as the top of each tower, which will minimize the total number of towers required.\nFor each test case:\n* Read the number of blocks.\n* Create an empty multiset to keep track of the blocks used to build towers.\n* For each block in the given order:\n    * Find the iterator to the smallest element in the multiset that is greater than the current block.\n    * If such an iterator is not found (i.e., the current block is greater than all blocks in the multiset), insert the block into the multiset.\n    * If such an iterator is found, erase that element from the multiset and insert the current block.\n    * The size of the multiset after all blocks have been processed gives the minimum number of towers that can be built.\nTime Complexity per test case: $O(N \\log N)$"
      },
      "id": 362,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\n\nThe first line of each test case contains one integer $N$ - the length of the array.\n\nThe second line of each test case contains $N$ space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, the towers would be: [3, 2, 1] and [5, 4].\n\nFor the second test case, the towers would be: [1], [1], [1], [1].\n\nFor the third test case, the towers would be: [5, 4, 3] and [5, 2].",
      "output_format": "<p>For each test case, print the minimum possible number of towers you can create.</p>",
      "samples": [
        {
          "input": "3\n5\n3 2 5 1 4\n4\n1 1 1 1\n5\n5 4 5 3 2 \n",
          "output": "2\n4\n2\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Towers AZ101",
      "video_editorial_id": 8186
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Find all valid combinations of <strong>k</strong> numbers that sum up to <strong>n</strong> such that the following conditions are true:</p><ul><li>Only numbers <strong>1</strong> through <strong>9</strong> are used.</li><li>Each number is used <strong>at most once</strong>.</li></ul><p>Return <i>a list of all possible valid combinations</i>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>",
      "complete_approach": "",
      "constraints": "<ul><li>2 ≤ k ≤ 9</li><li>1 ≤ n ≤ 60</li></ul>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvector<int> temp;\nvector<vector<int>> ans;\nvoid solve(int i, int &k, int sum, int &n) {\n    if (sum > n)return ; // pruning.\n    if (i == 10) { // base\n        if (temp.size() == k && sum == n)ans.push_back(temp);\n        return;\n    }\n    // not taking i in the combination.\n    solve(i + 1, k, sum, n);\n\n    // taking i into combination.\n    temp.push_back(i);\n    solve(i + 1, k, sum + i, n);\n    temp.pop_back(); // backtracking.\n}\nvector<vector<int>> combinationSum(int k, int n) {\n    ans.clear();\n    solve(1, k, 0, n);\n    return ans;\n}\n\nvoid checker() {\n    int k, n;\n    cin >> k >> n;\n    vector<int> t;\n    auto v = combinationSum(k, n);\n    for (auto &x : v) {\n        sort(x.begin(), x.end());\n    }\n    sort(v.begin(), v.end());\n    for (auto x : v) {\n        for (auto y : x)cout << y << \" \";\n        cout << endl;\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        checker();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:44:07.718048+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 869,
      "input_format": "<p>Complete the function <i><strong>combinationSum(k, n).</strong></i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Return <i>a list ( </i><strong>vector&lt;vector&lt;int&gt;&gt; </strong><i>) of all possible valid combinations</i>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>",
      "samples": [
        {
          "input": "3 9",
          "output": "1 2 6\n1 3 5\n2 3 4"
        },
        {
          "input": "4 1",
          "output": " "
        },
        {
          "input": "9 45",
          "output": "1 2 3 4 5 6 7 8 9"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n</fix>\n\n\nvector<vector<int>> combinationSum(int k, int n) {\n    // write code here.\n}\n\n<fix>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid checker() {\n    int k, n;\n    cin >> k >> n;\n    vector<int> t;\n    auto v = combinationSum(k, n);\n    for (auto &x : v) {\n        sort(x.begin(), x.end());\n    }\n    sort(v.begin(), v.end());\n    for (auto x : v) {\n        for (auto y : x)cout << y << \" \";\n        cout << endl;\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        checker();\n        // i++;\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Combination Sum II",
      "video_editorial_id": 8230
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given a binary tree with $n$ nodes. Each node has an integer value associated with it. Your task is to print the leaf nodes and then remove these leaf nodes. Now, return the new leaf nodes and repeat the process until the tree becomes empty.\n#### Note:\n- You don’t require to remove the leaf nodes. Just print the values in the required order.\n- The leaf nodes must be stored in a left to right order.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^4$ - the number of test cases.\n$1 \\leq n \\leq 10^5$ - number of nodes in binary tree.\n$1 \\leq value \\leq 10^5$ - value of nodes in binary tree.\nSum of $n$ over all test cases is $\\leq 10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstruct TreeNode\n{\t// TreeNode Definition.\n\tint data;\n\tTreeNode *left;\n\tTreeNode *right;\n\tTreeNode(int x) : data(x), left(nullptr), right(nullptr) {}\n};\n\n\nclass Solution {\npublic:\n\tmap<int, vector<int>> m;\n\tint dfs(TreeNode *root) {\n\t\tif (root == nullptr)return 0;\n\t\tint d = 0;\n\t\tif (root->left && !root->right)d = 1 + dfs(root->left);\n\t\telse if (root->right && !root->left)d = 1 + dfs(root->right);\n\t\telse if (root->left && root->right) {\n\t\t\td = 1 + dfs(root->left);\n\t\t\td = max(d, 1 + dfs(root->right)); // in max, flow is from right to left.\n\t\t}\n\t\telse d = 0;\n\t\tm[d].push_back(root->data);\n\t\treturn d;\n\t}\n\tvector<vector<int>> findLeaves(TreeNode * root) {\n\t\tvector<vector<int>> ans;\n\t\tm.clear();\n\t\tdfs(root);\n\t\tfor (auto v : m)ans.push_back(v.second);\n\t\treturn ans;\n\t}\n};\n\n// Decodes your encoded data to tree.\nTreeNode *deserialize(string data)\n{\n\tif (data.size() == 0)\n\t\treturn nullptr;\n\tvector<string> dat;\n\tstring t;\n\tfor (auto c : data)\n\t{\n\t\tif (c == ',')\n\t\t{\n\t\t\tdat.push_back(t);\n\t\t\tt.clear();\n\t\t}\n\t\telse\n\t\t\tt.push_back(c);\n\t}\n\tdat.push_back(t);\n\tint i = 0;\n\tqueue<TreeNode *> q;\n\tTreeNode *root = new TreeNode(stoll(dat[0]));\n\tq.push(root);\n\tauto cur = root;\n\ti++;\n\twhile (!q.empty())\n\t{\n\t\tauto x = q.front();\n\t\tq.pop();\n\t\tif (dat[i] != \"x\")\n\t\t{\n\t\t\tx->left = new TreeNode(stoll(dat[i]));\n\t\t\tq.push(x->left);\n\t\t}\n\t\ti++;\n\t\tif (dat[i] != \"x\")\n\t\t{\n\t\t\tx->right = new TreeNode(stoll(dat[i]));\n\t\t\tq.push(x->right);\n\t\t}\n\t\ti++;\n\t}\n\treturn root;\n}\n\nvoid solve() {\n\tstring s;\n\tcin >> s;\n\tSolution sol;\n\tauto root = deserialize(s);\n\tauto ans = sol.findLeaves(root);\n\tfor (auto x : ans) {\n\t\tfor (auto y : x)cout << y << \" \";\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:16:29.835154+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "The approach is to do a Depth First Traversal. For every node, we calculate the order of that node and then push the value of that node in the corresponding vector. The order of a node denotes the number of steps required to remove that node from the tree. The initial set of leaf nodes will have the order 1. After removing them, the next set of leaf nodes will have order 2 and so on and so forth.\n\n \n\nSteps:\n- Calculate the height of the tree and store it in a variable,  say $heightOfTree$.\n- Now, create a vector of vectors, say $allLeaves$, to store all the values in the required order. The size of allLeaves must be equal to $heightOfTree$.\n- Now, call the recursive function, $storeLeaves(allLeaves, root)$. This function will fill this vector with all the values in the required order.\n- Now, we simply return $allLeaves$.\n \n\nint height(TreeNode *root) \n- If node is not present, its height would be considered 0, so return 0.\n- The height of a node is 1 more than the maximum height among the height of the left subtree and the right subtree. So, return $1+max(height(root->left), height(root->right))$.\n \n\nint storeLeaves(vector<vector<int>> &allLeaves, TreeNode *root) \n- If the node is not present, return 0, as the order of a non-existing node is considered 0\n- The order of a node is 1 more than the maximum order among the order of the left subtree and the right subtree. Note that we are calling the recursive function for the right subtree before the left subtree. This is done to maintain the left to right order of nodes. So, define $currLeafOrder = 1+max(storeLeaves(root->right), storeLeaves(root->left))$.Now, we can simply push the value of the current node to the vector which contains all the nodes that have the same order. So, $allLeaves[currLeafOrder-1].pushback(root->data)$.\n- Return $currLeafOrder$.\n\n**Time Complexity -:** $O(n)$, where $n$ is the number of nodes in the given binary tree.\n\n We are calculating the height of the tree, which takes $O(n)$ time. After that, we visit each node only once and push its value in the corresponding vector, so the overall complexity remains $O(n)$.\n\n**Space Complexity -:** $O(n)$, where $n$ is the number of nodes in the given binary tree.\n\n We need extra linear space to maintain an array that will store all the nodes’ values in the required order."
      },
      "id": 1049,
      "input_format": "Complete the function ```vector<vector<int>> findLeaves(TreeNode* root)``` that takes root of the binary tree as input.\n\nFor local testing of the sample, the first line contains $T$, the number of test cases. The first line of each test case contains  the level order traversal of the tree, where *'$x$'* denotes the *'nullptr'*.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "for test case 1,\n```\n    1\n   / \\\n  2   3\n / \\     \n4   5   \n```\nOutput\n```\n[[4,5,3],[2].[1]]\n```\nfor test case 2,\n```\n    1\n   / \\\n  2   3\n /\n4 \n```\nOutput\n```\n[[4,3],[2],[1]]\n```",
      "output_format": "Return the nodes as a ```vector<vector<int>>``` where each series of removal will be stored in ```vector<int>```.\nThe leaf nodes must be stored in a left to right order for each series of removal.",
      "samples": [
        {
          "input": "2\n1,2,3,4,5,x,x,x,x,x,x\n1,2,3,4,x,x,x,x,x\n",
          "output": "4 5 3 \n2 \n1 \n\n4 3 \n2 \n1 \n\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstruct TreeNode\n{\t// TreeNode Definition.\n\tint data;\n\tTreeNode *left;\n\tTreeNode *right;\n\tTreeNode(int x) : data(x), left(nullptr), right(nullptr) {}\n};\n</fix>\n\n<fix>\nclass Solution {\npublic:\n</fix>\n<fix>\n\tvector<vector<int>> findLeaves(TreeNode * root) {\n</fix>\n\t\t// write code here....\n\t\treturn {{}};\n<fix>\n\t}\n</fix>\n<fix>\n};\n</fix>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<fix>\n// Decodes your encoded data to tree.\nTreeNode *deserialize(string data)\n{\n\tif (data.size() == 0)\n\t\treturn nullptr;\n\tvector<string> dat;\n\tstring t;\n\tfor (auto c : data)\n\t{\n\t\tif (c == ',')\n\t\t{\n\t\t\tdat.push_back(t);\n\t\t\tt.clear();\n\t\t}\n\t\telse\n\t\t\tt.push_back(c);\n\t}\n\tdat.push_back(t);\n\tint i = 0;\n\tqueue<TreeNode *> q;\n\tTreeNode *root = new TreeNode(stoll(dat[0]));\n\tq.push(root);\n\tauto cur = root;\n\ti++;\n\twhile (!q.empty())\n\t{\n\t\tauto x = q.front();\n\t\tq.pop();\n\t\tif (dat[i] != \"x\")\n\t\t{\n\t\t\tx->left = new TreeNode(stoll(dat[i]));\n\t\t\tq.push(x->left);\n\t\t}\n\t\ti++;\n\t\tif (dat[i] != \"x\")\n\t\t{\n\t\t\tx->right = new TreeNode(stoll(dat[i]));\n\t\t\tq.push(x->right);\n\t\t}\n\t\ti++;\n\t}\n\treturn root;\n}\n\nvoid solve() {\n\tstring s;\n\tcin >> s;\n\tSolution sol;\n\tauto root = deserialize(s);\n\tauto ans = sol.findLeaves(root);\n\tfor (auto x : ans) {\n\t\tfor (auto y : x)cout << y << \" \";\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "Leaves Removal",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given an undirected graph <i>G</i> with <i>N</i> nodes and <i>M</i> edges. You've to answer <i>Q</i> queries. Each query is either of the following two types:</p><ul><li>1 <i>X</i>: Print the size of the connected components containing node <i>X</i>.</li><li>2 <i>X</i> <i>Y</i>: Print ‘YES’ (without quotes) if node <i>X</i> and <i>Y</i> belong to the same connected component, else print ‘NO’ (without quotes).</li></ul>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nvector<int> graph[N];\nint sz[N], id[N];\nint CUR_ID = 1;\nbool visited[N];\n\nvoid dfs(int cur) {\n    if(visited[cur]) return;\n    visited[cur] = true;\n    id[cur] = CUR_ID;\n    sz[CUR_ID]++;\n    for(int u : graph[cur])\n        dfs(u);\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    for(int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    for(int i = 1; i <= n; i++) {\n        if(!visited[i]) {\n            dfs(i);\n            CUR_ID++;\n        }\n    }\n\n    while(q--) {\n        int t; cin >> t;\n        if(t == 1) {\n            int x; cin >> x;\n            cout << sz[id[x]] << \"\\n\";\n        }\n        else {\n            int x, y;\n            cin >> x >> y;\n            if(id[x] == id[y]) cout << \"YES\\n\";\n            else cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:43:59.963442+00:00"
      },
      "hints": {
        "hint1": "<p>Use DFS!</p>",
        "hint2": "<p>Run DFS and mark each connected components by a unique id.</p>",
        "solution_approach": "<p>Run DFS and for every node that will be visiting in the DFS mark them by a unique identifier. For that identifier maintain a count of a number of nodes equals to that unique identifier. For query of first type, you need to directly print the stored count of the unique identifier for the node X. For the query of the second type, you only need to only compare their unique id.</p><p>See the editorial code for a more detailed explanation.</p>"
      },
      "id": 400,
      "input_format": "<p>The first line of input contains three space-separated integers <i>N</i>, <i>M</i>, and <i>Q </i>(1 ≤ <i>N, M, Q</i> ≤ 10<sup>5</sup>).<br>Next <i>M</i> lines contain two space-separated integers <i>u</i> and <i>v </i>(1 ≤ <i>u, v</i> ≤ <i>N</i>).<br>Each of the next <i>Q</i> lines contains queries of one of the types as described in the statement.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print <i>Q</i> lines as the answer to the <i>Q</i> queries, each on a new line.</p>",
      "samples": [
        {
          "input": "6 5 5\n1 2\n2 3\n1 3\n4 4\n5 6\n1 2\n1 4\n2 3 4\n1 5\n2 5 6",
          "output": "3\n1\nNO\n2\nYES"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Easy Graph Queries",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a tree of $n$ nodes, your task is to find a *centroid*, i.e., a node such that when it is appointed the root of the tree, each subtree has at most $⌊n/{2}⌋$ nodes.",
      "complete_approach": "",
      "constraints": "$ 1 ≤ n ≤ 2⋅10^{5}$\n$ 1 ≤ a , b ≤ n $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint n;\nvector<vector<int>> adj;\nvector<int> cnt, centroids;\nvoid dfs(int v, int p) {\n    cnt[v] = 1;\n    bool is_centroid = true;\n    for (auto x : adj[v]) {\n        if (p == x)continue;\n        dfs(x, v);\n        cnt[v] += cnt[x];\n        if(cnt[x]>n/2)is_centroid=false;\n    }\n    // the nodes in the subtree are all now computed.\n\tif(n-cnt[v]>n/2) is_centroid = false;\n    if(is_centroid) centroids.push_back(v);\n}\n\nvoid solve() {\n    cin >> n;\n    adj.assign(n + 1, vector<int>());\n    cnt.assign(n + 1, 0);\n    int u, v;\n    for (int i = 0; i < n - 1; i++) {\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    dfs(1, -1);\n    cout<< *min_element(centroids.begin(),centroids.end())<<endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:40:16.261365+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We can find a centroid in a tree by starting at the root. Each step, loop through all of its children. If all of its children have subtree size less than or equal to $\\frac{N}{2}$, then it is a centroid. Otherwise, move to the child with a subtree size that is more than $\\frac{N}{2}$ and repeat until you find a centroid.\n\nTime Complexity : DFS ~ $O(N+M)$"
      },
      "id": 896,
      "input_format": "The first input line contains an integer n: the number of nodes. The nodes are numbered 1,2,…,n.\n\nThen there are $n−1$ lines describing the edges. Each line contains two integers $a$ and $b$: there is an edge between nodes $a$ and $b$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print one integer: a centroid node. If there are several possibilities, print the smallest one.",
      "samples": [
        {
          "input": "5\n1 2\n2 3\n3 4\n3 5\n",
          "output": "3\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Centroid",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Using characters: . (dot), * (asterisk), / (slash) and \\ (backslash) print a grid-like pattern as shown in the sample test case.",
      "complete_approach": "",
      "constraints": "- $1 \\leq T \\leq 100$\n- $1 \\leq N, M \\leq 100$\n- $1 \\leq P \\leq 100$\n\nIt is guaranteed that the sum of $N \\times M \\times P \\times P$ for all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m, p;\n        cin >> n >> m >> p;\n        for (int i = 0; i < (p+1)*n+1; ++i) {\n            for (int j = 0; j < (p+1)*m + 1; ++j) {\n                if(i%(p+1) == 0 || j%(p+1) == 0) cout<<\"*\";\n                else if((i+j)%((p+1)*2)==0) cout<<\"/\";\n                else if((i-j)%((p+1)*2)==0) cout<<\"\\\\\";\n                else cout<<\".\";\n            }\n            cout<<\"\\n\";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:15:03.931280+00:00"
      },
      "hints": {
        "hint1": "The total number of rows would be(P+1)*N+1 and columns would be (P+1)*M+1.",
        "hint2": "The left and right diagonal equate for (i+j) and (i-j) respectively.",
        "solution_approach": "<p>>An index will have * (asterisk) if its row/column number is a multiple of (p+1)(0-indexing), / (slash) if (i+j) is a multiple of (p+1), \\ (backslash) if (i-j) is a multiple of (p+1), otherwise character would be . (dot).</p><p>Time Complexity per test case: O(N*M*P*P)</p>"
      },
      "id": 318,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains three space-separated integers N, M, P. - P denotes the size of .(dot) and /,\\(slash) block.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "The diagonal of the first square of the grid is directed towards the down-right corner, use the \\ (backslash) character to print it, while the next diagonal will be directed towards the upper-right corner, use the / (slash) character to print it.",
      "output_format": "For each test case, print the required pattern.",
      "samples": [
        {
          "input": "3\n3 4 3\n4 2 1\n3 3 2\n",
          "output": "*****************\n*\\..*../*\\..*../*\n*.\\.*./.*.\\.*./.*\n*..\\*/..*..\\*/..*\n*****************\n*../*\\..*../*\\..*\n*./.*.\\.*./.*.\\.*\n*/..*..\\*/..*..\\*\n*****************\n*\\..*../*\\..*../*\n*.\\.*./.*.\\.*./.*\n*..\\*/..*..\\*/..*\n*****************\n\n*****\n*\\*/*\n*****\n*/*\\*\n*****\n*\\*/*\n*****\n*/*\\*\n*****\n\n**********\n*\\.*./*\\.*\n*.\\*/.*.\\*\n**********\n*./*\\.*./*\n*/.*.\\*/.*\n**********\n*\\.*./*\\.*\n*.\\*/.*.\\*\n**********"
        },
        {
          "explanation": "An index will have * (asterisk) if its row/column number is a multiple of (p+1)(0-indexing), / (slash) if (i+j) is a multiple of (p+1), \\ (backslash) if (i-j) is a multiple of (p+1), otherwise character would be . (dot).\n\nTime Complexity per test case: O(N*M*P*P)",
          "input": "1\n3 1 3",
          "output": "*****\n*\\..*\n*.\\.*\n*..\\*\n*****\n*../*\n*./.*\n*/..*\n*****\n*\\..*\n*.\\.*\n*..\\*\n*****"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Pattern Problem 2 AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given $Q$ queries and have to perform the following operations:\n\n1. **add x** - Add element $x$ to the set.  \n2. **erase x** - Delete the element with value $x$, if it exists.  \n3. **find x** - If $x$ is present, print “YES”; otherwise, print “NO”.  \n4. **print** - Print the values in the set.  \n5. **empty** - Empty the set.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$1 \\leq Q \\leq 10^5$  \n\n$1 \\leq X \\leq 10^6$  \n\nIt is guaranteed that the sum of $Q$ over all test cases does not exceed $10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int q;\n    cin >> q;\n    set<int> st;\n    while (q--) {\n      string s;\n      cin >> s;\n      if (s == \"add\") {\n        int x;\n        cin >> x;\n        st.insert(x);\n      } else if (s == \"erase\") {\n        int x;\n        cin >> x;\n        auto it = st.find(x);\n        if (it != st.end()) {\n          st.erase(it);\n        }\n      } else if (s == \"find\") {\n        int x;\n        cin >> x;\n        if (st.find(x) != st.end()) {\n          cout << \"YES\\n\";\n        } else {\n          cout << \"NO\\n\";\n        }\n      } else if (s == \"print\") {\n        for (int i : st) {\n          cout << i << \" \";\n        }\n        cout << \"\\n\";\n      } else {  // empty\n        st.clear();\n      }\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:44:17.353731+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Use `insert(x)` for adding element to set\nUse `erase(x)` for deleting the element with value x, but first check using `find(x)` if the element x is in the set or not\nUse `find(x)` for finding the iterator to the element\nUse `clear()` for emptying the set\nTime Complexity per test case: $O(Q \\times \\log N)$ where N is the size of the set"
      },
      "id": 356,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\n\nThe first line of each test case contains one integer $Q$ - the number of queries.\n\nEach of the next $Q$ lines contains a query.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "1. Set becomes: [3]  \n2. Set becomes: [2, 3]  \n3. Set becomes: [2, 3, 7]  \n4. Set is: 2, 3, 7.  \n5. 2 exists in the set  \n6. Set becomes: [3, 7]  \n7. 2 does not exist in the set",
      "output_format": "<p>For each test case, print the required queries.</p>",
      "samples": [
        {
          "input": "1\n7\nadd 3\nadd 2\nadd 7\nprint\nfind 2\nerase 2\nfind 2\n",
          "output": "2 3 7 \nYES\nNO\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Set AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a positive integer N, count the total number of set bits in binary representation of all numbers from 1 to N.",
      "complete_approach": "",
      "constraints": "<p><i>1 ≤ T ≤ 10<sup>5</sup></i></p><p><i>0 ≤ N ≤ 10<sup>8</sup></i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countSetBits(int n)\n{\n    if (n == 0)\n        return 0;\n    int left;\n    for (left = 30; left >= 0; left--)\n    {\n        if (n & (1 << left))\n            break;\n    }\n    if ((1 << (left + 1)) - 1 == n)\n        return (left + 1) * (1 << left);\n    return n + 1 - (1 << left) + countSetBits(n ^ (1 << left)) + countSetBits((1 << left) - 1);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        cout << countSetBits(n) << '\\n';\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:14:07.089475+00:00"
      },
      "hints": {
        "hint1": "<p>Can you come up with a recursive formula to count total bits?</p>",
        "hint2": "<p>How many total bits are there if N = 2<sup>K</sup>-1, i.e, it has binary representation 1111….1111.</p>",
        "solution_approach": "<p>The problem can be solved with recursion. The base case for the recursion can be:<br>1. If N=0: return 0<br>2. If N=2<sup>K </sup>- 1: The number of set bits and unset bits in all the numbers from 0 to N is equal. So the number of set bits can be (<i>len</i> + 1) * (N + 1) / 2, where <i>len</i> is the number of bits in <i>N.</i></p><p>If <i>N</i> is not of the form 2<sup>K </sup>- 1, let the leftmost bit be <i>left</i>, then the count of the <i>left</i> bit will be equal to <i>N + 1 - (1 &lt;&lt; left). </i>Now solve the subproblems for N = N ^ (1 &lt;&lt; <i>left</i>) and N = (1 &lt;&lt; left) - 1</p>"
      },
      "id": 639,
      "input_format": "The first line contains a single integer T - the number of test cases.\nT lines follow each containing a single integer N.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For <i>N</i> = 4:<br>1 : 001<br>2 : 010<br>3 : 011<br>4 : 100<br>Total number of set bits is 1+1+2+1 = 5</p>",
      "output_format": "For each test case print the number of set bits in all numbers from 1 to N.",
      "samples": [
        {
          "input": "4\n3\n4\n7\n8",
          "output": "4\n5\n12\n13"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint countSetBits(int n)\n{\n    //add code here\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        cout << countSetBits(n) << '\\n';\n    }\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "COUNTBIT",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers, find the number of subarrays with at most <i>K</i> distinct elements.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll freq[1000001];\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ll testcases;\n    cin >> testcases;\n    while (testcases--)\n    {\n        ll n, k;\n        cin >> n >> k;\n        ll arr[n];\n        for (ll i = 0; i < n; i++)\n            cin >> arr[i], freq[arr[i]] = 0;\n        ll ans = 0;\n        ll start = 0;\n        ll current = 0;\n        ll currSum = 0;\n        while (current < n)\n        {\n            freq[arr[current]]++;\n            if (freq[arr[current]] == 1)\n                currSum++;\n            while (start <= current and currSum > k)\n            {\n                if (freq[arr[start]] == 1)\n                    currSum--;\n                freq[arr[start]]--;\n                start++;\n            }\n            ans += (current - start + 1);\n            current++;\n        }\n        cout << ans << \"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:36.723574+00:00"
      },
      "hints": {
        "hint1": "If one of our subarray is between [L,R] we can for surely say that for the subarray starting from L+1 our desired subarray will be R' such that R' >= R. This allows us to apply the 2 pointer approach for this problem.",
        "hint2": "We use two pointers, start and current, to keep track of the window. We maintain an array freq to keep track of the frequency of each element in the current window.\n\nFor each subarray check using a frequency array how many distinct elements are there at a particular instant. Whenever we exceed K we make that as our right pointer boundary.",
        "solution_approach": "We loop through the array using current pointer. For each element arr[current], we update its frequency in the freq array. If its frequency becomes 1, we increment currSum.\n\nWe check if currSum is greater than K. If it is, we move the start pointer to the right and decrement the frequency of the element at arr[start] in the freq array. If its frequency becomes $0$, we decrement currSum.\n\nWe update the answer by adding the number of subarrays that end at the current pointer. The number of subarrays is equal to (current - start + 1).\n\nWe continue this process until we have covered the entire array.\n\n**Time Complexity : $O( N )$**"
      },
      "id": 60,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases <i>(1&lt;=T&lt;=10)</i>.</p><p>The first line contains two space-separated integers <i>N, K</i> where <i>1&lt;=N&lt;=10^5, 0&lt;=K&lt;=10^5</i>.</p><p>Next line contains <i>N</i> space-separated integers <i>(0&lt;=Ai&lt;=1e6)</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the number of subarrays with at most <i>K</i> distinct elements in a newline.</p>",
      "samples": [
        {
          "input": "5\n3 2\n1 2 3\n3 2\n3 2 2\n5 0\n2 1 0 4 0\n7 3\n1 2 1 0 1 0 2\n10 5\n1 0 7 1 10 2 4 10 1 3",
          "output": "5\n6\n0\n28\n46"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Number of Subarray with at most K distinct",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string $S$. Print number of words in it.\n\n$\\textbf{Word}$ : consists of $\\textbf{lowercase}$ and $\\textbf{uppercase}$ English letters.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq |S| \\leq 10^6 $ where $|S|$ is the length of the string and it consists of $\\textbf{lowercase}$ and $\\textbf{uppercase}$ English letters, spaces and ('!', '.', '?' and ',') symbols.",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    string s, temp;\n    getline(cin, s);\n    int n = s.size();\n    set<char> check;\n    check.insert('!'); check.insert('.');\n    check.insert('?'); check.insert(',');\n    check.insert(' ');\n    int ans = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (check.find(s[i]) == check.end()) {\n            temp += s[i];\n        }\n        if ((i == n - 1 || check.find(s[i]) != check.end()) && temp.size() > 0) {\n            ans++;\n            temp = \"\";\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:37:53.965993+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We traverse the string and maintain a temp string and in that string we add the english alphabets (('a' to 'z') or ('A' to 'Z')) we counter in the input string if there exists a non alphabet ('!', '?', ',', '.',' ') then we found one word so we clear our temp string and increment our answer."
      },
      "id": 1197,
      "input_format": "Only one line contains $S$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the number of words in the given string.",
      "samples": [
        {
          "input": "Meep Meep!\n",
          "output": "2\n"
        },
        {
          "input": "I tot I taw a putty tat.\n",
          "output": "7\n"
        },
        {
          "input": "Shsssssssssh ... I am hunting wabbits. Heh Heh Heh Heh ...\n",
          "output": "9\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Count Words",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a row wise sorted matrix A of size <i>N x M, </i>where <i>N </i>and <i>M</i> are always odd, find the median of the matrix.</p>",
      "complete_approach": "",
      "constraints": "<p><i>1 ≤ N,M ≤ 1000</i><br><i>1 ≤ A[i] ≤ 10</i><sup>6</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint MedianInMatrix(vector<vector<int>> &a)\n{\n    int n = (int)a.size();\n    int m = (int)a[0].size();\n\n    int l = 1, r = 1e6, ans;\n\n    while (l <= r)\n    {\n        int mid = (l + r) / 2;\n        int cnt = 0;\n\n        for (int i = 0; i < n; i++)\n        {\n            auto it = lower_bound(a[i].begin(), a[i].end(), mid);\n\n            if (it == a[i].begin())\n                continue;\n\n            it--;\n            cnt += it - a[i].begin() + 1;\n        }\n\n        if (cnt <= (n * m - 1) / 2)\n            ans = mid, l = mid + 1;\n        else\n            r = mid - 1;\n    }\n\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            cin >> a[i][j];\n\n    cout << MedianInMatrix(a) << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:46:36.689702+00:00"
      },
      "hints": {
        "hint1": "Binary Search by answer",
        "hint2": "<p>Iterate on all rows and use binary search to count the number of elements less than a given number.</p>",
        "solution_approach": "<p>We use binary search by answer to find the median of the matrix. For a number to be median the count of numbers less than it should be less than or equal to (N x M)/2<i>.</i> So we find the greatest number that satisfies this condition using binary search. To find the count of numbers we iterate row-wise and find the number of elements less than the given number by binary search (<i>lower_bound()</i> method in C++).</p><p><strong>Expected Time Complexity - </strong>O(20 x N x log(M))</p>"
      },
      "id": 592,
      "input_format": "<p>The first line of each test case contains two integers <i>N</i> and <i>M</i> - the dimensions of the matrix.<br>The next <i>N</i> lines contain <i>M</i> integers - the elements of the matrix <i>A</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>Sorting all the matrix elements gives us [1,<strong><u>2</u></strong>,3] in the first test case.<br>Sorting all the matrix elements gives us [1,1,2,2,<strong><u>3</u></strong>,4,5,5,5] in the second test case.</p>",
      "output_format": "Print the median of the matrix.",
      "samples": [
        {
          "input": "3 1\n3\n2\n1",
          "output": "2"
        },
        {
          "input": "3 3\n1 2 2\n1 3 5\n4 5 5",
          "output": "3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint MedianInMatrix(vector<vector<int>> &a)\n{\n    // Complete the function\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            cin >> a[i][j];\n\n    cout << MedianInMatrix(a) << \"\\n\";\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "MATMED",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array <i>A</i> of size <i>N</i>, you have to find the subset with the maximum sum such that the subset does not contain any adjacent elements.</p>",
      "complete_approach": "",
      "constraints": "<p><i>1 ≤ N ≤ 10<sup>5</sup></i></p><p><i>1≤ A[i] ≤ 10<sup>9</sup></i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n    ll a[n];\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    ll dp[n][2];\n    dp[0][0] = a[0], dp[0][1] = 0;\n    for (int i = 1; i < n; i++)\n    {\n        dp[i][0] = a[i] + dp[i - 1][1];\n        dp[i][1] = max(dp[i - 1][0], dp[i - 1][1]);\n    }\n    cout << max(dp[n - 1][0], dp[n - 1][1]) << '\\n';\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:18:59.359354+00:00"
      },
      "hints": {
        "hint1": "<p>Use dynamic programming. What will be the state?</p>",
        "hint2": "For each index maintain two different sums - one for including the current element and one for excluding it. dp(i, 0) → Maximum sum obtained from 0 to i which contains A[i]. dp(i, 1) → Maximum sum obtained from 0 to i which doesn't contain A[i]. Think of transition.",
        "solution_approach": "\nWe maintain a `dp` array where we store the maximum sums including and excluding the current value.\n\nThe `dp` states are:\n\n```cpp\ndp[i][0] - is the maximum sum till the i-th index including A[i]\ndp[i][1] - is the maximum sum till the i-th index excluding A[i]\n```\n\nFor a current index $i$, if we want to include $A[i]$, we have to exclude $A[i-1]$. If we exclude $A[i]$, we may or may not include $A[i-1]$.\n\nThe `dp` transitions can be:\n\n```cpp\ndp[i][0] = dp[i-1][1] + A[i]\ndp[i][1] = max(dp[i-1][0], dp[i-1][1])"
      },
      "id": 601,
      "input_format": "The first line of each test case contains a single integer N - the size of the array A.\nThe second line contains N integers - the elements of the array A.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>In the first test case choose the numbers [ <strong><u>1 </u></strong>2 <strong><u>3</u></strong> ] so that the maximum sum is 4.</p><p>In the second test case choose the numbers [ <strong><u>100</u></strong> 50 60 <strong><u>100</u></strong> 20 ] so that the max sum is 200.</p>",
      "output_format": "For each test case print in a new line the maximum sum possible.",
      "samples": [
        {
          "input": "3\n1 2 3",
          "output": "4"
        },
        {
          "input": "5\n100 50 60 100 20",
          "output": "200"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Non Consecutive Sum",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are <i>N</i> Ranks and <i>M</i> students in a class. Each student has a happiness value for the rank in the class he gets. The i th Student gets <i>happy[i][j]</i> on getting a rank <i>j</i>. It's ok to not keep all students in the ranks (They get 0 happiness). At most one student can be assigned to a rank. The total happiness of the assignment can be calculated as Sum of Happiness of each of the students in the class. Find the best way to calculate.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\n \nint happy[50][10];\nint dp[50][(1<<10)];\nint n, m;\n \nint dfs(int pos, int vis) {\n    if(pos == m) {\n        return 0;\n    }\n    if(dp[pos][vis] != -1) {\n        return dp[pos][vis];\n    }\n    int ans = dfs(pos+1, vis);\n    for (int i = 0; i < n; ++i) {\n        if((vis & (1<<i)) == 0) {\n            int temp = happy[pos][i] + dfs(pos+1, vis | (1<<i));\n            ans = max(ans, temp);\n        }\n    }\n    dp[pos][vis] = ans;\n    return ans;\n}\n \nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        cin >> n >> m;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < (1<<n); ++j) {\n                dp[i][j] = -1;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cin >> happy[i][j];\n            }\n        }\n        cout << dfs(0, 0) << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:41:44.198923+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">The brute force approach would be to find the answer for every possible solution. Since one student can be assigned only one rank, the first student will have M choices, the second student will have (M-1) choices and so on. The time complexity would be O(M*(M-1)*..(M-N+1)) when N &lt;= M. Otherwise it would be O(M!).</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">While assigning the ranks to the students starting from 1 to i, it can be noticed that the happiness of the i+1-th rank is independent of the ranks assigned to the first i persons. So we can use DP with bit masking in this problem. We would be iterating on the list of students (M) and make a set to store the ranks (N) which have already been assigned.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">We would make the DP array as DP[pos][vis] which denotes the maximum happiness that can be made by taking pos number of students and vis is the subset of ranks assigned. The subset of ranks assigned can be stored by using bit masking by using 2^N possible cases. For student pos, there can be two cases: we can either assign a rank to him, for this case we would iterate through all the possible ranks, that have not been assigned earlier and perform a recursive solution by adding the happiness for student pos with the particular rank and add it to the subset. For the second case, we don’t have to assign any rank to the student and just perform the recursive solution for the next student. Note that you need to use memoization otherwise the answer will result in TLE. The base case would be when we have processed all the M students, the happiness would be 0 in this case.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(M * N * 2^N)</span></p>"
      },
      "id": 452,
      "input_format": "<p>The first line contains an integer T (1 ≤ T ≤ 200) - the number of testcases.</p><p>The first line of each test case contains two space-separated integers N, M. 1 ≤ N ≤ 10, 1 ≤ M ≤ 50.</p><p>The next M lines contain N integers, 0 ≤ happy[i][j] ≤ 10^5.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the maximum sum of happiness possible in a new line.</p>",
      "samples": [
        {
          "input": "4\n6 11\n49 78 23 100 29 2\n11 28 39 27 77 45\n24 52 18 45 84 41\n85 88 75 21 98 100\n59 24 27 21 94 90\n88 0 0 16 89 54\n63 24 100 23 18 75\n26 34 54 14 28 11\n68 61 40 14 67 14\n16 62 17 70 29 52\n97 53 0 98 90 75 \n1 2\n8\n6 \n5 9\n6 0 7 9 3\n10 0 1 1 4\n0 2 4 6 1\n7 1 5 5 10\n0 3 3 1 10\n9 8 6 9 1\n0 10 6 0 2\n4 9 2 4 9\n4 10 10 3 7 \n4 5\n10 2 4 0\n10 1 6 7\n6 3 2 0\n2 3 5 1\n10 4 7 6 ",
          "output": "564\n8\n49\n27"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Students Happiness",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of positive integers you have to print the number of subarrays whose XOR is less than K. Subarrays are defined as a sequence of continuous elements Ai, Ai+1, ..., Aj . XOR of a subarray is defined as Ai ^ Ai+1 ^ ... ^ Aj.&nbsp;</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nclass trieNode {\npublic:\n    int leaves;\n    trieNode* left;\n    trieNode* right;\n    trieNode() {\n        leaves = 0;\n        left = NULL;\n        right = NULL;\n    }\n};\n\nvoid insert(int n, trieNode* head) {\n    trieNode* cur = head;\n    for (int i = 31; i >= 0; --i) {\n        int bit = (n >> i)&1;\n        if(bit) {\n            if(!cur->right) {\n                cur->right = new trieNode();\n            }\n            cur = cur->right;\n            cur->leaves++;\n        }\n        else {\n            if(!cur->left) {\n                cur->left = new trieNode();\n            }\n            cur = cur->left;\n            cur->leaves++;\n        }\n    }\n}\n\nint XORlessThanK (int n, int k, trieNode* head) {\n    trieNode* cur = head;\n    int ans = 0;\n    for (int i = 31; i >= 0; --i) {\n        if(cur == NULL) {\n            break;\n        }\n        int bit = (n>>i)&1;\n        int k1 = (k>>i)&1;\n        if(bit == k1) {\n            if(k1) {\n                if(cur->right) {\n                    ans += cur->right->leaves;\n                }\n            }\n            cur = cur->left;\n        }\n        else {\n            if(k1) {\n                if(cur->left) {\n                    ans += cur->left->leaves;\n                }\n            }\n            cur = cur->right;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        int n, k;\n        cin >> n >> k;\n        int a[n];\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        trieNode* head = new trieNode();\n        insert(0, head);\n        int ans = 0;\n        int pre = 0;\n        for (int i = 0; i < n; ++i) {\n            pre ^= a[i];\n            ans += XORlessThanK(pre, k, head);\n            insert(pre, head);\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:33:00.520082+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">If you make a prefix array of xors, prefix[r]^prefix[l-1] will give the xor of the subarray (l,r). This will take O(N^2) if we consider each subarray. Can you implement the same using tries?</span></p>",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">You need to insert the prefix xors while traversing through the trie, at any i, the trie will have all the prefix xors till (i-1). When you are at i, you need to add all the possible subarrays with xor less than K and ending at i. This can be done by considering all the four cases using the i-th bit for the current number and in K. Let the i-th bit for current number be n1 and the i-th bit for K be k1. If n1=1 and k1=1, taking 1 as the bit would result in 0 (1^1=0) and any such number would be less than k, so you need to add all the leaves which have 1 at this bit and then move to the bit 0. If n1=1 and k1=0, taking 1 as the bit would result in 1(0^1=1) and any such number would be greater than k, so you just need to move to the bit 0 without adding anything. You can do the same considering n1=0, k1=0/1.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N logN)</span></p>"
      },
      "id": 419,
      "input_format": "<p>The first line contains an integer T ( 1 ≤ T ≤ 10), the number of test cases.</p><p>The first line of each test case contains 2 space-separated integers N,k 1 ≤ N ≤ 10^5, 1 ≤ k ≤ 10^6.</p><p>The second line of each test case contains N space-separated integers, 1≤ Ai ≤ 10^5</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the number of subarray with XOR less than k in a new line.</p>",
      "samples": [
        {
          "input": "2\n5 3\n1 2 3 4 5\n10 472156\n645 45 8 6 45564 46868 89797 4566 65546 65467",
          "output": "8\n55"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Subarrays with xor less than k",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given Q queries and have to perform the following operations:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">add x - add element x in the set</span></li><li><span style=\"background-color:transparent;color:#000000;\">erase x - delete one element with value x, if it exists</span></li><li><span style=\"background-color:transparent;color:#000000;\">eraseall x - delete all elements with value x, if it exists</span></li><li><span style=\"background-color:transparent;color:#000000;\">find x - if x is present print “YES”, else print “NO”</span></li><li><span style=\"background-color:transparent;color:#000000;\">count x - print the number of times x occurs in the set</span></li><li><span style=\"background-color:transparent;color:#000000;\">print - print the values in set</span></li><li><span style=\"background-color:transparent;color:#000000;\">empty - empty the set</span></li></ol>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ Q ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ X ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of Q over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>5</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int q;\n    cin >> q;\n    multiset<int> st;\n    while (q--) {\n      string s;\n      cin >> s;\n      if (s == \"add\") {\n        int x;\n        cin >> x;\n        st.insert(x);\n      } else if (s == \"erase\") {\n        int x;\n        cin >> x;\n        if (st.find(x) != st.end()) {\n          st.erase(st.find(x));\n        }\n      } else if (s == \"eraseall\") {\n        int x;\n        cin >> x;\n        if (st.find(x) != st.end()) {\n          st.erase(x);\n        }\n      } else if (s == \"find\") {\n        int x;\n        cin >> x;\n        if (st.find(x) != st.end()) {\n          cout << \"YES\\n\";\n        } else {\n          cout << \"NO\\n\";\n        }\n      } else if (s == \"count\") {\n        int x;\n        cin >> x;\n        cout << st.count(x) << \"\\n\";\n      } else if (s == \"print\") {\n        for (int i : st) {\n          cout << i << \" \";\n        }\n        cout << \"\\n\";\n      } else {  // empty\n        st.clear();\n      }\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:44:45.990990+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Use `insert(x)` for adding element to multiset\nUse `find(x)` for finding the iterator to the element\nUse `erase(x)` for deleting all elements with value x\nUse `erase(ms.find(x))` for deleting one occurence of element with value x, first find iterator then erase using erase(it)\nUse `count(x)` for finding the number of time x occurs in the multiset\nUse `clear()` for emptying the set\nTime Complexity per test case: $O(Q \\log N)$ where $N$ is the size of the set"
      },
      "id": 361,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer Q - the number of queries.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Each of the next Q lines contains queries.</span></p><p><span style=\"background-color:rgb(255,255,255);color:rgb(33,37,41);\">The combination of print and n does not exceed 10^8.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<ol><li><span style=\"background-color:transparent;color:#000000;\">Multiset becomes: [3]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Multiset becomes: [1, 3]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Multiset becomes: [1, 3, 5]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Multiset becomes: [1, 3, 3, 5]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Multiset becomes: [1, 3, 3, 3, 5]</span></li><li><span style=\"background-color:transparent;color:#000000;\">3 occurs 3 times in the multiset</span></li><li><span style=\"background-color:transparent;color:#000000;\">Multiset becomes: [1, 3, 3, 5]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Multiset is: 1, 3, 3, 5</span></li><li><span style=\"background-color:transparent;color:#000000;\">Multiset becomes: [1, 5]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Multiset is: 1, 5</span></li><li><span style=\"background-color:transparent;color:#000000;\">5 exists in the multiset</span></li><li><span style=\"background-color:transparent;color:#000000;\">Multiset becomes empty</span></li><li><span style=\"background-color:transparent;color:#000000;\">5 does not exist in the multiset</span></li></ol>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the required queries.</span></p>",
      "samples": [
        {
          "input": "1\n13\nadd 3\nadd 1\nadd 5\nadd 3\nadd 3\ncount 3\nerase 3\nprint\neraseall 3\nprint\nfind 5\nempty\nfind 5\n",
          "output": "3\n1 3 3 5 \n1 5 \nYES\nNO\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Multiset AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a non-empty singly linked list, remove the Nth node from the end and returns its head.&nbsp;</p><p>Try to do it in one pass.</p><p>Complete the function</p><pre><code class=\"language-plaintext\">ListNode* removeNthFromEnd(ListNode* head, int N)</code></pre><p><i>head </i>points to the beginning of the linked list.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ Length of the linked list ≤ 10<sup>6</sup><br>1 ≤ N ≤ Length of the linked list<br>0 ≤ Value stored in nodes ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* removeNthFromEnd(ListNode* head, int N) {\n    if(!head) return head;\n        \n    ListNode *prev = NULL, *cur = head;\n    \n    for(int i = 0; i < N; i++) \n        cur = cur->next;\n    \n    if(!cur) return head->next;\n    \n    while(cur) {\n        cur = cur->next;\n        if(prev) prev = prev->next;\n        else prev = head;\n    }\n    \n    prev->next = prev->next->next;\n    \n    return head;\n} \n\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    int N;\n    cin >> N;\n\n    ListNode* head = GetList(num);\n\n    head = removeNthFromEnd(head, N);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:17:58.123695+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 530,
      "input_format": "",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "3\n1 2 3\n1",
          "output": "1 2"
        },
        {
          "input": "4\n1 2 3 4\n3",
          "output": "1 3 4"
        },
        {
          "input": "4\n1 2 3 4\n4",
          "output": "2 3 4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\n\nListNode* removeNthFromEnd(ListNode* head, int N) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    int N;\n    cin >> N;\n\n    ListNode* head = GetList(num);\n\n    head = removeNthFromEnd(head, N);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Remove Nth Node From End",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a map of a building, and your task is to count the number of its rooms. The size of the map is <i>n</i> × <i>m</i> squares, and each square is either floor or wall. You can walk left, right, up, and down through the floor squares.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n, m</i> ≤ 1000</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n, m;\nvector<string> arr;\nusing ii = pair<int, int>;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nbool visited[1000][1000];\n\nbool check(int x, int y)\n{\n    if (x < 0 || x >= n || y < 0 || y >= m)\n    {\n        return 0;\n    }\n    else\n    {\n        return 1;\n    }\n}\n\nvoid dfs(ii k)\n{\n    int x = k.first, y = k.second;\n    visited[x][y] = true;\n    for (int i = 0; i < 4; i++)\n    {\n        if (check(x + dx[i], y + dy[i]) && arr[x + dx[i]][y + dy[i]] == '.')\n        {\n            if (!visited[x + dx[i]][y + dy[i]])\n            {\n                dfs({x + dx[i], y + dy[i]});\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio();\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    arr.resize(n + 1);\n\n    for (int i = 0; i < n; i++)\n    {\n        cin >> arr[i];\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            visited[i][j] = false;\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            if (!visited[i][j] && arr[i][j] == '.')\n            {\n                dfs({i, j});\n                ans++;\n            }\n        }\n    }\n    cout << ans << endl;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:13:45.390327+00:00"
      },
      "hints": {
        "hint1": "Apply DFS/BFS",
        "hint2": "Look for components. Once all connected floor squares have been visited for a given DFS, return to the starting point and look for another unvisited floor square to start a new DFS.",
        "solution_approach": "1. Create a two-dimensional boolean array to keep track of the visited squares in the building.\n2. For each floor square that has not been visited yet, do a depth-first search (DFS) to visit all connected floor squares.\n3. Each time you start a new DFS, increment the counter variable by 1.\n4. During each DFS, mark all visited floor squares as \"visited\" in the boolean array.\n5. Once all connected floor squares have been visited for a given DFS, return to the starting point and look for another unvisited floor square to start a new DFS.\n6. Continue until all floor squares have been visited.  \n\nOverall time complexity : $O(n*m)$"
      },
      "id": 191,
      "input_format": "<p>The first input line has two integers <i>n</i> and <i>m</i>: the height and width of the map.<br>Then there are <i>n</i> lines of <i>m</i> characters describing the map. Each character is either ‘.’ (floor) or '#' (wall).</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "Print one integer: the number of rooms.",
      "samples": [
        {
          "input": "5 8\n########\n#..#...#\n####.#.#\n#..#...#\n########",
          "output": "3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Find the Number of Rooms",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Given a grid of size n*m with 0s and 1s, you need to find the area of the largest rectangle containing only 1.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ t ≤ 10<sup>5</sup></p><p>1 ≤ n, m ≤ 200</p><p>0 ≤ aij ≤ 1</p><p>It is guaranteed that the sum of n*m over all test cases does not exceed 10<sup>5</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nsigned main(){\n   ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n   int t;\n   cin >> t;\n   while(t--) {\n       int n, m;\n       cin >> n >> m;\n       bool grid[n][m];\n       for (int i = 0; i < n; ++i) {\n           for (int j = 0; j < m; ++j) {\n               cin >> grid[i][j];\n           }\n       }\n       int dp[n][m];\n       memset(dp, 0, sizeof(dp));\n       int ans = 0;\n       for (int i = 0; i < n; ++i) {\n           for (int j = 0; j < m; ++j) {\n               if(grid[i][j]) {\n                   dp[i][j] = j == 0 ? 1 : dp[i][j-1] + 1;\n                   int width = dp[i][j];\n                   \n                   for (int k = i; k >= 0; --k) {\n                       width = min(width, dp[k][j]);\n                       ans = max(ans, width * (i - k + 1));\n                   }\n               }\n           }\n       }\n       cout << ans << \"\\n\";\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:42:04.023406+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">If the value of the cell at (i,j) is 1, to find the answer for the largest rectangle with bottom right corner at (i, j), you can find the width using dp and iterate on the height.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Instead of the area, store the width of the rectangle in the dp array.</span></p>",
        "solution_approach": "<p>Define dp[i][j] which denotes the maximum width (number of consecutive ones) in row i and ending at j. Iterate through the height, k ≤ i and take the minimum for the width. The area of rectangle is given by height*width, take the max for each (i, j).</p><p>&nbsp;</p><p>Time Complexity per test case: O(n<sup>2</sup> *m)</p>"
      },
      "id": 495,
      "input_format": "<p>The first line of the input contains one integer t - the number of test cases. Then t test cases follow.</p><p>The first line of each test case contains two space-separated integers n, m - the size of the grid.</p><p>Each of the next n lines contains m space-separated integers, aij - the number at that cell.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the maximum area.</span></p>",
      "samples": [
        {
          "input": "3\n2 3\n0 1 1\n0 0 0\n3 3\n1 0 1\n0 1 1\n0 1 1\n2 2\n0 0\n0 0",
          "output": "2\n4\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Maximum Area of Rectangle",
      "video_editorial_id": 8213
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given a grid consisting of <strong>n </strong>rows and <strong>m </strong>columns. In the given grid, it is guaranteed that all the rows are sorted in increasing order and the columns are also sorted in increasing order. You have to answer <strong>q </strong>queries. In each query you are given a number <strong>x</strong>. You need to print <strong>‘Yes’</strong> if the number is present in the grid and <strong>‘No’</strong> otherwise.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Try to solve this problem using constant extra space.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1 &lt;= n,m &lt;= 1000</span><br><span style=\"background-color:transparent;color:#000000;\">1 &lt;= q &lt;= 10000</span><br><span style=\"background-color:transparent;color:#000000;\">1 &lt;= grid[i][j] &lt;= 10<sup>9</sup></span><br><span style=\"background-color:transparent;color:#000000;\">1 &lt;= x &lt;= 10<sup>6</sup></span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool search(vector<vector<int>> &grid, int x)\n{\n\tint n = (int)grid.size();\n\tint m = (int)grid[0].size();\n\tint i, j;\n\ti = 0;\n\tj = m - 1;\n\twhile (i < n && j >= 0)\n\t{\n\t\tif (grid[i][j] == x) // value found\n\t\t\treturn true;\n\t\tif (grid[i][j] > x) // eliminating this column\n\t\t\tj--;\n\t\telse // eliminating this row\n\t\t\ti++;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL); cout.tie(NULL);\n\n\tint n, m;\n\tcin >> n >> m;\n\t\n\tvector<vector<int>> grid(n, vector<int>(m));\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tcin >> grid[i][j];\n\t}\n\t\n\tint q;\n\tcin >> q;\n\t\n\twhile (q--)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tif (search(grid, x))\n\t\t\tcout << \"Yes\\n\";\n\t\telse\n\t\t\tcout << \"No\\n\";\n\t}\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:28:41.403349+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Can we use the property of the grid to search faster?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">If the value at the end of a row is less than x, x cannot be present in this row.</span><br><span style=\"background-color:transparent;color:#000000;\">If the value at the beginning of a column is more than x, x cannot be present in this column.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">For each query we cannot search the entire grid as that would timeout. We can use the property of the grid that the rows and columns are both sorted in increasing order.</span><br><span style=\"background-color:transparent;color:#000000;\">We start from the top right corner of the grid.</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">If the value is equal to x we print true.</span></li><li><span style=\"background-color:transparent;color:#000000;\">If the value is less than x, all the numbers in the current row will also be smaller than x so they can be eliminated. So the current row is eliminated.</span></li><li><span style=\"background-color:transparent;color:#000000;\">If the value is greater than x, all the numbers in the current column will also be greater than x as we are at the top of the column and the column is sorted in increasing order.</span></li></ol><p><span style=\"background-color:transparent;color:#000000;\">So the current column is also eliminated.</span><br><span style=\"background-color:transparent;color:#000000;\">This works as in each step a row or a column is eliminated and as there are a total of n + m rows and columns, we can answer each query in O(n+m) time complexity.</span></p>"
      },
      "id": 587,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains two integers <strong>n</strong> and <strong>m</strong> — the number of rows and columns, respectively.</span><br><span style=\"background-color:transparent;color:#000000;\">The following <strong>n</strong> lines contain <strong>m</strong> integers each, the j-th element in the i-th line is the number written in the j-th cell of the i-th row.</span><br><span style=\"background-color:transparent;color:#000000;\">The next line contains a single integer <strong>q </strong>- the number of queries.</span><br><span style=\"background-color:transparent;color:#000000;\">Then q lines follow. The ith line contains the value of <strong>x </strong>for the ith query.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">Yes’ is printed for the numbers present in the grid and ‘No’ for the numbers not present.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print q lines. For each query print <strong>‘Yes’</strong> if the number is present in the grid and <strong>‘No’</strong> otherwise.</span></p>",
      "samples": [
        {
          "input": "3 4\n1 3 4 6\n2 5 7 9\n7 11 12 19\n5\n3\n8\n10\n12\n13",
          "output": "Yes\nNo\nNo\nYes\nNo"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nbool search(vector<vector<int>> &grid, int x)\n{\n\t//Complete the function\n}\n\n<fix>\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL); cout.tie(NULL);\n\n\tint n, m;\n\tcin >> n >> m;\n\t\n\tvector<vector<int>> grid(n, vector<int>(m));\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tcin >> grid[i][j];\n\t}\n\t\n\tint q;\n\tcin >> q;\n\t\n\twhile (q--)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\tif (search(grid, x))\n\t\t\tcout << \"Yes\\n\";\n\t\telse\n\t\t\tcout << \"No\\n\";\n\t}\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Grid Queries",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string $s$. An awesome substring is a non-empty substring of $s$ such that we can make any number of swaps in order to make it a palindrome.\n\nFind the length of the maximum length awesome substring of $s$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$\n$1 \\leq |s| \\leq 10^5$\nString $s$ only contains digts from $0-9$. \nSum of $|s|$ over all test cases is $\\leq 10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint Awesome(string s) {\n\tint mask = 0, ans = 0;\n\tvector<int> m(1 << 10, s.size() + 1);\n\tm[0] = -1;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tmask ^= (1 << (s[i] - '0'));\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tans = max(ans, i - m[mask ^ (1 << j)]);\n\t\t}\n\t\tans = max(ans, i - m[mask]);\n\t\tm[mask] = min(m[mask], i);\n\t}\n\treturn ans;\n}\nvoid solve() {\n\tstring s;\n\tcin >> s;\n\tcout << Awesome(s) << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:32:21.628619+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We can form a palindrome if the count of each included number (except maybe one) is even, and this is the property of an awesome string.\n\nA bit in our mask is $0$ if the count for the corresponding number is even, and $1$ if it's odd. As we go through the string, we track odd/even counts in our mask. If we see the same mask again, the subarray between a first position (exclusive) and the current position (inclusive) with the same mask has all numbers with the even count.\n\nWe will use the DP array to track the smallest (first) position of each mask. We can get the size of the substring by subtracting it from the current position.\n\nNote that the position for zero masks is $-1$, as we need to include the very first character.\n\n**Time Complexity:** $O(10*|s|)$ per test case."
      },
      "id": 981,
      "input_format": "First-line contains $T$ - the number of test cases.\nThe first line of each test case contains string $s$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the length of the maximum length awesome substring of $s$.",
      "samples": [
        {
          "input": "3\n185801630663498\n213123\n123456\n",
          "output": "5\n6\n1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Awesome",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(22,27,54);\">You are given a list of <i>N</i> intervals. The <i>i</i>-th interval is <i>[l<sub>i</sub>, r<sub>i</sub>)</i>, which denotes a range of numbers greater than or equal to <i>l<sub>i</sub></i> and strictly less than <i>r<sub>i</sub></i>.&nbsp;</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(22,27,54);\">Find The minimum integer <i>y</i> such that for all possible combinations of <i>y</i> intervals from the given <i>N</i> interval, it </span><i>does</i><span style=\"background-color:rgb(255,255,255);color:rgb(22,27,54);\"> cover <i>[0, L)</i>.</span></p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 ≤ N ≤ 2×10^5\n1 ≤ L ≤ 10^12\n0 ≤ li &lt; ri ≤ L</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\nusing lli =  int long long;\nlli n,n2;\nlli tot = 1e9+10;\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    // for getting input from input.txt\n    freopen(\"input.txt\", \"r\", stdin);\n    // for writing output to output.txt\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    \n    IOS\n    lli t;\n    \n    //cin>>t;\n    //while(t--){\n        int n;\n        lli l;\n        cin >> n >> l;\n        lli x,y;\n        vector<pair<lli,int>> event;\n\n        for(int i=0;i<n;i++){\n            cin >> x >> y;\n            event.push_back({x,+1});\n            event.push_back({y,-1});\n        }\n        sort(event.begin(),event.end()); // sort all the events \n\n        int cnt=0;                       // keeps count of number of intervals covering that point.\n        int ans = n+1;\n\n        for(int i=0;i+1<(int)event.size();i++){\n\n            cnt+=event[i].second;\n            if(event[i].first != event[i+1].first){\n                ans = min(ans,cnt);\n            }\n\n        }\n        // all points are covered by atleast \"ans\" no. of intervals\n        cout << n-ans+1 << \"\\n\";\n        \n    //}\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:28:56.758772+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">The problem requires finding all possible combinations of N or N-1 or N-2 …...1 number of ranges. In order to find out the minimum number of ranges for which all possible subsets of ranges will have a union of [0,L). Think of the brute force approach, of taking all possible range subsets. Will it be the optimal solution?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">The brute force solution will not pass the time constraints, so think along greedy lines. .Apply the idea of sweep line in this problem, where you don’t have to traverse across the same range twice, in order to find the minimum.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">There are N possible numbers of ranges that cover all the L+1 points of the range [0, L). Across all the points, keep a count of the number of intervals that cover each point. Find out the minimum count of intervals that cover each point of the number line. A total number of intervals+1 minus this minimum number will give the required answer. Why??</span></p><p><span style=\"background-color:transparent;color:#000000;\">Let's say we are deleting segments. The first point that is going to become vulnerable to being disconnected will be the point covered by the least number of segments. Find this minimum Value, Say, X.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Note that we are Finding The minimum integer y such that for all possible combinations of y intervals from the given N interval, it does cover [0, L).</span></p><p><span style=\"background-color:transparent;color:#000000;\">That is the same as saying We are Deleting any N-y segments and it should be connected.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Now N-y &lt; X or else this vulnerable point will be cut.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Or y&gt;N-X. So we can always say Y = N-X+1 for minimum value.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Sort all the intervals in increasing order of their starting values. Maintain a count of the number of intervals that cover a particular point along the line and as long as the successive event doesn’t have the same starting or ending value, keep track of the minimum value of count. Finally, subtract this from the total number of intervals to the required answer.</span></p><p><span style=\"background-color:transparent;color:#000000;\">EXAMPLE RUN&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">5 5</span></p><p><span style=\"background-color:transparent;color:#000000;\">0 4</span></p><p><span style=\"background-color:transparent;color:#000000;\">3 5</span></p><p><span style=\"background-color:transparent;color:#000000;\">0 2</span></p><p><span style=\"background-color:transparent;color:#000000;\">2 5</span></p><p><span style=\"background-color:transparent;color:#000000;\">2 4</span></p><p><span style=\"background-color:transparent;color:#000000;\">There are 5 ranges and L=5 is given. For each interval extreme point, maintain a +1 or -1&nbsp; value to keep track of a number of intervals.:&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">On sorting the range becomes : [0,2),[0,4),[2,4),[2,5),[3,5) . Clearly each point is covered by at least 2 intervals . So the minimum count of intervals whose union covers the entire length L .is 5-2+1 = 4.</span></p><p><span style=\"background-color:transparent;color:#000000;\">TIME COMPLEXITY: O(NlogN)</span></p>"
      },
      "id": 119,
      "input_format": "<p>The first line contains two integers <i>N</i> (1 ≤ <i>N </i>≤ 2×10<sup>5</sup>) and <i>L</i> (1 ≤ <i>L </i>≤ 10<sup>12</sup>), where <i>N</i> is the number of intervals and <i>L</i> is the length of the range to be covered, respectively.&nbsp;<br>The <i>i</i>-th of the following <i>N</i> lines contains two integers <i>l<sub>i</sub></i> and <i>r<sub>i</sub></i> (0 ≤ <i>l<sub>i </sub></i>&lt; <i>r<sub>i </sub></i>≤ <i>L</i>), representing the range of the <i>i</i>-th interval <i>[l<sub>i</sub>, r<sub>i</sub>)</i>.&nbsp;<br>You can assume that the union of all the <i>N</i> intervals is <i>[0, L)</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">There are 5 ranges given and the total length of the line is 5.</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">First choose 5 ranges . Only one set is possible [ [0,2),[0,4),[2,4),[2,5),[3,5) ] and their union is [0, 5).&nbsp;</span></li><li><span style=\"background-color:transparent;color:#000000;\">Choose any 4 ranges.&nbsp; 5 subsets are possible&nbsp;</span><ol><li><span style=\"background-color:transparent;color:#000000;\">[ [0,2),[0,4),[2,4),[2,5) ]&nbsp; union&nbsp; =&nbsp; [0, 5)</span></li><li><span style=\"background-color:transparent;color:#000000;\">[ [0,2),[0,4),[2,4),[3,5) ]&nbsp; union&nbsp; =&nbsp; [0, 5)</span></li><li><span style=\"background-color:transparent;color:#000000;\">[ [0,2),[0,4),[2,5),[3,5) ]&nbsp; union&nbsp; =&nbsp; [0, 5)</span></li><li><span style=\"background-color:transparent;color:#000000;\">[ [0,2),[2,4),[2,5),[3,5) ]&nbsp; union&nbsp; =&nbsp; [0, 5)</span></li><li><span style=\"background-color:transparent;color:#000000;\">[ [0,4),[2,4),[2,5),[3,5) ]&nbsp; union&nbsp; =&nbsp; [0, 5)</span></li></ol></li><li><span style=\"background-color:transparent;color:#000000;\">Choose any 3 ranges. 5C3 = 10 subsets are possible.</span><ol><li><span style=\"background-color:transparent;color:#000000;\">If you list them out, then you'll see not all unions are [0, L).For example , 3 ranges : [3,5) , [2,5) , [2,4) has union [2,5)&nbsp; And hence, 3 is not a possible answer.</span></li></ol></li></ol><p><span style=\"background-color:transparent;color:#000000;\">So the minimum number of ranges required such that any combination of that number of ranges will have union [0,L) is 4.</span></p>",
      "output_format": "<p>Output integer <i>y</i> mentioned in the problem statement.</p>",
      "samples": [
        {
          "input": "5 5\n0 4\n3 5\n0 2\n2 5\n2 4",
          "output": "4"
        },
        {
          "input": "2 4\n0 4\n0 4",
          "output": "1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Solve Intervals 2",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given Q queries and have to perform the following operations:\n\n1. add x y - add student name X (string) for marks y (integer). If it already exists, add a new entry.\n2. erase x - erase the first current entry of student with name x\n3. eraseall x - erase all entries of student with name x\n4. print x - print the first entry of marks of student with name x, if entry is not there for x, print 0.",
      "complete_approach": "",
      "constraints": "- $1 \\leq T \\leq 10^5$\n- $1 \\leq Q \\leq 10^5$\n- $1 \\leq X \\leq 10^6$\n\nIt is guaranteed that the sum of $Q$ over all test cases does not exceed $10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS;\n  int t;\n  cin >> t;\n  while (t--) {\n    int q;\n    cin >> q;\n    multimap<string, int> m;\n    while (q--) {\n      string s;\n      cin >> s;\n      if (s == \"add\") {\n        string x;\n        int y;\n        cin >> x >> y;\n        m.insert({x, y});\n      } else if (s == \"erase\") {\n        string x;\n        cin >> x;\n        auto it = m.find(x);\n        if(it != m.end()) {\n          m.erase(it);\n        }\n      } else if (s == \"eraseall\") {\n        string x;\n        cin >> x;\n        if (m.find(x) != m.end()) {\n          m.erase(x);\n        }\n      } else {\n        string x;\n        cin >> x;\n        auto it = m.find(x);\n        if (it != m.end()) {\n          cout << it->second << \"\\n\";\n        } else {\n          cout << \"0\\n\";\n        }\n      }\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:15:57.397566+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Add entry `x`, `y` using `insert({x,y})`.\nUse `erase(x)` for deleting all entry of student with name `x`\nFirst find iterator to first entry of `x` using `find(x)`, then erase this using `erase(it)`\nUse `count(x)` for checking if entry with name `x` exists\nPrint by iterating through the map and check if key is equal to `x`\nTime Complexity per test case: $O(Q \\log N)$ where `N` is the size of the set"
      },
      "id": 363,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer Q - the number of queries.\n\nEach of the next Q lines contains queries.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "1. Map becomes: [alice: 24]\n2. Map becomes: [alice: 24, bob: 21]\n3. Map becomes: [alice: 24, bob: 21, alice: 23]\n4. Map becomes: [alice: 24, bob: 21, alice: 23, alice: 22]\n5. alice: 24\n6. Map becomes: [bob: 21, alice: 23, alice: 22] (since first entry of alice is removed)\n7. alice: 23\n8. Map becomes: [bob: 21]\n9. key alice doesn't exist, hence alice: 0",
      "output_format": "For each test case, print the required queries.",
      "samples": [
        {
          "input": "1\n9\nadd alice 24\nadd bob 21\nadd alice 23\nadd alice 22\nprint alice\nerase alice\nprint alice\neraseall alice\nprint alice\n",
          "output": "24\n23\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Multimap AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string of length $n$, your task is to determine the longest palindromic substring of the string. For example, the longest palindrome in *\"algoazzaa\"* is *\"azza\"*.\nIf there are multiple longest palindromic substrings, Output the one which comes first in the string.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 1000$\n$1 \\leq n \\leq 1000$\nSum of $n$ across all test cases is $\\leq$ $10^{4}$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nclass Solution1 { // O(N^2) using DP + Memoisation.\npublic:\n    vector<vector<int>> dp;\n    bool is_palindrome(string &s, int i, int j) {\n        if (i >= j)return 1;\n        auto &ans = dp[i][j];\n        if (ans != -1)return ans;\n        ans = 0;\n        if (s[i] == s[j])ans = is_palindrome(s, i + 1, j - 1);\n        return ans;\n    }\n    string solve(string &s) {\n        int n = s.size();\n        dp.assign(n + 1, vector<int>(n + 1, -1));\n        int mxl = 0, st = -1;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (is_palindrome(s, i, j)) {\n                    if (mxl < j - i + 1)mxl = j - i + 1, st = i;\n                }\n            }\n        }\n        return s.substr(st, mxl);\n    }\n};\nclass Solution2 {\npublic:\n    string longestPalindrome(string s) { // O(N^2) using 2 Pointers.\n        int n = s.length();\n        int mx = 1;\n        int ai, aj;\n        for (int i = 0; i < n; i++) {\n            int l = i, r = i; // odd size\n            while (l >= 0 && r < n) {\n                if (s[l] == s[r]) {\n                    if (r - l + 1 > mx) {\n                        mx = r - l + 1;\n                        ai = l, aj = r;\n                    }\n                    else if (r - l + 1 == mx && l < ai) {\n                        mx = r - l + 1;\n                        ai = l, aj = r;\n                    }\n                    l--, r++;\n                }\n                else break;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int l = i, r = i + 1; // even size\n            while (l >= 0 && r < n) {\n                if (s[l] == s[r]) {\n                    if (r - l + 1 > mx) {\n                        mx = r - l + 1;\n                        ai = l, aj = r;\n                    }\n                    else if (r - l + 1 == mx && l < ai) {\n                        mx = r - l + 1;\n                        ai = l, aj = r;\n                    }\n                    l--, r++;\n                }\n                else break;\n            }\n        }\n        return s.substr(ai, mx);\n    }\n};\nclass Solution3 { // O(N) using manacher algorithm.\npublic:\n    vector<int> manacher(string s) { // gives 2n-1 size manacher array. (a#c#...#d )\n        string s1 = \"@\"; for (auto c : s) s1 += c, s1 += \"#\";\n        s1.back() = '&';\n        vector<int> ans(s1.size() - 1); int lo = 0, hi = 0;\n        for (int i = 1; i <= s1.size() - 2; i++) {\n            if (i != 1) ans[i] = min(hi - i, ans[hi - i + lo]);\n            while (s1[i - ans[i] - 1] == s1[i + ans[i] + 1]) ans[i] ++;\n            if (i + ans[i] > hi) lo = i - ans[i], hi = i + ans[i];\n        }\n        ans.erase(begin(ans));\n        for (int i = 0; i <= ans.size() - 1; i++) if ((i & 1) == (ans[i] & 1)) ans[i] ++;\n        return ans;\n    }\n    string getLPS(string s) { // gives one of the long. palindromic substr.\n        auto a = manacher(s);\n        auto it = max_element(a.begin(), a.end());\n        int l = *it, p;\n        for (int i = 0; i < a.size(); i++) {\n            if (a[i] == l) {\n                p = i;\n                break;\n            }\n        }\n        return s.substr((p + 1) / 2 - l / 2, l);\n    }\n};\n\nvoid solve() {\n    string s;\n    cin >> s;\n    Solution1 s1;\n    Solution2 s2;\n    Solution3 s3;\n    auto ans1 = s1.solve(s);\n    auto ans2 = s2.longestPalindrome(s);\n    auto ans3 = s3.getLPS(s);\n    cout << ans1 << endl;\n    assert(ans1 == ans2 && ans2 == ans3);\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:24:26.601218+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "**Intuition:** We can solve this question in 3 ways that come at first glance:\n-   Use Brute Force : Check for every corresponding element in string the longest palindrome possible and do it till the end.\n-   DP: Since we are essentially looping over every element in Brute Force, maybe we can somehow use the result from our previous iteration to simplify the current one? This gives us a nudge to look for a pattern and hence we go for DP.\n- Expand through the center for even and odd length palindromes.\n- Manacher Algorithm.\n\n**Analysis:**\nLet's see all the approaches one by one !!!\n\n1.  **Brute Force:** Instead of directly going to code and finding a problem later, lets stop and think about the concept we intend to use here  \n**Concept:** We will go through all possible elements in string and find the longest palindrome amongst them.\n**Review:** To calculate all the possible substrings in a string of length n, the number of combinations generated are:\n1+2+3+4+..........n=n(n-1)/2. To check all the substrings for Palindrome, we will have to go through all the n characters.\n Total Combinations: n*n(n-1)/2= O(n^3)\n**Conclusion:** Since the time complexity is O(n^3), hence we will not discuss this approach, and our energy would be better spent looking at the DP solution.\n\n2.  **DP** : if we know string \"aba\" is palindrome then \"cabac\" must be palindrome as left and right are equal.\n**State :** P(i,j) - True if substring(i,j) is a palindrome\n**Transition:** P(i, j) == P(i+1, j-1) && s[i] == s[j];\n**Base cases** :\nP(i, i) = true;  //One character\nP(i, i+1) = s[i] == s[i+1];  //Two character\n**Time Complexity** - O(N^2), Space Complexity - O(N^2) (caching all substring)\n3. **Expand Around Center** : Time: O(n^2), Space: O(1)\nLoop through the input string with i then inner loop through a section of that string with j\nYou now have two pointers left and right (i, j) respectively\nSince we start with 2 letters, for them to be a palindrome they have to be the same, so while that is the case, we'll keep expanding our window till they're no longer a palindrome\nMax will be the longest palindrome so if the current palindrome length is greater than our previous palindrome length we'll update the max\nWe'll do this till we're done looping through the string for both odd and even length palindromes, then return max.\n3. **Manacher Algorithm:** it can be solved in O(N), Refer to Manacher Video( AZ201 String Algo Module ) for the details."
      },
      "id": 964,
      "input_format": "The first line contains $T$ - the number of test cases.\nThe first line of each test case contains a string of length $n$. Each character is one of *a–z*.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, Output the Longest Palindromic Substring.\nIf there are multiple longest palindromic substrings, Output the one which comes first in the string.",
      "samples": [
        {
          "input": "9\nalgoazzaa\naaaaaaaaaa\nababababab\nihpohpzoffel\nflexflexvpqxierullgcfckjqflexflex\nobsession\nabcxcbaxcba\nzzabc\naaccaabbaaccaaccaabbaaccaa\n",
          "output": "azza\naaaaaaaaaa\nababababa\nff\ncfc\nses\nabcxcba\nzz\naaccaabbaaccaaccaabbaaccaa\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Longest Palindromic Substring - Easy Version",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You have a 2-D array of size <strong>N x M</strong>. Consider connected <strong>0</strong>s (which share a common edge) as one single component and <strong>1</strong>s as walls. Replace <strong>0</strong>s with the size of the connected component but if the size of the component is one, then leave it with <strong>0</strong>.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1 ≤ Sum of (N x M) over all test cases ≤ 2 x 10<sup>5</sup></span><br><span style=\"background-color:transparent;color:#000000;\">0 ≤ A<sub>i</sub> ≤ 1</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define mp make_pair\n\nvoid bfs(vector<vector<int>> &arr, vector<vector<int>> &vis, int i, int j)\n{\n    int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\n    int n = arr.size(), m = arr[0].size();\n\n    vis[i][j] = 2;\n    int sz = 1;\n\n    queue<pii> q;\n    q.push(mp(i, j));\n    while (!q.empty())\n    {\n        int x = q.front().first, y = q.front().second;\n        q.pop();\n        for (int k = 0; k < 4; k++)\n        {\n            int nx = x + dx[k], ny = y + dy[k];\n            if ((nx >= 0 && nx < n && ny >= 0 && ny < m) && vis[nx][ny] == 0)\n            {\n                vis[nx][ny] = 2, sz++;\n                q.push(mp(nx, ny));\n            }\n        }\n    }\n\n    vis[i][j] = 1;\n    if (sz == 1)\n        return;\n    arr[i][j] = sz;\n\n    q.push(mp(i, j));\n    while (!q.empty())\n    {\n        int x = q.front().first, y = q.front().second;\n        q.pop();\n        for (int k = 0; k < 4; k++)\n        {\n            int nx = x + dx[k], ny = y + dy[k];\n            if ((nx >= 0 && nx < n && ny >= 0 && ny < m) && vis[nx][ny] == 2)\n            {\n                vis[nx][ny] = 1, arr[nx][ny] = sz;\n                q.push(mp(nx, ny));\n            }\n        }\n    }\n}\n\nvoid solve()\n{\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> arr(n, vector<int>(m));\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            cin >> arr[i][j];\n\n    // <0 -> not visited, 1 -> completed, 2 -> visited but not completed>\n    vector<vector<int>> vis(n, vector<int>(m));\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            vis[i][j] = arr[i][j];\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            if (vis[i][j] == 0)\n                bfs(arr, vis, i, j);\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n            cout << arr[i][j] << \" \";\n        cout << \"\\n\";\n    }\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int _t = 1; // number of test cases\n    cin >> _t;\n    while (_t--)\n        solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:20:24.951559+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Use simple BFS.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Use BFS to determine the component size and then replace them with the size value.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Keep a visited array. If the <i>Visited[i]</i> value is 0, then that node is not visited, 2 means visited but the value is not updated, 1 means the value is updated too. Now, we can perform two BFS - one for getting the exact size and another to replace all the 0s accordingly. The time complexity will be O(N x M).</span></p>"
      },
      "id": 684,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains a single integer <strong>t</strong>, the number of test cases.</span><br><span style=\"background-color:transparent;color:#000000;\">For each test case, the first line contains two integers <strong>N</strong> and <strong>M</strong> and then there are N lines containing M 0s and 1s, representing a N x M binary matrix.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">In the first test case, we have only 2 components and both have size 1. So nothing is replaced.</span><br><span style=\"background-color:transparent;color:#000000;\">In the second test case, we have a total of 5 components of size 7, 4, 3, 1, 1 respectively. So all the 0s are replaced accordingly.</span><br>&nbsp;</p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the final matrix after replacing all the 0s accordingly.</span></p>",
      "samples": [
        {
          "input": "2\n2 2\n0 1\n1 0\n6 5\n1 0 0 1 0\n0 1 0 0 0\n0 0 1 1 0\n0 1 1 0 1\n1 1 1 1 1\n0 1 0 0 0",
          "output": "0 1 \n1 0 \n1 7 7 1 7\n4 1 7 7 7\n4 4 1 1 7\n4 1 1 0 1\n1 1 1 1 1\n0 1 3 3 3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Connected Component Size",
      "video_editorial_id": 10668
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p><p>Complete the function:</p><p><i>vector&lt;int&gt; getInorderTraversal(Node* root)</i></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvoid inorderTraversal(Node* root, vector<int>&ans){\n    if(root==NULL)\n        return;\n    inorderTraversal(root->left,ans);\n    ans.push_back(root->val);\n    inorderTraversal(root->right,ans);\n}\n\nvector<int> getInorderTraversal(Node* root) {\n    vector<int> ans;\n    if(root==NULL)\n        return ans;\n    inorderTraversal(root, ans);\n    return ans;\n}\n\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        vector<int> ans = getInorderTraversal(tree);\n        for(auto v:ans){\n            cout<<v<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:43:18.555842+00:00"
      },
      "hints": {
        "hint1": "<p>First, go to the left tree and print the inorder traversal of the left tree.&nbsp;</p><p>Then print the value of the current node.</p><p>Then go to the right tree and print the inorder traversal of the right tree.</p>",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 573,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, &nbsp;the length of the array representing the serialized representation of a tree.</p><p>The next line contains N-space-separated integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<pre><code class=\"language-plaintext\">Test case 2- \n 5222\n    \\\n   3819\n    /\n  6801\n\t\nTest case 3 - \n   8901\n   /\n  7891\n   /   \\\n  5407 1720</code></pre>",
      "output_format": "<p>Return the inorder traversal of the tree.</p>",
      "samples": [
        {
          "input": "3\n3\n6004 -1 -1 \n7\n5222 -1 3819 6801 -1 -1 -1 \n9\n8901 7891 5407 -1 -1 1720 -1 -1 -1 ",
          "output": "6004 \n5222 6801 3819 \n5407 7891 1720 8901 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n</fix>\n\nvector<int> getInorderTraversal(Node* root) {\n    //Complete the function\n}\n\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        vector<int> ans = getInorderTraversal(tree);\n        for(auto v:ans){\n            cout<<v<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Inorder Traversal",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are <i>n</i> students in AlgoZenith Course and <i>m</i> friendships between them. <span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Your task is to divide the students into two teams in such a way that no two students in a team are friends. You can freely choose the sizes of the teams. The size of each team should be positive.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i> ≤ 10<sup>5</sup><br>1 ≤ <i>m</i> ≤ 2 x 10<sup>5</sup><br>1 ≤ <i>a, b</i> ≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nconst int N = 100010;\n\nint mod = 1e9 + 7;\n\nvector<int> graph[N];\nint par[N];\n\nbool dfs(int u, int x)\n{\n    if (par[u] != -1)\n        return par[u] == x;\n    par[u] = x;\n    for (int v : graph[u])\n    {\n        if (!dfs(v, 1 - x))\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    for (int i = 1; i <= n; i++)\n    {\n        par[i] = -1;\n    }\n\n    for (int i = 1; i <= n; i++)\n    {\n        if (par[i] == -1 && !dfs(i, 0))\n        {\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n\n    cout << \"YES\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:40:14.247007+00:00"
      },
      "hints": {
        "hint1": "Look to use some property of Bipartite Graphs.",
        "hint2": "To divide the students into two teams such that no two students in a team are friends, we can use the concept of graph theory. We can represent the students as vertices in a graph, and the friendships between them as edges. Then, we need to find if the graph is bipartite or not.\n\nA bipartite graph is a graph whose vertices can be divided into two disjoint sets, say A and B, such that every edge connects a vertex in set A to a vertex in set B. If the graph is bipartite, we can divide the students into two teams by assigning one team to set A and the other team to set B.",
        "solution_approach": "To check if the graph is bipartite, we can use graph coloring. We can start by assigning a color (say, red) to one vertex and then assign the opposite color (say, blue) to all its neighbors. We repeat this process for all uncolored vertices until all vertices are colored or we find a conflict, i.e., a vertex and its neighbor have the same color. If we find a conflict, it means that the graph is not bipartite and we cannot divide the students into two teams. Otherwise, we can divide the students into two teams based on their colors.\n\nIf the graph is not bipartite, we cannot divide the students into two teams such that no two students in a team are friends. In this case, we may need to form more than two teams or change the size of the teams.\n\nIn terms of complexity, the worst-case time complexity of graph coloring is $O(V + E)$, where $V$ is the number of vertices and $E$ is the number of edges in the graph. Therefore, the time complexity of dividing the students into two teams using graph coloring is $O(n + m)$."
      },
      "id": 193,
      "input_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">The first input line has two integers <i>n</i> and <i>m</i>: the number of students and friendships. The students are numbered 1, 2, …, <i>n</i>.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Then, there are <i>m</i> lines describing friendships. Each line has two integers <i>a</i> and <i>b</i>: students <i>a</i> and <i>b</i> are friends.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Every friendship is between two different students. You can assume that there is at most one friendship between any two students.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>Print ‘YES’ if it's possible to divide students in two teams, otherwise print ‘NO’.</p>",
      "samples": [
        {
          "input": "5 3\n1 2\n1 3\n4 5",
          "output": "YES"
        },
        {
          "input": "4 3\n1 2\n2 3\n1 3",
          "output": "NO"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Creating Teams",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Alice and Bob have a keyboard that can type lower case English alphabets. The keyboard also has a <strong>backspace</strong> key. When the backspace key is pressed, the last character from the string is removed and if the string is empty, nothing happens.</span><br><span style=\"background-color:transparent;color:#000000;\">Alice and Bob have both typed a string in their respective computers with this keyboard. When they pressed the backspace key, ‘<strong>#</strong>’ was inserted into the string.</span><br><span style=\"background-color:transparent;color:#000000;\">They want to know whether their strings are equal when it is typed into a text editor.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For example,</span><br><span style=\"background-color:transparent;color:#000000;\">When the string “<strong>aab#a</strong>” is typed into a text editor, we obtain “<strong>aaa</strong>”.</span></p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= |s| &lt;= 100000\n1 &lt;= |t| &lt;= 100000</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nbool StringCompare(string s, string t) {\n\tint n, m;\n\tn = s.length();\n\tm = t.length();\n\tstack <char> cur;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == '#') {\n\t\t\tif (cur.empty())\n\t\t\t\tcontinue;\n\t\t\tcur.pop();\n\t\t}\n\t\telse\n\t\t\tcur.push(s[i]);\n\t}\n\ts = \"\";\n\twhile (!cur.empty()) {\n\t\tchar ch = cur.top();\n\t\tcur.pop();\n\t\ts += ch;\n\t}\n\treverse(s.begin(), s.end());\n\tfor (int i = 0; i < m; i++) {\n\t\tif (t[i] == '#') {\n\t\t\tif (cur.empty())\n\t\t\t\tcontinue;\n\t\t\tcur.pop();\n\t\t}\n\t\telse\n\t\t\tcur.push(t[i]);\n\t}\n\tt = \"\";\n\twhile (!cur.empty()) {\n\t\tchar ch = cur.top();\n\t\tcur.pop();\n\t\tt += ch;\n\t}\n\treverse(t.begin(), t.end());\n\tif (s == t)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tstring s, t;\n\tcin >> s >> t;\n\tif (StringCompare(s, t))\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n}\n```\n\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool StringCompare(string s, string t) {\n\tint i = (int)s.length() - 1;\n\tint j = (int)t.length() - 1;\n\tint skips = 0;\n\tint skipt = 0;\n\twhile (i >= 0 || j >= 0) {\n\t\twhile (i >= 0) {\n\t\t\tif (s[i] == '#') {\n\t\t\t\tskips++;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse if (skips > 0) {\n\t\t\t\tskips--;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (j >= 0) {\n\t\t\tif (t[j] == '#') {\n\t\t\t\tskipt++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t\telse if (skipt > 0) {\n\t\t\t\tskipt--;\n\t\t\t\tj--;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= 0 && j >= 0 && s[i] != t[j])\n\t\t\treturn false;\n\t\tif ((i >= 0) != (j >= 0))\n\t\t\treturn false;\n\t\ti--;\n\t\tj--;\n\t}\n\treturn true;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tstring s, t;\n\tcin >> s >> t;\n\tif (StringCompare(s, t))\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:19:30.943674+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Can you think of a data structure that can help us do the backspace operations easily?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">A Stack of characters can be used to implement the backspace operations.</span></p>",
        "solution_approach": "<p><u>Solution 1</u></p><p><span style=\"background-color:transparent;color:#000000;\">To implement the functions of the keyboard we use a stack. We push the characters of the string into the stack one by one and when we encounter the backspace ‘#’ character, we pop the character present at the top of the stack and if the stack is empty we do nothing.</span></p><p><span style=\"background-color:transparent;color:#000000;\">When the entire string has been traversed, the characters left in the stack represent the string typed into the text editor. So we pop all the characters in the stack one by one and add them to the final string. The string is currently in reverse order so we can reverse the two final strings and compare them.</span></p><p><span style=\"background-color:transparent;color:#000000;\"><u>Solution 2</u></span></p><p><span style=\"background-color:transparent;color:#000000;\">When writing a character, it may or may not be part of the final string depending on how many backspace keystrokes occur in the future.</span><br><span style=\"background-color:transparent;color:#000000;\">If instead, we iterate through the string in reverse, then we will know how many backspace characters we have seen, and therefore whether the result includes our character.</span><br><span style=\"background-color:transparent;color:#000000;\">Iterate through the string in reverse. If we see a backspace character, the next non-backspace character is skipped. If a character isn't skipped, it is part of the final answer.</span></p>"
      },
      "id": 640,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">Implement the <strong>StringCompare</strong> function that takes in the two strings <strong>s </strong>and <strong>t</strong>.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<ol><li><span style=\"background-color:transparent;color:#000000;\">Both strings become “b” in the text editor.</span></li><li><span style=\"background-color:transparent;color:#000000;\">String s becomes&nbsp; “b” while the string t becomes “c”.</span></li></ol>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Return <strong>true</strong> if the two strings are equal and <strong>false</strong> otherwise.</span></p>",
      "samples": [
        {
          "input": "a##b\n#a#b",
          "output": "Yes"
        },
        {
          "input": "a##b\n#a#c",
          "output": "No"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nbool StringCompare(string s, string t) {\n\t\n}\n\n<fix>\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tstring s, t;\n\tcin >> s >> t;\n\tif (StringCompare(s, t))\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "String Compare",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array \\(A\\) of size \\(N\\). $(A_1, A_2, \\ldots, A_N)$ are the elements of the array. All elements in the array \\(A\\) are distinct.  \n\nFind the sum of the minimum of all subarrays possible of array \\(A\\).  \n\n##### Definition:\nA **subarray** of an \\(N\\)-element array is an array composed of a contiguous block of the original array's elements.",
      "complete_approach": "",
      "constraints": "<p>1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>T</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 100000<br>1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>N</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 100000<br>1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>A<sub>i</sub></i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>6</sup><br>Sum of <i>N</i> over all test cases <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 5 * 10<sup>5</sup>.<br>It is guaranteed that all elements in an array <i>A</i> are distinct.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int T; cin >> T;\n    while(T--) {\n        int n; cin >> n;\n        int A[n + 2];\n        for(int i = 1; i <= n; i++)\n            cin >> A[i];\n        A[0] = -inf;\n        A[n + 1] = -inf;\n\n        int prev[n + 2], nxt[n + 2];\n\n        stack<int> s;\n        s.push(0);\n        for(int i = 1; i <= n; i++) {\n            while(!s.empty() && A[s.top()] >= A[i])\n                s.pop();\n            assert(!s.empty());\n            prev[i] = s.top();\n            s.push(i);\n        }\n\n        while(!s.empty()) s.pop();\n\n        s.push(n + 1);\n        for(int i = n; i >= 1; i--) {\n            while(!s.empty() && A[s.top()] >= A[i])\n                s.pop();\n            assert(!s.empty());\n            nxt[i] = s.top();\n            s.push(i);\n        }\n\n        ll ans = 0;\n\n        for(int i = 1; i <= n; i++)\n            ans += 1LL * A[i] * (i - prev[i]) * (nxt[i] - i);\n\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:47:41.807942+00:00"
      },
      "hints": {
        "hint1": "<p>Try to think for the Individual Elements Contribution to the Final answer. How may subarrays will some element <i>A<sub>i</sub></i> be a minimum of in total?</p>",
        "hint2": "<p>Find the next smaller and just previous smaller elements for all elements in the array. How to find them? Use stack!</p>",
        "solution_approach": "<p>We try to find the individual contribution of all elements in the array.&nbsp;<br>Suppose <i>cnt<sub>i</sub></i> is the number of subarrays with <i>A<sub>i</sub></i> is the minimum.<br>Then the answer will be the sum of all <i>cnt<sub>i</sub> * A<sub>i</sub></i>. So now the question is how to find <i>cnt<sub>i</sub></i>?<br>Create a new array <i>B</i> by appending <i>-INF</i> at the beginning and end of the array <i>A</i>.<br><i>B = {-INF, A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>, -INF}.</i><br>Now for newly constructed array <i>B</i> find the next smaller and the previous smaller for each element <i>B<sub>i</sub></i> s.t. 2 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>i</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>N</i>+1 (assuming array to be 1-index).<br>Let <i>n<sub>i</sub></i> and <i>p<sub>i</sub></i> be the index of next smaller and previous smaller of element <i>B<sub>i</sub></i>, s.t. 2 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>i</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>N</i>+1.<br>Now all the subarrays <i>[start, end]</i> with <i>start <strong>∈</strong> {p<sub>i</sub> + 1, i}</i> and <i>end <strong>∈</strong> {i, n<sub>i</sub> - 1}</i> has minimum value of <i>B<sub>i</sub></i>.<br>That means, the contribution of <i>B<sub>i</sub></i> in total sum is <i>(i - p<sub>i</sub>) * (n<sub>i</sub> - i)</i>.<br>So the final answer is the sum of the contribution of all <i>B<sub>i</sub></i>s. (Note that we are only considering 2 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>i</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>N</i>+1.)<br>We can find the next smaller and previous smaller in <i>O(N)</i> using stack.</p><p><strong>Time complexity:</strong> <i>O(N)</i><br><strong>Space complexity:</strong> <i>O(N)</i></p>"
      },
      "id": 78,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases.<br>The first line of each test case contains <i>N</i>, the number of integers in an array <i>A</i>.<br>The second line of each test case contains <i>N</i> space-separated integers <i>A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub></i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>Min{1} + Min{1, 2} + Min{1, 2, 3} + Min{2} + Min{2, 3} + Min{3} = 1 + 1 + 1 + 2 + 2 + 3 = 10</p><p><i><strong>Explanation 2:</strong></i><br>Min{1} + Min{1, 5} + Min{5} = 1 + 1 + 5 = 7</p>",
      "output_format": "<p>For each test case, print a single number representing the sum of the minimum of all subarrays of <i>A</i>.</p>",
      "samples": [
        {
          "input": "5\n3\n1 2 3\n2\n1 5\n4\n2 3 4 10\n8\n1000000 1000001 1000002 1000003 1000004 1000005 1000006 1000007\n3\n3 1 2",
          "output": "10\n7\n35\n36000084\n9"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Super Minimum Sum",
      "video_editorial_id": 8141
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a binary array of length <strong>N</strong>. The score of an array is the length of the longest continuous subsegment consisting of only one.</p><p>Find the maximum score possible if you can change at most <strong>K</strong> elements of the array.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤ 10<sup>4</sup><br>1 <i>≤ </i>N <i>≤ </i>10<sup>5</sup><br>0<i> ≤ </i>K <i>≤ </i>N<br>Sum of N across all test cases ≤ 10<sup>6</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint arr[1000000];\nint n,k;\nbool check(int x)\n{\n   int cnt = 0,i;\n   for(i=0;i<x;i++)\n   {\n       if(arr[i]==0)\n           cnt++;\n   }\n   if(cnt<=k)\n       return true;\n   for(i=x;i<n;i++)\n   {\n       if(arr[i-x]==0)\n           cnt--;\n       if(arr[i]==0)\n           cnt++;\n       if(cnt<=k)\n           return true;\n   }\n   return false;\n}\nint main()\n{\n   ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n   int testcases;\n   cin>>testcases;\n   while(testcases--){\n       int i;\n       cin>>n>>k;\n       for(i=0;i<n;i++)\n           cin>>arr[i];\n       int low = k;\n       int high = n;\n       int ans = low;\n       while(low<=high)\n       {\n           int mid=(low+high)/2;\n           if(check(mid))\n           {\n               ans = mid;\n               low=mid+1;\n           }\n           else\n               high = mid-1;\n       }\n       cout<<ans<<\"\\n\";\n   }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:44:34.753686+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">If maximum score X is possible, then scores below X are also possible. That means this is a monotonic function. You can use this to apply binary search.</span></p>",
        "hint2": "<p>We would be doing binary search on the maximum score possible. We take the left pointer as L = 0 and the right pointer as R = N. We take mid = (L+R)/2. Find if it is possible to have mid number of consecutive ones, by changing at most K values in the array. This can be done by going through all the subarrays of size mid and counting the number of 0s in it. If any subarray has a count of 0s ≤ K, then mid is a possible answer.</p><p>If it is possible, mid could be a possible answer and we continue binary search on L = mid+1 and R. Otherwise, any value above mid would also not be a possible answer(because if score mid is not possible, any score above mid would also not be possible), so we continue binary search on L and R = mid-1.</p><p>Time Complexity per test case: O(N*log<sub>2</sub>N)</p>",
        "solution_approach": ""
      },
      "id": 44,
      "input_format": "<p>The first line contains an integer <strong>T</strong>, the number of test cases.<br>The first line of each test case contains two space-separated integer <strong>N, K</strong> where&nbsp;<br>The next line contains <strong>N</strong> space-separated integers which are either 0 or 1.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the maximum score possible if you can change at most <strong>K</strong> elements of the array in a new line.</p>",
      "samples": [
        {
          "input": "5\n10 2\n1 0 1 1 0 1 1 0 0 1\n10 1\n1 1 0 1 0 0 0 1 0 0\n10 3\n1 0 0 1 1 0 1 1 0 1\n10 3\n1 1 1 0 0 0 1 1 1 1\n10 3\n1 1 0 0 1 1 0 0 1 1",
          "output": "7\n4\n8\n10\n7"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Consecutive one",
      "video_editorial_id": 10684
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a lowercase alphabet string $s$, output the minimum number of adjacent swaps required to convert it into a palindrome. If it's not possible, output $-1$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$\n$1 \\leq |s| \\leq 1000$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint minswaps(string s) {\n\tvector<array<int, 2>> v[26];\n\tint l = 0, r = s.size() - 1, ans = 0;\n\twhile (l <= r) {\n\t\tint cost = 1e9, ai = -1, aj = -1;\n\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\tint i = l, j = r;\n\t\t\twhile (i <= j && s[i] != c)i++;\n\t\t\twhile (i <= j && s[j] != c)j--;\n\t\t\tif (i < j && cost >= abs(l - i) + abs(r - j))ai = i, aj = j, cost = abs(l - i) + abs(r - j);\n\t\t}\n\t\twhile (aj != -1 && ai > l)swap(s[ai], s[ai - 1]), ai--, ans++;\n\t\twhile (aj != -1 && aj < r)swap(s[aj], s[aj + 1]), aj++, ans++;\n\t\tl++, r--;\n\t}\n\tstring t = s;\n\treverse(t.begin(), t.end());\n\tif (t == s)return ans;\n\treturn -1;\n}\nint minswaps2(string s) {\n\tint l = 0, r = s.size() - 1, ans = 0, odd = 0;\n\tvector<int> cnt(26, 0);\n\tfor (auto c : s)cnt[c - 'a']++;\n\tfor (int i = 0; i < 26; i++)odd += (cnt[i] & 1);\n\tif (odd > 1)return -1;\n\twhile (l < r) {\n\t\tint i = l, j = r;\n\t\twhile (s[i] != s[j])j--;\n\t\tif (i == j) {\n\t\t\tswap(s[i], s[i + 1]), ans++;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (j < r)swap(s[j], s[j + 1]), j++, ans++;\n\t\tl++, r--;\n\t}\n\treturn ans;\n}\n\n\nvoid solve() {\n\tstring s;\n\tcin >> s;\n\tint ans1 = minswaps(s), ans2 = minswaps2(s);\n\tcout << ans1 << endl;\n\tassert(ans1 == ans2);\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:25:11.288764+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "**Intuition**\n\n1. If more than one character in a string occurs an odd number of times that string can't be a palindrome.\n2. Only adjacent swaps are allowed, so for each character in the left half of a string, we need to find the rightmost occurrence of that char so we can minimize the swaps.\n3. Handle the corner case that is, one odd occurring element in the string.\n\n**Implementation**\n\nCode for the invalid case is trivial, now when finding the rightmost occurring character of the current character if we reach the current character itself that means the current character is the odd occurring character in our string.\nFor an odd occurring character, we will just swap it with the next character of our string because the ideal place for that character is in the middle so by shifting it right we are ensuring we are not increasing our answer, plus if we shift that character all the way to middle in that iteration itself then the answer may not be correct consider the example \"daamm\" for my second point. if we shift d to the middle in that iteration itself it messes up the order for other elements.\n\n**Time Complexity :** $O(n^2)$ \n**Space Complexity :** $O(26)$"
      },
      "id": 990,
      "input_format": "The first line contains $T$ - the number of test cases.\nThe first line of each test case contains string $s$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the minimum number of adjacent swaps required to convert it into a palindrome. If it's not possible, then output $-1$.",
      "samples": [
        {
          "input": "4\ndaamm\nbaa\nabba\nalgozenith\n",
          "output": "4\n1\n0\n-1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Minimum Swaps Palindrome",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given an array A of size N. In one operation you can select any <strong>non-decreasing</strong> subarray and increment all the elements in the subarray by one. Your goal is to make the whole array <strong>non-decreasing</strong> in minimum operations.</p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "<p>T ≤ 10</p><p>1 ≤ n ≤ 10<sup>5</sup></p><p>0 ≤ A<sub>i</sub> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \nint main()\n{\n    int n, i, j, t;\n \n    cin >> t;\n    while (t--)\n    {\n        cin>>n;\n        int arr[n];\n        for(i=0;i<n;i++) cin>>arr[i];\n        long long sum=0;\n        for(i=1;i<n;i++)\n        {\n            if(arr[i]<arr[i-1])\n            {\n                sum+=arr[i-1]-arr[i];\n            }\n        }\n        cout<<sum<<\"\\n\";\n    }\n \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:38:14.503949+00:00"
      },
      "hints": {
        "hint1": "If you increase all the elements of a non-decreasing subarray, it would remain to be a non-decreasing subarray.",
        "hint2": "Consider a subarray which is non-decreasing, you need to make the first element of this subarray ≥ its previous element.",
        "solution_approach": "Traverse through the given array and if you get A[i-1] ≥ A[i], add (A[i-1] - A[i]) to the answer. The value, (A[i-1] - A[i]) would be added to all the elements in the non-decreasing subarray starting from A[i].\n\nTime Complexity per test case: O(N)"
      },
      "id": 222,
      "input_format": "<p>First line of input contains T, number of test cases.</p><p>First line of each test case contains n.</p><p>Next line contains n integers of array A.</p><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print a single integer in a new line: Minimum number of operations.</p>",
      "samples": [
        {
          "input": "2\n4\n5 3 2 5\n3\n1 1 1",
          "output": "3\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Make it smooth",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an integer N. You have to find the number of divisors of N.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1 </span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 1000</span></p><p><span style=\"background-color:#ffffff;color:#000000;\">1 ≤ N ≤ 10<sup>7</sup></span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int ans = 0;\n    for (int i = 1; i * i <= n; ++i) {\n      if (n % i == 0) {\n        if (i * i == n) {\n          ans++;\n        } else {\n          ans += 2;\n        }\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:32:38.878585+00:00"
      },
      "hints": {
        "hint1": "All the divisors are present in pairs i.e. if $x$ is a divisor of $N$, then $\\dfrac{N}{x}$ is also a divisor of $N$.",
        "hint2": "",
        "solution_approach": "If $x$ is a divisor of $N$, then $\\dfrac{N}{x}$ is also a divisor of $N$. Either $x \\leq \\sqrt(N)$ or $\\dfrac{N}{x} \\leq \\sqrt(N)$. So we iterate from $1$ to $\\sqrt(N)$ to find the number of divisors. For pairs where $x=\\dfrac{N}{x}$, you need to count the diviors only once.\n\nTime Complexity per test case: $O(\\sqrt(N))$"
      },
      "id": 322,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer N.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, the divisors of 12 are: 1, 2, 3, 4, 6, 12.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, the divisors of 5 are: 1, 5.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, the divisors of 9 are: 1, 3, 9.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the number of divisors of N.</span></p>",
      "samples": [
        {
          "input": "3\n12\n5\n9\n",
          "output": "6\n2\n3\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Number of Divisors AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Alice and Bob are playing a new game, which is very interesting and fun. The game is as follows:\n\n1. The game starts with two $n$-sized integer arrays, $A$ and $B$, and is played by two players, $P_1$ and $P_2$.\n2. The players move in alternating turns, with $P_1$ always moving first. During each move, the current player must choose an integer, $i$, such that $0 \\leq i \\leq n - 1$.  \n   - If the current player is $P_1$, then $P_1$ receives $A_i$ points.  \n   - If the current player is $P_2$, then $P_2$ receives $B_i$ points.\n3. Each value of $i$ can be chosen only once. That is, if a value of $i$ is already chosen by some player, none of the players can re-use it. So, the game always ends after $n$ moves.\n4. The player with the maximum number of points wins.\n5. The arrays $A$ and $B$ are accessible to both the players $P_1$ and $P_2$. So the players make an **optimal move** at every turn.\n\nGiven the values of $n$, $A$, and $B$, can you determine the outcome of the game? $P_1$ is Alice, and $P_2$ is Bob.  \nPrint **‘Alice’** if Alice will win, **'Bob'** if Bob will win, or **'Tie'** if they will tie. Assume both players always move *optimally*.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10$  \n\n$2 \\leq N \\leq 1000$  \n\n$1 \\leq A_i, B_i \\leq 10^5$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define int long long\n#define F first\n#define S second\n\nusing ii = pair<int, int>;\n\nbool comp(ii a, ii b) { return a.F + a.S > b.F + b.S; }\n\nvoid solve() {\n  int n;\n  cin >> n;\n  int a[n], b[n];\n  vector<ii> arr;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) cin >> b[i];\n  for (int i = 0; i < n; i++) arr.push_back({a[i], b[i]});\n\n  sort(arr.begin(), arr.end(), comp);\n  int asc = 0, bsc = 0, turn = 0;\n  for (int i = 0; i < n; i++) {\n    if (turn == 0) {\n      asc += arr[i].F;\n      turn++;\n    } else {\n      bsc += arr[i].S;\n      turn--;\n    }\n  }\n\n  if (asc > bsc)\n    cout << \"Alice\" << endl;\n  else if (asc == bsc)\n    cout << \"Tie\" << endl;\n  else\n    cout << \"Bob\" << endl;\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  int _t = 1;\n  cin >> _t;\n  // string s; getline(cin, s);//\n\n  while (_t--) {\n    solve();\n  }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:36:28.183047+00:00"
      },
      "hints": {
        "hint1": "Optimal play is to make your score > opponent's score, NOT to maximize your score.\nAn optimal move isn't always to choose the maximum available element\nSometimes, optimal move is to choose smaller element which blocks a big element on the opponent's side.",
        "hint2": "Lets take an example :  A = [ a , x ] B = [ b , y ]\nIf I am player $1$: if I pick the first , my score is a , my opponents score is y\nIf I pick the second , my score is x , my opponents score is b\nCondition for first choice to be better than second choice is that if I score better than my opponents score in first choice\n$a-y > x-b$\n$a+b > x+y$\n\nAfter some thinking one may conclude, that in an optimal play the sequence of cards must have descending values.",
        "solution_approach": "It can be proven that the optimal move for the current player is to always choose the first unused element having the maximal value for $A_i + B_i$, as the player will either add the largest number of points to their own score or block the opposing player from ever receiving a large number of points.\n\nSo now that we've established we must both maintain paired values and choose the first available index i having a maximal value for $A_i + B_i$, we have to consider the most efficient way to find which index i to choose. The best way to do this is to sort each pair of values in descending order of the maximum sum of $A_i$ and $B_i$.\n\nNext, we simply need to traverse the sorted array from $0$ to $n - 1$, adding the appropriate number of points at index i (i.e., the paired value at i associated with the current player) to the current player's score. This means that in the ith move, the current player will make an optimal move by choosing the ith element in the sorted array.\n\nOnce we've finished summing the scores, we simply compare them and print the appropriate result.\n\nTime Complexity: $O(N \\log N)$\nSpace Complexity: $O(N)$ extra space"
      },
      "id": 76,
      "input_format": "The first line of input contains one integer $T$ ($1 \\leq T \\leq 10$) — the number of test cases. Then $T$ test cases follow.  \n\nThe first line of each test case contains $N$ ($2 \\leq N \\leq 1000$), the number of elements in arrays $A$ and $B$.  \n\nThe second line contains $N$ space-separated integers $A_1, A_2, \\dots, A_N$ - the elements of array $A$.  \n\nThe third line contains $N$ space-separated integers $B_1, B_2, \\dots, B_N$ - the elements of array $B$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>The players make the following 3 moves:</p><ol><li>Alice chooses i = 2 and receives 4 coins.</li><li>Bob chooses i = 0 and receives 5 coins. Notice that Bob won't choose i = 1, because this would cause Alice to win.</li><li>Alice chooses i = 1 (the only remaining move) and receives 3 coins.</li></ol><p>The total score of Alice is 7, while the total score of Bob is 5. Hence, Alice wins.</p><p><i><strong>Explanation 2:</strong></i><br>Both players will only make 1 move and all possible point values are 1, the players will end the game with equal scores.</p><p><i><strong>Explanation 3:</strong></i><br>Both players will only make 1 move and all the possible point values for Bob are greater than all the possible point values for Alice, Bob will win the game.</p>",
      "output_format": "<p>For each test case, print one of the following predicted outcomes of the game on a new line:</p><ol><li>Print 'Alice' if Alice will win.</li><li>Print 'Bob' if Bob will win.</li><li>Print 'Tie' if the two players will tie.</li></ol>",
      "samples": [
        {
          "input": "3\n3\n1 3 4\n5 3 1\n2\n1 1\n1 1\n2\n2 2\n3 3",
          "output": "Alice\nTie\nBob"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Interesting Game",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two strings $S$ and $T$, find length of the shortest subsequence in $S$ which is not a subsequence in $T$. If no such subsequence is possible, return $-1$. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.",
      "complete_approach": "",
      "constraints": "$1 \\leq t \\leq 100$\n$1 \\leq |S| \\leq 1000$\n$1 \\leq |T| \\leq 1000$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstring s1, s2;\nint n, m;\nint dp[1001][1001], pre[1001][1001];\nint rec(int i, int j) {\n    if (i == -1)return 1e9;\n    if (j == -1)return 1;\n    auto &ans = dp[i][j];\n    if (ans != -1)return ans;\n    ans = rec(i - 1, j);\n    if (pre[i][j] == -1)ans = 1;\n    else ans = min(ans, 1 + rec(i - 1, pre[i][j] - 1));\n    return ans;\n}\nvoid solve() {\n    cin >> s1 >> s2;\n    n = s1.size(), m = s2.size();\n    memset(dp, -1, sizeof(dp));\n    for (int i = 0; i < n; i++) {\n        int p = -1;\n        for (int j = 0; j < m; j++) {\n            if (s1[i] == s2[j])p = j;\n            pre[i][j] = p;\n        }\n    }\n    int ans = rec(n - 1, m - 1);\n    if (ans > n)ans = -1;\n    cout << ans << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n\n\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:42:39.758347+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We establish the relationship between the sub problems and the problem at hand. Let $L(i, j)$ be the length of the shortest subsequence that is in $S[1..i]$ that is not in $T[1..j]$. Here we have the following relationship:\n$L(i, j) =$\n1. If letter $S[i]$ is nowhere to be found in $T[1..j]$, then $L(i,j) = 1$.\n2. Otherwise, we have two cases:\n    2.1. $S[i]$ is in the shortest subsequence. We find $k$, the most immediate index in $T[1..j]$ where $T[k] == S[i]$. Then $L(i, j) = 1 + L(i-1, k-1)$.\n    2.2 $S[i]$ is not in the shortest subsequence. Then $L(i, j) = L(i-1, j)$.\n    We pick whichever is lower.\n\n**Time Complexity** : $O(N^{2})$ per test case."
      },
      "id": 920,
      "input_format": "First-line contains $t$ - the number of test cases.\nThe first line of each test case contains the string $S$.\nThe Second-line of each test case contains the string $T$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "for first test, one of the shortest uncommon subsequence is \"banna\".",
      "output_format": "For each test case, output the length of the shortest subsequence in $S$ which is not a subsequence in $T$. If no such subsequence is possible, output $-1$.",
      "samples": [
        {
          "input": "3\nbanana \nanbnaanbaan\naaa\na\naba\nabaa\n",
          "output": "5\n2\n-1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Uncommon Subsequences",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given a string S consisting of ‘(‘ and ‘)’ characters. You have to find the longest substring that is a regular bracket sequence. You also have to find the number of such substrings. A bracket sequence is called regular if by inserting ‘+’ and ‘1’ into it we can get a correct mathematical expression.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤100000</p><p>1 ≤ |S| ≤ 10^5</p><p>Sum of |S| across all test cases ≤ 10^7.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main(){\n   IOS\n   int t;\n   cin>>t;\n   while (t--) {\n       string s;\n       cin>>s;\n       int n=s.size();\n       stack<int> ss;\n       int dp[n];\n       memset(dp,-1,sizeof(dp));\n       for (int i = 0; i < n; ++i) {\n           if(s[i]=='('){\n               ss.push(i);\n           }\n           else{\n               if(!ss.empty()){\n                   int t = ss.top();\n                   ss.pop();\n                   if(t-1 >= 0 && s[t-1] == ')' && dp[t-1] != -1) {\n                       dp[i]=dp[t-1];\n                   }\n                   else{\n                       dp[i]=t;\n                   }\n               }\n           }\n       }\n       int ans=0;\n       for (int i = 0; i < n; ++i) {\n           if(dp[i] != -1){\n               ans=max(ans, i-dp[i]+1);\n           }\n       }\n       int x=0;\n       for (int i = 0; i < n; ++i) {\n           if(dp[i] != -1){\n               if(ans == i-dp[i]+1)\n                   x++;\n           }\n       }\n       if(ans==0) x=1;\n       cout<<ans<<\" \"<<x<<\"\\n\";\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:22:05.457403+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Match every ‘)’ character with the left closest ‘(‘ character.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Make an array DP[i] which stores the left closest ‘(‘ character for every ‘)’ character. For every i, the difference between i and DP[i] tells the maximum length of </span>the <span style=\"background-color:transparent;color:#000000;\">regular bracket sequence.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The implementation can be made easier with the use of </span>a <span style=\"background-color:transparent;color:#000000;\">stack.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N)</span></p>",
        "solution_approach": ""
      },
      "id": 184,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first and only line of each test case contains string S.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, there is one regular bracket sequence ()(<strong>(())</strong> which is of length 4.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, there are two regular bracket sequences, )<strong>()()</strong>)<strong>(())</strong>, which are of length 4.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, there is no regular bracket sequence, no ‘(‘ matches ‘).</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the length of the longest substring that is a regular bracket sequence, and the number of such substrings. If there are no such substrings, print \"0 1\".</span></p>",
      "samples": [
        {
          "input": "3\n()((())\n)()())(())\n))((",
          "output": "4 1\n4 2\n0 1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Bracket Sequence",
      "video_editorial_id": 8164
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$. Print first $N$ numbers of the Fibonacci sequence.\n\n**Note**: In order to create the **Fibonacci** sequence use the following function:\n\n* fib($1$) = $0$.\n* fib($2$) = $1$.\n* fib($N$) = fib($N - 1$) + fib($N - 2$).",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N \\leq 45 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// O(N) time\n// O(1) space\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    // base case if n is 1\n    if (n == 1)\n    {\n        cout << \"0\";\n    }\n    else\n    {\n        int a = 0; // f(1)\n        int b = 1; // f(2)\n        cout << a << \" \" << b << \" \";\n        // n>=2 so print first two terms\n        for (int i = 3; i <= n; i++)\n        {\n            cout << a + b << \" \"; // f(i) = f(i-1)+f(i-2)\n            int t = b;            // t = f(i-1)\n            b = a + b;            // b = f(i) = f(i-1)+f(i-2)\n            a = t;                // a = f(i-1)\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:36:04.621030+00:00"
      },
      "hints": {
        "hint1": "The recurrence formula is already given. You can store the previous numbers and use it to calculate next term.",
        "hint2": "",
        "solution_approach": "You can store the fibonacci sequence in an array and print the result. The time and space complexity will be $O(N)$. However a new term depends only on the previous two terms, so we can **store only the previous two terms**, and find new term, and update the previous two terms. This will reduce the space complexity to $O(1)$."
      },
      "id": 1214,
      "input_format": "Only one line containing a number $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "Calculate the first $7$ elements of the fibonacci sequence, they are $0, 1, 1, 2, 3, 5$ and $8$.",
      "output_format": "Print the first $N$ numbers from the **Fibonacci** Sequence.",
      "samples": [
        {
          "input": "7\n",
          "output": "0 1 1 2 3 5 8\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Easy Fibonacci",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Design a data structure that supports adding new words and finding if a string matches any previously added string.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Implement the <strong>WordDictionary </strong>class:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\"><strong>WordDictionary() - </strong>Initialises the object.</span></li><li><span style=\"background-color:transparent;color:#000000;\"><strong>void addWord(word) - </strong>Adds word to the data structure, it can be matched later.</span></li><li><span style=\"background-color:transparent;color:#000000;\"><strong>bool search(word)</strong> - Returns <strong>true</strong> if there is any string in the data structure that matches <strong>word</strong> or <strong>false</strong> otherwise. <strong>word</strong> may contain dots '.' where dots can be matched with any letter.</span></li></ol>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= |word| &lt;= 100\n1 &lt;= q &lt;= 1000 (total number of function calls made)\nword in addWord consists of lower case English alphabets\nword in search consists of lower case English alphabets and ‘.’ character</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Trie {\npublic:\n\tbool word;\n\tTrie* children[26];\n\tTrie() {\n\t\tword = false;\n\t\tmemset(children, NULL, sizeof(children));\n\t}\n\n};\n\nclass WordDictionary {\npublic:\n\tWordDictionary() {\n\n\t}\n\n\tvoid addWord(string word) {\n\t\tTrie* node = root;\n\t\tfor (char c : word) {\n\t\t\tif (!node->children[c - 'a']) {\n\t\t\t\tnode->children[c - 'a'] = new Trie();\n\t\t\t}\n\t\t\tnode = node->children[c - 'a'];\n\t\t}\n\t\tnode->word = true;\n\t}\n\n\tbool search(string word) {\n\t\treturn search(word.c_str(), root);\n\t}\n\nprivate:\n\tTrie* root = new Trie();\n\tbool search(const char* word, Trie* node) {\n\t\tfor (int i = 0; word[i] && node; i++) {\n\t\t\tif (word[i] != '.') {\n\t\t\t\tnode = node->children[word[i] - 'a'];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tTrie* temp = node;\n\t\t\t\tfor (int j = 0; j < 26; j++) {\n\t\t\t\t\tnode = temp->children[j];\n\t\t\t\t\tif (search(word + i + 1, node)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn node && node->word;\n\t}\n\n};\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tWordDictionary* obj = new WordDictionary();\n\n\tint q;\n\tcin >> q;\n\n\twhile (q--) {\n\n\t\tstring op;\n\t\tcin >> op;\n\n\t\tif (op == \"add\") {\n\t\t\tstring word;\n\t\t\tcin >> word;\n\t\t\tobj->addWord(word);\n\t\t}\n\n\t\telse {\n\t\t\tstring word;\n\t\t\tcin >> word;\n\t\t\tif (obj->search(word))\n\t\t\t\tcout << \"Yes\\n\";\n\t\t\telse\n\t\t\t\tcout << \"No\\n\";\n\t\t}\n\t}\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:30:21.354877+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">We can solve this problem using the Trie data structure. Do DFS on trie, till the match happens.</span></p>"
      },
      "id": 665,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">Your WordDictionary object will be instantiated and called as such:</span></p><pre><code class=\"language-plaintext\">WordDictionary* obj = new WordDictionary();\nobj-&gt;addWord(word);\nbool param_2 = obj-&gt;search(word);</code></pre>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<pre><code class=\"language-plaintext\">pad -&gt; No matching string.\nmad -&gt; present in the data structure.\n.ad -&gt; Matched by bad, mad, dad.\nb.. -&gt; Matched by bad.</code></pre>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For <strong>search </strong>queries, if there is a string in the data structure that matches <strong>word</strong>, ‘Yes’ is printed.</span><br><span style=\"background-color:transparent;color:#000000;\">Otherwise, ‘No’ is printed.</span></p>",
      "samples": [
        {
          "input": "7\nadd dad\nadd bad\nadd mad\nsearch pad\nsearch mad\nsearch .ad\nsearch b..",
          "output": "No\nYes\nYes\nYes"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nclass WordDictionary {\npublic:\n\tWordDictionary() {\n\n\t}\n\n\tvoid addWord(string word) {\n\t\t\n\t}\n\n\tbool search(string word) {\n\t\t\n\t}\n\n};\n\n<fix>\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tWordDictionary* obj = new WordDictionary();\n\n\tint q;\n\tcin >> q;\n\n\twhile (q--) {\n\n\t\tstring op;\n\t\tcin >> op;\n\n\t\tif (op == \"add\") {\n\t\t\tstring word;\n\t\t\tcin >> word;\n\t\t\tobj->addWord(word);\n\t\t}\n\n\t\telse {\n\t\t\tstring word;\n\t\t\tcin >> word;\n\t\t\tif (obj->search(word))\n\t\t\t\tcout << \"Yes\\n\";\n\t\t\telse\n\t\t\t\tcout << \"No\\n\";\n\t\t}\n\t}\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "Word Dictionary",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>We have given an adjacency&nbsp;representation of a <strong>directed weighted graph</strong> and an array of vertices. At each iteration,&nbsp;a vertex is removed from the graph. Vertices are removed in the order given in the array. When the vertex is removed, all the edges that go in and out are also removed.&nbsp;</p><p>Print the sum of all pairs shortest path<i><strong>&nbsp;</strong></i><strong>just before each iteration</strong>.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>N</i> ≤ 500</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\n#define ll long long int\n#define N 510\nusing namespace std;\n \nll inf=1e16;\nint main()\n{\n    int n;\n    ll A[N][N]; // the adjecency matrix\n    scanf(\"%d\",&n); // take n.\n    for(int i=0;i<n;i++) for(int j=0;j<n;j++) scanf(\"%lld\",&A[i][j]); // we take the graph in a 0 indexed manner.\n    vector<ll> ans; // the final answer array.\n    int x[N]; // the order of elements removed.\n    for(int i=0;i<n;i++) scanf(\"%d\",&x[i]),x[i]--;// take input, -- for 0 index\n    for(int i=n-1;i>=0;i--) // move from backward [x[i],x[i+1]...x[n-1]] are the active edges.\n    {\n        for(int j=0;j<n;j++) \n        \tfor(int k=0;k<n;k++) \n        \t\tA[j][k]=min(A[j][k],A[j][x[i]]+A[x[i]][k]); // relax the current node (Floyd washall)\n\n        // After the ith iteration. The matrix has relaxed nodes x[i],x[i+1]...x[n-1].\n        // So we these are the active nodes, and Floyd warshall ensures all those have correct shortest paths.\n        ll temp=0;\n        for(int j=i;j<n;j++) \n        \tfor(int k=i;k<n;k++)\n        \t\ttemp+=A[x[j]][x[k]]; // get the all pair distnce for all active nodes.\n        ans.push_back(temp); // add it to the ans.\n    }\n    for(int i=(int)ans.size()-1;i>=0;i--) printf(\"%lld \",ans[i]); // print in reverse order as we added instead of remove.\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:13:20.297214+00:00"
      },
      "hints": {
        "hint1": "<p>Use Floyd-Warshall Algorithm!</p>",
        "hint2": "<p>Think about the order of loops in the Floyd-Warshall Algorithm.</p>",
        "solution_approach": "<p>In Floyd-Warshall algorithm we do iterations like this:</p><p>for all k in (1, n) : D[i][j] = min(D[i][j], D[i][k] + D[k][j]).</p><p>When we do this we assume that from vertex <i>i</i> to <i>j</i> we already found the shortest path which has all intermediate vertices in the set {1, 2, …, <i>k</i>-1}. After D[i][j] = min(D[i][j], D[i][k] + D[k][j]), we will get the shortest path from <i>i</i> to <i>j</i> which has all intermediate vertices in the set {1,2, …, <i>k</i>}.</p><p>For solving the problem we will use this concept of Floyd-Warshall algorithm. Instead of going forward, we will add vertices from the backward of the array. So running time of the algorithm is as same as Floyd Warshall algorithm i.e. <i>O(n<sup>3</sup>)</i>.</p>"
      },
      "id": 431,
      "input_format": "<p>The first line contains integer <i>n</i> (1 ≤ <i>n</i> ≤ 500) — the number of vertices in the graph.<br>Next <i>n</i> lines contain <i>n</i> integers each — the graph adjacency matrix: the <i>j</i>-th number in the <i>i</i>-th line <i>a<sub>ij</sub></i> (1 ≤ <i>a<sub>ij</sub></i> ≤ 10<sup>5</sup>, <i>a<sub>ii</sub></i> = 0) represents the weight of the edge that goes from vertex <i>i</i> to vertex <i>j</i>.<br>The next line contains <i>n</i> distinct integers: <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, ..., <i>x<sub>n</sub></i> (1 ≤ <i>x<sub>i</sub></i> ≤ <i>n</i>) — the order of vertices removed from the graph.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print <i>N </i>space-separated numbers, where <i>i</i>th number represents the sum of all pairs shortest path just before <i>i</i>th removal.</p>",
      "samples": [
        {
          "input": "2\n0 5\n4 0\n1 2",
          "output": "9 0"
        },
        {
          "input": "4\n0 3 1 1\n6 0 400 1\n2 4 0 1\n1 1 1 0\n4 1 2 3",
          "output": "17 23 404 0 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "All Pairs Shortest Path",
      "video_editorial_id": 8203
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array of colored gemstones. In one second, you can remove exactly one continuous substring of colored gemstones that is a palindrome. You have to find the minimum number of seconds needed to destroy all the gemstones.",
      "complete_approach": "",
      "constraints": "<p>1≤ T ≤ 200</p><p>1≤ N ≤ 100</p><p>1≤ Ai ≤ N</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint dp[505][505];\n\nint main() {\n   IOS\n   int t;\n   cin >> t;\n   while (t--) {\n       int n;\n       cin >> n;\n       int a[n+2];\n       a[0] = 0; a[n+1] = 0;\n       for (int i = 1; i <= n; ++i) {\n           cin >> a[i];\n       }\n       for (int i = 0; i <= n + 4; ++i) {\n           for (int j = 0; j <= n + 4; ++j) {\n               dp[i][j] = 0;\n           }\n       }\n       for (int l = 1; l <= n; ++l) {\n           for (int s = 1, e = l; e <= n; ++s, ++e) {\n               if(l == 1) dp[s][e] = 1;\n               else {\n                   dp[s][e] = 1 + dp[s+1][e];\n                   if(a[s] == a[s+1])\n                       dp[s][e] = min(dp[s][e], 1 + dp[s+2][e]);\n                   for (int k = s + 2; k <= e; ++k) {\n                       if(a[s] == a[k])\n                           dp[s][e] = min(dp[s][e], dp[s+1][k-1] + dp[k+1][e]);\n                   }\n               }\n           }\n       }\n       cout << dp[1][n] << \"\\n\";\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:39:40.638017+00:00"
      },
      "hints": {
        "hint1": "Define a DP array, DP[X][Y] which denotes the minimum number of seconds to destroy the array from X to Y.",
        "hint2": "A gemstone can either be destroyed individually or as a part of a range. When $A[i] = A[j]$, we can say that $DP[i][j] = DP[i+1][j-1]$. This is because the last subarray which you destroy from $[i+1, j-1]$ will be a palindrome, but $i$ and $j$ gemstones are of the same color. If we include $A[i]$ and $A[j]$ at the end positions, it would still be a palindrome.\n",
        "solution_approach": "<p>We can make three cases, destroy the left-most gemstone of [i, j] and reduce to the subproblem [i + 1, j]. In the second case, the left-most gemstone will match with some gemstone to its right. We iterate through every gemstone with the same color as the left-most (let k be the index of this matching gemstone) and reduce to two subproblems [i + 1, k - 1] and [k + 1, j]. We make a special case when the first two elements in a range are equal and consider the subproblem [i + 2, j].</p><p>&nbsp;</p><p>Time Complexity per test case: O(N^3)</p>"
      },
      "id": 179,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\n\nThe first line of each test case contains one integer $N$ - the length of the array.  \n\nThe second line of each test case contains $N$ space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, the given array is a palindrome. You can remove it in one go.\n\nFor the second test case, you will have to destroy one gemstone at a time.\n\nFor the third test case, first destroy `2 3 2` and then `1 3 4 3 3 4 3 1` as follows:  \n`1 3 [2 3 2] 4 3 3 4 3 1`.",
      "output_format": "For each test case, print the minimum number of seconds needed to destroy all the gemstones.",
      "samples": [
        {
          "input": "3\n4\n1 3 3 1\n3\n2 4 3\n11\n1 3 2 3 2 4 3 3 4 3 1",
          "output": "1\n3\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Destroy Coloured Gemstones",
      "video_editorial_id": 8161
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">There are <strong>n </strong>types of 3-D rectangular boxes. Each box has a height <strong>h</strong>, a width <strong>w</strong> and a length <strong>l</strong>. You are allowed to rotate the boxes so that any side can function as its base. Your task is to create the <strong>tallest stack</strong> by stacking the boxes on top of each other but you are allowed to stack a box on top of the other only if the <strong>dimensions </strong>of the 2-D base of the lower box are strictly larger than those of the higher box, i.e, you can stack a box with dimensions {h1, w1, l1} on top of another box with dimensions {h2, w2, l2} only if <strong>h1 &lt; h2 </strong>and<strong> w1 &lt; w2.</strong> You are also allowed to use multiple instances of the same box.&nbsp;</span><br><span style=\"background-color:transparent;color:#000000;\">You need to print the height of the tallest possible stack that follows the above conditions.</span></p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 1000\n1 &lt;= h,w,l &lt;= 1000</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define pb push_back\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint n;\n\tcin >> n;\n\tvector <pair<pair<int, int>, int>> boxes;\n\tfor (int i = 0; i < n; i++) {\n\t\tint h, w, l;\n\t\tcin >> h >> w >> l;\n\t\tboxes.pb({{h, w}, l}); // taking all possible rotations of the boxes\n\t\tboxes.pb({{w, h}, l});\n\t\tboxes.pb({{h, l}, w});\n\t\tboxes.pb({{l, h}, w});\n\t\tboxes.pb({{w, l}, h});\n\t\tboxes.pb({{l, w}, h});\n\t}\n\tsort(boxes.begin(), boxes.end());\n\treverse(boxes.begin(), boxes.end());\n\tvector <int> dp(6 * n);\n\tint ans = 0;\n\tfor (int i = 0; i < 6 * n; i++) {\n\t\tdp[i] = boxes[i].ss;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (boxes[j].ff.ss > boxes[i].ff.ss && boxes[j].ff.ff > boxes[i].ff.ff)\n\t\t\t\tdp[i] = max(dp[i], dp[j] + boxes[i].ss);\n\t\t}\n\t\tans = max(ans, dp[i]);\n\t}\n\tcout << ans;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:18:53.683489+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Can this problem be reduced to the well-known LIS problem?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">If we sort the array according to one of the dimensions of the base, the problem becomes similar to the LIS problem.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">This problem can be solved using Dynamic Programming. We take all 6 possible rotations of each box. If we sort the boxes in decreasing according to one of the dimensions of the base, the problem becomes similar to the LIS problem which can be solved using O(n*n) DP.&nbsp;</span><br><span style=\"background-color:transparent;color:#000000;\">Let dp[i]=Length of the Tallest Stack with the ith box at the top.</span><br><span style=\"background-color:transparent;color:#000000;\">We initialize dp[i] with the height of the ith box.</span></p><ul><li>&nbsp;&nbsp;&nbsp; dp[i]=height[i]</li></ul><p><span style=\"background-color:transparent;color:#000000;\">We can calculate dp[i] by iterating over all j&lt;i and if the length and width of the jth box are strictly greater than those of the ith box we can keep this box on top of the stack ending at the jth box.</span><br><span style=\"background-color:transparent;color:#000000;\">So,</span></p><ul><li><span style=\"background-color:transparent;color:#000000;\">&nbsp;&nbsp;&nbsp; dp[i]=max(dp[i],dp[j]+height[i]) for all j for which the below conditions are valid.</span><ol><li><span style=\"background-color:transparent;color:#000000;\">j&lt;i</span></li><li><span style=\"background-color:transparent;color:#000000;\">length[j]&gt;length[i] and width[j]&gt;width[i]</span></li></ol></li></ul><p><span style=\"background-color:transparent;color:#000000;\">Since we have sorted the boxes in decreasing order of length of the base, we can put the ith box on the top of only the boxes which appear before i and none of the boxes after i.</span><br><span style=\"background-color:transparent;color:#000000;\">So the above dp will always reach the optimal answer.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The final answer will be max(dp[i]).</span></p>"
      },
      "id": 599,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains a single integer <strong>n.</strong></span><br><span style=\"background-color:transparent;color:#000000;\">Then <strong>n </strong>lines follow. The ith line contains three space-separated integers denoting the height, width, and length of the ith box respectively.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">One of the optimal ways is:</span></p><p><span style=\"background-color:transparent;color:#000000;\">(15, 8, <strong>7</strong>) -&gt; (8, 7, <strong>15</strong>) -&gt; (6, 4, <strong>2</strong>) -&gt; (3, 2,<strong> 8</strong>) -&gt; (2, 1,<strong> 3</strong>)</span><br><span style=\"background-color:transparent;color:#000000;\">Therefore height of the stack = 7+15+2+8+3</span><br><span style=\"background-color:transparent;color:#000000;\">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; = 35.</span><br><span style=\"background-color:transparent;color:#000000;\">We can see that the dimensions of the base are strictly decreasing.</span><br><span style=\"background-color:transparent;color:#000000;\">No other combination of boxes produces height greater than this.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the height of the tallest stack possible.</span></p>",
      "samples": [
        {
          "input": "4\n2 6 4\n1 2 3\n15 7 8\n8 2 3",
          "output": "35"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Tallest Stack",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(39,50,57);\"><strong>Construct Tree from given Inorder and Preorder traversals</strong></span></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:38:16.293501+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 651,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, &nbsp;the length of the array representing the serialized representation of a tree.</p><p>The next line contains N-space-separated distinct integers representing the Inorder Traversal of the tree.&nbsp;</p><p>The next line contains N-space-separated distinct integers representing the Preorder Traversal of the tree.&nbsp;</p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case find the Binary Tree and return the Root Node of the binary tree. Complete this function -&nbsp;</p><p>Node* getBinaryTree(vector&lt;int&gt;&amp;inorder,vector&lt;int&gt;&amp;preorder)<br>{</p><p>}</p><p>A function in the main converts the Binary Tree Root returned into serialized array structure and prints it.</p>",
      "samples": [
        {
          "input": "3\n4\n8766 2202 6058 4965 \n4965 6058 2202 8766 \n2\n3501 2847 \n2847 3501 \n10\n9648 6223 3180 3901 7171 3849 8580 5539 6609 1578 \n6609 8580 7171 3180 9648 6223 3901 3849 5539 1578 ",
          "output": "4965 6058 2202 8766 -1 -1 -1 -1 -1 \n2847 3501 -1 -1 -1 \n6609 8580 7171 3180 9648 -1 6223 -1 -1 3901 -1 -1 3849 -1 -1 5539 -1 -1 1578 -1 -1 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n</fix>\nNode* getBinaryTree(vector<int>&inorder,vector<int>&preorder)\n{\n  // Complete the function.\n}\n<fix>\nvoid generateArray(Node* root, vector<int>&ans){\n    if(root==NULL){\n        ans.push_back(-1);\n        return;\n      }\n    ans.push_back(root->val);\n    generateArray(root->left,ans);\n    generateArray(root->right,ans);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr1(n);\n        for(int i=0;i<n;i++)\n            cin>>arr1[i];\n        vector<int>arr2(n);\n        for(int i=0;i<n;i++)\n            cin>>arr2[i];\n        Node* tree = getBinaryTree(arr1,arr2);\n        vector<int>ans;\n        generateArray(tree,ans);\n        for(auto v:ans)cout<<v<<\" \";\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "Tree from inorder and preorder",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$ and an array $A$ of $N$ numbers. Determine if the number $X  \\textbf{exists} $ in array $A$ or $ \\textbf{not} $ and print its position $ \\textbf{(0-index)} $.\n\n$ \\textbf{Note:} $ $X$ may be found $ \\textbf{once} $ or $ \\textbf{more than once}$ and $ \\textbf{may not be found}$.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N \\leq 10^5 $\n$ 1 \\leq A[i] \\leq 10^9 $\n$ 1 \\leq X \\leq 10^9 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        int A[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> A[i];\n        }\n        int x;\n        cin >> x;\n\n        bool found = false;\n        for (int i = 0; i < n; i++)\n        {\n            if (A[i] == x)\n            {\n                cout << i << \"\\n\";\n                found = true;\n                break;\n            }\n        }\n        if (!found)\n        {\n            cout << \"-1\\n\";\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:32:06.126759+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Loop through the array. Check if the current element is equal to X. If that is true, print the index of its occurrence.\nloop (0<=i<=N) {\n    if A[i]==X:\n        print(i)\n        break\n}\nTime Complexity: $O(n)$"
      },
      "id": 1159,
      "input_format": "The first line contains T. The number of test cases. <br/>\nFor each testcase: The first line contains a number $ N $ , the number of elements.\nSecond line contains $ N $ numbers. \nThird line contains a number $ X $.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, 0 is present at index 1. For the second test case 10 is absent.\nFor the third test case, first occurence of 2 is at index 0.",
      "output_format": "Print the $\\textbf{position}$ of $X$ in the first time you find it. If it doesn't $\\textbf{exist}$ print $\\textbf{-1}$.",
      "samples": [
        {
          "input": "1\n3\n3 0 1\n0\n",
          "output": "1\n"
        },
        {
          "input": "1\n5\n1 3 0 4 5\n10\n",
          "output": "-1\n"
        },
        {
          "input": "1\n4\n2 3 2 1\n2\n",
          "output": "0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Searching",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>String P is given, consisting of uppercase alphabets. You have to find the number of strings Q, such that string Q is lexicographically larger than string P and reverse of string Q is lexicographically larger than the reverse of string P. Since the answer can be large, print the number of integers modulo 10<sup>9</sup> + 7.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤ 100</p><p>1 ≤ |P| ≤ 10<sup>5</sup> where |P| is the length of string P.</p><p>It is guaranteed that the sum of |P| for all test cases is not greater than 10<sup>5</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1000000007;\n\nstring s;\n\nint tt;// current test-case\nint testcase[100010][2][2]; // which testcase dp array is storing for\n\n\nint dp[100010][2][2]; // dp cache array.\n\n// t1 -> tight for same as Q from start or not. \n// t2 -> tight for larger or same as Q from end or not.\nint rec(int pos,int t1,int t2){\n    if(pos==s.length()){\n        if(t2==0 && t1==0)\n            return 1;// 1 valid string found.\n        else\n            return 0;\n    }\n    if(testcase[pos][t1][t2]==tt){ // check if the saved value is relevant for this testcase.\n        return dp[pos][t1][t2];\n    }\n    int ans = 0;\n    for(char dig = 'A'; dig<='Z'; dig++){\n        if(t1==1&&dig<s[pos])continue;\n        \n        int nt1 = t1;\n        if(t1==1&&dig>s[pos]) nt1 = 0;\n    \n        int nt2;\n        if(dig==s[pos]){\n            nt2 = t2;\n        }else if(dig>s[pos]){\n            nt2 = 0;\n        }else{\n            nt2 = 1;\n        }\n        \n        ans =(ans + rec(pos+1,nt1,nt2))%mod;\n    }\n    testcase[pos][t1][t2] = tt;\n    return dp[pos][t1][t2]=ans;\n}\n\nint main(){\n    int t;cin>>t;\n    for(tt=1;tt<=t;tt++){\n        cin>>s;\n        cout<<rec(0,1,1)<<endl;\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:39:24.266760+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Make DP array DP[index][t1][t2] - the number of ways to choose characters so far such that t1=0 denotes that the first index-1 characters of T match the corresponding characters of S and t1=1 means that T is larger than S. t2 = 0 denotes that the last index-1 characters of T match the corresponding characters of S and t2=1 means that reversed T is larger than reversed S.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">For each possible character in the i-th position of the given string, the DP transitions can be divided into three cases: when character is more, less and equal than </span>the <span style=\"background-color:transparent;color:#000000;\">corresponding character in given number. When it is greater, t1=1 and t2=1 and when it is equal, t1 and t2 remain the same as before. When it is lesser and t1=1, t1=1, t2=0.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(|P| * 2 * 2* 26)&nbsp;</span></p><p><span style=\"background-color:#ffffff;color:#000000;\">where |P| is the length of string P.</span></p>",
        "solution_approach": ""
      },
      "id": 304,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line and</span> <span style=\"background-color:transparent;color:#000000;\">only line of input </span>contain<span style=\"background-color:transparent;color:#000000;\"> string P.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, Q will be valid when Q is YZZ or ZZY. Other 26 cases will be ZAZ to ZZZ.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, the valid strings are XZ, YY, YZ, ZY, ZZ.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, no string is greater than ZZZZ.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the number of strings Q.</span></p>",
      "samples": [
        {
          "input": "3\nYZY\nXY\nZZZZ",
          "output": "28\n5\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "The Larger String",
      "video_editorial_id": 8182
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">A valid expression is a string of the form ‘([valid expression][operator][valid expression])’.</span></p><p>For example, the following expressions are <strong>valid</strong>:</p><ul><li>\"1\"</li><li>\"(x^0)\"</li><li>“((X&amp;0)|x)”</li></ul><p>While the following expressions are <strong>invalid</strong>:</p><ul><li>\"(1)\"</li><li>\"x^0\"</li><li>\"(X&amp;0|x)\"</li></ul><p><span style=\"background-color:transparent;color:#000000;\">A valid expression with a single term can be:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">‘0’ - False</span></li><li><span style=\"background-color:transparent;color:#000000;\">‘1’ - True</span></li><li><span style=\"background-color:transparent;color:#000000;\">‘x’ - The variable x</span></li><li><span style=\"background-color:transparent;color:#000000;\">‘X’ - The negation of variable x</span></li></ol><p><span style=\"background-color:transparent;color:#000000;\">The operator can be one of the following three characters:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">‘|’ - OR operator - returns True when at least one operand is True</span></li><li><span style=\"background-color:transparent;color:#000000;\">‘&amp;’ - AND operator - returns False when at least one operand is False</span></li><li><span style=\"background-color:transparent;color:#000000;\">‘^’ - XOR operator - returns True when exactly one operand is True</span></li></ol><p><span style=\"background-color:transparent;color:#000000;\">Given a valid expression, you have to tell the minimum number of characters to modify such that the result of the given expression is a valid expression that <strong>does not depend on x</strong>.</span></p><p>For example, the expression \"(X|(0&amp;x))\" evaluates to True if x is False, and False if x is True. If it were to be changed into \"((X&amp;0)&amp;1)\" (by modifying its 2nd, 3rd, 4th, 6th, 7th, and 8th characters), then it would evaluate to False regardless of x's value. Though, it's also possible to make its value independent of x by modifying fewer than 6 of its characters.</p><p>Given an expression <strong>E</strong>, what's the minimum number of characters which must be modified? It's possible that no characters may need to be modified at all.</p>",
      "complete_approach": "",
      "constraints": "<p>1≤ <i>T</i> ≤ 2000<br>1≤ |<i>E</i>| ≤ 300 where |<i>E</i>| denotes the length of the given expression.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n#define N 100010\n#define ll long long int\n#define LD long double\n\nusing namespace std;\n\nint mod = 1000000007;\n\nchar get(char c1, char e, char c2, int val) {\n    int m1, m2;\n    if(c1 == 'x') m1 = val;\n    else if(c1 == 'X') m1 = 1 - val;\n    else m1 = c1 - '0';\n    if(c2 == 'x') m2 = val;\n    else if(c2 == 'X') m2 = 1 - val;\n    else m2 = c2 - '0';\n    if(e == '&') {\n        return ('0' + (m1 & m2));\n    }\n    if(e == '|') {\n        return ('0' + (m1 | m2));\n    }\n    return ('0' + (m1 ^ m2));\n}\n\nint eval(string E, int val) {\n    stack < char > s;\n    for(int i = 0; i < (int)E.length(); i++) {\n        if(E[i] == '(') {\n            continue;\n        }\n        if(E[i] == ')') {\n            char c2 = s.top();\n            s.pop();\n            char e = s.top();\n            s.pop();\n            char c1 = s.top();\n            s.pop();\n            s.push(get(c1, e, c2, val));\n        }\n        else {\n            if(E[i] == 'x') s.push('0' + val);\n            else if(E[i] == 'X') s.push('0' + 1 - val);\n            else s.push(E[i]);\n        }\n    }\n    return (s.top() - '0');\n}\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int T;\n    cin >> T;\n    for(int t = 1; t <= T; t++) {\n        string E;\n        cin >> E;\n        assert((int)E.length() <= 300);\n        int x = eval(E, 0);\n        int y = eval(E, 1);\n        if(x == y) {\n            cout << \"0\\n\";\n        }\n        else {\n            cout << \"1\\n\";\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:45:45.702996+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Think about what the maximum answer could be.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Try using a data structure to calculate the answer for each expression.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">If the expression already evaluates to a constant value (‘0’ or ‘1’), then the answer is 0.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Otherwise, if the expression is a single term (‘x’ or ‘X’), then the answer will be 1. This is because, in the outermost operation, you can do the following change:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">If one of the valid expressions evaluates to 0, use the ‘&amp;’ operator.</span></li><li><span style=\"background-color:transparent;color:#000000;\">Otherwise, if one of the valid expressions evaluates to 1, use the ‘|’ operator.</span></li><li><span style=\"background-color:transparent;color:#000000;\">Otherwise, both are variable values, and the ‘^’ can be used</span></li></ol><p><span style=\"background-color:transparent;color:#000000;\"><strong>Time Complexity per test case:</strong> <i>O(N)</i></span></p>"
      },
      "id": 91,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer <i>T</i> - the number of test cases. Then <i>T</i> test cases follow.</span><br><span style=\"background-color:transparent;color:#000000;\">For each test case, there is a string <i>E</i> which is a valid expression.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">The first expression can be left unchanged (as it always evaluates to True).</span><br><span style=\"background-color:transparent;color:#000000;\">The second expression can be changed to (0&amp;1) (and it would then always evaluate to False).</span><br><span style=\"background-color:transparent;color:#000000;\">The third expression can be changed to ((1&amp;(X^X))|1)&nbsp; (and it would then always evaluate to True).</span><br><span style=\"background-color:transparent;color:#000000;\">The fourth expression can be left unchanged (as it always evaluates to False).</span><br><span style=\"background-color:transparent;color:#000000;\">The fifth expression can be left unchanged (as it always evaluates to True).</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print on a new line the minimum number of characters to modify in <i>E</i> such that the result of the given expression is a valid expression that does not depend on <i>x</i>.</span></p>",
      "samples": [
        {
          "input": "5\n1\n(X&1)\n((1&(X^X))|x)\n(0&(X^((X&1)^x)))\n(1^(X&x))",
          "output": "0\n1\n1\n0\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Evaluating Boolean Expressions",
      "video_editorial_id": 8147
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Android mobile unlock pattern is a grid of \\(3 \\times 3\\) cells, where drawing a specific pattern connecting a specific sequence of cells in order will unlock the android mobile.\n\nGiven a number \\(n\\), your task is to find the number of android unlock patterns connecting exactly \\(n\\) cells.\n\n##### Rules of a valid pattern:\n1. Each pattern must connect exactly \\(n\\) cells.\n2. All the cells must be distinct.\n3. If the line connecting two consecutive cells in the pattern passes through any other cells, the other cells must have previously been selected in the pattern. No jumps through the non-selected cell are allowed.\n4. The order of cells used matters.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i> ≤ 9</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nbool visited[10];\nint skip[10][10];\n\nint brute_force(int cur, int remLen) {\n    // base case : if remaining length done, then return 1 as 1 sequence found.\n    if(!remLen) return 1;\n    // Mark this cell visited.\n    visited[cur] = true;\n    int ans = 0;\n    // Try to take next cell as i\n    for(int i = 1; i <= 9; i++) {\n    \t// If i is not already taken && either their is no cell to skip or the cell to skip is already selected.\n        if(!visited[i] && (!skip[cur][i] || visited[skip[cur][i]])) {\n            // try that option.\n            ans += brute_force(i, remLen - 1);\n        }\n    }\n    // revert the changes done.\n    visited[cur] = false;\n    return ans;\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    memset(visited, false, sizeof(visited));\n    memset(skip, 0, sizeof(skip));\n    \n    // We are numbering\n    // 1 2 3\n    // 4 5 6\n    // 7 8 9\n\n    // These save the connection that skips a point.\n    skip[1][3] = skip[3][1] = 2;\n    // to join 1 and 3, 2 needs to be pre-selected, or its invalid move.\n    skip[1][7] = skip[7][1] = 4;\n    skip[3][9] = skip[9][3] = 6;\n    skip[7][9] = skip[9][7] = 8;\n    skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5;\n    // This you will have to create manually.\n\n    int n;\n    cin >> n;\n\n    int ans = 0;\n    ans += brute_force(1, n - 1) * 4;   \n    //Symmetry as starting from 1 3 7 9 all will be similar\n    ans += brute_force(2, n - 1) * 4;   \n    //Symmetry as starting from 2 4 6 8 all will be similar\n    ans += brute_force(5, n - 1);\n\n    cout << ans << \"\\n\";\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:41:59.144276+00:00"
      },
      "hints": {
        "hint1": "<p>Numbered the cells as</p><figure class=\"table\"><table><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>4</td><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td><td>9</td></tr></tbody></table></figure>",
        "hint2": "<p>Lets try out some examples.</p><ol><li>6 - 5 - 4 - 1 - 9 - 2: It's a valid move.</li><li>4 - 1 - 9 - 2 : It's a invalid move, because line 1 - 9 passes through key 5 which had not been selected in the pattern.&nbsp;</li><li>4 - 1 - 3 - 6 : It's a invalid move, because line 1 - 3 passes through key 2 which had not been selected in the pattern.</li></ol><p>Can you observe some pattern?</p>",
        "solution_approach": "<p>We use DFS to count the number of valid paths from the current number (1–9)to the remaining numbers. To optimize, calling DFS less than 9 times, we can use the symmetry of the 3 by 3 matrix. If we start from 1 or 3 or 7 or 9, the valid paths number should be the same. If we start from 2 or 4 or 6 or 8, the valid paths number are also the same. Start from 5 is the third case.</p><p>One of the invalid cases can be if you want to move your finger from 1 to 3, without selecting 2, that's not possible. Can you try it on your own Android phone?</p><p>We need to create a matrix to keep a record of unselected numbers on the path between two keys.</p><p>Now in DFS, we keep trying to find the next valid cell. What is a valid candidate? We need to make sure if the next cell hasn’t been visited, and either it’s adjacent to the current cell, or it’s the cell in between (recorded as the unselected number on the path)but has been visited.</p>"
      },
      "id": 486,
      "input_format": "<p>The only line of input contains a single integer <i>n</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print answer on a new line.</p>",
      "samples": [
        {
          "input": "1",
          "output": "9"
        },
        {
          "input": "2",
          "output": "56"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Android Unlock Pattern",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(22,27,54);\">For given integer </span><span style=\"color:rgb(0,0,0);\"><i>n</i></span><span style=\"background-color:rgb(255,255,255);color:rgb(22,27,54);\">, count the totatives of </span><span style=\"color:rgb(0,0,0);\"><i>n</i></span><span style=\"background-color:rgb(255,255,255);color:rgb(22,27,54);\">, that is, the positive integers less than or equal to </span><span style=\"color:rgb(0,0,0);\"><i>n</i></span><span style=\"background-color:rgb(255,255,255);color:rgb(22,27,54);\"> that are relatively prime to </span><span style=\"color:rgb(0,0,0);\"><i>n</i></span><span style=\"background-color:rgb(255,255,255);color:rgb(22,27,54);\">.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n </i>≤ 10<sup>12</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n\nsigned main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\n\tll n;\n\tcin >> n;\n\n\tll ans = n;\n\n\tfor(ll i = 2; i * i <= n; i++) {\n\t\tbool is = false;\n\t\twhile(n % i == 0) {\n\t\t\tn /= i;\n\t\t\tis = true;\n\t\t}\n\t\tif(is) {\n\t\t\tans /= i;\n\t\t\tans *= (i - 1);\n\t\t}\n\t}\n\n\tif(n > 1) {\n\t\tans /= n;\n\t\tans *= (n - 1);\n\t}\n\n\tcout << ans << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:44:12.029194+00:00"
      },
      "hints": {
        "hint1": "<p>If we know the prime factors, can we use a direct formula for Euler's totient?</p><p>We know we can factorize the numbers in O(sqrt(N)).</p>",
        "hint2": "<p>Since we have to find only one number we use the following formula:</p><figure class=\"image\"><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/595bed4719c49a400b24755d6bca6e759e7a8503\" alt=\"{\\displaystyle {\\begin{array}{rcl}\\varphi (n)&amp;=&amp;\\varphi (p_{1}^{k_{1}})\\,\\varphi (p_{2}^{k_{2}})\\cdots \\varphi (p_{r}^{k_{r}})\\\\[.1em]&amp;=&amp;p_{1}^{k_{1}-1}(p_{1}-1)\\,p_{2}^{k_{2}-1}(p_{2}-1)\\cdots p_{r}^{k_{r}-1}(p_{r}-1)\\\\[.1em]&amp;=&amp;p_{1}^{k_{1}}\\left(1-{\\frac {1}{p_{1}}}\\right)p_{2}^{k_{2}}\\left(1-{\\frac {1}{p_{2}}}\\right)\\cdots p_{r}^{k_{r}}\\left(1-{\\frac {1}{p_{r}}}\\right)\\\\[.1em]&amp;=&amp;p_{1}^{k_{1}}p_{2}^{k_{2}}\\cdots p_{r}^{k_{r}}\\left(1-{\\frac {1}{p_{1}}}\\right)\\left(1-{\\frac {1}{p_{2}}}\\right)\\cdots \\left(1-{\\frac {1}{p_{r}}}\\right)\\\\[.1em]&amp;=&amp;n\\left(1-{\\frac {1}{p_{1}}}\\right)\\left(1-{\\frac {1}{p_{2}}}\\right)\\cdots \\left(1-{\\frac {1}{p_{r}}}\\right).\\end{array}}}\"></figure>",
        "solution_approach": "<p>See the Euler Totient function. <a href=\"https://en.wikipedia.org/wiki/Euler%27s_totient_function\">https://en.wikipedia.org/wiki/Euler%27s_totient_function</a></p>"
      },
      "id": 227,
      "input_format": "<p>The only line of input contains an integer <i>n.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the answer on a new line.</p>",
      "samples": [
        {
          "input": "6",
          "output": "2"
        },
        {
          "input": "1000000",
          "output": "400000"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Euler's Phi Function",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a BST (Binary Search Tree), find the shortest range $[x, y]$, such that, at least one node of every level of the BST lies in the range.\nIf there are multiple ranges with the same gap (i.e. $(y-x)$) return the range with the smallest $x$.\nWe define the range $[a, b]$ is smaller than range $[c, d]$ if $b - a < d - c$ or $a < c$ if $b - a == d - c$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^4$ - the number of test cases.\n$1 \\leq n \\leq 10^5$ - number of nodes in binary search tree.\n$-10^6 \\leq value \\leq 10^6$ - value of nodes in binary search tree.\n- All node values are unique.\n- Sum of $n$ over all test cases is $\\leq 10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstruct TreeNode {\n    int data;\n    TreeNode*left;\n    TreeNode*right;\n    TreeNode(int x) {\n        this->data = x;\n        this->left = nullptr;\n        this->right = nullptr;\n    }\n};\n\n\nclass Solution {\npublic:\n    pair<int, int> shortestRangeBST(TreeNode *root) {\n        unordered_map<int, vector<int>> nums;\n        queue<pair<TreeNode*, int>> q;\n        q.push({root, 0});\n        while (!q.empty()) {\n            auto x = q.front(); q.pop();\n            nums[x.second].push_back(x.first->data);\n            if (x.first->left)q.push({x.first->left, x.second + 1});\n            if (x.first->right)q.push({x.first->right, x.second + 1});\n        }\n        int k = nums.size(), ans = 1e9;\n        pair<int, int> range = { -1e9, 1e9};\n        vector<int> ptr(k, 1);\n        multiset<array<int, 2>> s;\n        for (int i = 0; i < k; i++)s.insert({nums[i][0], i});\n        while (1) {\n            auto x = *s.begin(), y = *s.rbegin();\n            if (ans > y[0] - x[0])ans = y[0] - x[0], range = {x[0], y[0]};\n            else if (ans == y[0] - x[0])range = min(range, {x[0], y[0]});\n            if (ptr[x[1]] == nums[x[1]].size())break;\n            s.erase(s.find(x));\n            s.insert({nums[x[1]][ptr[x[1]]], x[1]});\n            ptr[x[1]]++;\n        }\n        return {range.first, range.second};\n    }\n};\n\nTreeNode *deserialize(string data) {\n    if (data.size() == 0)\n        return nullptr;\n    vector<string> dat;\n    string t;\n    for (auto c : data)\n    {\n        if (c == ',')\n        {\n            dat.push_back(t);\n            t.clear();\n        }\n        else\n            t.push_back(c);\n    }\n    dat.push_back(t);\n    int i = 0;\n    queue<TreeNode *> q;\n    TreeNode *root = new TreeNode(stoll(dat[0]));\n    q.push(root);\n    auto cur = root;\n    i++;\n    while (!q.empty())\n    {\n        auto x = q.front();\n        q.pop();\n        if (dat[i] != \"x\")\n        {\n            x->left = new TreeNode(stoll(dat[i]));\n            q.push(x->left);\n        }\n        i++;\n        if (dat[i] != \"x\")\n        {\n            x->right = new TreeNode(stoll(dat[i]));\n            q.push(x->right);\n        }\n        i++;\n    }\n    return root;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    auto root = deserialize(s);\n    Solution sol;\n    auto ans = sol.shortestRangeBST(root);\n    cout << ans.first << \" \" << ans.second << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:26:42.855704+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "First, store the values of the nodes level-wise in a ```vector<int> nums[K]```, where $K$ is the height of the binary search tree.\nFor each level, these values will be sorted.\nNow, we want the smallest range covering elements from these $K$ lists $nums$.\n\n##### Algorithm to find shortest K lists range:  \n\n1. Create a Min heap to store $k$ elements, one from each array and a variable minrange initialized to a maximum value and also keep a variable max to store the maximum integer.\n2. Initially put the first element of each element from each list and store the maximum value in max.\n3. Repeat the following steps until at least one list exhausts : \n    -   To find the minimum value or min, use the top or root of the Min heap which is the minimum element.\n    -   Now update the midrange if the current (max-min) is less than minrange.\n    -   Remove the top or root element from the priority queue and insert the next element from the list which contains the min element and update the max with the new element inserted.\n\n#### Complexity Analysis: \n**Time complexity:** $O(n * k *log k)$, where $k$ is the height of the tree.\n\nTo find the maximum and minimum in a Min Heap of length k the time required is $O(log k)$, and to traverse all the k arrays(lists) of length $n$ (in the worst case), the time complexity is $O(n*k)$, then the total time complexity is $O(n * k *log k)$.\n\n**Space complexity:** $O(n)$."
      },
      "id": 1062,
      "input_format": "You don't need to read input or print anything. Complete the function ```pair<int,int> shortestRangeBST(TreeNode *root)``` which takes the root of the binary search tree as an input parameter and returns the pair having the shortest range.\n\nFor local testing of the sample, the first line contains $T$, the number of test cases. The first line of each test case contains $n$- number of nodes. The second line of each test case contains the level order traversal of the tree, where *'$x$'* denotes the *'nullptr'*.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For test case 1\n```\n            8\n          /   \\\n         3     10\n       /  \\      \\\n      2   |6|     14\n          / \\     /\n         4   7   12\n                /  \\\n             |11|   13\n```\nLevel order traversal of the tree is $[8], [3, 10], [2, 6, 14], [4, 7, 12], [11, 13]$. \nThe shortest range which satisfies the above-mentioned condition is $[6, 11]$.",
      "output_format": "Returns the pair having the shortest range, such that, at least one node of every level of the BST lies in the range.\nIf there are multiple ranges with the same gap (i.e. $(y-x)$) return the range with the smallest $x$.",
      "samples": [
        {
          "input": "2\n11\n8,3,10,2,6,x,14,x,x,4,7,12,x,x,x,x,x,11,13,x,x,x,x\n5\n12,x,13,x,14,x,15,x,16,x,x\n",
          "output": "6 11\n12 16\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstruct TreeNode {\n    int data;\n    TreeNode*left;\n    TreeNode*right;\n    TreeNode(int x) {\n        this->data = x;\n        this->left = nullptr;\n        this->right = nullptr;\n    }\n};\n</fix>\n\n<fix>\nclass Solution {\n    </fix>\n    <fix>\npublic:\n    </fix>\n    <fix>\n    pair<int, int> shortestRangeBST(TreeNode *root) {\n        </fix>\n        // write code here.\n        return {0, 0};\n        <fix>\n    }\n    </fix>\n\n    <fix>\n};\n</fix>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<fix>\nTreeNode *deserialize(string data) {\n    if (data.size() == 0)\n        return nullptr;\n    vector<string> dat;\n    string t;\n    for (auto c : data)\n    {\n        if (c == ',')\n        {\n            dat.push_back(t);\n            t.clear();\n        }\n        else\n            t.push_back(c);\n    }\n    dat.push_back(t);\n    int i = 0;\n    queue<TreeNode *> q;\n    TreeNode *root = new TreeNode(stoll(dat[0]));\n    q.push(root);\n    auto cur = root;\n    i++;\n    while (!q.empty())\n    {\n        auto x = q.front();\n        q.pop();\n        if (dat[i] != \"x\")\n        {\n            x->left = new TreeNode(stoll(dat[i]));\n            q.push(x->left);\n        }\n        i++;\n        if (dat[i] != \"x\")\n        {\n            x->right = new TreeNode(stoll(dat[i]));\n            q.push(x->right);\n        }\n        i++;\n    }\n    return root;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    auto root = deserialize(s);\n    Solution sol;\n    auto ans = sol.shortestRangeBST(root);\n    cout << ans.first << \" \" << ans.second << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 3,
      "title": "Shortest Range in a BST",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a tree of N nodes and an array A of length N corresponding to the value of the nodes.</p><p>You have to answer Q queries. In each query, two nodes are given x, y→ find the gcd of nodes present on the shortest path from x to y.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nconst long long int infl = 1e18;\nconst int MOD = 1e9 + 7;\n\n#define endl '\\n'\nvector<vector<long long int>> adj;\nvector<vector<pair<long long int, long long int>>> par;\nvector<long long int> v(100100);\nvector<long long int> depth;\nvoid dfs(long long int node, long long int prev, long long int dep)\n{\n    par[node][0] = {prev, __gcd(v[node], v[prev])};\n    depth[node] = dep;\n    for (long long int i = 1; i < 20; i++)\n    {\n        long long int a = par[node][i - 1].first;  // the node\n        long long int b = par[node][i - 1].second; // the gcd\n        long long int x = __gcd(par[a][i - 1].second, b);\n        par[node][i] = {par[a][i - 1].first, x};\n    }\n    for (auto u : adj[node])\n    {\n        if (u != prev)\n        {\n            dfs(u, node, dep + 1);\n        }\n    }\n}\n\nlong long int find_lca(long long int a, long long int b)\n{\n    long long int hcf = __gcd(v[a], v[b]);\n\n    if (depth[a] > depth[b])\n        swap(a, b);\n    // always make a closer to root\n    for (long long int i = 19; i >= 0; i--)\n    {\n        if ((depth[b] - depth[a]) & (1 << i))\n        {\n\n            hcf = __gcd(par[b][i].second, hcf);\n            b = par[b][i].first;\n        }\n    }\n\n    if (a == b)\n        return hcf;\n    else\n    {\n        for (long long int i = 19; i >= 0; i--)\n        {\n            if (par[a][i].first != par[b][i].first)\n            {\n                hcf = __gcd(par[b][i].second, hcf);\n                hcf = __gcd(par[a][i].second, hcf);\n                b = par[b][i].first;\n                a = par[a][i].first;\n            }\n        }\n        hcf = __gcd(hcf, par[a][0].second);\n        return hcf;\n    }\n}\nvoid solve()\n{\n    long long int a, b, c, d, x, y, n, m, k, l, i, j, Max = INT_MIN, Min = INT_MAX, ctr = 0, cnt = 0, ans = 0, lo, hi, mid, q;\n    char ch;\n    cin >> n;\n    adj.clear();\n\n    adj = vector<vector<long long int>>(n + 1);\n    pair<long long int, long long int> p = {0, 0};\n    par = vector<vector<pair<long long int, long long int>>>(n + 1, vector<pair<long long int, long long int>>(21, p));\n    depth = vector<long long int>(n + 1, 0);\n    v[0] = 1;\n    for (i = 1; i <= n; i++)\n    {\n        cin >> v[i];\n    }\n    for (i = 1; i <= n - 1; i++)\n    {\n        cin >> a >> b;\n        adj[a].pb(b);\n        adj[b].pb(a);\n    }\n    dfs(1, 0, 0);\n\n    cin >> q;\n    for (i = 1; i <= q; i++)\n    {\n        cin >> a >> b;\n        cout << find_lca(a, b) << endl;\n    }\n}\n\nint main()\n{\n    // #ifndef ONLINE_JUDGE\n    // freopen(\"input.txt\",\"r\",stdin);\n    // freopen(\"output.txt\",\"w\",stdout);\n    // #endif\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int i, T;\n\n    T = 1;\n    cin >> T;\n\n    for (i = 1; i <= T; i++)\n    {\n        solve();\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:33:27.218072+00:00"
      },
      "hints": {
        "hint1": "Use binary lifting and precompute gcd of nodes on all powers of 2 depth.",
        "hint2": "We need to find the gcd of nodes present on the shortest path from x to y. A simple approach is to find the LCA of x and y and then compute the gcd of nodes on the path from x to LCA and from LCA to y, and then take the gcd of these two values. To find LCA efficiently, we can use binary lifting. We will precompute the gcd of nodes on all powers of 2 depth, and use them to compute the gcd of nodes on any path in $O(\\log N)$ time.",
        "solution_approach": "We can precompute the GCD of each node with its parent in the tree, and store it in a 2D array par[node][i], where i represents the $2^i$th parent of the node node.\n\nTo find the GCD of nodes present on the shortest path between two nodes x and y, we can use the concept of Lowest Common Ancestor (LCA). First, we find the LCA of x and y using the depth of the nodes and par array.\n\nThen, we can iterate from the LCA to the node x, and update the GCD of nodes using the par array. Similarly, we can iterate from the LCA to the node y and update the GCD of nodes using the par array. Finally, we can take the GCD of the two updated values to get the answer.\n\nWe can perform the above operations using bitwise operations to reduce the time complexity of finding LCA to $O(\\log N)$.\n\nThe overall time complexity of the approach is $O(NlogN + QlogN)$, where $N$ is the number of nodes in the tree and $Q$ is the number of queries."
      },
      "id": 125,
      "input_format": "<p>The first line contains an integer T (1 ≤ T ≤ 10000) - the number of test cases.</p><p>The second line of each test case contains two space-separated integers N (1 ≤ N ≤ 10^5).</p><p>The next line contains N space-separated integers denoting the value of the nodes. (1 ≤ A[i] ≤ 10^6).</p><p>The next N-1 lines contain two space-separated integers u, v (1 ≤ u, v ≤ N) denoting there is an undirected edge between node u and node v.</p><p>The next line contains an integer Q (1 ≤ Q ≤ 10^5).</p><p>The next Q lines contain three space-separated integers x, y (1 ≤ x, y ≤ N).</p><p>Sum of N+Q across all test cases ≤ 2*10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each query print the output in a new line.</p>",
      "samples": [
        {
          "input": "2\n5\n2 4 5 10 6\n1 2\n2 3\n3 4\n4 5\n5\n1 2\n2 5\n4 5\n3 4\n4 5\n5\n5 10 15 10 10\n1 2\n2 3\n3 4\n3 5\n10\n1 2\n1 3\n2 4\n2 5\n3 5\n3 4\n4 1\n4 5\n5 1\n2 3",
          "output": "2\n1\n2\n5\n2\n5\n5\n5\n5\n5\n5\n5\n5\n5\n5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Path GCD",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given the heads of K singly-linked lists, return their common intersection node. If the linked lists don’t intersect, return null. It is guaranteed that this structure does not have any cycles.</p><p>Complete the function</p><p><strong>ListNode* getKIntersectionNode(vector&lt;ListNode*&gt; head)</strong></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>K</i> ≤ 100<br>0 ≤ <i>N<sub>i</sub></i> ≤ 1000</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode *getTwoIntersectionNode(ListNode *headA, ListNode *headB) {\n    ListNode* l1 = headA, *l2 = headB;\n    while(l1 != l2) {\n        l1 = (l1 == NULL) ? headB : l1->next;\n        l2 = (l2 == NULL) ? headA : l2->next;\n    }\n    return l1;\n}\n\nListNode* mergeLists(vector<ListNode*>& lists, int l, int r) {\n    if (l == r) {\n        return lists[l];\n    }\n    \n    int mid = (l + r) / 2;\n    \n    ListNode* head1 = mergeLists(lists, l, mid);\n    ListNode* head2 = mergeLists(lists, mid + 1, r);\n    \n    return getTwoIntersectionNode(head1, head2);\n}\n\nListNode* getKIntersectionNode(vector<ListNode*>& lists) {\n    if(lists.empty()) {\n        return NULL;\n    }\n    \n    return mergeLists(lists, 0, (int)lists.size() - 1);\n}\n\nvector<ListNode*> GetList(vector<vector<int>> &num, int K) {\n    vector<ListNode*> head(K), cur(K);\n\n    for(int i = 0; i < K; i++) {\n        head[i] = NULL;\n        cur[i] = NULL;\n    }\n\n    map <int,ListNode*> M;\n\n    for(int i = 0; i < K; i++) {\n        for(int u : num[i]) {\n            if(M.find(u) != M.end()) {\n                if(!head[i]) {\n                    head[i] = M[u];\n                    cur[i] = head[i];\n                }\n                else {\n                    cur[i]->next = M[u]; \n                    cur[i] = cur[i]->next;\n                }\n                break;\n            }\n            else {\n                ListNode* temp = new ListNode(u);\n                if(!head[i]) {\n                    head[i] = temp;\n                    cur[i] = head[i];\n                }\n                else {\n                    cur[i]->next = temp;\n                    cur[i] = cur[i]->next;\n                }\n                M[u] = temp;\n            }\n        }\n    }\n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int K;\n    cin >> K;\n\n    vector<vector<int>> num(K);\n\n    for(int i = 0; i < K; i++) {\n        int n;\n        cin >> n;\n        for(int j = 0; j < n; j++) {\n            int x;\n            cin >> x;\n\n            num[i].push_back(x);\n        }\n    }\n\n    vector<ListNode*> head = GetList(num, K);\n\n    ListNode* ans = getKIntersectionNode(head);\n\n    if(ans) cout << ans->val << \"\\n\";\n    else cout << \"-1\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:42:11.622117+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<h2><span style=\"background-color:transparent;color:#000000;\">Solution 1(Brute Force)</span></h2><p><span style=\"background-color:transparent;color:#000000;\">Find the intersection of the K lists by taking two linked lists at a time. This has to be done (k-1) times since there would be (k-1) pairs of linked lists.</span></p><p><span style=\"background-color:transparent;color:#000000;\"><i>Time Complexity:</i> The time complexity is O(k*n) where n is the number of nodes in the linked list and k is the number of lists.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Space Complexity:</i> Since constant extra memory is used, the space complexity is O(1).</span></p><p>&nbsp;</p><h2><span style=\"background-color:transparent;color:#000000;\">Solution 2(Optimal)</span></h2><p><span style=\"background-color:transparent;color:#000000;\">The approach here is a modification of Solution 1. Use divide and conquer. Recursively split the k lists into halves until the count becomes 1. Find the intersection of two lists each time.</span></p><p><span style=\"background-color:transparent;color:#000000;\"><i>Time Complexity:</i> The time complexity is O(n log(k)) where n is the number of nodes in the linked list and k is the number of lists.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>Space Complexity:</i> Since constant extra memory is used, the space complexity is O(1).</span></p>"
      },
      "id": 539,
      "input_format": "<p>The first line of input contains <i>K </i>- the number of linked lists.<br>The 2<i>i</i>th line contains <i>N<sub>i</sub></i> - the number of nodes in <i>i</i>th linked list.<br>The (2<i>i</i> + 1)th line contains <i>N<sub>i </sub></i>space-separated integers denoting the nodes in the <i>i</i>th linked list.<br>Each unique node has a unique value, and vice-versa. No two different nodes have the same value.</p><p>The following function parses the input</p><p><strong>vector&lt;ListNode*&gt; GetList(vector&lt;vector&lt;int&gt;&gt; num, int K)</strong></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>Node 6 is a common intersection of all linked lists.</p><figure class=\"image\"><img src=\"https://lh3.googleusercontent.com/0-ccIE7IK6a5pVrFT7rfjA0D8AePHC1D1-EnxKbJPUIYihtMqrcklgwmyy6kovm4dnjsG2WJMAbb588bYqSji8rW2hw-LxNT67Et0945rAEI2CwaaEuzD5Ubr-Aml1NnBmGD0_q2\"></figure>",
      "output_format": "",
      "samples": [
        {
          "input": "3\n7\n1 2 3 5 6 8 9\n6\n4 3 5 6 8 9\n4\n7 6 8 9",
          "output": "6"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\nListNode* getKIntersectionNode(vector<ListNode*>& lists) {\n    //Complete the function\n}\n\n<fix>\nvector<ListNode*> GetList(vector<vector<int>> &num, int K) {\n    vector<ListNode*> head(K), cur(K);\n\n    for(int i = 0; i < K; i++) {\n        head[i] = NULL;\n        cur[i] = NULL;\n    }\n\n    map <int,ListNode*> M;\n\n    for(int i = 0; i < K; i++) {\n        for(int u : num[i]) {\n            if(M.find(u) != M.end()) {\n                if(!head[i]) {\n                    head[i] = M[u];\n                    cur[i] = head[i];\n                }\n                else {\n                    cur[i]->next = M[u]; \n                    cur[i] = cur[i]->next;\n                }\n                break;\n            }\n            else {\n                ListNode* temp = new ListNode(u);\n                if(!head[i]) {\n                    head[i] = temp;\n                    cur[i] = head[i];\n                }\n                else {\n                    cur[i]->next = temp;\n                    cur[i] = cur[i]->next;\n                }\n                M[u] = temp;\n            }\n        }\n    }\n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int K;\n    cin >> K;\n\n    vector<vector<int>> num(K);\n\n    for(int i = 0; i < K; i++) {\n        int n;\n        cin >> n;\n        for(int j = 0; j < n; j++) {\n            int x;\n            cin >> x;\n\n            num[i].push_back(x);\n        }\n    }\n\n    vector<ListNode*> head = GetList(num, K);\n\n    ListNode* ans = getKIntersectionNode(head);\n\n    if(ans) cout << ans->val << \"\\n\";\n    else cout << \"-1\\n\";\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Intersection of K Lists",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Zenithland has n cities and m roads between them. Your task is to check for the existence of a round trip that begins in a city, goes through two or more other cities, and finally returns to the starting city. Every intermediate city on the route has to be distinct.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i> ≤ 10<sup>5</sup><br>1 ≤ <i>m</i> ≤ 2 x 10<sup>5</sup><br>1 ≤ <i>a, b</i> ≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nconst int N = 100010;\n\nint mod = 1e9 + 7;\n\nint n;\nvector<vector<int>> adj;\nvector<int> color;\nvector<int> parent;\nint cycle_start, cycle_end;\n\nbool dfs(int v, int par) { // passing vertex and its parent vertex\n    color[v] = 1;\n    for (int u : adj[v]) {\n        if(u == par) continue; // skipping edge to parent vertex\n        if (color[u] == 0) {\n            parent[u] = v;\n            if (dfs(u, parent[u]))\n                return true;\n        } else if (color[u] == 1) {\n            cycle_end = v;\n            cycle_start = u;\n            return true;\n        }\n    }\n    color[v] = 2;\n    return false;\n}\n\nvoid find_cycle() {\n    color.assign(n + 1, 0);\n    parent.assign(n + 1, -1);\n    cycle_start = -1;\n\n    for (int v = 1; v <= n; v++) {\n        if (color[v] == 0 && dfs(v, parent[v]))\n            break;\n    }\n\n    if (cycle_start == -1) {\n        cout << \"NO\\n\";\n    } else {\n        cout << \"YES\\n\";\n    /***********************************************************\n        --CODE TO PRINT CYCLE--\n        vector<int> cycle;\n        cycle.push_back(cycle_start);\n        for (int v = cycle_end; v != cycle_start; v = parent[v])\n            cycle.push_back(v);\n        cycle.push_back(cycle_start);\n        reverse(cycle.begin(), cycle.end());\n\n        cout << (int)cycle.size() << \"\\n\";\n        for (int v : cycle) cout << v << \" \";\n        cout << \"\\n\";\n    ************************************************************/\n    }\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int m;\n    cin >> n >> m;\n\n    adj.resize(n + 1);\n    \n    for(int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    find_cycle();\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:13:47.338171+00:00"
      },
      "hints": {
        "hint1": "Apply DFS to find the cycle with length ≥ 2 in the graph.",
        "hint2": "To check if a cycle exists in a directed graph, you can use a modified depth-first search (DFS) algorithm.\n\n1. First, you can represent the graph as an adjacency list or matrix.\n2. Next, you can perform a DFS starting from each vertex in the graph. During the DFS, you can keep track of the visited vertices and mark each visited vertex as you visit it. If you encounter a visited vertex again during the DFS, then you have found a cycle in the graph.\n3. However, in a directed graph, you need to consider the direction of the edges. Therefore, you need to keep track of not only visited vertices, but also which vertices are on the current path being traversed.\n4. To do this, you can use a color array to keep track of each vertex's state during the DFS. The color array can have the following values:  \n        $0$: the vertex is completely unvisited.   \n        $1$: the vertex whose some but not all children are visited.   \n        $2$: the vertex whose all the children are visited.    \n5. During the DFS, if you encounter a vertex that is already on the current path being traversed (i.e. has a color value of $1$), then you have found a cycle.  \n\nTime complexity : $O(V+E)$\n\n\n*Note : It is important to note that when dealing with graphs that are not explicitly stated to be connected, one must perform a depth-first search (DFS) on all unvisited nodes to ensure that all components of the graph are explored. This is because running DFS only on one starting node may miss components of the graph that are not connected to that starting node.*",
        "solution_approach": "To check if a cycle exists in a directed graph, you can use a modified depth-first search (DFS) algorithm.\n\n1. First, you can represent the graph as an adjacency list or matrix.\n2. Next, you can perform a DFS starting from each vertex in the graph. During the DFS, you can keep track of the visited vertices and mark each visited vertex as you visit it. If you encounter a visited vertex again during the DFS, then you have found a cycle in the graph.\n3. However, in a directed graph, you need to consider the direction of the edges. Therefore, you need to keep track of not only visited vertices, but also which vertices are on the current path being traversed.\n4. To do this, you can use a color array to keep track of each vertex's state during the DFS. The color array can have the following values:  \n        $0$: the vertex is completely unvisited.   \n        $1$: the vertex whose some but not all children are visited.   \n        $2$: the vertex whose all the children are visited.    \n5. During the DFS, if you encounter a vertex that is already on the current path being traversed (i.e. has a color value of $1$), then you have found a cycle.  \n\nTime complexity : $O(V+E)$\n\n\n*Note : It is important to note that when dealing with graphs that are not explicitly stated to be connected, one must perform a depth-first search (DFS) on all unvisited nodes to ensure that all components of the graph are explored. This is because running DFS only on one starting node may miss components of the graph that are not connected to that starting node.*"
      },
      "id": 194,
      "input_format": "The first input line has two integers n and m: the number of cities and roads. The cities are numbered 1, 2, …, n.\nThen, there are m lines describing the roads. Each line has two integers a and b: there is a road between those cities.\nEvery road is between two different cities, and there is at most one road between any two cities.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>Print ‘YES’ if such round trip exists, otherwise print ‘NO’.</p>",
      "samples": [
        {
          "input": "5 6\n1 3\n1 2\n5 3\n1 5\n2 4\n4 5",
          "output": "YES"
        },
        {
          "input": "4 3\n1 2\n1 3\n3 4",
          "output": "NO"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Round Trip",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a non-empty linked list, your task is to find the cycle in the linked list. Return starting node of the cycle and length of the cycle. If there is no cycle, then return <i>null</i> as node and <i>-1</i> as length.</p><p>Complete the function</p><pre><code class=\"language-plaintext\">pair&lt;ListNode*,int&gt; cycleInLinkedList(ListNode* head)</code></pre><p><i>head </i>is the pointer to the beginning node of the linked list.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ Length of the linked list ≤ 1000000<br>0 ≤ Value in node ≤ 10<sup>9</sup><br>1 ≤ <i>LastLink</i> ≤ Length of the linked list -1</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\npair<ListNode*,int> cycleInLinkedList(ListNode* head) {\n    if(head->next == NULL) {\n        return {NULL, -1};\n    }\n    \n    ListNode* slow_p = head;\n    ListNode* fast_p = head;\n  \n    while(slow_p && fast_p && fast_p->next) {\n        slow_p = slow_p->next;\n        fast_p = fast_p->next->next;\n\n        if(slow_p == fast_p) {\n            break;\n        }\n    }\n\n    if(slow_p == fast_p) {\n        int len = 0;\n        ListNode* temp = slow_p->next;\n        len++;\n        while(temp != slow_p) {\n            len++;\n            temp = temp->next;\n        }\n\n        slow_p = head;\n        while(slow_p != fast_p) {\n            slow_p = slow_p->next;\n            fast_p = fast_p->next;\n        }\n        \n        return {slow_p, len};\n    }\n\n    return {NULL, -1};\n}\n\n\nListNode* GetList(int n, vector<int> &num, int lastLink) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < n; i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n\n    if(lastLink) {\n        ListNode* temp = head;\n        for(int i = 0; i < lastLink - 1; i++) {\n            temp = temp->next;\n        }\n        cur->next = temp;\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    int lastLink;\n    cin >> lastLink;\n\n    ListNode* head = GetList(n, num, lastLink);\n\n    pair<ListNode*,int> ans = cycleInLinkedList(head);\n\n    cout << (ans.first ? ans.first->val : -1) << \" \" << ans.second << \"\\n\";\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:14:58.395705+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 527,
      "input_format": "<p>The first line contains <i>n </i>- the length of the linked list.<br>The second line contains the sequence of elements in linked list nodes.<br>The third line contains an integer <i>LastLink -</i> denoting to which node from the starting position the last node connects. If it is 0, then there is no cycle.</p><p>The following function translates the input.</p><pre><code class=\"language-plaintext\">ListNode* GetList(int n, vector&lt;int&gt; &amp;num, int lastLink)</code></pre><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><strong>Explanation 1:</strong></p><pre><code class=\"language-plaintext\">1 -----&gt; 2 -----&gt; 3\n         ^        |\n         |        |\n         ----------</code></pre><p><strong>Explanation 2:</strong></p><pre><code class=\"language-plaintext\">1 -------&gt; 2\n^          |\n|          |\n------------</code></pre><p><strong>Explanation 3:</strong></p><pre><code class=\"language-plaintext\">1 -------&gt; 2 ------&gt; 3</code></pre>",
      "output_format": "",
      "samples": [
        {
          "input": "3\n1 2 3\n2",
          "output": "2 2"
        },
        {
          "input": "2\n1 2\n1",
          "output": "1 2"
        },
        {
          "input": "3\n1 2 3\n0",
          "output": "-1 -1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\npair<ListNode*,int> cycleInLinkedList(ListNode* head) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(int n, vector<int> &num, int lastLink) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < n; i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n\n    if(lastLink) {\n        ListNode* temp = head;\n        for(int i = 0; i < lastLink - 1; i++) {\n            temp = temp->next;\n        }\n        cur->next = temp;\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    int lastLink;\n    cin >> lastLink;\n\n    ListNode* head = GetList(n, num, lastLink);\n\n    pair<ListNode*,int> ans = cycleInLinkedList(head);\n\n    cout << (ans.first ? ans.first->val : -1) << \" \" << ans.second << \"\\n\";\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "Cycle in Linked List",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You have to find the largest rectangular area possible in a given histogram where the largest rectangle can be made of contiguous bars. Assume that all bars have the same width, and the width is 1 unit.",
      "complete_approach": "",
      "constraints": "- $1 \\leq T \\leq 100$  \n- $1 \\leq N \\leq 10^5$  \n- $1 \\leq H_i \\leq 10^5$  \n\nWhere:  \n- **T** is the number of test cases.  \n- **N** is the number of bars in the histogram.  \n- **Hᵢ** is the height of the $i$-th bar.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        int a[n];\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        stack<int> s;\n        int i = 0;\n        long long ans = 0;\n        while (i < n) {\n            if (s.empty() || a[i] >= a[s.top()]) {\n                s.push(i);\n                i++;\n            }\n            else {\n                int t = s.top();\n                s.pop();\n                if (s.empty()) {\n                    ans = max(ans, 1LL * i * a[t]);\n                }\n                else {\n                    ans = max(ans, 1LL * a[t] * (i - s.top() - 1));\n                }\n            }\n        }\n        while (!s.empty()) {\n            int t = s.top();\n            s.pop();\n            if (s.empty()) {\n                ans = max(ans, 1LL * i * a[t]);\n            }\n            else {\n                ans = max(ans, 1LL * a[t] * (i - s.top() - 1));\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:38:45.975918+00:00"
      },
      "hints": {
        "hint1": "Height of the largest rectangle will be one of the heights of the histogram. We can iterate through all the histograms, and for each histogram H, we try to create the maximum rectangle with H as the height.",
        "hint2": "Consider 2 consecutive histograms $H[i]$ and $H[i+1]$. When $H[i+1] < H[i]$, for all histograms $X$ with index $> i + 1$, when traversing left for $L$, there is no point looking at $H[i]$ after looking at $H[i+1]$.\n\nIf $H[i+1] > X$, then $H[i] > X$ as we already know $H[i] > H[i+1]$. Then, the next entry we would want to look at is the first histogram left of $H[i+1]$ with height less than $H[i+1]$.\n",
        "solution_approach": "We traverse all histograms from left to right, maintaining a stack of histograms. Every histogram is pushed to the stack once. A histogram is popped from the stack when a histogram of smaller height is seen.  \n\nWhen a histogram is popped, we calculate the area with the popped histogram as the smallest histogram. The current index tells us the 'right index' $R$, and the index of the previous item in the stack is the 'left index' $L$.  \n\nTime Complexity per test case: $O(N)$\n"
      },
      "id": 461,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.  \nThe first line of each test case contains one integer $N$ - the length of the array.  \nThe second line of each test case contains $N$ space-separated integers, where $H_i$ denotes the height of the $i^{th}$ bar.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, take all the histograms to get area as $3 \\times 1 = 3$.\n\n![Image for Test Case 1](https://docs.google.com/drawings/u/0/d/ss62cfucO2XuMUKEM3hHNIw/image?w=76&h=52&rev=37&ac=1&parent=1Gfkf2CiiZJ4HZQkX-8CYiH6NDjYyYMNamayN2f9NhTc)\n\nFor the second test case, take the last two histograms to get area as $2 \\times 3 = 6$.\n\n![Image for Test Case 2](https://docs.google.com/drawings/u/0/d/s-KiTN-arqmwy9VjoLgmvHQ/image?w=102&h=102&rev=51&ac=1&parent=1Gfkf2CiiZJ4HZQkX-8CYiH6NDjYyYMNamayN2f9NhTc)\n\nFor the third test case, take the first two histograms to get area as $2 \\times 4 = 8$.\n\n![Image for Test Case 3](https://docs.google.com/drawings/u/0/d/sBgKvB4o6rq7Q9oNk3fWCbA/image?w=102&h=126&rev=27&ac=1&parent=1Gfkf2CiiZJ4HZQkX-8CYiH6NDjYyYMNamayN2f9NhTc)",
      "output_format": "For each test case, print the largest area of the rectangle in the histogram.",
      "samples": [
        {
          "input": "3\n3\n2 1 2\n4\n1 2 3 4\n4\n5 4 1 2",
          "output": "3\n6\n8"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Largest Rectangle",
      "video_editorial_id": 10688
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Write a program that manipulates a disjoint set <i>S = S<sub>1</sub>, S<sub>2</sub>, ..., S<sub>k</sub></i>.</p><p>First of all, the program should read an integer <i>n</i>, then make a disjoint set where each element consists of <i>0, 1, ..., n-1</i> respectively.</p><p>Next, the program should read an integer <i>q</i> and manipulate the set of <i>q</i> queries. There are two kinds of queries for different operations:</p><ol><li><i><strong>unite(x, y)</strong>:</i> unite sets that contain <i>x</i> and <i>y</i>, say <i>S<sub>x</sub></i> and <i>S<sub>y</sub></i>, into a new set.</li><li><i><strong>same(x, y)</strong>:</i> determine whether <i>x</i> and <i>y</i> are in the same set.</li></ol>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nclass wunionfind {\n  public:\n    int *id, *sz;\n    wunionfind(int n = N) {\n        id = new int[n + 1];\n        sz = new int[n + 1];\n        for(int i = 0; i <= n; i++) {\n            id[i] = i;\n            sz[i] = 1;\n        }\n    }\n    int root(int idx) {\n        int x = idx;\n        while(x != id[x]) {\n            id[x] = id[id[x]];\n            x = id[x];\n        }\n        return x;\n    }\n    bool uni(int a, int b) {\n        int x = root(a), y = root(b);\n        if(sz[x] < sz[y]) {\n            swap(x, y);\n        }\n        if (x != y) {\n            id[y] = x;\n            sz[x] += sz[y];\n            sz[y] = 0;\n            return false;\n        }\n        return true;\n    }\n    bool check(int a, int b) {\n        return (root(a) == root(b));\n    }\n};\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n, q; cin >> n >> q;\n    wunionfind W(n);\n\n    for(int i = 0; i < q; i++) {\n        int com, x, y;\n        cin >> com >> x >> y;\n        if(!com) W.uni(x, y);\n        else cout << W.check(x, y) << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:47:52.629447+00:00"
      },
      "hints": {
        "hint1": "<p><i>N/A</i></p>",
        "hint2": "<p><i>Use disjoint set union.</i></p>",
        "solution_approach": "<p><i>Check out the video.</i></p>"
      },
      "id": 40,
      "input_format": "<p>The first line contains two space-separated integers <i>n</i> and <i>q</i>, (1 ≤ <i>n</i> ≤ 10<sup>4</sup>, 1 ≤ <i>q</i> ≤ 10<sup>5</sup>).<br>Then, <i>q</i> queries are given in the form <i><strong>com x y</strong></i>, where <i>com</i> represents the type of queries. <i>'0'</i> denotes <i><strong>unite</strong></i> and <i>'1'</i> denotes <i><strong>same</strong></i> operation (<i>x != y</i>).</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each same operation, print 1 if <i>x</i> and <i>y</i> are in the same set, otherwise 0, in a line.</p>",
      "samples": [
        {
          "input": "5 12\n0 1 4\n0 2 3\n1 1 2\n1 3 4\n1 1 4\n1 3 2\n0 1 3\n1 2 4\n1 3 0\n0 0 4\n1 0 2\n1 3 0",
          "output": "0\n0\n1\n1\n1\n0\n1\n1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.2,
      "title": "Disjoint Union",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers and <i>Q</i> queries and an integer <i>K</i>. Initially, all the elements of the array have value 0.</p><p>In each query 3 integers <i>A</i>, <i>L</i>, <i>R</i> is given, which means perform GP addition</p><p><i>Arr[L]+=A</i></p><p><i>Arr[L+1]+=A*K</i></p><p><i>Arr[L+2]+=A*K*K</i></p><p><i>Arr[L+3]+=A*K*K*K</i></p><p><i>.</i></p><p><i>.</i></p><p><i>.</i></p><p><i>.</i></p><p><i>Arr[R]+=A*(K^(R-L))</i></p><p>&nbsp;</p><p>After performing all the operations. Print the final array % 10^9+7.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += mod;\n}\n\ninline int mul(int a, int b) {\n  return (int) ((long long) a * b % mod);\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= mod;\n  if (a < 0) a += mod;\n  int b = mod, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += mod;\n  return u;\n}\n\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n, q, k;\n    cin >> n >> q >> k;\n    int A[n + 2];\n    memset(A, 0, sizeof(A));\n\n    while(q--) {\n        int a, l, r;\n        cin >> a >> l >> r;\n        add(A[l], mul(a, inv(power(k, l))));\n        sub(A[r + 1], mul(a, inv(power(k, l))));\n    }\n\n    for(int i = 1; i <= n; i++) {\n        add(A[i], A[i - 1]);\n        cout << mul(A[i], power(k, i)) << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:32:40.518826+00:00"
      },
      "hints": {
        "hint1": "Use Gp on Partial Sums. If new to this concept,\nCheck the video solution - GP on Partial Sum.",
        "hint2": "$Arr[i]=A\\times K^{i-L}$  \n$ Arr[i]=A\\times \\dfrac{K^i}{K^L}$    \n\n$ Arr[i]=AK^{-L}\\times K^i $  \n$ Arr[i]=$ constant for a query $\\times K^i $  \n$ Arr[i]= C \\times K^i$    \n\nThe `C` is constant across a particular query. So we can make use of partial sums for this this particular constant. Just add `C` at Arr[L] and subtract it from Arr[R+1].  \n\nFor the variable part $K^i$ , make sure when we are at a particular index, bring `K` to that particular power of i and multiply with the constant term in array $Arr$.",
        "solution_approach": "So our steps for a particular query A L R, our steps are as follows;  \n$ Arr[L]+=AK^{-L} $  \n$ Arr[R+1]-=AK^{-L} $  \n\nDo this across all queries\nAfter all queries are executed start a loop from the beginning of the array and \n$ Arr[i]+=Arr[i-1] $  \n$ Arr[i]=Arr[i]*K^{i} $    \n\n In the given code, the add function is used to add a value to an element of the array, while the sub function is used to subtract a value from an element of the array.\n\n\n\n\nThe time complexity of the given problem is $O(Q + N)$, where Q is the number of queries and N is the size of the array.\n\nThe while loop in the main function iterates Q times, and each iteration takes $O(1)$ time. Inside the while loop, we call the add and sub functions which take $O(1)$ time each. Therefore, the time complexity of processing all the queries is $O(Q)$.\n\nAfter processing all the queries, the for loop iterates $N$ times and performs constant-time operations inside the loop. Therefore, the time complexity of the for loop is also $O(N)$.\n\nSo the overall time complexity of the main function is $O(Q + N)$."
      },
      "id": 31,
      "input_format": "<p>The first line contains three space-separated integers <i>N</i>, <i>Q</i>, <i>K</i> where 1&lt;=<i>N</i>&lt;=10^6, 1&lt;=<i>Q</i>&lt;=10^6, 1&lt;=<i>K</i>&lt;=10^9.</p><p>Next <i>Q</i> lines contain three space-separated integers <i>A, L, R</i> where 0&lt;=<i>A</i>&lt;=10^4, 1&lt;=<i>L</i>&lt;=<i>R</i>&lt;=N.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>Print the <i>N</i> space-separated integer representing the final array %10^9+7.</p>",
      "samples": [
        {
          "input": "5 5 2\n3 1 5\n4 2 2\n6 3 5\n9 5 5\n4 2 4",
          "output": "3 14 26 52 81 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "GP Addition",
      "video_editorial_id": 8130
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Most basic question.<br><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.84);\">Given a set of cities and </span>the <span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.84);\">distance between every pair of cities, the problem is to find the shortest possible route that visits every city exactly once and returns to the starting point.</span></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint d[15][15];\nint dp[(1<<15)][15];\n\nint dfs(int vis, int pos, int n) {\n    if(vis == (1<<n)-1) {\n        return d[pos][0];\n    }\n    if(dp[vis][pos]) {\n        return dp[vis][pos];\n    }\n    int ans = 2e18;\n    for (int i = 0; i < n; ++i) {\n        if((vis & (1<<i)) == 0) {\n            int temp = d[pos][i] + dfs(vis | (1<<i), i, n);\n            ans = min(ans, temp);\n        }\n    }\n    dp[vis][pos] = ans;\n    return ans;\n}\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        int n;\n        cin >> n;\n        memset(dp, 0, sizeof(dp));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cin >> d[i][j];\n            }\n        }\n        cout << dfs(1, 0, n) << \"\\n\";\n    }\n    return 0;\n}\n```\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint d[15][15];\nint dp[(1<<15)][15];\n\nint dfs(int vis, int pos, int n) {\n    if(vis == (1<<n)-1) {\n        return d[pos][0];\n    }\n    if(dp[vis][pos]) {\n        return dp[vis][pos];\n    }\n    int ans = 2e18;\n    for (int i = 0; i < n; ++i) {\n        if((vis & (1<<i)) == 0) {\n            int temp = d[pos][i] + dfs(vis | (1<<i), i, n);\n            ans = min(ans, temp);\n        }\n    }\n    dp[vis][pos] = ans;\n    return ans;\n}\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        int n;\n        cin >> n;\n        memset(dp, 0, sizeof(dp));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cin >> d[i][j];\n            }\n        }\n        cout << dfs(1, 0, n) << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:29:13.391194+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">The brute force approach would be to calculate all permutations and find the smallest possible answer. Time Complexity for this will be O((N-1)!). There would be overlapping subproblems in this, for example if you want to visit some city j and there would be some subset of cities already visited. So you can optimise the brute force solution using dynamic programming with bitmasking.</span></p>",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Without loss of generality, let's start the tour from vertex 1. We define the DP array as DP[i][j] which is the length of the shortest path from node i while going through all the vertices in j and ending at 1.</span></p><p><span style=\"background-color:transparent;color:#000000;\">DP[1][S - {1}] would be the optimal answer. Here, S-{1} is the set of all the vertices except vertex 1. The transitions can be defined as: DP[i][S] = min(D[i][j] + DP[j][S-{j}]), for all i does not belong to S and j belongs to S. This way we are adding the distance between i and j and the answer for the set S-{j} connecting to j.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity: O(N^2 * 2^N)</span></p>"
      },
      "id": 456,
      "input_format": "<p>The first line contains an integer T (1 ≤ T ≤ 50) - the number of testcases.</p><p>The first line of each test case contains an integer N. 1 ≤ N ≤ 15.</p><p>The next N lines contains N space-separated integers, dis[i][j] which denotes distance between city i and city j is dis[i][j], 1 ≤ dis[i][j] ≤ 10^5.<br>dis[i][i] = 0, dis[i][j]=dis[j][i].</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the shortest distance that needs to be traveled to visit every city exactly once and returns to the starting point in a new line.</p>",
      "samples": [
        {
          "input": "10\n6\n0 9 9 10 3 7\n9 0 6 7 1 8\n9 6 0 7 10 3\n10 7 7 0 4 7\n3 1 10 4 0 7\n7 8 3 7 7 0\n3\n0 8 6\n8 0 8\n6 8 0\n1\n0\n7\n0 8 6 5 2 9 8\n8 0 1 5 5 1 7\n6 1 0 2 6 1 6\n5 5 2 0 10 6 3\n2 5 6 10 0 4 8\n9 1 1 6 4 0 1\n8 7 6 3 8 1 0\n6\n0 5 6 2 5 6\n5 0 9 10 4 3\n6 9 0 5 3 9\n2 10 5 0 4 10\n5 4 3 4 0 10\n6 3 9 10 10 0\n5\n0 6 6 8 5\n6 0 10 5 2\n6 10 0 9 4\n8 5 9 0 4\n5 2 4 4 0\n10\n0 7 8 3 5 9 7 2 6 6\n7 0 2 7 6 5 3 4 7 8\n8 2 0 9 9 7 10 3 4 10\n3 7 9 0 7 9 5 2 3 8\n5 6 9 7 0 9 10 6 9 3\n9 5 7 9 9 0 6 6 6 7\n7 3 10 5 10 6 0 8 4 3\n2 4 3 2 6 6 8 0 2 10\n6 7 4 3 9 6 4 2 0 2\n6 8 10 8 3 7 3 10 2 0\n4\n0 10 3 2\n10 0 6 9\n3 6 0 2\n2 9 2 0\n11\n0 5 2 1 6 3 4 7 8 10 3\n5 0 10 7 9 7 3 5 6 7 5\n2 10 0 10 2 8 5 8 6 4 6\n1 7 10 0 5 5 6 8 4 1 1\n6 9 2 5 0 6 1 3 1 9 8\n3 7 8 5 6 0 5 7 7 8 2\n4 3 5 6 1 5 0 2 4 8 2\n7 5 8 8 3 7 2 0 3 3 6\n8 6 6 4 1 7 4 3 0 4 7\n10 7 4 1 9 8 8 3 4 0 9\n3 5 6 1 8 2 2 6 7 9 0\n10\n0 2 2 9 4 10 5 5 2 4\n2 0 5 9 2 2 1 8 6 1\n2 5 0 10 3 7 5 7 1 1\n9 9 10 0 5 10 7 10 3 10\n4 2 3 5 0 2 3 9 2 2\n10 2 7 10 2 0 8 6 6 4\n5 1 5 7 3 8 0 5 4 6\n5 8 7 10 9 6 5 0 5 9\n2 6 1 3 2 6 4 5 0 3\n4 1 1 10 2 4 6 9 3 0",
          "output": "28\n22\n0\n18\n23\n25\n35\n20\n26\n28"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "TSP",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given the arrival and leaving time of N customers. Find the maximum number of customers at any time. **All arriving and leaving times are distinct.**",
      "complete_approach": "",
      "constraints": "- $1 \\leq T \\leq 10^5$\n- $1 \\leq N \\leq 10^5$\n- $1 \\leq A_i \\leq 10^9$\n- $1 \\leq B_i \\leq 10^9$\n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<pair<int, int>> v;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            cin >> x >> y;\n            v.push_back({x, 1});\n            v.push_back({y, -1});\n        }\n        sort(v.begin(), v.end());\n        int cur = 0, ans = 0;\n        for(auto i:v) {\n            cur += i.second;\n            ans = max(ans, cur);\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:15:30.904833+00:00"
      },
      "hints": {
        "hint1": "Make a vector of pair to store the time of arrival/leaving along with the status of arriving or leaving.",
        "hint2": "",
        "solution_approach": "Sort the vector of pair according to the time. Arrival would increase the number of customers and departure would decrease the number of customers.\n\nTime Complexity per test case: O(N log N)\n\nThis solution will not work if all the arriving and departing time is not distinct. Can you figure out an approach to solve the problem without distinct constraints?"
      },
      "id": 369,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer N - the length of the array. \n\nEach of the next N lines contain two space-separated integers A, B - the arrival and leaving time of the customer.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, there are 2 customers at time, t = 2\n\nFor the second test case, there are 3 customers at time, t = 3\n\nFor the third test case, there is 1 customer at time, t = 3",
      "output_format": "For each test case, print the maximum number of customers at any time.",
      "samples": [
        {
          "input": "3\n2\n1 3\n2 4\n3\n3 4\n1 9\n2 5\n2\n3 4\n1 2\n",
          "output": "2\n3\n1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Maximum Number of Customers AZ101",
      "video_editorial_id": 8188
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given the <i>root</i> of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).</p><p>Complete the function:</p><p><i>vector&lt;vector&lt;int&gt;&gt; getLevelorderTraversal(Node* root)&nbsp;</i></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<vector<int>> getLevelorderTraversal(Node* root) {\n   vector<vector<int>> ans;\n   if(!root) return ans;\n   queue<Node*> q;\n   q.push(root);\n   while(!q.empty()){\n       int sz = q.size();\n       vector<int> v;\n       while(sz--){\n           Node * temp = q.front();\n           v.push_back(temp->val);\n           q.pop();\n           if(temp->left) q.push(temp->left);\n           if(temp->right) q.push(temp->right);\n       }\n       ans.push_back(v);\n   }\n   return ans;\n}\n\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        vector<vector<int>> ans = getLevelorderTraversal(tree);\n        for(auto u:ans){\n            for(auto v:u){\n                cout<<v<<\" \";\n            }\n            cout<<\"\\n\";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:15:35.152021+00:00"
      },
      "hints": {
        "hint1": "<p>Try to think in terms of BFS. BFS also traverses the nodes levelwise. Here first we have to take the left node, so push the left node first for any level.</p>",
        "hint2": "<p>Push the root.</p><p>Start doing dfs, take the size of the queue which currently contains all the nodes present in the current level. For all these nodes push the left child first, then the right child.</p>",
        "solution_approach": ""
      },
      "id": 576,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, &nbsp;the length of the array representing the serialized representation of a tree.</p><p>The next line contains N-space-separated integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<pre><code class=\"language-plaintext\">Test case 2- \n 5222\n    \\\n   3819\n    /\n  6801\n\t\nTest case 3 - \n   8901\n   /\n  7891\n   /   \\\n  5407 1720</code></pre>",
      "output_format": "<p>Return the level order traversal of the tree.</p>",
      "samples": [
        {
          "input": "3\n3\n6004 -1 -1 \n7\n5222 -1 3819 6801 -1 -1 -1 \n9\n8901 7891 5407 -1 -1 1720 -1 -1 -1 ",
          "output": "6004 \n\n5222 \n3819 \n6801 \n\n8901 \n7891 \n5407 1720 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n</fix>\nvector<vector<int>> getLevelorderTraversal(Node* root) {\n  // Complete the function.\n}\n\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        vector<vector<int>> ans = getLevelorderTraversal(tree);\n        for(auto u:ans){\n            for(auto v:u){\n                cout<<v<<\" \";\n            }\n            cout<<\"\\n\";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Level Order Traversal",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given an array <i>A</i> of <i>n</i> integers. Your task is to answer <i>q</i> queries. Each query contains an integer <i>x</i>.&nbsp;<br>For each query, print the minimum index <i>i</i> such that <i>A<sub>i</sub></i> ≥ <i>x, </i>and then decrease the value at position <i>i </i>by<i> x, </i>i.e., <i>A<sub>i </sub>= A<sub>i</sub> - x. </i>If there doesn't exist any index <i>i </i>satisfying the condition, then simply print 0.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i>, <i>q </i>≤ 2 x 10<sup>5</sup><br>0 ≤ <i>A<sub>i</sub>, x<sub>i</sub> </i>≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 200010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nint tree[4 * N];\nint A[N];\n\nvoid build(int node, int start, int end)\n{\n    if (start == end)\n    {\n        tree[node] = A[start];\n        return;\n    }\n    int mid = (start + end) / 2;\n    build(2 * node, start, mid);\n    build(2 * node + 1, mid + 1, end);\n    tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n}\n\nvoid update(int node, int start, int end, int idx, int val)\n{\n    if (start == end)\n    {\n        A[start] -= val;\n        tree[node] = A[start];\n        return;\n    }\n    int mid = (start + end) / 2;\n    if (idx <= mid)\n        update(2 * node, start, mid, idx, val);\n    else\n        update(2 * node + 1, mid + 1, end, idx, val);\n    tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n}\n\nint query(int node, int start, int end, int x)\n{\n    if (tree[node] < x)\n        return -1;\n    if (start == end)\n        return start;\n    int mid = (start + end) / 2;\n    if (tree[2 * node] >= x)\n        return query(2 * node, start, mid, x);\n    return query(2 * node + 1, mid + 1, end, x);\n}\n\nsigned main()\n{\n    // freopen(\"IN\", \"r\", stdin);\n    // freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n\n    for (int i = 0; i < n; i++)\n        cin >> A[i];\n\n    build(1, 0, n - 1);\n\n    for (int i = 0; i < q; i++)\n    {\n        int x;\n        cin >> x;\n        int ans = query(1, 0, n - 1, x);\n        if (ans >= 0)\n            update(1, 0, n - 1, ans, x);\n        cout << ans + 1 << \" \";\n    }\n    cout << \"\\n\";\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:31:17.463638+00:00"
      },
      "hints": {
        "hint1": "Use a segment tree to efficiently handle the queries.",
        "hint2": "",
        "solution_approach": "The segment tree is built initially to store the values of the array.\nRecursively build the left and right subtrees of each node by dividing the range in half.\nUpdate each node with the maximum value of its children.\nFor each query, a binary search is performed on the segment tree to find the minimum index where the value is greater than or equal to the given value.\nIf such an index is found, the value at that index is decreased by the given value.\n\nTime Complexity:\n\nBuilding the segment tree takes $O(n)$ time.\nEach query performs a binary search on the segment tree, which takes $O(\\log n)$ time.\nOverall, the time complexity of the solution is $O(n + q \\log n)$, where $n$ is the size of the array and $q$ is the number of queries."
      },
      "id": 403,
      "input_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">The first input line has two integers <i>n</i> and <i>q</i>: the number of values and queries.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">The second line has <i>n</i> integers <i>A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub></i>: the array values.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Finally, there are <i>q</i> integers describing the queries. <i>x<sub>1</sub>, x<sub>2</sub>, …, x<sub>q</sub></i>.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the index <i>i </i>as mentioned in the problem statement. If such an index doesn't exist, then print 0.</p>",
      "samples": [
        {
          "input": "8 5\n3 2 4 1 5 5 2 6\n4 4 7 1 1",
          "output": "3 5 0 1 1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "First Min Queries",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have been given a grid of size <i>N</i> x <i>N. </i>Each cell is either empty (.) or occupied (#). Size of each cell is 1 x 1. In the connected component, you can reach any cell from every other cell in the component by repeatedly stepping to adjacent cells in the north, south, east, and west directions.&nbsp;<br>Your task is to find the area and perimeter of the connected component having the largest area. The area of a connected component is just the number of '#' characters that are part of it. If multiple connected components tie for the largest area, find the smallest perimeter among them.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>N</i> ≤ 1000</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint N, R;\nchar grid[1002][1002]; // pad with .'s\nint region[1002][1002], area[1000000], perimeter[1000000];\n\ntypedef pair<int,int> pii;\nvoid visit(int i, int j, int r)\n{\n  stack<pii> to_visit;\n  to_visit.push(make_pair(i,j));\n  while (!to_visit.empty()) {\n    pii current = to_visit.top();\n    to_visit.pop();\n    i = current.first; j = current.second;\n    if (region[i][j] != 0 || grid[i][j]=='.') continue;\n    region[i][j] = R;\n    area[R]++;\n    to_visit.push(make_pair(i-1,j));\n    to_visit.push(make_pair(i+1,j));\n    to_visit.push(make_pair(i,j-1));\n    to_visit.push(make_pair(i,j+1));\n  }\n}\n\nvoid find_perimeters(void)\n{\n  for (int i=1; i<=N; i++)\n    for (int j=1; j<=N; j++) {\n      int r = region[i][j];\n      if (r == 0) continue;\n      if (region[i-1][j]==0) perimeter[r]++;\n      if (region[i+1][j]==0) perimeter[r]++;\n      if (region[i][j-1]==0) perimeter[r]++;\n      if (region[i][j+1]==0) perimeter[r]++;\n    }\n}\n\nint main(void)\n{\n  ios_base::sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n\n  cin >> N;\n  string s;\n  for (int i=0; i<N+2; i++) grid[0][i] = grid[N+1][i] = '.';\n  for (int i=1; i<=N; i++) {\n    grid[i][0] = grid[i][N+1] = '.';\n    cin >> s;\n    for (int j=1; j<=N; j++) grid[i][j] = s[j-1];\n  }\n\n  for (int i=1; i<=N; i++)\n    for (int j=1; j<=N; j++)\n      if (grid[i][j] == '#' && region[i][j] == 0) visit(i,j,++R);\n\n  find_perimeters();\n\n  int best_a=0, best_p=0;\n  for (int i=1; i<=R; i++)\n    if (area[i] > best_a || (area[i] == best_a && perimeter[i] < best_p)) {\n      best_a = area[i];\n      best_p = perimeter[i];\n    }\n\n  cout << best_a << \" \" << best_p << \"\\n\";\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:32.602673+00:00"
      },
      "hints": {
        "hint1": "Given a grid of cells with # or . (empty) elements. Each cell of the grid is equivalent to the node of a graph. All valid transitions to neighboring cells (right, left, top and bottom), form the edges that connect the cells. In this way, how many connected components do you see in the grid?",
        "hint2": "The grid can be divided into components of contiguous-filled cells. The area is the size of the component, while the perimeter is the count of the number of cell borders of the component, which is not shared by another filled cell. We are going to use flood fill to determine the maximum possible area and its corresponding minimum possible perimeter.",
        "solution_approach": "This problem can be solved with flood fill. We loop over all cells and use depth-first search (DFS) or breadth-first search (BFS) to label the entire component containing the cell. Ordinarily, this would take $O(N^4)$ time, since each search could take $O(N^2)$ time, and we perform $O(N^2)$ searches. However, if a cell has already been visited by a previous search (i.e., it is in the same component as a previously seen cell), then we can skip it since the cells in its component have already been labeled. Thus, every cell is only visited once, so the complexity of all the searches together is only $O(N^2)$, which runs in time.\n\nNow each cell is labeled with a \"component ID.\" We then need to find the area and perimeter of each connected component. The area is simply the number of cells labeled with this ID, and the perimeter is the sum over all cells in the region of the number of \"border edges\" of that cell (i.e., the number of empty-space cells adjacent to that cell).\n\nWe can initialize the area and perimeter of each region to zero and compute them incrementally by making a final pass over the grid.\n\nOnce all areas and perimeters are computed, it is a simple matter to find the largest area, and among those connected components with the largest area, find the smallest perimeter.\n\n---\n\nWe traverse over all the cells of the grid, keeping count of the maximum contiguous filled components we can find. We apply DFS or BFS to do so. Since the number of cells is $N^2$, there will be $N^2$ searches on all the $N^2$ cells, making the time complexity $O(N^4)$.\n\nThe time complexity can be reduced by maintaining a `vis[][]` array, which marks the cells that have already been visited. When a cell is marked, all the cells in the same component as that cell are also traversed and marked. Hence, no cell is traversed twice, and the time complexity becomes $O(N^2)$.\n\n---\n\n### Alternative Explanation:\n\nTo calculate the area of the components, count the number of filled cells in that component. The value of the perimeter is the count of border edges of the connected cells, which they share either with a boundary or an empty cell.\n\nFinally, for all the connected components, find the one with the largest area and its corresponding perimeter.\n\n---\n\n### Example Run:\n\nInput Grid:\n\n```\n5\n#...#\n##.##\n....#\n##...\n##...\n```\n\nThis is a $5 \\times 5$ grid.\n\n1. **Component 1:**\n   - Start DFS from the top-left cell (`#`).\n   - Area = Number of components = 3  \n   - Perimeter = Boundary edges (3) + Shared with empty cells (5) = $8$  \n\n   Mark the cells as visited.\n\n2. **Component 2:**\n   - Start DFS from the 5th cell of the 1st row (`#`) and its connected cells.  \n   - Area = 4, Perimeter = 10  \n\n3. **Component 3:**\n   - Area = 4, Perimeter = 8  \n\n**Result:**  \nThe maximum possible area is $4$, with the smallest perimeter of $8$.\n\n**Answer:**  \nArea = $4$, Perimeter = $8$\n\n---\n\n### Time Complexity:\n\n- **Time Complexity:** $O(N^2)$"
      },
      "id": 422,
      "input_format": "The first line of input contains N, and the next N lines describe the grid. At least one '#' character will be present.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Please output one line containing two space-separated integers, the first being the area of the largest connected component, and the second being its perimeter. If multiple connected components tie for the largest area, print the one which has the smallest perimeter among them.",
      "samples": [
        {
          "input": "6\n##....\n....#.\n.#..#.\n.#####\n...###\n....##",
          "output": "13 22"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Area and Perimeter of Connected Components",
      "video_editorial_id": 8202
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You've given an array <i>A</i> of length <i>N</i>. You've to answer <i>Q</i> queries. In each query, you'll be given three numbers <i>l, r, k</i>. Your task is to find the <i>k</i>th smallest elements in the subarray <i>A<sub>l</sub>, A<sub>l+1</sub>, …, A<sub>r</sub></i>.<br>It is guaranteed that all elements in the array <i>A</i> will be distinct.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>N</i> ≤ 10<sup>5</sup><br>1 ≤ <i>A<sub>i</sub></i> ≤ 10<sup>9</sup><br>1 ≤ <i>Q</i> ≤ 5 x 10<sup>4</sup><br>1 ≤ <i>l<sub>i</sub></i> ≤ <i>r<sub>i</sub></i> ≤ <i>N</i><br>1 ≤ <i>k<sub>i</sub></i> ≤ <i>r<sub>i</sub></i> - <i>l<sub>i</sub></i> + 1</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nvector<int> tree[4 * N];\nint A[N];\n\nvoid build(int node, int start, int end) {\n    for(int i = start; i <= end; i++) tree[node].push_back(A[i]);\n    sort(tree[node].begin(), tree[node].end());\n    if(start == end) return;\n    int mid = (start + end) / 2;\n    build(2 * node, start, mid);\n    build(2 * node + 1, mid + 1, end);\n}\n\nint binary(vector<int> &a, int x) {\n    int L = 0, R = (int)a.size() - 1;\n    int ans = -1;\n    while(L <= R) {\n        int mid = (L + R) / 2;\n        if(a[mid] <= x) {\n            ans = mid;\n            L = mid + 1;\n        }\n        else R = mid - 1;\n    }\n    return ans + 1;\n}\n\nint query(int node, int start, int end, int l, int r, int x) {\n    if(start > r || end < l) return 0;\n    if(start >= l && end <= r) return binary(tree[node], x);\n    int mid = (start + end) / 2;\n    return query(2 * node, start, mid, l, r, x) + query(2 * node + 1, mid + 1, end, l, r, x);\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n, q; cin >> n >> q;\n\n    for(int i = 0; i < n; i++) cin >> A[i];\n\n    build(1, 0, n - 1);\n\n    while(q--) {\n        int l, r, k;\n        cin >> l >> r >> k;\n        l--; r--;\n        int L = 0, R = 1e9;\n        int ans = -1;\n        while(L <= R) {\n            int mid = (L + R) / 2;\n            if(query(1, 0, n - 1, l, r, mid) >= k) {\n                ans = mid;\n                R = mid - 1;\n            }\n            else L = mid + 1;\n        }\n        assert(ans != -1);\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:32:35.295340+00:00"
      },
      "hints": {
        "hint1": "<p>Merge Sort Tree… If you don't know the merge sort tree, it's basically a segment tree where each node maintains all elements belonging to the range for that node.</p>",
        "hint2": "<p>Sort all elements for all nodes in the merge sort tree.</p>",
        "solution_approach": "<p>Please read Hint 1 and 2 first.<br>Now the solution is to apply binary search on the answer. We can find the number of elements ≤ <i>x </i>in the given range <i>l</i> to <i>r</i> in the O(logN * logN) time (we also have to do upperbound/lowerbound at each node belonging to that range).&nbsp;<br>With binary search, each query will be answered in O(log N * log N * log (1e9)).</p><p>Please go through the editorial code for more clarity.</p>"
      },
      "id": 409,
      "input_format": "The first line of input contains two space-separated integers $N$ and $Q$ - the number of elements and queries.\n\nThe second line contains $N$ space-separated numbers $A_1, A_2, \\dots, A_N$.\n\nEach of the next $Q$ lines contains a pair of integers. The $i$-th line contains integers $l_i$, $r_i$, and $k_i$ — the description of the $i$-th query.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each query, print the answer on a new line.</p>",
      "samples": [
        {
          "input": "7 3\n1 5 2 6 3 7 4\n2 5 3\n4 4 1\n1 7 3",
          "output": "5\n6\n3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Little Tougher Queries",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two integers $dividend$ and $divisor$, divide two integers without using multiplication, division, and mod operator.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, $8.345$ would be truncated to $8$, and $-2.7335$ would be truncated to $-2$.\n\nReturn the quotient after dividing the dividend by the divisor.\n\n### Note: \n-   Assume we are dealing with an environment that could only store integers within the $32$-bit signed integer range: $[−2^{31}, 2^{31}-1]$. \n( **This means no long long or unsigned int** )\n-   For this problem, if the quotient is strictly greater than $2^{31} - 1$, then return $2^{31} - 1$, and if the quotient is strictly less than $-2^{31}$, then return $-2^{31}$.\n-   No multiplication, division, or mod operator.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^{5}$.\n$-2^{31} \\leq dividend, divisor \\leq 2^{31} - 1$.\n$divisor \\neq 0$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint divide(int dividend, int divisor) {\n\n\t// Edge Case-: INT_MIN\n\tif (dividend == INT_MIN) {\n\t\tif (divisor == -1) {return INT_MAX;}\n\t\telse if (divisor == INT_MIN) {return 1;}\n\t\telse if (divisor < 0) {\n\t\t\t// do this so we can avoid abs(dividend) overflowing the upper int limit\n\t\t\treturn 1 + divide(dividend - divisor, divisor);\n\t\t}\n\t\telse {\n\t\t\t// same as above comment\n\t\t\treturn -1 + divide(dividend + divisor, divisor);\n\t\t}\n\t}\n\telse if (divisor == INT_MIN) {return 0;}\n\n\n\tint ans = 0, sign = 1; // keeping track of sign.\n\tif ((dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0))sign = -1;\n\n\tdividend = abs(dividend), divisor = abs(divisor); // taking both +ve value.\n\n\tfor (int i = __builtin_clz(divisor) - 1; i >= 0; i--) {\n\t\tif (dividend >= (divisor << i))dividend -= (divisor << i), ans += (1 << i);\n\t}\n\n\treturn sign * ans;\n}\nvoid solve() {\n\tint a, b;\n\tcin >> a >> b;\n\tcout << divide(a, b) << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:17:10.898348+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "### Note: \n-   Assume we are dealing with an environment that could only store integers within the $32$-bit signed integer range: $[−2^{31}, 2^{31}-1]$. \n( **This means no long long or unsigned int** )\n-   For this problem, if the quotient is strictly greater than $2^{31} - 1$, then return $2^{31} - 1$, and if the quotient is strictly less than $-2^{31}$, then return $-2^{31}$.\n-   No multiplication, division, or mod operator.\n\n\nThe general idea is similar to many others. We change both the dividend and divisor to positive and then add in the negative sign at the end if needed. But firstly, we have a few edge cases:\n\n-   If dividend = INT_MIN and divisor = -1, then the actual result of the divison would be -INT_MIN, or +2147483648. But this overflows INT_MAX, so we just return INT_MAX in this case.\n-   If dividend = INT_MIN and divisor = INT_MIN, then return 1.\n-   Even if the above two cases do not happen, we still need to modify dividend. The reason is if dividend = INT_MIN, then abs(dividend) would overflow INT_MAX, so we can't allow this to happen. I take care of this by simply subtracting or adding one divisor from dividend, based on the sign of divisor. If you don't understand this, consider the following logic: The quotient when 10000 is divided by 3 is also equal to 1 + the quotient of 9997 / 3. We basically remove one instance of divisor from the dividend so that abs(dividend) no longer overflows.\n-   If none of the above happens (basically, if dividend != INT_MIN), but divisor is INT_MIN, then obviously the correct quotient is 0.\n\nWithout multiplication, division, or modulo operators, the only way we can do this is through bit shift operators. But more specifically, this program mainly relies on the binary right shift (>>) operator, because this helps us avoid overflow. This loop is the main part of the program:\n\n```\nint result = 0;\nfor(int i = 31; i >= 0; --i) {\n\tint shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\n\tif(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\n\t\tresult += (1 << i);\n\t\tdividend -= (divisor << i);\n\t}\n}\n```\n\nWhat happens here is the following.\n\n-   Loop from the most significant bit to the least significant bit in a 32-bit number. For each bit, we determine if the final quotient (result) should have this bit set or not. How do we decide this for each position i? Just do the following:\n-   Let shifted_dividend = (dividend >> i), which is the quotient of dividend / 2^i. Basically, this is just how many times 2^i can go into dividends. Now, obviously, if 2^i can go into dividend at least divisor times, then we know that divisor * 2^i <= dividend, which means that we should add 2^i to the quotient, and subtract divisor * 2^i from dividend!\n-   Notice how (dividend >> i) never overflows, since it must result in a number smaller than the dividend. Also, it never becomes negative; if i is too large, then (dividend >> i) would just equal 0. This fits up with the conceptual definition that this is the number of times 2^i can go into the dividend.\n-   Obviously, we return results and make sure to take care of whether it's negative or positive.\n\n**Note about C++ Undefined Behavior:** Right-shifting a negative signed integer is undefined behavior, but right-shifting a positive signed integer isn't. cppreference.com says that \"For unsigned a and for signed and non-negative a, the value of a >> b is the integer part of a/(2^b).\" This is one of the main reasons why we choose to change both numbers to positive before finding the quotient (and only adding the negative sign at the very end).\n\n**Time Complexity:** $O(32)$"
      },
      "id": 954,
      "input_format": "The First line contains $T$ - the number of test cases.\nThe first line of each test case contains two integers - $dividend$ and $divisor$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the $quotient$ after dividing $dividend$ by $divisor$.",
      "samples": [
        {
          "input": "8\n-2147483648 -1\n-2147483648 1\n-2147483648 -2147483648\n-2147483648 2147483647\n10 3\n7 -3\n0 1\n1 5\n",
          "output": "2147483647\n-2147483648\n1\n-1\n3\n-2\n0\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Hard Division",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an array <i>A </i>of binary strings, of size <i>N,</i> and two integers <i>x</i> and <i>y</i>.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Return <i>the size of the largest subset of A such that there are <strong>at most</strong> x </i>0<i>'s and y </i>1<i>'s in the subset</i>.</span></p><p><span style=\"background-color:transparent;color:#000000;\">A set x is a <strong>subset</strong> of a set y if all elements of x are also elements of y.</span></p>",
      "complete_approach": "",
      "constraints": "<p><i>1 ≤ N ≤ 100</i></p><p><i>1 ≤ x,y ≤ 100</i></p><p><i>1 ≤ length of binary string A[i] ≤ 200</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint findMaxSubset(vector<string> &v, int x, int y)\n{\n    // dp[i][j] will store Max subset size possible with zeros_limit = i, ones_limit = j\n    vector<vector<int>> dp(x + 1, vector<int>(y + 1, 0));\n    for (auto &str : v)\n    {\n        int zeros = count(begin(str), end(str), '0'), ones = str.size() - zeros;\n        for (int i = x; i >= zeros; i--)\n        {\n            for (int j = y; j >= ones; j--)\n            {\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[x][y];\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, x, y;\n    cin >> n >> x >> y;\n    vector<string> v(n);\n    for (auto &i : v)\n    {\n        cin >> i;\n    }\n    cout << findMaxSubset(v, x, y) << '\\n';\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing"
        ],
        "last_updated": "2024-06-22T02:37:09.631195+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Can you think of Dynamic Programming? Consider the state dp[i][j] represents the max number of elements in the set with i zeros and j ones. Think of transition similar to 0-1 knapsack problem.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">This problem is similar to the 0-1 knapsack problem, the only difference being that there are two constraints instead of one in this one. We can maintain a 2d dp array, where <i>dp[i][j]</i> will maintain the optimal solution when limit on zeroes is i and limit on ones is j.</span><br><span style=\"background-color:transparent;color:#000000;\">For each string, some number of 0s and 1s are required. Obviously, if our balance of zeros and ones is less than what is required by the current string, we can't choose it. But in the case where our balance of <i>zeros</i> and <i>ones</i> is greater than the required, we have two cases -</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">Either take the current string into our subset. The resultant count would be 1 + optimal solution that we had when our balance was i - zeros &amp; j - ones.</span></li><li><span style=\"background-color:transparent;color:#000000;\">Or leave the current string meaning the resultant count will remain the same.</span></li></ol><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity - <i>O(n*m*k)</i></span><br><span style=\"background-color:transparent;color:#000000;\">Time Complexity - <i>O(n*m)</i></span></p>"
      },
      "id": 642,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains 3 integers <i>N, x, </i>and <i>y.</i></span><br><span style=\"background-color:transparent;color:#000000;\"><i>N</i> lines follow each containing a binary string.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>In the first test case, the largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.<br>In the second test case, the largest subset is {\"0\", \"1\"}, so the answer is 2.</p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the maximum possible size of the subset.</span></p>",
      "samples": [
        {
          "input": "5 5 3\n10\n0001\n111001\n1\n0",
          "output": "4"
        },
        {
          "input": "3 1 1\n10\n0\n1",
          "output": "2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint findMaxSubset(vector<string> &v, int x, int y)\n{\n    //Complete the function\n}\n<fix>\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, x, y;\n    cin >> n >> x >> y;\n    vector<string> v(n);\n    for (auto &i : v)\n    {\n        cin >> i;\n    }\n    cout << findMaxSubset(v, x, y) << '\\n';\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "ONEZERO",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string of length $n$, your task is to determine the longest palindromic substring of the string. For example, the longest palindrome in *\"algoazzaa\"* is *\"azza\"*.\nIf there are multiple longest palindromic substrings, Output the one which comes first in the string.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^{4}$\n$1 \\leq n \\leq 10^{5}$\n\nSum of $n$ across all test cases is $\\leq$ $10^{6}$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\n\nclass Solution3 { // O(N) using manacher algorithm.\npublic:\n    vector<int> manacher(string s) { // gives 2n-1 size manacher array. (a#c#...#d )\n        string s1 = \"@\"; for (auto c : s) s1 += c, s1 += \"#\";\n        s1.back() = '&';\n        vector<int> ans(s1.size() - 1); int lo = 0, hi = 0;\n        for (int i = 1; i <= s1.size() - 2; i++) {\n            if (i != 1) ans[i] = min(hi - i, ans[hi - i + lo]);\n            while (s1[i - ans[i] - 1] == s1[i + ans[i] + 1]) ans[i] ++;\n            if (i + ans[i] > hi) lo = i - ans[i], hi = i + ans[i];\n        }\n        ans.erase(begin(ans));\n        for (int i = 0; i <= ans.size() - 1; i++) if ((i & 1) == (ans[i] & 1)) ans[i] ++;\n        return ans;\n    }\n    string getLPS(string s) { // gives one of the long. palindromic substr.\n        auto a = manacher(s);\n        auto it = max_element(a.begin(), a.end());\n        int l = *it, p;\n        for (int i = 0; i < a.size(); i++) {\n            if (a[i] == l) {\n                p = i;\n                break;\n            }\n        }\n        return s.substr((p + 1) / 2 - l / 2, l);\n    }\n};\n\nvoid solve() {\n    string s;\n    cin >> s;\n    Solution3 s3;\n    auto ans3 = s3.getLPS(s);\n    cout << ans3 << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:41:34.182215+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">For each position 0 &lt;= i &lt; N, you can find the palindromic substring length considering i as the center. For even length substrings, you can take i and i+1 to be the centers. But this would take O(N^2), can you reduce it to O(N).</span></p>",
        "hint2": "",
        "solution_approach": "**Intuition:** We can solve this question in 3 ways that come at first glance:\n-   Use Brute Force : Check for every corresponding element in string the longest palindrome possible and do it till the end.\n-   DP: Since we are essentially looping over every element in Brute Force, maybe we can somehow use the result from our previous iteration to simplify the current one? This gives us a nudge to look for a pattern and hence we go for DP.\n- Expand through the center for even and odd length palindromes.\n- Manacher Algorithm.\n\n**Analysis:**\nLet's see all the approaches one by one !!!\n\n1.  **Brute Force:** Instead of directly going to code and finding a problem later, lets stop and think about the concept we intend to use here  \n**Concept:** We will go through all possible elements in string and find the longest palindrome amongst them.\n**Review:** To calculate all the possible substrings in a string of length n, the number of combinations generated are:\n1+2+3+4+..........n=n(n-1)/2. To check all the substrings for Palindrome, we will have to go through all the n characters.\n Total Combinations: n*n(n-1)/2= O(n^3)\n**Conclusion:** Since the time complexity is O(n^3), hence we will not discuss this approach, and our energy would be better spent looking at the DP solution.\n\n2.  **DP** : if we know string \"aba\" is palindrome then \"cabac\" must be palindrome as left and right are equal.\n**State :** P(i,j) - True if substring(i,j) is a palindrome\n**Transition:** P(i, j) == P(i+1, j-1) && s[i] == s[j];\n**Base cases** :\nP(i, i) = true;  //One character\nP(i, i+1) = s[i] == s[i+1];  //Two character\n**Time Complexity** - O(N^2), Space Complexity - O(N^2) (caching all substring)\n3. **Expand Around Center** : Time: O(n^2), Space: O(1)\nLoop through the input string with i then inner loop through a section of that string with j\nYou now have two pointers left and right (i, j) respectively\nSince we start with 2 letters, for them to be a palindrome they have to be the same, so while that is the case, we'll keep expanding our window till they're no longer a palindrome\nMax will be the longest palindrome so if the current palindrome length is greater than our previous palindrome length we'll update the max\nWe'll do this till we're done looping through the string for both odd and even length palindromes, then return max.\n3. **Manacher Algorithm:** it can be solved in O(N), Refer to Manacher Video( AZ201 String Algo Module ) for the details.\nRefer to : https://cp-algorithms.com/string/manacher.html\nOnly Manacher Algorithm based $O(N)$ solution will pass the all test cases for this problem."
      },
      "id": 337,
      "input_format": "The first line contains $T$ - the number of test cases.\nThe first line of each test case contains a string of length $n$. Each character is one of *a–z*.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, Output the Longest Palindromic Substring.\nIf there are multiple longest palindromic substrings, Output the one which comes first in the string.",
      "samples": [
        {
          "input": "9\nalgoazzaa\naaaaaaaaaa\nababababab\nihpohpzoffel\nflexflexvpqxierullgcfckjqflexflex\nobsession\nabcxcbaxcba\nzzabc\naaccaabbaaccaaccaabbaaccaa\n",
          "output": "azza\naaaaaaaaaa\nababababa\nff\ncfc\nses\nabcxcba\nzz\naaccaabbaaccaaccaabbaaccaa\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Longest Palindromic Substring - Hard Version",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an unsorted array <strong>nums</strong> consisting of <strong>n </strong>integers. A beautiful sequence is a sequence of integers that consist of consecutive integers.</span><br><span style=\"background-color:transparent;color:#000000;\">For example,</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">5 6 9 7 8 10 - is a beautiful sequence because it contains consecutive integers.</span></li><li><span style=\"background-color:transparent;color:#000000;\">1 1 2 3 - is not a beautiful sequence because 1 appears twice.</span></li></ol><p><span style=\"background-color:transparent;color:#000000;\">You need to find the maximum length of a beautiful sequence that can be made using the elements of <strong>nums</strong>.</span><br><span style=\"background-color:transparent;color:#000000;\">Try to solve the problem in O(n) time complexity.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1 &lt;= n &lt;= 100000</span></p><p><span style=\"background-color:transparent;color:#000000;\">-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint LongestConsecutive(vector <int>& nums) {\n\tint n = nums.size();\n\tunordered_map <int, int> freq;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfreq[nums[i]]++;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (freq[nums[i] - 1] == 0) {\n\t\t\tint cur = nums[i];\n\t\t\tint len = 1;\n\t\t\twhile (freq[cur + 1] > 0) {\n\t\t\t\tlen++;\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\tans = max(ans, len);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() \n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint n;\n\tcin >> n;\n\tvector <int> nums(n);\n\tfor (auto &i : nums)\n\t\tcin >> i;\n\tcout << LongestConsecutive(nums);\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:25:07.296496+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">If x is the start of the maximum length beautiful sequence, x-1 must be absent in the array <strong>nums</strong>.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">We can iterate on the array and find the maximum length beautiful sequence for all the starting points (numbers that follow the above condition).</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">To solve this problem in O(n) time complexity we can use <strong>std:: unorderer_map </strong>(HashMap) in C++ to store the frequency of each number.</span><br><span style=\"background-color:transparent;color:#000000;\">We iterate on the elements present in the array. If the current element is <strong>x</strong> and <strong>x-1</strong> is present in the array, it is never optimal to choose this element as the start of a beautiful sequence as we can include the previous number to increase the length of the sequence.</span><br><span style=\"background-color:transparent;color:#000000;\">If <strong>x-1</strong> is not present in the array, this number is the start of a beautiful sequence. We keep increasing <strong>x </strong>by one till <strong>x+1</strong> is present in the array. The length of the sequence obtained is the maximum possible length a beautiful sequence can have consisting of these elements. We take the maximum of the lengths of all these sequences and return the answer.</span></p>"
      },
      "id": 613,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">Implement the <strong>LongestConsecutive</strong> function that takes the array <strong>nums</strong>.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">-1 -2 -3 -4 -5</span><br><span style=\"background-color:transparent;color:#000000;\">Is the maximum length beautiful sequence that can be obtained.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Return the maximum length of a beautiful sequence that can be made using the elements of <strong>nums</strong>.</span></p>",
      "samples": [
        {
          "input": "6\n-5 1 -3 -2 -1 -4",
          "output": "5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint LongestConsecutive(vector <int>& nums) {\n\t\n}\n\n<fix>\nint main() \n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint n;\n\tcin >> n;\n\tvector <int> nums(n);\n\tfor (auto &i : nums)\n\t\tcin >> i;\n\tcout << LongestConsecutive(nums);\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Longest Consecutive Sequence",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$ and two arrays $A$, $B$ of $N$ numbers. Determine if $B$ is a $ \\textbf{permutation} $ of $ \\textbf{A} $ or $ \\textbf{not} $.\n$ \\textbf{Note:} $ A $ \\textbf{permutation} $ is an arrangement of all or part of a set of objects.\n\n$ \\textbf{For example:} $ The array $ \\textbf{[2, 1, 3], [3, 2, 1]} $ and $ \\textbf{[2, 3, 1]} $ are $ \\textbf{permutation} $ of the array $ \\textbf{[1, 2, 3]} $.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N \\leq 3*10^5 $ \n$ 1 \\leq A[i] \\leq 10^7 $\n$ 1 \\leq B[i] \\leq 10^7 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        int A[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> A[i];\n        }\n        bool perm = true;\n        int B[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> B[i];\n        }\n        sort(A, A+n);\n        sort(B, B+n);\n        bool isPerm = true;\n        for (int i = 0; i<n; i++) {\n            if (A[i] != B[i]) {\n                isPerm = false;\n                break;\n            }\n        }\n        if (isPerm) {\n            cout << \"yes\\n\";\n        } else {\n            cout << \"no\\n\";\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:39:18.226001+00:00"
      },
      "hints": {
        "hint1": "Can we make the order of elements in both the arrays same?",
        "hint2": "Think of sorting both the arrays.",
        "solution_approach": "Sort both the arrays. Compare element by element, if there is a mismatch, then B is not a permutation of A.\nOtherwise of both the arrays are same, then B is a permutation of A.\nTime Complexity: $O(n)$"
      },
      "id": 1146,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains an integer $ N $, the number of elements in the array $A$ and $B$. The second line contains $N$ space separated integers each denoting an element of the array $A$. The third line contains $N$ space separated integers each denoting an element of the array $B$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print $ \\textbf{\"yes\"} $ if array $\\textbf{B}$ is a permutation of $\\textbf{A}$ otherwise, print $ \\textbf{\"no\"} $ without quotations.",
      "samples": [
        {
          "input": "1\n4\n4 2 3 7\n2 3 4 9\n",
          "output": "no\n"
        },
        {
          "input": "2\n4\n4 2 3 7\n2 3 4 9\n5\n5 1 1 9 3\n1 9 1 5 3\n",
          "output": "no\nyes\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Permutation With Arrays",
      "video_editorial_id": 10677
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "A transformation sequence from word $src$ to word $target$ using a dictionary $wordList$ is a sequence of words $src \\rightarrow s_1 \\rightarrow s_2 \\rightarrow ... \\rightarrow target$ such that:\n\n- Every adjacent pair of words differs by a single letter.\n- Every $s_i$ for $1 \\leq i \\leq n$ is in $wordList$. Note that $src$ does not need to be in $wordList$.\n\nGiven two words, $src$ and $target$, and a dictionary $wordList$, Output the number of the shortest transformation sequences, followed by all the shortest transformation sequences from $src$ to $target$, transformation sequences must be lexicographically sorted relatively, or Output 0 if no such sequence exists. \n\nEach sequence should be output as a sequence of the words $[src, s1, s2, ..., target]$, sequences must be **relatively lexicographically sorted**.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$\n$1 \\leq n \\leq 10^4$\n$1 \\leq |src|==|target|==|wordList[i]| \\leq 5$\n$src$, $target$ and $wordList[i]$ consist of lowercase English letters.\n$src \\neq target$. \nAll the words in $wordList$ are unique.\nThe Sum of $n$ over all test cases is $\\leq 10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvector<vector<string>> findLadders(string src, string tar, vector<string>& wordList) {\n\tqueue<vector<string>> q;\n\tvector<vector<string>> ans;\n\tunordered_set<string> st(wordList.begin(), wordList.end()), visited;\n\tq.push({src});\n\tst.erase(src);\n\tint mn_lvl = 1e9, f = 1;\n\twhile (!q.empty() && f) {\n\t\tint sz = q.size();\n\t\twhile (sz--) {\n\t\t\tauto path = q.front();\n\t\t\tq.pop();\n\t\t\tif (path.size() >= mn_lvl) { // optimisation.\n\t\t\t\tf = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstring last = path.back();\n\t\t\tfor (auto i = 0; i < last.size(); i++) {\n\t\t\t\tfor (auto c = 'a'; c <= 'z'; c++ ) {\n\t\t\t\t\tstring news = last;\n\t\t\t\t\tnews[i] = c;\n\t\t\t\t\tif (st.find(news) != st.end()) {\n\t\t\t\t\t\tvisited.insert(news);\n\t\t\t\t\t\tvector<string> new_path = path;\n\t\t\t\t\t\tnew_path.push_back(news);\n\t\t\t\t\t\tif (news == tar)ans.push_back(new_path), mn_lvl = new_path.size();\n\t\t\t\t\t\telse q.push(new_path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto x : visited)st.erase(x);\n\t\tvisited.clear();\n\t}\n\tsort(ans.begin(), ans.end());\n\treturn ans;\n}\nvoid solve() {\n\tstring a, b;\n\tint n;\n\tcin >> a >> b;\n\tcin >> n;\n\tvector<string> s(n);\n\tfor (int i = 0; i < n; i++)cin >> s[i];\n\tauto ans = findLadders(a, b, s);\n\tsort(ans.begin(), ans.end());\n\tcout << ans.size() << endl;\n\tfor (auto v : ans) {\n\t\tfor (auto s : v)cout << s << \" \";\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:44:22.852179+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "The requirement of this question is to output all the shortest paths, which means if we find one path using the BFS, then all the other shortest paths must also be in this level, so the search will stop once this level ends.\n\nWe need to output the exact path, so we need one way to store the paths.\n\nFor each word in the BFS queue, we still need to use the previous way to generate the valid words in the ducts (from 1st to last, change every char from 'a' to 'z' ).\n\nDuplicates are permitted within a level. e.g.,\n      $hem -> hex -> tex -> ted$\n      $hem->  tem -> tex -> ted$,  are all valid paths.\n      Draw this into a tree structure:\n```\n                        hem\n                       /  \\\n                    hex   tem\n                      \\   /\n                       tex    \n                        |     \n                       ted    \n```     \nA solution is to erase all the words in the previous level, instead of erasing words for each word in the level.\n\nWe want to prove that in the shortest path from source to target, one word will never be used twice.\nLet us consider a path which we claim to be the shortest path with duplicate words. Let that path be \"$start$, $a_2$ ,... $a_p$ ,$a_{p+1}$,......,$a_q$,$a_{q+1}$....$end$\".\nHere $a_p = a_q$ and $p < q$. It is easy to see we can cut the part of the path $a_{q+1}$....$end$ and paste it after $a_p$ which will cause a reduction of length $(q-p)$. Since $q-p$ is at least $1$, we have a shorter path than what we started. Thus our hypothesis is incorrect and we can never have the shortest path with duplicate words.\nNow let us extend this argument to multiple paths.\nLet us have a path that $p$ that uses word $w$ at level $l_2$ which was used at level $l_1$ by path $q$. let $l_2$ > $l_1$. By the above argument, $p$ can never be the shortest path because we would get a shorter path by extending $q$ from $w$.\n\n\nThis problem can be solved with a very standard BFS process, The only tricky thing you need to remember is this is a BFS of paths, not words!, So the element in the queue is a vector that represents the current path from $src$ word. That's it.\n\nIn BFS, The next level words are generated from the current level. During the generation of valid words, the path can be stored at the same time. When the next level words are all generated, if the end string is included, we can output the paths, otherwise, we can erase the words in the current level, and search for the next level. This erasing step is helping reduce the dict, and eliminate the case that a cycle exists in the path as we are going level by level. The dict and BFS queue can contain a max of $10^4$ words.\nWe can stop BFS once we reached the target word and the current level becomes more than the minimum level.\nRefer to the editorial's code for more details.\n\nTime Complexity : Approx. Worst $O(n*26*5)$ per test case."
      },
      "id": 997,
      "input_format": "The First line contains $T$ - the number of test cases.\nThe first line of each test case contains the word $src$.\nThe second line of each test case contains the word $target$.\nThe third line of each test case contains $n$ - the size of the $wordList$.\nNext $n$ lines contains $n$ words of the $wordList$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the number of the shortest transformation sequences, followed by all the shortest transformation sequences from $src$ to $target$, transformation sequences must be lexicographically sorted relatively, or Output $0$ if no such sequence exists.\n\nEach sequence should be output as a sequence of the words $[src, s1, s2, ..., target]$, sequences must be **relatively lexicographically sorted**.\n\nAlso, print a new line after every test case.",
      "samples": [
        {
          "input": "3\n\nlol\nuwu\n7\nlou\nlwl\nuwl\nlwu\nuou\nuol\nuwu\n\nhit\ncog\n6\nhot \ndot \ndog \nlot \nlog \ncog\n\nhit\ncog\n5\nhot \ndot \ndog \nlot \nlog \n",
          "output": "6\nlol lou lwu uwu \nlol lou uou uwu \nlol lwl lwu uwu \nlol lwl uwl uwu \nlol uol uou uwu \nlol uol uwl uwu \n\n2\nhit hot dot dog cog \nhit hot lot log cog \n\n0\n\n\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Shortest Transformation Sequences",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given an array A of n integers. You can perform as many swap operations as you want. In a swap operation you can swap the elements at any two positions.&nbsp;</p><p>Define score as number of indices i such that after all the operations, A<sub>i</sub> is different from the original value of A<sub>i</sub>. Print the maximum score possible.</p>",
      "complete_approach": "",
      "constraints": "<p>T ≤ 10</p><p>1 ≤ n ≤ 10<sup>5</sup></p><p>1 ≤ A<sub>i</sub> ≤ 10<sup>6</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int t, i, j;\n\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin>>n;\n        map<int,int> cnt;\n        for(i=0;i<n;i++)\n        {\n            int num;\n            cin>>num;\n            cnt[num]++;\n        }\n\n        int mxCnt=0;\n        for(auto z:cnt) mxCnt=max(mxCnt,z.second);\n\n        if(mxCnt>= (n+1)/2)\n        {\n            int remain_same = mxCnt - (n-mxCnt);\n            cout<< n-remain_same<<'\\n';\n        }\n        else cout<< n << \"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:17.953956+00:00"
      },
      "hints": {
        "hint1": "If the original array is A and the new array is B, we want to maximise the values of i such that A[i] ≠ B[i]. This hints us about making a frequency map.",
        "hint2": "Try to use the strategy to merge 2 elements from the highest 2 frequencies available at each step. Of course, this will TLE if you simulate. You need to observe when will this be able to finish all, or when is not possible.",
        "solution_approach": "Let the maximum frequency be x and the sum of frequencies of all other elements be y = n-x. If we have x ≥ y, here we can swap y pair of numbers to get the answer as 2*y. Otherwise, it would always be possible to swap numbers such that no position will have the original number, and the answer would be n."
      },
      "id": 242,
      "input_format": "<p>First line of input contains T, number of test cases.</p><p>First line of each test case contains n.</p><p>Second line contains n integers, i<sup>th </sup>integer is A<sub>i </sub>.</p><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each testcase print the maximum score possible in a new line.</p>",
      "samples": [
        {
          "input": "1\n3\n1 2 3",
          "output": "3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Dearrange",
      "video_editorial_id": 8175
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "A subsequence is a string that can be derived from another string by deleting some or no symbols without changing the order of the remaining symbols. Characters to be deleted are not required to go successively, there can be any gaps between them. For example, for the string \"abaca\" the following strings are subsequences: \"abaca\", \"aba\", \"aaa\", \"a\" and \"\" (empty string). But the following strings are not subsequences: \"aabaca\", \"cb\" and \"bcaa\".\n\nYou are given a string $s$ consisting of $n$ lowercase Latin letters.\n\nIn one move you can take any subsequence $t$ of the given string and add it to the set $S$. The set $S$ can't contain duplicates. This move costs $n−|t|$, where $|t|$ is the length of the added subsequence (i.e. the price equals to the number of the deleted characters).\n\nYour task is to find out the minimum possible total cost to obtain a set $S$ of size $k$ or report that it is impossible to do so.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$\n$1 \\leq n \\leq 100$\n$1 \\leq k \\leq 10^{12}$",
      "editorial_code": [
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstring s;\nll n, k;\nll dp[101][101][26];\nll rec(int i, int l, int c) {\n    if (l < 0)return 0;\n\n    if (i == -1) {\n        if (l == 0)return 1;\n        return 0;\n    }\n    auto &ans = dp[i][l][c];\n    if (ans != -1)return ans;\n    ans = 0;\n    if (s[i] - 'a' == c) {\n        if (l == 1) { // only single character c.\n            ans = 1;\n        }\n        else {\n            for (int j = 0; j < 26; j++) {\n                ans += rec(i - 1, l - 1, j);\n                ans = min(ans, k);\n            }\n        }\n    }\n    else ans = rec(i - 1, l , c);\n    ans = min(ans, k);\n    return ans;\n}\nvoid solve() {\n    cin >> n >> k;\n    cin >> s;\n    memset(dp, -1, sizeof(dp));\n    ll ans = 0;\n    for (int i = n; i >= 1 && k; i--) {\n        for (int j = 0; j < 26 && k; j++) {\n            if (k >= rec(n - 1, i, j)) {\n                k -= rec(n - 1, i, j);\n                ans += rec(n - 1, i, j) * (n - i);\n            }\n            else {\n                ans += k * (n - i);\n                k = 0;\n                break;\n            }\n        }\n    }\n    if (k == 1) {\n        ans += n;\n    }\n    else if (k > 1)ans = -1;\n    cout << ans << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```\n\n\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e12;\n\nint main() {\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        long long k;\n        cin >> n >> k;\n        --k; // the whole string costs nothing\n        string s;\n        cin >> s;\n\n        vector<vector<int>> lst(n, vector<int>(26, -1));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < 26; ++j) {\n                if (i > 0) lst[i][j] = lst[i - 1][j];\n            }\n            lst[i][s[i] - 'a'] = i;\n        }\n\n        vector<vector<long long>> dp(n + 1, vector<long long>(n + 1));\n        for (int i = 0; i < n; ++i) {\n            dp[i][1] = 1;\n        }\n\n        for (int len = 2; len < n; ++len) {\n            for (int i = 1; i < n; ++i) {\n                for (int j = 0; j < 26; ++j) {\n                    if (lst[i - 1][j] != -1) {\n                        dp[i][len] = min(INF64, dp[i][len] + dp[lst[i - 1][j]][len - 1]);\n                    }\n                }\n            }\n        }\n\n        long long ans = 0;\n        for (int len = n - 1; len >= 1; --len) {\n            long long cnt = 0;\n            for (int j = 0; j < 26; ++j) {\n                if (lst[n - 1][j] != -1) {\n                    cnt += dp[lst[n - 1][j]][len];\n                }\n            }\n            if (cnt >= k) {\n                ans += k * (n - len);\n                k = 0;\n                break;\n            } else {\n                ans += cnt * (n - len);\n                k -= cnt;\n            }\n        }\n\n        if (k == 1) {\n            ans += n;\n            --k;\n        }\n\n        if (k > 0) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:27:29.456554+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Firstly, let's calculate the following auxiliary matrix: $lst_{i,j}$ means the maximum position $pos$ that is less than or equal to $i$, and the character $s_{pos}=j$ (in order from $0$ to $25$, $'a' = 0$, $'b' = 1$, and so on). It can be calculated naively.\n\nAfter calculating this matrix we can solve the problem by the following dynamic programming: let $dp_{i,j}$ be the number of subsequences of length $j$ that ends exactly in the position $i$. Initially all values are zeros except $dp_{i,1}=1$ for each $i$ from $0$ to $n−1$.\n\nHow do we perform transitionss? Let's iterate over all lengths $j$ from $2$ to $n$, then let's iterate over all positions $i$ from $1$ to $n−1$ in a nested loop, and for the current state $dp_{i,j}$ we can calculate it as $\\Sigma_{c=0}^{25}dp_{lst_{i−1,c},j−1}$. If $lst_{i−1,c}=−1$ then we don't need to add this state of the dynamic programming to the current state. Don't forget to take the minimum with $10^{12}$ after each transition!\n\nThis transition means that we take all subsequences that end with each possible character of the alphabet and try to add the current character to each of them. You can understand that there are no overlapping subsequences in this dynamic programming.\n\nAfter that let's iterate over all possible lengths $j$ from $n$ to $1$ and calculate the number of subsequences of the current length $j$. It equals to $cnt=\\Sigma_{c=0}^{25}dp_{lst_{n−1,c},j}$. The same, if $lst_{n−1,c}=−1$ then we don't need to add this state of the dynamic programming to $cnt$. Don't forget to take the minimum with $10^{12}$! If $cnt ≥ k$ then let's add $k*(n−len)$ to the answer and break the cycle. Otherwise let's add $cnt*(n−len)$ to the answer and decrease $k$ by $cnt$.\n\nIf after all iterations $k$ is greater than zero then let's try to add the empty string to the answer (we didn't take it into account earlier). Increase the answer by $n$ and decrease $k$ by one. If after this $k$ is still greater than zero then the answer is $-1$, otherwise the answer is the calculated sum.\n\n**Time complexity**: $O(26*n^{2})$ per test case."
      },
      "id": 916,
      "input_format": "First-line contains $T$ - the number of test cases.\nThe first line of each test case contains two integers $n$ and $k$  — the length of the string and the size of the set, correspondingly.\nThe second line of each test case contains a string $s$ consisting of $n$ lowercase Latin letters.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "In the first example we can generate $S$ = { \"asdf\", \"asd\", \"adf\", \"asf\", \"sdf\" }. The cost of the first element in $S$ is $0$ and the cost of the others is $1$. So the total cost of $S$ is $4$.",
      "output_format": "For each test case, Print one integer —:  \nif it is impossible to obtain the set $S$ of size $k$, print $-1$.\n Otherwise, print the minimum possible total cost to do it.",
      "samples": [
        {
          "input": "4\n4 5\nasdf\n10 100\najihiushda\n5 7\naaaaa\n5 6\naaaaa\n",
          "output": "4\n233\n-1\n15\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Distinct Subsequences III",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given Q queries and have to perform the following operations:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">add x - add element x at the end of queue</span></li><li><span style=\"background-color:transparent;color:#000000;\">remove- delete front element of the queue, if queue is not empty</span></li><li><span style=\"background-color:transparent;color:#000000;\">print - print the element at the first position, if queue is not empty, otherwise print 0</span></li></ol>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ Q ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ X ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of Q over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>6</sup></span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int q1;\n    cin >> q1;\n    queue<int> q;\n    while (q1--) {\n      string s;\n      cin >> s;\n      if (s == \"add\") {\n        int x;\n        cin >> x;\n        q.push(x);\n      } else if (s == \"remove\") {\n        if (!q.empty()) {\n          q.pop();\n        }\n      } else {\n        if (!q.empty()) {\n          cout << q.front() << \"\\n\";\n        } else {\n          cout << \"0\\n\";\n        }\n      }\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:26:51.505320+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Use `push()` for inserting element at end of queue\nUse `pop()` for deleting element at front of queue.Before popping make sure to check if the stack is empty or not using `empty()` function.\nUse `front()` for printing element at front of queue.Again check emptiness using `empty()` function\nTime Complexity per test case: $O(1)$"
      },
      "id": 349,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer Q - the number of queries.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Each of the next Q ines contains queries.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<ol><li><span style=\"background-color:transparent;color:#000000;\">Queue becomes [3]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Queue becomes [3, 4]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Element at front = 3</span></li><li><span style=\"background-color:transparent;color:#000000;\">Queue becomes [4]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Element at front = 4</span></li></ol>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the required queries.</span></p>",
      "samples": [
        {
          "input": "1\n5\nadd 3\nadd 4\nprint\nremove\nprint\n",
          "output": "3\n4\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Queue AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO ($\\text{First In First Out}$) principle and the last position is connected back to the first position to make a circle. It is also called \"Ring Buffer\".\n\nIn a normal Queue, we can insert elements until the queue becomes full. But once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue.\n\nImplement the following functions:\n\n1. **MyCircularQueue(k)**: Initializes the object with the size of the queue to be $k$.\n2. **int Front()**: Gets the front item from the queue. If the queue is empty, return $-1$.\n3. **int Rear()**: Gets the last item from the queue. If the queue is empty, return $-1$.\n4. **bool enQueue(int value)**: Inserts an element into the circular queue. Return `true` if the operation is successful.\n5. **bool deQueue()**: Deletes an element from the circular queue. Return `true` if the operation is successful.\n6. **bool isEmpty()**: Checks whether the circular queue is empty or not.\n7. **bool isFull()**: Checks whether the circular queue is full or not.\n\nInitially, the queue is empty.\n\nYou must solve the problem without using the built-in queue data structure in your programming language.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>k</i>, <i>Q</i> ≤ 10<sup>5</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass MyCircularQueue\n{\npublic:\n    struct ListNode\n    {\n        int val;\n        ListNode *next, *back;\n        ListNode() : val(0), next(nullptr), back(nullptr) {}\n        ListNode(int x) : val(x), next(nullptr), back(nullptr) {}\n        ListNode(int x, ListNode *next, ListNode *back) : val(x), next(next), back(back) {}\n    };\n\n    ListNode *head;\n    int K;\n    int curSize;\n\n    MyCircularQueue(int k)\n    {\n        head = nullptr;\n        K = k;\n        curSize = 0;\n    }\n\n    bool enQueue(int value)\n    {\n        if (curSize == K)\n            return false;\n\n        ListNode *newNode = new ListNode(value);\n\n        if (!curSize)\n        {\n            head = newNode;\n            head->next = head;\n            head->back = head;\n        }\n        else\n        {\n            ListNode *tail = head->next;\n            tail->back = newNode;\n            newNode->next = tail;\n            newNode->back = head;\n            head->next = newNode;\n        }\n\n        curSize++;\n\n        return true;\n    }\n\n    bool deQueue()\n    {\n        if (!curSize)\n            return false;\n\n        if (curSize == 1)\n        {\n            delete (head);\n            head = nullptr;\n        }\n        else\n        {\n            ListNode *tail = head->next;\n            head = head->back;\n            delete (head->next);\n            head->next = tail;\n            tail->back = head;\n        }\n\n        curSize--;\n        return true;\n    }\n\n    int Front()\n    {\n        if (head)\n            return head->val;\n        return -1;\n    }\n\n    int Rear()\n    {\n        if (head)\n            return head->next->val;\n        return -1;\n    }\n\n    bool isEmpty()\n    {\n        return !curSize;\n    }\n\n    bool isFull()\n    {\n        return (curSize == K);\n    }\n};\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int q;\n    cin >> q;\n\n    int k;\n    cin >> k;\n\n    MyCircularQueue myCircularQueue(k);\n\n    while (q--)\n    {\n        string s;\n        cin >> s;\n\n        if (s == \"enQueue\")\n        {\n            int val;\n            cin >> val;\n\n            if (myCircularQueue.enQueue(val))\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"deQueue\")\n        {\n            if (myCircularQueue.deQueue())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"Front\")\n        {\n            cout << myCircularQueue.Front() << \"\\n\";\n        }\n        else if (s == \"Rear\")\n        {\n            cout << myCircularQueue.Rear() << \"\\n\";\n        }\n        else if (s == \"isEmpty\")\n        {\n            if (myCircularQueue.isEmpty())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"isFull\")\n        {\n            if (myCircularQueue.isFull())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else\n        {\n            assert(1 == 0); //This never happen\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:44:15.606218+00:00"
      },
      "hints": {
        "hint1": "If we use a singly linked list, then all operations, except **deQueue**, are $O(1)$. The **deQueue** operation will take $O(n)$, since we’re not storing any back information of the front node. \n\nHow can we make this operation also $O(1)$?\n",
        "hint2": "Yes, we can use a **doubly-linked list** to make all operations $O(1)$. \n\nBut can we achieve this using only **one pointer**?\n",
        "solution_approach": "We create a doubly linked list structure, like below:\n\n```cpp\nstruct ListNode\n{\n    int val;\n    ListNode *next, *back;\n    ListNode() : val(0), next(nullptr), back(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr), back(nullptr) {}\n    ListNode(int x, ListNode *next, ListNode *back) : val(x), next(next), back(back) {}\n};\n```\n\nWe maintain only one pointer `head`. The front and rear sides of the list are connected, and the list is arranged in a circular fashion.\n\n1. **enQueue()**:  \n   - Check if the queue is full or not.  \n   - Create a new node and attach it after the `head`.  \n   - Update the `back` and `next` pointers of the new node, `head`, and `head→next` (the rear node, because the list is circular).  \n   - Move the `head` to the new node.\n\n2. **deQueue()**:  \n   - Check if the queue is empty or not.  \n   - Remove the front node and travel to the new front using the `back` pointer.  \n   - Update the `next` and `back` pointers of `head` and `head→next`.\n\n3. **Front()**:  \n   - Check if the queue is empty or not.  \n   - Otherwise, `head` is the front node.\n\n4. **Rear()**:  \n   - Check if the queue is empty or not.  \n   - Otherwise, `head→next` is the rear node.\n"
      },
      "id": 543,
      "input_format": "<p>The first line of input contains <i>Q</i> - the number of queries.<br>The second line contains <i>k.</i><br>Each of the next lines contains queries of one of the types mentioned in the problem statement.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "9\n3\nenQueue 1\nenQueue 2\nenQueue 3\nenQueue 4\nRear\nisFull\ndeQueue\nenQueue 4\nRear",
          "output": "True\nTrue\nTrue\nFalse\n3\nTrue\nTrue\nTrue\n4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nclass MyCircularQueue\n{\npublic:\n    \n    MyCircularQueue(int k)\n    {\n        \n    }\n\n    bool enQueue(int value)\n    {\n        \n    }\n\n    bool deQueue()\n    {\n        \n    }\n\n    int Front()\n    {\n        \n    }\n\n    int Rear()\n    {\n        \n    }\n\n    bool isEmpty()\n    {\n        \n    }\n\n    bool isFull()\n    {\n        \n    }\n};\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int q;\n    cin >> q;\n\n    int k;\n    cin >> k;\n\n    MyCircularQueue myCircularQueue(k);\n\n    while (q--)\n    {\n        string s;\n        cin >> s;\n\n        if (s == \"enQueue\")\n        {\n            int val;\n            cin >> val;\n\n            if (myCircularQueue.enQueue(val))\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"deQueue\")\n        {\n            if (myCircularQueue.deQueue())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"Front\")\n        {\n            cout << myCircularQueue.Front() << \"\\n\";\n        }\n        else if (s == \"Rear\")\n        {\n            cout << myCircularQueue.Rear() << \"\\n\";\n        }\n        else if (s == \"isEmpty\")\n        {\n            if (myCircularQueue.isEmpty())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"isFull\")\n        {\n            if (myCircularQueue.isFull())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else\n        {\n            assert(1 == 0); //This never happen\n        }\n    }\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Circular Queue",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given two arrays A and B, both of size N. A pair is called good if i &lt; j and A<sub>i</sub> + A<sub>j</sub> &gt; B<sub>i</sub> + B<sub>j</sub>. Find the number of good pairs.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ N ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ A<sub>i</sub> ≤ 10<sup>9</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of N over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>6</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<ll> vl;\n\nvoid solve()\n{\n    ll i, j, n, cnt = 0;\n    cin >> n;\n    vl A(n), B(n), C(n);\n    for (i = 0; i < n; i++)\n    {\n        cin >> A[i];\n    }\n    for (i = 0; i < n; i++)\n    {\n        cin >> B[i];\n    }\n    for (i = 0; i < n; i++)\n    {\n        C[i] = A[i] - B[i];\n    }\n    // since addition is commutative just sort the elements of the array C\n    sort(C.begin(), C.end());\n    for (i = 0; i < n; i++)\n    {\n        if (C[i] <= 0)\n        {\n            // we want to find element Cj which is strictly greater than -Ci\n            // Cj>-Ci equivalent to finding a  Cj>=-Ci+1\n            if (lower_bound(C.begin(), C.end(), -C[i] + 1ll) - C.begin() != n)\n            {\n                cnt += n - (lower_bound(C.begin(), C.end(), -C[i] + 1ll) - C.begin());\n            }\n        }\n        else\n        {\n            cnt += n - (i + 1);\n        }\n    }\n    cout << cnt << endl;\n}\n\nint main()\n{\n    // #ifndef ONLINE_JUDGE\n    // freopen(\"input.txt\",\"r\",stdin);\n    // freopen(\"output.txt\",\"w\",stdout);\n    // #endif\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int i, T;\n\n    T = 1;\n    cin >> T;\n\n    for (i = 1; i <= T; i++)\n    {\n        solve();\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:28:52.895019+00:00"
      },
      "hints": {
        "hint1": "The given inequality is the same as: $(A_i - B_i) + (A_j - B_j) > 0$. Let $C_i = A_i - B_i$. You just need to find pairs such that $C_i + C_j > 0$.",
        "hint2": "Store all the values of Ai - Bi in a vector and sort it. A question that might arise is how we can allow ourselves to sort the vector since the constraint $i \\lt j$ is clearly mentioned in the problem. Sorting a vector results in the loss of information about the original indices of the elements, making it difficult to determine the original order of the elements.\n\n\nWhen we want to find pairs in a vector such that their sum is greater than $0$, we can use the fact that addition is a commutative operation, which means that the order in which we add the elements doesn't matter. For example, $2 + 3$ is the same as $3 + 2$.\n\nNow, let's say we have a vector $C$ and we want to find pairs $(i,j)$ such that $C_i + C_j > 0$. We can sort the vector in non-decreasing order, which means that the smallest element will be first and the largest element will be last. Once the vector is sorted, we can start with the smallest element and add it to the largest element. If the sum is greater than $0$, then we know that all pairs involving the largest element will satisfy the condition as well, because any pair with a smaller element than the largest element will have a sum that is even smaller than the sum we just computed.\n\nAt no point during this process do we need to worry about losing track of the original indices of the elements, because we can always interchange the indices of any two elements in a pair. For example, if we find a pair $(i,j)$ where $i > j$, we can simply swap $i$ and $j$ to get the pair $(j,i)$. This means that even if we sort the vector, we can still consider all possible pairs and find the ones that satisfy the condition $C_i + C_j > 0$.",
        "solution_approach": "Store all the values of $A_i - B_i$ in a vector and sort it. Since $C_j > -C_i$, you can use upper_bound for finding the value of such pairs.\n\nTime Complexity per test case: $O(N \\log N)$"
      },
      "id": 377,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer N - the length of the array.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">The second line of each test case contains N space-separated integers.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The third line of each test case contains N space-separated integers.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, following pairs satisfy the given inequality: (2+3) &gt; (2+1) and (3+5) &gt; (1+5)</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, following pairs satisfy the given inequality: (1+6) &gt; (2+3) and (4+6) &gt; (3+3)</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, following pairs satisfy the given inequality: (5+6) &gt; (1+9), (5+1) &gt; (1+2), (5+1) &gt; (1+4) and (5+2) &gt; (1+1)</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the number of good pairs.</span></p>",
      "samples": [
        {
          "input": "3\n4\n2 3 5 4\n2 1 5 6\n3\n1 4 6\n2 3 3\n5\n5 6 1 1 2\n1 9 2 4 1\n",
          "output": "2\n2\n4\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Good Pairs AZ101",
      "video_editorial_id": 8191
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>A number N is said to be D-Magic if digit D appears in the decimal representation of the number on only even positions. You have to tell the number of D-Magic numbers in the range A to B(both inclusive) that are multiple of M. Since the answer can be large, print the number of integers modulo 10<sup>9</sup> + 7.</p><p><strong>It is given that the number of digits in A and B is the same and A ≤ B.</strong></p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤ 5</p><p>1 ≤ M ≤ 2000</p><p>0 ≤ D ≤ 9</p><p>1 ≤ A ≤ B ≤ 10<sup>2000</sup></p>",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "Editorial Code data is currently empty."
        ],
        "last_updated": "2024-06-22T02:14:45.391644+00:00"
      },
      "hints": {
        "hint1": "Make a DP array, $DP[\\text{index}][\\text{sum}][\\text{smaller\\_already}]$ - the number of ways to choose digits so far such that the ‘sum’ tells if the number is divisible by $M$ (gives modulo $M$) and ‘smaller\\_already’ says whether we have already chosen some digits smaller than the corresponding digit in $K$.\n",
        "hint2": "You should not subtract $A$ by $1$. That would only make your implementation tougher.\n\nStress on the given condition that the number of digits in $A$ and $B$ is the same.\n",
        "solution_approach": "For each possible digit in the $i$-th position of the given number, the DP transition will be:\n\n$$\nDP[i][\\text{sum}][\\text{smaller}] += DP[i+1][(10 \\times \\text{sum} + \\text{digit}) \\% M][\\text{smaller} \\, || \\, (\\text{digit} < t)]\n$$\nwhere $t$ is the corresponding digit in $K$.\n\n**Time Complexity:** $O(N \\times M \\times 20)$ where $N$ is the number of digits in $A$ and $B$ (equal).\n"
      },
      "id": 302,
      "input_format": "<p>The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</p><p>The first line of each test case contains two space-separated integers M and D.</p><p>The second line of each test case contains one integer A.</p><p>The third line of each test case contains one integer B.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, the following are the 12 numbers between 10 and 90 which are 2-Magic Numbers: 14, 24, 34, 54, 64, 74, 84.\n\nFor the second test case, the following are the 7 numbers between 200 and 300 which are 9-Magic Numbers: 291, 294, 297.\n\nFor the third test case, there are no 1-Magic Numbers between 10 and 90.",
      "output_format": "<p>Print single integer denoting the number of D-Magic numbers in the range A to B(both inclusive) that are multiple of M, modulo 10<sup>9</sup> + 7.</p>",
      "samples": [
        {
          "input": "3\n2 4\n10\n90\n3 9\n200\n300\n2 1\n10 \n90",
          "output": "7\n3\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "D-Magic Number",
      "video_editorial_id": 10695
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Scientists have discovered a new solvent that has some unique properties. When atoms of different elements (with varying atomic weights) are introduced into the solvent, they form bonds with each other, resulting in the formation of a large crystal-like structure\nThe solvent seems to assign magnetic properties to the atoms, because of the way the atoms formed bonds: atoms with higher atomic weights were always pushed to the right, while the lower weight atoms were pushed to the left. An atom can bond with only one atom in the right direction, and one atom in the left direction. The atoms are introduced into the solvent one after the other gradually, and the bonding also happens in sequence.\nThe first atom remains stable in the solvent by itself and forms the center of the crystal. Once the second atom is introduced, it is pushed to the right (if its weight is more than the first atom) or to the left (if its weight is lesser) and a bond is formed between the two atoms. When the third atom is introduced, it tries to bond with the first element (the center of the crystal) and is pushed either to the right or the left (depending on its atomic weight). In case the second atom is already in that same direction, then the third atom cannot bond with the first atom, and so forms a bond with the second atom (and is pushed to the right or left of the second atom). All subsequent atoms also follow this pattern and keep bonding within the crystal and growing it.\nThe solvent also causes the crystal to be *' self-balancing'* i.e. if it grows too much in one direction (say right), it immediately reorients itself such that proper balance is maintained. If the absolute size difference between the right and left directions for any atom becomes larger than 1 , then a rebalancing occurs at that stage, to bring down the absolute difference to 0 or 1 . Rebalancing always happens at the smallest size possible i.e. if there is an imbalance in one corner of the crystal, only that part is rebalanced to restore balance. Rebalancing happens by rotation either in the clockwise or anti-clockwise directions. \n\nFor more clarity, see the examples below to understand how rebalancing works.\n\nGiven the sequence of introduction of atoms into the solvent, write a program to determine the final stable structure of the crystal.\n\nRead the input from STDIN and print the output to STDOUT. Do not write arbitrary strings anywhere in the program, as these contribute to the standard output and test cases will fail.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^4$\n$1 \\leq n \\leq 10^5$ - Number of atoms. \n$1 \\leq w \\leq 10^6$ - Atomic Weight.\n\n- Atomic weights are unique.\n- Sum of $n$ across all test cases is $\\leq 10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstruct Node {\npublic:\n    int64_t key;\n    Node *left;\n    Node *right;\n    int depth;\n    Node(int64_t x) {\n        this->key = x;\n        this->left = nullptr;\n        this->right = nullptr;\n        this->depth = 1; // initially set to 1.\n    }\n};\nclass AVLTree { // For Balanced BST\npublic:\n\n    // Node *root;\n    // A utility function to get the depth of the tree\n    int depth(Node *v) {\n        if (v == nullptr)return 0;\n        return v->depth;\n    }\n\n    // A utility function to right rotate subtree rooted with y.\n    Node *rightRotate(Node *y) {\n        Node *x = y->left;\n        Node *T2 = x->right;\n\n        // Perform rotation\n        x->right = y;\n        y->left = T2;\n\n        // Update depths\n        y->depth = max(depth(y->left), depth(y->right)) + 1;\n        x->depth = max(depth(x->left), depth(x->right)) + 1;\n\n        // Return new root\n        return x;\n    }\n\n    // A utility function to left rotate subtree rooted with x\n    Node *leftRotate(Node *x) {\n        Node *y = x->right;\n        Node *T2 = y->left;\n\n        // Perform rotation\n        y->left = x;\n        x->right = T2;\n\n        // Update depths\n        x->depth = max(depth(x->left), depth(x->right)) + 1;\n        y->depth = max(depth(y->left), depth(y->right)) + 1;\n\n        // Return new root\n        return y;\n    }\n\n    // Get Balance factor of node v\n    int getBalance(Node *v) {\n        if (v == nullptr)return 0;\n        return depth(v->left) - depth(v->right);\n    }\n\n    // Recursive function to insert a key in the subtree rooted with node and returns the new root of the subtree.\n    Node *insert(Node *v, int key) {\n        /* 1. Perform the normal BST insertion */\n        if (v == nullptr)return (new Node(key));\n\n        if (key < v->key)v->left = insert(v->left, key);\n        else if (key > v->key)v->right = insert(v->right, key);\n        else return v; // Equal keys are not allowed in BST\n\n        /* 2. Update depth of this ancestor v */\n        v->depth = 1 + max(depth(v->left), depth(v->right));\n\n        /* 3. Get the balance factor of this ancestor\n            v to check whether this v became\n            unbalanced */\n        int balance = getBalance(v);\n\n        // If this v becomes unbalanced, then\n        // there are 4 cases\n\n        // Left Left Case\n        if (balance > 1 && key < v->left->key)return rightRotate(v);\n\n        // Right Right Case\n        if (balance < -1 && key > v->right->key)return leftRotate(v);\n\n        // Left Right Case\n        if (balance > 1 && key > v->left->key) {\n            v->left = leftRotate(v->left);\n            return rightRotate(v);\n        }\n\n        // Right Left Case\n        if (balance < -1 && key < v->right->key) {\n            v->right = rightRotate(v->right);\n            return leftRotate(v);\n        }\n        /* return the (unchanged) v pointer */\n        return v;\n    }\n    void dfs(Node* root) {\n        if (root == nullptr)return;\n        cout << root->key << \" \";\n        dfs(root->left);\n        dfs(root->right);\n    }\n};\n\n\nvoid solve() {\n    AVLTree tr;\n    int x = 1;\n    Node * root = nullptr;\n    while (x) {\n        cin >> x;\n        root = tr.insert(root, x);\n        cin >> x;\n    }\n    tr.dfs(root);\n    cout << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:41:32.397574+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Refer to the working of AVL tree ( Self Balancing Binary Tree), specifically the 'Insertion' operation with balancing using left and right rotation.\n\nRefer to the Editorial's Code, for the implementation details."
      },
      "id": 1061,
      "input_format": "First-line contains $T$ - the number of test cases.\nThe first line of each test case has integers which are the atomic weights of atoms that are being introduced into the solvent (in sequence). alternating with a $flag$ ( $1$ or $0$ ) which indicates the introduction of more atoms ($1 =$ next atom present, $0 =$ next atom absent), each separated by a single white space.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "Explanation Sample 1:\nThe first atom introduced into the solvent has an atomic weight of 12 which becomes the center of the crystal. The next digit is 1 which suggests that another atom is being introduced into the solvent. The second atom has a weight of 25, and as it is heavier than the first atom, it is pushed in the right direction, and a bond is formed between the two atoms, shown as \n```\n12\n  \\\n   25\n```\n\nThe next atom has a weight of 26 and it tries to bond with the crystal center which is the atom with a weight of 12. Since it is heavier, it is pushed to the right side. However, there are already 25 on the right side, so 26 cannot form a bond with 12 and has to form a bond with 25. The crystal now has the structure \n```\n12\n  \\\n   25\n     \\\n      26\n```\n \nThe crystal is now imbalanced as the difference between the right (2 atoms) and left (0 atoms) directions of 12 is more than 1. The rebalancing occurs by changing the center of the crystal to 25 such that it has one atom to the right ( 26 ) and one to the left (12). \n```\n   25\n  /  \\\n12    26\n```\n\nAfter atoms with weights 32 and 28 are processed, the crystal structure will be as \n```\n   25\n  /  \\\n12    26\n        \\\n        32\n       /\n      28 \n```\nwhich will again need rebalancing as the longest imbalanced chain is on the right side (of the crystal center) with 3 atoms and only 1 atom on the left side, an absolute difference of more than 1. The rebalancing will be done to the sub-structure of 26-32-28 by making 28 the local center. The crystal structure now looks like\n```\n   25\n  /  \\\n12    28\n     /  \\\n   26    32\n```\nThe next atoms 11 and 10 will make the structure as \n```\n         25\n        /  \\\n      12    28\n     /     /  \\\n   11    26    32\n  /\n10\n```\nmaking it imbalanced for atom 12 as it has 2 atoms to the left and none to the right. The rebalancing is achieved by making 11 the local center for the sub-structure with one element to the right (12) and one to the left (10). The structure is stable at the center level too as there is 1 bond each on the left and right sides of the center atom.\n```\n          25\n        /     \\\n      11       28\n     /  \\     /  \\\n   10    12  26   32\n```\nThe next input is 0 which means no more atoms are being introduced, and hence this is the final stable structure of the crystal. The final structure is printed with the Crystal center atom first i.e. 25 followed by its left bond atom 11, whose left and right atoms are 10 and 12, followed by 28 (right of the center), 26, and 32 (left and right of 28 ).\n\nThe Pre-order of the above binary search tree is 25 11 10 12 28 26 32.",
      "output_format": "For each test case, in a new line, a single line of output has the final structure of the crystal as a sequence of integers, each separated by a single white space, where the integers are atomic weights of atoms in the final stabilized crystal. They are printed in the order: the center atom first, the left side atom next, and then the right side atom. If the left side atom has its own bonds, then they are printed (again left first and right next) before printing the right side atom. This goes on until all the atoms in the crystal are printed. ( Pre-order Traversal )",
      "samples": [
        {
          "input": "1\n12 1 25 1 26 1 32 1 28 1 11 1 10 0\n",
          "output": "25 11 10 12 28 26 32\n"
        },
        {
          "input": "1\n31 1 6 1 82 1 5 1 4 1 41 1 53 0\n",
          "output": "31 5 4 6 53 41 82\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Self Balancing",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given the head of the singly connected linked list, your task is to reorder it as follows.</p><p>Original list:</p><pre><code class=\"language-plaintext\">L1 -&gt; L2 -&gt; L3 -&gt; ...... -&gt; Ln-2 -&gt; Ln-1 -&gt; Ln</code></pre><p>Reorder list:</p><pre><code class=\"language-plaintext\">L1 -&gt; Ln -&gt; L2 -&gt; Ln-1 -&gt; L3 -&gt; Ln-2 -&gt; .....</code></pre><p>Complete the function</p><pre><code class=\"language-plaintext\">void reorderList(ListNode* head)</code></pre><p><i>head </i>is the pointer to the beginning of the linked list.</p><p>You may not modify the values in the list's nodes. Only nodes themselves may be changed.</p>",
      "complete_approach": "",
      "constraints": "<p>0 ≤ Length of the linked list ≤ 10<sup>6</sup><br>0 ≤ Value stored in the node ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nvoid reorderList(ListNode* head) {\n    if(!head) {\n        return;\n    }\n\n    // Finding the mid element\n    ListNode* cur = head;\n    ListNode* mid = head;\n    int cnt = 0;\n    \n    while(cur) {\n        if(cnt & 1) {\n            mid = mid -> next;\n        }\n        cur = cur -> next;\n        cnt++;\n    }\n    \n    if(cnt == 1) {\n        return;\n    }\n    \n    if(cnt & 1) {\n        mid = mid -> next;\n    }\n\n    \n    // Processing first half\n    cur = head;\n    \n    while(cur -> next != mid) {\n        cur = cur -> next;\n    }\n    \n    cur -> next = NULL;\n    \n    \n    // Processing second half\n    ListNode *nxt = mid -> next;\n    \n    mid -> next = NULL;\n    \n    while(nxt != NULL) {\n        ListNode *temp = nxt;\n        nxt = nxt -> next;\n        temp -> next = mid;\n        mid = temp;\n    }\n    \n    \n    cur = head;\n    head = NULL;\n    \n    ListNode* temp;\n    \n    while(cur && mid)\n    {\n        if(!head) {\n            head = cur;\n            temp = cur;\n        }\n        else {\n            head -> next = cur;\n            head = head -> next;\n        }\n        cur = cur -> next;\n        head -> next = mid;\n        head = head -> next;\n        mid = mid -> next;\n    }\n    \n    while(cur)\n    {\n        if(!head) {\n            head = cur;\n            temp = cur;\n        }\n        else {\n            head -> next = cur;\n            head = head -> next;\n        }\n        cur = cur -> next;\n    }\n    \n    while(mid)\n    {\n        if(!head) {\n            head = mid;\n            temp = mid;\n        }\n        else {\n            head -> next = mid;\n            head = head -> next;\n        }\n        mid = mid -> next;\n    }\n    \n    head = temp;\n}\n\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    ListNode* head = GetList(num);\n\n    reorderList(head);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:15:00.239757+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 528,
      "input_format": "",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "1\n3",
          "output": "3"
        },
        {
          "input": "5\n1 2 3 4 5",
          "output": "1 5 2 4 3"
        },
        {
          "input": "4\n1 2 3 4",
          "output": "1 4 2 3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\nvoid reorderList(ListNode* head) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    ListNode* head = GetList(num);\n\n    reorderList(head);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Reorder List I",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two numbers $K$ and $S$. Determine how many different values of $X$,$Y$ and $Z$ such that $(0 \\leq X,Y,Z \\leq K)$ and $X+Y+Z=S$.",
      "complete_approach": "",
      "constraints": "$ 0 \\leq K \\leq 3000 $\n$ 0 \\leq S \\leq 3K $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// O(K) time\n// O(1) space\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int k, s;\n    cin >> k >> s;\n    int ans = 0;\n    // to ensure s-z is below 2*k\n    int st = max(0, s - 2 * k);\n    // to ensure s-z is greater than equal to 0\n    int end = min(k, s);\n    for (int z = st; z <= end; z++) // loop for all possible values of x\n    {\n        int rem = s - z;\n        if (rem > k)\n            ans += (2 * k - rem + 1);\n        else\n            ans += (rem + 1);\n    }\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:36:17.123202+00:00"
      },
      "hints": {
        "hint1": "If we fix $X$ and $Y$, $Z$ is also fixed. So we need to check for all possibilities of $X$ and $Y$.",
        "hint2": "",
        "solution_approach": "We can iterate over all possible values of $X$ and $Y$ ranging from $0$ to $K$, and then check if $S-(X+Y)$ lies in the range from $0$ to $K$. If it does we increment our answer by $1$. This approach has a time complexity of $O(K^2)$ and space complexity of $O(1)$.\n\nWe can optimise this further. If we fix only $Z$, then $X+Y=S-Z$ and we can now calculate solutions to the equation $X+Y=C$ where $0 \\leq X \\leq K$ and $0 \\leq Y \\leq K$. We only need to look at values of $X$, since that fixes $Y$. If $C \\ge K$, then number of solutions is $2K-C+1$, since X can only take values from $C-K$ to $K$. If $C<K$, then number of solutions is $C+1$ since X can now take values from $0$ to $C$. We also make sure $Z$ is chosen appropriatley such that $S-Z$ remains in the range from $0$ to $2K$. This approach has a time complexity of $O(K)$ and space complexity of $O(1)$."
      },
      "id": 1217,
      "input_format": "Only one line containing two numbers $K$ and $S$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "In the first sample, $K=2$ and $S=1$,\nwhich allows $3$ solutions = $\\{(1,0,0),(0,1,0),(0,0,1)\\}$.\n\nIn the second sample, $K=9$ amd $S=4$,which allows a total of $15$ solutions = $\\{(0,1,3),(0,3,1),(1,3,0),(3,1,0),(1,0,3),(3,0,1),(0,0,4),(4,0,0),(0,4,0),(0,2,2),(2,0,2),(2,0,2),(1,1,2),(1,2,1),(2,1,1)\\}$.",
      "output_format": "Print the answer required above.",
      "samples": [
        {
          "input": "2 1\n",
          "output": "3\n"
        },
        {
          "input": "9 4\n",
          "output": "15\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Three Numbers",
      "video_editorial_id": 10658
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given two rectangles with their lower-left and upper-right coordinates. You have to find the area of the intersection and union of the rectangles. Both rectangles are axis-aligned.</p>",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$-10^3 \\leq X_i, Y_i \\leq 10^3$  \n\nIt is guaranteed that $X_1 \\leq X_2$, $Y_1 \\leq Y_2$, $X_3 \\leq X_4$, and $Y_3 \\leq Y_4$.",
      "editorial_code": [
        {
          "code": "\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t=1;\n    cin >> t;\n    while (t--) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        int x3, y3, x4, y4;\n        cin >> x3 >> y3 >> x4 >> y4;\n        int a1 = max(x1, x3), b1 = max(y1, y3);\n        int a2 = min(x2, x4), b2 = min(y2, y4);\n        int ari = 0;\n        if(a1 <= a2 && b1 <= b2) {\n            ari = (a2 - a1) * (b2 - b1);\n        }\n        int ar1 = (x2 - x1) * (y2 - y1);\n        int ar2 = (x4 - x3) * (y4 - y3);\n        cout << ari << \" \" << ar1 + ar2 - ari << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:45:53.171746+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "- For finding the intersection of the rectangles, the following gives the endpoints of the diagonal:\n\n  $X_5 = \\max(X_1, X_3)$  \n  $Y_5 = \\max(Y_1, Y_3)$  \n  $X_6 = \\min(X_2, X_4)$  \n  $Y_6 = \\min(Y_2, Y_4)$\n\n- For the rectangle to exist, the conditions must hold:\n\n  $(X_5 \\leq X_6) \\quad \\text{and} \\quad (Y_5 \\leq Y_6)$\n\n- The area of union of rectangles would be:\n\n  $\\text{Area of union} = \\text{Sum of the area of rectangles} - \\text{Area of the intersection of rectangles}$\n\n**The time complexity per test case is:** \n$O(1)$"
      },
      "id": 330,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\n\nThe first line of each test case contains four space-separated integers $X_1, Y_1, X_2, Y_2$ - coordinates of the first rectangle.\n\nThe second line of each test case contains four space-separated integers $X_3, Y_3, X_4, Y_4$ - coordinates of the second rectangle.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>If the image is not visible please check this docs link - https://docs.google.com/document/d/126mU5E-f2FhaByhQ8xE3jeI7JrpCOwyT2Pnp1pAvAu0/</p><p>For the first test case,</p><figure class=\"image\"><img src=\"https://docs.google.com/drawings/u/0/d/sQFwdr--y5qlzdqO5qEqfXA/image?w=83&amp;h=110&amp;rev=40&amp;ac=1&amp;parent=15_PncQhkecHEs0DaYaVsBAhJduX6eDMDo2X52k9QyH8\"></figure><p>For the second test case,</p><figure class=\"image\"><img src=\"https://docs.google.com/drawings/u/0/d/syI9YsB7zXywECT7WwE1YlQ/image?w=86&amp;h=86&amp;rev=9&amp;ac=1&amp;parent=15_PncQhkecHEs0DaYaVsBAhJduX6eDMDo2X52k9QyH8\"></figure><p>For the third test case,</p><figure class=\"image\"><img src=\"https://docs.google.com/drawings/u/0/d/sO57LOqLiNzro1Bk2Kv22ow/image?w=90&amp;h=118&amp;rev=6&amp;ac=1&amp;parent=15_PncQhkecHEs0DaYaVsBAhJduX6eDMDo2X52k9QyH8\"></figure>",
      "output_format": "<p>For each test case, print the area of intersection and union of the rectangles.</p>",
      "samples": [
        {
          "input": "3\n0 0 2 2\n1 1 3 4\n0 0 3 3\n1 1 2 3\n1 2 3 4\n0 0 1 1\n",
          "output": "1 9\n2 9\n0 5\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Intersection and Union of Two Rectangles AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Given two sorted arrays of size <i>N</i> and <i>M</i>, you have to find the <i>K<sup>th</sup></i> element if you merge these two arrays and sort the final array.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">Expected Time Complexity - <i>O(log(N) + log(M))</i></span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\"><i>1 ≤ N,M ≤ 10<sup>5</sup></i></span></p><p><span style=\"background-color:transparent;color:#000000;\"><i>1 ≤ K ≤ N+M</i></span></p><p><span style=\"background-color:transparent;color:#000000;\"><i>1 ≤ A[i] ≤ 10<sup>6</sup></i></span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint KthElement(vector<int> &a, vector<int> &b, int k)\n{\n    int n = (int)a.size();\n    int m = (int)b.size();\n\n    int l = 1, r = 1e6, ans;\n    while (l <= r)\n    {\n        int mid = (l + r) / 2, cnt = 0;\n        auto it = lower_bound(a.begin(), a.end(), mid);\n        if (it != a.begin())\n        {\n            it--;\n            cnt += it - a.begin() + 1;\n        }\n        it = lower_bound(b.begin(), b.end(), mid);\n        if (it != b.begin())\n        {\n            it--;\n            cnt += it - b.begin() + 1;\n        }\n        if (cnt <= k - 1)\n            l = mid + 1, ans = mid;\n        else\n            r = mid - 1;\n    }\n    return ans;\n}\n\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n    \n    vector<int> a(n), b(m);\n    \n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    \n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    \n    cout << KthElement(a, b, k) << '\\n';\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:18:12.911503+00:00"
      },
      "hints": {
        "hint1": "<p>Binary search on answer</p>",
        "hint2": "<p>Find the largest element for which the count of elements less than it is less than K-1</p>",
        "solution_approach": "<p><strong>Method 1 (Binary Search):</strong><br>Binary search on answer to find the K<sup>th</sup> element. The number of elements less than the K<sup>th</sup> element will be less than equal to K-1. So we find the largest element for which the count of elements less than it is less than K-1. To find the count you can use binary search.</p><p><strong>Method 2 (Divide and Conquer):</strong></p><pre><code class=\"language-cpp\">int KthElement(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b, int l1, int r1, int l2, int r2, int k)\n{\n    int n = max(0, r1 - l1 + 1), m = max(0, r2 - l2 + 1);\n    // base case where there are a total of K elements in the array\n    if (n + m == k)\n        return max(a[r1], b[r2]);\n        \n    // base case where either of the arrays are empty\n    if (n == 0)\n        return b[l2 + k - 1];\n    if (m == 0)\n        return a[l1 + k - 1];\n    // base case where either of the arrays has only one element\n    if (n == 1)\n    {\n        if (b[l2 + k - 1] &lt;= a[l1])\n            return b[l2 + k - 1];\n        else\n            return max(a[l1], b[l2 + k - 2]);\n    }\n    if (m == 1)\n    {\n        if (a[l1 + k - 1] &lt;= b[l2])\n            return a[l1 + k - 1];\n        else\n            return max(b[l2], a[l1 + k - 2]);\n    }\n    // we eliminate the smallest n/2 or the largest n/2 elements that \n    // cannot be the answer\n    int mid1 = (n + 1) / 2, mid2 = (m + 1) / 2;\n    if (mid1 + mid2 &lt;= k)\n    {\n        if (a[l1 + mid1 - 1] &gt; b[l2 + mid2 - 1])\n            return KthElement(a, b, l1, r1, l2 + mid2, r2, k - mid2);\n        else\n            return KthElement(a, b, l1 + mid1, r1, l2, r2, k - mid1);\n    }\n    else\n    {\n        if (a[l1 + mid1 - 1] &gt; b[l2 + mid2 - 1])\n            return KthElement(a, b, l1, l1 + mid1 - 1, l2, r2, k);\n        else\n            return KthElement(a, b, l1, r1, l2, l2 + mid2 - 1, k);\n    }\n}</code></pre><p>Time Complexity - <i>O(log(m)+log(n))</i></p><p><strong>Method 2 (Divide and Conquer):</strong></p><pre><code class=\"language-cpp\">int KthElement(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b, int l1, int r1, int l2, int r2, int k)\n{\n    int n = max(0, r1 - l1 + 1), m = max(0, r2 - l2 + 1);\n    // In case we have reached end of array 1\n    if (n == 0)\n        return b[l2 + k - 1];\n    // In case we have reached end of array 2\n    if (m == 0)\n        return a[l1 + k - 1];\n    // Compare first elements of arrays and return\n    if (k == 1)\n        return min(a[l1], b[l2]);\n    int curr = k / 2;\n    // Size of array 1 is less than k / 2\n    if (n &lt; curr)\n    {\n        if (a[r1] &lt;= b[l2 + curr - 1])\n            return b[l2 + (k - n) - 1];\n        else\n            return KthElement(a, b, l1, r1, l2 + curr, r2, k - curr);\n    }\n    // Size of array 2 is less than k / 2\n    if (m &lt; curr)\n    {\n        if (b[r2] &lt;= a[l1 + curr - 1])\n            return a[l1 + (k - m) - 1];\n        else\n            return KthElement(a, b, l1 + curr, r1, l2, r2, k - curr);\n    }\n    else\n    {\n        // Normal comparison, move starting index\n        // of one array k / 2 to the right\n        if (a[l1 + curr - 1] &lt; b[l2 + curr - 1])\n            return KthElement(a, b, l1 + curr, r1, l2, r2, k - curr);\n        else\n            return KthElement(a, b, l1, r1, l2 + curr, r2, k - curr);\n    }\n}</code></pre><p>Time Complexity - <i>O(log(m+n))</i></p>"
      },
      "id": 554,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains three integers <i>N</i>, <i>M</i> and <i>K</i>.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The second line contains <i>N</i> integers - elements of the first array.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The third line contains <i>M</i> integers - elements of the second array.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">The array elements after sorting in the first test case [1,2,3,<strong><u>4</u></strong>,5,6]</span></p><p><span style=\"background-color:transparent;color:#000000;\">The array elements after sorting in the second test case [1,2,3,4,<strong><u>6</u></strong>,7,8,9,10]</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the <i>K<sup>th</sup></i> element of the final array.</span></p>",
      "samples": [
        {
          "input": "3 3 4\n1 2 3\n4 5 6",
          "output": "4"
        },
        {
          "input": "5 4 5\n2 3 6 7 9\n1 4 8 10",
          "output": "6"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint KthElement(vector<int> &a, vector<int> &b, int k)\n{\n    // Complete the function\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n    \n    vector<int> a(n), b(m);\n    \n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    \n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    \n    cout << KthElement(a, b, k) << '\\n';\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "KTHELE",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given an array of length <i>N</i>, and a number <i>X</i>. Find the number of subsets with the sum of elements less than equal to <i>X</i>.</p><p><i>Note:</i></p><ol><li>The sum of elements in an empty subset is 0.</li><li>The set may contain duplicates elements.</li></ol>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>T</i> ≤ 5<br>1 ≤ <i>N</i> ≤ 35<br>0 ≤ <i>A<sub>i</sub></i> ≤ 10<sup>4</sup><br>0 ≤ <i>X</i> ≤ 10<sup>6</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nsigned main() \n{\n    ios::sync_with_stdio(0); \n    cin.tie(0); cout.tie(0);   \n    \n    int T; cin >> T;\n    while(T--) {\n        int n, x; \n        cin >> n >> x;\n        \n        vector<int> aL, aR;\n        for(int i = 0; i < n / 2; i++) {\n            int x; cin >> x;\n            aL.push_back(x);\n        }\n        for(int i = n / 2; i < n; i++) {\n            int x; cin >> x;\n            aR.push_back(x);\n        }\n\n        vector<int> left, right;\n\n        int m = (int)aL.size();\n        for(int i = 0; i < (1 << m); i++) {\n            int sum = 0;\n            for(int j = 0; j < m; j++) {\n                if((i >> j) & 1) {\n                    sum += aL[j];\n                }\n            }\n            left.push_back(sum);\n        }\n        \n        m = (int)aR.size();\n        for(int i = 0; i < (1 << m); i++) {\n            int sum = 0;\n            for(int j = 0; j < m; j++) {\n                if((i >> j) & 1) {\n                    sum += aR[j];\n                }\n            }\n            right.push_back(sum);\n        }\n\n        sort(left.begin(), left.end());\n        sort(right.begin(), right.end());\n\n        ll ans = 0;\n\n        int ptr = (int)right.size() - 1;\n        for(int u : left) {\n            if(u > x) break;\n            while(ptr >= 0 && right[ptr] + u > x) {\n                ptr--;\n            }\n            ans += ptr + 1;\n        }\n\n        cout << ans << \"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:34:56.290960+00:00"
      },
      "hints": {
        "hint1": "<p>You can generate all subsets with the time complexity of 2<i><sup>N</sup></i>. But it's not enough to pass the limits.</p>",
        "hint2": "<p>Divide the array into two parts, one is of size <i>N / 2</i> and the other is of size <i>N - N / 2</i>.</p>",
        "solution_approach": "<p>Brute force won't pass the limits. So we have to apply to optimize brute force techniques.</p><p>Divide the array into two parts of size <i>N / 2</i> each. Generate all subset sums for each part with complexity <i>O(2<sup>N/2</sup>)</i>. Observe that generating <i>2<sup>N/2</sup></i> subsets are within the limits (2<sup>35/2</sup> ~ 10<sup>5</sup>).</p><p>Sort all subset sums for each part. Now iterate over the first half, for each subset-sum <i>S<sub>i</sub></i> in the first half we have to find the number of subsets in the second half with sum ≤<i> X - S<sub>i</sub></i>. You can find it using different techniques like binary search, or two pointers.</p><p>This trick is called <strong>meet-in-the-middle</strong>. This trick will be discussed in more detail in the session.</p><p><strong>Time Complexity:</strong> <i>O(N 2<sup>N/2</sup>)</i><br><strong>Space Complexity:</strong> <i>O(2<sup>N/2</sup>)</i></p>"
      },
      "id": 141,
      "input_format": "<p>The first line of input contains <i>T</i> - the number of test cases.<br>The first line of each test case contains two space-separated numbers <i>N</i> and <i>X</i>.<br>The second line of each test case contains <i>N</i> space-separated integers <i>A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub></i>. &nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>The subsets are {}, {1}, {2}, {1, 2}. The number of subsets with sum ≤ 1 is 2.</p><p><i><strong>Explanation 2:</strong></i><br>The subsets are {}, {2}, {2}, {6}, {2, 2}, {2, 6}, {2, 6}, {2, 2, 6} The number of subsets with sum ≤ 8 is 7.</p>",
      "output_format": "<p>Print the number of subsets with a sum less than equal to <i>X</i> in a new line for each test case.</p>",
      "samples": [
        {
          "input": "2\n2 1\n1 2\n3 8\n2 2 6",
          "output": "2\n7"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Target Subsets",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a simple graph, output the number of simple cycles in it.  \nA **simple cycle** is a cycle with no repeated vertices or edges.",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint dp[20][(1<<20)];\nbool isEdge[20][20];\nint n, m;\nint cur;\n\nint dfs(int pos, int vis, int sz) {\n    if(dp[pos][vis] != -1) {\n        return dp[pos][vis];\n    }\n    int ans = 0;\n    if(sz > 2 && isEdge[pos][cur]) {\n        ans++;\n    }\n    for (int i = cur; i < n; ++i) {\n        if((vis & (1<<i))) continue;\n        if(isEdge[pos][i]) {\n            ans += dfs(i, (vis | (1<<i)), sz+1);\n        }\n    }\n    return dp[pos][vis]=ans;\n}\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        isEdge[a][b] = isEdge[b][a] = 1;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        cur = i;\n        memset(dp, -1, sizeof(dp));\n        ans += dfs(i, (1<<i), 1);\n    }\n    cout << ans/2;\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "Editorial code is not passing the Sample cases.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:34:24.375302+00:00"
      },
      "hints": {
        "hint1": "The brute force approach would be to find the answer for every possible solution by taking each subset of n and then adding it to the final answer if it's a simple cycle. The time complexity would be O(N * N!) and would result in TLE. Can you optimise it?",
        "hint2": "",
        "solution_approach": "We make a DP array `DP[i][j]` which denotes the count of simple paths from vertex **i** to the smallest set bit in **j**, and it contains only vertices from the set **j**.\n\nWe will calculate the value of `DP[i][j]` and then check if there exists an edge between **i** and the smallest set bit in **j**. If such an edge exists, it forms a simple cycle, and we add this to the final answer.\n\nFor the subset of visited vertices **j**, we iterate on all the vertices which have not been visited and are greater than the smallest set bit in **j**. Then, we find the neighbors of **i**, and if there is an edge, add that to the answer recursively.\n\nFinally, we need to divide the total answer by 2 since the graph is undirected, and each cycle is counted twice.\n\n### Time Complexity\n- Per test case: $O(N^2 \\cdot 2^N)$\n"
      },
      "id": 454,
      "input_format": "The first line of input contains two integers **n** and **m**:  \n- $1 \\leq n \\leq 20$, $0 \\leq m$ – the number of vertices and edges in the graph, respectively.\n\nEach of the next **m** lines contains two integers **a** and **b**:  \n- $1 \\leq a, b \\leq n$, $a \\neq b$ – indicating that vertices **a** and **b** are connected by an undirected edge.\n\nThere is no more than one edge connecting any pair of vertices.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the number of simple cycles.</p>",
      "samples": [
        {
          "input": "7 16\n1 2\n1 3\n1 5\n1 7\n2 3\n2 4\n2 6\n3 4\n3 5\n3 6\n3 7\n4 5\n4 6\n4 7\n5 6\n6 7",
          "output": "214"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Cycles in a graph",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given the <i>root</i> of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).</p><p>Complete the function:</p><p><i>vector&lt;vector&lt;int&gt;&gt; getZigzagLevelorderTraversal(Node* root)</i></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<vector<int>> getZigzagLevelorderTraversal(Node* root) {\n   queue<Node*>q;\n   vector<vector<int>>ans;\n   if(root==NULL)\n   {\n       return ans;\n   }\n   q.push(root);\n   int level = 0;\n   while(!q.empty())\n   {\n       vector<int>v;\n       int sz = q.size();\n       while(sz--)\n       {\n           if(q.front()->left!=0)\n           {\n               q.push(q.front()->left);\n           }\n           if(q.front()->right!=0)\n           {\n               q.push(q.front()->right);\n           }\n           v.push_back(q.front()->val);\n           q.pop();\n       }\n       if(level%2)\n       {\n           reverse(v.begin(),v.end());\n       }\n       ans.push_back(v);\n       level++;\n   }\n   return ans;\n} \n\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        vector<vector<int>> ans = getZigzagLevelorderTraversal(tree);\n        for(auto u:ans){\n            for(auto v:u){\n                cout<<v<<\" \";\n            }\n            cout<<\"\\n\";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:15:36.996627+00:00"
      },
      "hints": {
        "hint1": "<p>Please first solve level order traversal. And think how you can modify it to solve this problem.</p>",
        "hint2": "<p>Maintain a variable or use the current size of the array to get the current level. Accordingly, push the left or right child to the queue first.</p>",
        "solution_approach": ""
      },
      "id": 577,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, &nbsp;the length of the array representing the serialized representation of a tree.</p><p>The next line contains N-space-separated integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<pre><code class=\"language-plaintext\">Test case 2- \n 5222\n    \\\n   3819\n    /\n  6801\n\t\nTest case 3 - \n   8901\n   /\n  7891\n   /   \\\n  5407 1720</code></pre>",
      "output_format": "<p>Return the zigzag level order traversal of the tree.</p>",
      "samples": [
        {
          "input": "3\n3\n6004 -1 -1 \n7\n5222 -1 3819 6801 -1 -1 -1 \n9\n8901 7891 5407 -1 -1 1720 -1 -1 -1 ",
          "output": "6004 \n\n5222 \n3819 \n6801 \n\n8901 \n7891 \n5407 1720 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n</fix>\nvector<vector<int>> getZigzagLevelorderTraversal(Node* root) {\n  // Complete the function.\n}\n\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        vector<vector<int>> ans = getZigzagLevelorderTraversal(tree);\n        for(auto u:ans){\n            for(auto v:u){\n                cout<<v<<\" \";\n            }\n            cout<<\"\\n\";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "ZigZag Level Order Traversal",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an array <i>A</i>, where each <i>i</i>th index represents an elevation on that index. The width of each bar is 1. You have to compute how much water it is able to trap after raining.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1 </span><span style=\"background-color:#ffffff;color:#000000;\">≤ <i>T</i> ≤ 100</span><br><span style=\"background-color:transparent;color:#000000;\">1 </span><span style=\"background-color:#ffffff;color:#000000;\">≤ <i>N</i> ≤ 10<sup>5</sup></span><br><span style=\"background-color:transparent;color:#000000;\">0 </span><span style=\"background-color:#ffffff;color:#000000;\">≤ <i>A<sub>i</sub></i> ≤ 10<sup>5</sup></span></p>",
      "editorial_code": [
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main(){\n    IOS\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        cin>>n;\n        int a[n];\n        for (int i = 0; i < n; ++i) {\n            cin>>a[i];\n        }\n        int pre[n], suff[n];\n        pre[0]=a[0];\n        suff[n-1]=a[n-1];\n        for (int i = 1; i < n; ++i) {\n            pre[i]=max(pre[i-1], a[i]);\n        }\n        for (int i = n-2; i >= 0; --i) {\n            suff[i]=max(suff[i+1], a[i]);\n        }\n        long long ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans+=min(pre[i], suff[i]) - a[i];\n        }\n        cout<<ans<<\"\\n\";\n    }\n    return 0;\n}\n```\n\n\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main(){\n    IOS\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        cin>>n;\n\n        int a[n];\n\n        for (int i = 0; i < n; ++i) {\n            cin>>a[i];\n        }\n\n        long long ans = 0;\n\n        stack<int> s;\n\n        for(int i = 0; i < n; i++) {\n            while(!s.empty()) {\n                if(a[s.top()] > a[i]) break;\n\n                int x = s.top();\n                s.pop();\n\n                if(s.empty()) break;\n                int y = s.top();\n                ans += 1LL * (min(a[y], a[i]) - a[x]) * (i - y - 1);\n            }\n            s.push(i);\n        }\n        cout<<ans<<\"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:43:41.710427+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">An element of the given array can store rainwater if there are taller elevations on its left and right side.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">If there exists an elevation that is taller than the current on its left and right, then rainwater can be trapped above the current elevation. To calculate this, subtract the current elevation’s height from the result of the minimum of the maximum elevation on its left and right.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N)</span></p>",
        "solution_approach": "<p>We can use the stack to keep track of the bars that are bounded by longer bars and hence, may store water. Using the stack, we can do the calculations in only one iteration.</p><p>We keep a stack and iterate over the array. We add the index of the bar to the stack if the bar is smaller than or equal to the bar at top of the stack, which means that the current bar is bounded by the previous bar in the stack. If we found a bar longer than that at the top, we are sure that the bar at the top of the stack is bounded by the current bar and a previous bar in the stack, hence, we can pop it and add resulting trapped water to <i>ans</i>.</p>"
      },
      "id": 462,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer <i>T</i> - the number of test cases. Then <i>T</i> test cases follow.</span><br><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer <i>N</i> - the length of the array.&nbsp;</span><br><span style=\"background-color:transparent;color:#000000;\">The second line of each test case contains <i>N</i> space-separated integers, where <i>A<sub>i</sub></i> denotes the height of the <i>i</i>th bar.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case:</span></p><figure class=\"image\"><img src=\"https://docs.google.com/drawings/u/0/d/s2WaCP1JOxBBBM4xnk_-ocQ/image?w=76&amp;h=76&amp;rev=10&amp;ac=1&amp;parent=1EwEPxxRd3IzB98YLm0jNnvDJe2S-_IAVrBeSWYA0WmI\"></figure><p><span style=\"background-color:transparent;color:#000000;\">For the second test case:</span></p><figure class=\"image\"><img src=\"https://docs.google.com/drawings/u/0/d/skPlTxXR_YYQT-GnG8IeuYQ/image?w=105&amp;h=84&amp;rev=10&amp;ac=1&amp;parent=1EwEPxxRd3IzB98YLm0jNnvDJe2S-_IAVrBeSWYA0WmI\"></figure><p><span style=\"background-color:transparent;color:#000000;\">For the third test case:</span></p><figure class=\"image\"><img src=\"https://docs.google.com/drawings/u/0/d/s5OXwMYvoNTfpjB3oBCGfpg/image?w=131&amp;h=131&amp;rev=13&amp;ac=1&amp;parent=1EwEPxxRd3IzB98YLm0jNnvDJe2S-_IAVrBeSWYA0WmI\"></figure>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, you have to print how much water it is able to trap after raining.</span></p>",
      "samples": [
        {
          "input": "3\n3\n3 0 2\n5\n2 0 0 4 3\n5\n1 2 3 1 5",
          "output": "2\n4\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Rain Water",
      "video_editorial_id": 10673
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array A of size N, consisting of elements between 1 and N-1, in random order, with only one number being repeated. Find this number.\n\nTry to solve this using O(1) extra space.",
      "complete_approach": "",
      "constraints": "<p>2 ≤ <i>N</i> ≤ 10<sup>6</sup><br>1 ≤ A[i] ≤ <i>N</i> - 1</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint FindRepeated(vector<int> &a)\n{\n    int n = (int)a.size();\n\n    int x = 0;\n\n    for (int i = 1; i <= n - 1; i++)\n        x ^= i;\n\n    for (int i = 0; i < n; i++)\n        x ^= a[i];\n\n    return x;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(NULL);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n\n    cout << FindRepeated(a) << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:45:55.031083+00:00"
      },
      "hints": {
        "hint1": "Can you find what the sum of all elements will be?",
        "hint2": "The difference between the sum of numbers from 1….n-1 and the array sum is the answer.",
        "solution_approach": "There are multiple ways to solve this problem like hashing, sorting, etc.\nHere we discuss two ways which will not require any extra space.\nYou can find the sum of all numbers till N-1 by the formula (N-1)*N / 2. The difference between the calculated sum and the sum of the array is the repeated number. Calculating the sum can result in overflow. You can avoid that by solving the problem with XOR. Find out the XOR of all numbers till N-1 and the XOR of all elements of the array. The XOR of these two will give the repeated number as all other numbers will cancel out."
      },
      "id": 588,
      "input_format": "The first line contains an integer N - the size of the array A.\nThe next line contains N integers the elements of the array A.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the repeated number.",
      "samples": [
        {
          "explanation": "2 is the only number repeated in the array.",
          "input": "5\n3 1 2 4 2",
          "output": "2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint FindRepeated(vector<int> &a)\n{\n    // Complete the function\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(NULL);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n\n    cout << FindRepeated(a) << \"\\n\";\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "ONLYREP",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an array consisting of <strong>n </strong>integers and a number <strong>k</strong>.</span><br><span style=\"background-color:transparent;color:#000000;\">You need to determine if you can divide the array into sets of <strong>k </strong>consecutive integers. Each set must contain <strong>k </strong>integers and each element of the array must be present in 1 set. One element cannot be present in more than 1 set.</span></p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 100000\n1 &lt;= k &lt;= n\n1 &lt;= v[i] &lt;= 100000</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ii = pair<ll, ll>;\n#define len(x) ((ll)(x).size())\n#define rep(i, x) for (ll(i) = 0; (i) < (x); ++(i))\n#define F first\n#define S second\n#define pb push_back\n\nvoid solve() {\n  ll n, k;\n  cin >> n >> k;\n  vector<ii> v;\n  map<ll, ll> mp;\n  rep(i, n) {\n    ll x;\n    cin >> x;\n    mp[x]++;\n  }\n  if (n % k) {\n    cout << \"No\\n\";\n    return;\n  }\n  for (auto x : mp) {\n    v.pb(x);\n  }\n  rep(i, len(v)) {\n    if (v[i].S == 0) continue;\n    for (ll j = i + 1; j < i + k; j++) {\n      if (v[j].S < v[i].S) {\n        cout << \"No\" << endl;\n        return;\n      } else {\n        v[j].S -= v[i].S;\n      }\n    }\n    v[i].S = 0;\n  }\n  cout << \"Yes\" << endl;\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:37:39.424367+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">The minimum number must be the start of some set of k consecutive integers.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">For any number x present in the array if x-1 is not present, x must be the start of some set of k consecutive integers.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Using the above observation, we can start from any number x and come down till the current number x is not present in the array. If x is not present, x+1 must be the start of some streak of consecutive integers. To have all occurrences of the number x+1 in some set, we must have at least that many occurrences of the next k-1 numbers.</span><br><span style=\"background-color:transparent;color:#000000;\">So we decrease the frequency of all the numbers in the range [x+1, x+k] by the frequency of x+1, and if any number in this range has a frequency less than that of x+1, we print No.</span><br><span style=\"background-color:transparent;color:#000000;\">Each number can be visited utmost twice, once while coming down and the other while going up and decreasing the frequency. So the complexity is O(n).</span></p>"
      },
      "id": 609,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of input contains two integers <strong>n </strong>and <strong>k</strong>.</span><br><span style=\"background-color:transparent;color:#000000;\">The second line contains <strong>n</strong> integers denoting the input array.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<ol><li><span style=\"background-color:transparent;color:#000000;\">We can divide the array into two sets:</span><br><span style=\"background-color:transparent;color:#000000;\">[1, 2, 3, 4]</span><br><span style=\"background-color:transparent;color:#000000;\">[6, 7, 8, 9]</span></li><li><span style=\"background-color:transparent;color:#000000;\">We cannot divide 4 integers into sets of size 3.</span></li><li>Two sets are: [1, 2, 3, 4] and [3, 4, 5, 6]</li></ol>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print <strong>‘Yes’</strong> if you can divide the array into sets of <strong>k</strong> consecutive integers. If you cannot, print <strong>‘No’</strong>.</span></p>",
      "samples": [
        {
          "input": "8 4\n2 3 1 4 9 8 7 6",
          "output": "Yes"
        },
        {
          "input": "4 3\n5 6 7 8",
          "output": "No"
        },
        {
          "input": "8 4\n1 2 3 3 4 4 5 6",
          "output": "Yes"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Consecutive Numbers",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an integer array $nums$ of even length $n$ and an integer $limit$. In one move, you can replace any integer from $nums$ with another integer between $1$ and $limit$, inclusive.\n\nThe array $nums$ is *\"Balanced\"* if for all indices $i$ (0-indexed), $nums[i] + nums[n - 1 - i]$ equals the same number. For example, the array $[1,2,3,4]$ is balanced because for all indices $i$, $nums[i] + nums[n - 1 - i] = 5$.\n\nFind the minimum number of moves required to make $nums$ *\"Balanced\"*.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$\n\n$2 \\leq n \\leq 10^5$ , $n$ is even.\n\n$1 \\leq nums[i] \\leq limit \\leq 10^5$\n\nThe Sum of $n$ across all test cases is $\\leq 10^6$ \n\nThe Sum of $limit$ across all test cases is $\\leq 10^6$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvoid solve() {\n\tint n, limit;\n\tcin >> n >> limit;\n\tvector<int> nums(n);\n\tfor (int i = 0; i < n; i++)cin >> nums[i];\n\tvector<int> dp(2 * limit + 10, 0);\n\tint  cur = n, ans = n;\n\tfor (int i = 0; i < n / 2; i++) {\n\t\tdp[min(nums[i], nums[n - i - 1]) + 1]--;\n\t\tdp[nums[i] + nums[n - i - 1]]--;\n\t\tdp[nums[i] + nums[n - i - 1] + 1]++;\n\t\tdp[max(nums[i], nums[n - i - 1]) + limit + 1]++;\n\t}\n\tfor (int i = 2; i <= 2 * limit; i++)cur += dp[i], ans = min(ans, cur);\n\tcout << ans << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tsolve();\n\t}\n\treturn 0;\n}\n\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:30:24.805213+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "If we want to make the nums balanced, having all the pairs $A = nums[i], B = nums[n - 1 - i]$ with $A + B = T$. Considering a pair $A = nums[i], B = nums[n - 1 - i]$, there are 5 different situation for every such pair $(A, B)$, given different target $T$.\n\n1. $2 <= T < min(A, B) + 1$, we need $2$ operations to make both $A, B$ smaller\n2. $min(A, B) + 1 <= T < A + B$, we need $1$ operation to make the larger one out of $A$ and $B$ smaller\n3. $T = A + B$, we need $0$ operation\n4. $A + B < T < max(A, B) + limit$, we need $1$ operation to make the smaller one out of $A$ and $B$ larger\n5. $max(A, B) + limit < T <= 2 * limit$, we need $2$ operation to make both $A, B$ larger\n\nWe calculate the boundary for each pair (A, B) and note down the corresponding operation changes as delta. $delta[i] = x$ means we need x more operations when target $T$ change from $i - 1$ to $i$.\n\nWe can use Partial Sums to do that.\n\nHere $delta$ represents the left boundary of the $5$ cases for each $nums[i]$.\n\n1. $2 <= T < min(A, B) + 1$ The left boundary of this interval is $2$, $delta[2] += 2$, so the changing of the target will add two operations, if $T$ falls in range $[2, limit*2+1]$\n\n2. $min(A, B) + 1 <= T < A + B$ The left boundary is $min(A, B) + 1$.\ndelta[min(a, b) + 1]--, one operation can be saved if $T$ falls in range $[min(A, B) + 1, limit*2+1]$\n\n3. $T = A + B$ The left boundary is $A + B$. Two operations are saved for this case.\n\n4. $A + B < T < max(A, B) + limit$ The left boundary is $A + B + 1$. One more operation required if $T$ falls in range $[A + B + 1, limit*2*1]$\n\n5. $max(A, B) + limit < T <= 2 * limit$ The left boundary is $max(A, B) + 1$. Another operation required if T falls in range $[max(A, B)+1, limit*2+1]$\n\n**Time Complexity:** $O(max(n, k))$\n**Space:** $O(k)$"
      },
      "id": 979,
      "input_format": "First-line contains $T$ - the number of test cases.\nThe first line of each test case contains two integers- $n$ and $limit$.\nThe second line of each test case contains $nums$ array.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the minimum number of moves required to make $nums$ *\"Balanced\"*.",
      "samples": [
        {
          "input": "2\n4 6\n1 5 1 5\n6 5\n1 2 3 4 5 1\n",
          "output": "0\n2\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Balance",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$. Print all **even** numbers between $1$ and $N$ inclusive in separate lines.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N ≤ 10^3 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// O(n) time\n// O(1) space\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    if (n == 1)\n    {\n        cout << \"-1\\n\";\n    }\n    else\n    {\n        // this loops runs n/2 times\n        for (int i = 2; i <= n; i += 2)\n        {\n            cout << i << \"\\n\";\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:36:39.710694+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Print $-1$ if $N==1$, else run a loop from $2$ to $N$ and print all the numbers which occur at an interval of $2$ repeatedly until it exceeds $N$. The time complexity will be $O(N)$ and space complexity will be $O(1)$."
      },
      "id": 1220,
      "input_format": "Only one line containing a number $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first sample input, there are $5$ even numbers $2,4,6,8,10$ from $1$ to $10$.\n\nFor the second sample input, there are $2$ even numbers $2,4$ from $1$ to $5$.",
      "output_format": "Print the answer according to the required above. If there are no **even** numbers print **-1**.",
      "samples": [
        {
          "input": "10\n",
          "output": "2\n4\n6\n8\n10\n"
        },
        {
          "input": "5\n",
          "output": "2\n4\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Even Numbers",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a vector of <strong>distinct</strong> integers <i>candidates</i> and a target integer <i>target</i>, return <i>a list of all <strong>unique combinations</strong> of candidates where the chosen numbers sum to target.</i> You may return the combinations in <strong>any order</strong>.</p><p>The <strong>same</strong> number may be chosen from vector <i>candidates</i> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>",
      "complete_approach": "",
      "constraints": "<ul><li>1 ≤ candidates.length() ≤ 30.</li><li>1 ≤ candidates[i] ≤ 200.</li><li>All elements of candidates are distinct.</li><li>1 ≤ target ≤ 500.</li></ul>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvector<int> temp;\nvector<vector<int>> ans;\nvoid rec(vector<int>& candidates, int i, int &target, int sum) {\n    if (sum > target)return; // pruning\n    if (i == candidates.size()) { // base\n        if (sum == target) { // save combination.\n            ans.push_back(temp);\n        }\n        return;\n    }\n    rec(candidates, i + 1, target, sum); // not choosing i-th element.\n\n    // choosing i-th element.\n    temp.push_back(candidates[i]);\n    rec(candidates, i, target, sum + candidates[i]);\n    temp.pop_back(); // backtracking\n}\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n    ans.clear();\n    rec(candidates, 0, target, 0);\n    return ans;\n}\n\nvoid checker() {\n    int n, x, target;\n    cin >> n >> target;\n    vector<int> t;\n    for (int i = 0; i < n; i++) {\n        cin >> x;\n        t.push_back(x);\n    }\n    auto v = combinationSum(t, target);\n    for (auto &x : v) {\n        sort(x.begin(), x.end());\n    }\n    sort(v.begin(), v.end());\n    for (auto x : v) {\n        for (auto y : x)cout << y << \" \";\n        cout << endl;\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        checker();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:17:54.153310+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 868,
      "input_format": "<p>Complete the function <i><strong>combinationSum(candidates, target).&nbsp;</strong></i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>return combinations as <i><strong>vector&lt;vector&lt;int&gt;&gt;</strong></i> in any order.</p>",
      "samples": [
        {
          "input": "4 7\n2 3 6 7 \n ",
          "output": "2 2 3\n7"
        },
        {
          "input": "1 1 \n2\n",
          "output": "  "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n</fix>\n\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n    // write code here.\n}\n\n<fix>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid checker() {\n    int n, x, target;\n    cin >> n >> target;\n    vector<int> t;\n    for (int i = 0; i < n; i++) {\n        cin >> x;\n        t.push_back(x);\n    }\n    auto v = combinationSum(t, target);\n    for (auto &x : v) {\n        sort(x.begin(), x.end());\n    }\n    sort(v.begin(), v.end());\n    for (auto x : v) {\n        for (auto y : x)cout << y << \" \";\n        cout << endl;\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        checker();\n        // i++;\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Combination Sum I",
      "video_editorial_id": 8229
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array of size 2N + 2 where N elements occur twice and 2 occur just once. You have to find the 2 non-repeating elements.\n\nTry to solve this using O(1) extra space.",
      "complete_approach": "",
      "constraints": "<p>0 ≤&nbsp;<i>N</i>&nbsp;≤ 5 x 10<sup>5</sup></p><p>1 ≤ A[i]&nbsp;≤ <i>N</i> + 2</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> FindRepeated(vector<int> &a)\n{\n    int n = (int)a.size();\n\n    int xr = 0;\n    for (int i = 0; i < n; i++)\n        xr ^= a[i];\n\n    int j = 0;\n    while (1)\n    {\n        if (xr & (1 << j)) //finding set bit of XOR of array\n            break;\n        j++;\n    }\n    int xxor = 0, yxor = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (a[i] & (1 << j))\n            xxor ^= a[i];\n        else\n            yxor ^= a[i];\n    }\n\n    vector<int> ans;\n    ans.push_back(min(xxor, yxor));\n    ans.push_back(max(xxor, yxor));\n\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(NULL);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<int> a(2 * n + 2);\n\n    for (int i = 0; i < 2 * n + 2; i++)\n        cin >> a[i];\n\n    vector<int> ans = FindRepeated(a);\n    cout << ans[0] << \" \" << ans[1] << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:47:25.868842+00:00"
      },
      "hints": {
        "hint1": "Find the XOR of the entire array.",
        "hint2": "Can you split the array into 2 groups such that both the groups contain one of the non repeated elements?",
        "solution_approach": "Find the XOR of the entire array. Any set bit of the XOR will come from either of the non repeated elements. So we split the array into 2 groups - one which has the set bit and one which doesn’t. Now take XOR of the groups separately and that will give the non-repeated elements as all the other elements are present in pairs."
      },
      "id": 590,
      "input_format": "The first line contains a single integer N.\nThe second line contains 2N + 2 integers - the array elements.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "5 and 6 are the numbers that are not repeated",
      "output_format": "Print two integers - the elements which are not repeated in ascending order.",
      "samples": [
        {
          "input": "4\n1 2 3 4 1 4 2 3 5 6",
          "output": "5 6"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nvector<int> FindRepeated(vector<int> &a)\n{\n    // Complete the function\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(NULL);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<int> a(2 * n + 2);\n\n    for (int i = 0; i < 2 * n + 2; i++)\n        cin >> a[i];\n\n    vector<int> ans = FindRepeated(a);\n    cout << ans[0] << \" \" << ans[1] << \"\\n\";\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "TWOREP",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You've been given chemical formula of a compound. Your task is to print the count of each atom.<br>The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.<br>One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.<br>Two formulas concatenated together to produce another formula. For example, H2O2He3Mg4 is also a formula.<br>A formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas.</p><p>It's guaranteed that the total count of each individual atom is within INT_MAX.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ |<i>S</i>| ≤ 10<sup>3</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nstring solve(string formula) {\n    stack < pair < string, int > > s;\n\n    for(int i = 0; i < (int)formula.length(); i++) {\n        if(formula[i] == '(') {\n            s.push({\"(\", -1});\n        }\n        else if(formula[i] == ')') {\n            int multiplier = 0;\n            while(i + 1 < (int)formula.length() && formula[i + 1] >= '0' && formula[i + 1] <= '9') {\n                multiplier *= 10;\n                multiplier += formula[i + 1] - '0';\n                i++;\n            }\n            if(!multiplier) multiplier = 1;\n\n            stack < pair < string, int > > temp;\n\n            while(!s.empty()) {\n                auto it = s.top();\n                s.pop();\n                if(it.first == \"(\") break;\n                temp.push({it.first, it.second * multiplier});\n            }\n\n            while(!temp.empty()) {\n                s.push(temp.top());\n                temp.pop();\n            }\n        }\n        else if(formula[i] >= 'A' && formula[i] <= 'Z') {\n            string atom = \"\";\n            atom += formula[i];\n            while(i + 1 < (int)formula.length() && formula[i + 1] >= 'a' && formula[i + 1] <= 'z') {\n                atom += formula[i + 1];\n                i++;\n            }\n\n            int cnt = 0;\n            while(i + 1 < (int)formula.length() && formula[i + 1] >= '0' && formula[i + 1] <= '9') {\n                cnt *= 10;\n                cnt += formula[i + 1] - '0';\n                i++;\n            }\n\n            if(!cnt) cnt = 1;\n\n            s.push({atom, cnt});\n        }\n    }\n\n    map < string, int > M;\n\n    while(!s.empty()) {\n        M[s.top().first] += s.top().second;\n        s.pop();\n    }\n\n    string ans = \"\";\n\n    for(auto it : M) {\n        ans += it.first;\n        if(it.second > 1) ans += to_string(it.second);\n    }\n\n    return ans;\n}\n\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    string formula;\n    cin >> formula;\n\n    cout << solve(formula) << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:53.608036+00:00"
      },
      "hints": {
        "hint1": "<p>Parse the input string, and open the brackets. It's kind of simulating the entire manual process in programming!</p>",
        "hint2": "<p>We can use stack for that purpose.</p>",
        "solution_approach": "<p>The expected time complexity of the solution using simulation: <i>O(|S|<sup>2</sup>)</i></p><p>We can optimize the solution to O(|<i>S</i>|) by doing some simple optimizations, like the count of each element will get multiply by only those numbers which are outside the closing brackets of brackets containing this atom. Try it out by yourself!</p>"
      },
      "id": 460,
      "input_format": "<p>The only line of input contains a string <i>S</i> representing the chemical formula of a compound.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.</p>",
      "samples": [
        {
          "input": "Mg(OH)2",
          "output": "H2MgO2"
        },
        {
          "input": "K4(ON(SO3)2)2",
          "output": "K4N2O14S4"
        },
        {
          "input": "(Ti34)10",
          "output": "Ti340"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Molecular Formula",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "There are $n$ friends in a 2D plane who want to meet at some common point. Each of their position is given to you as $x$ &amp; $y$ coordinates.\n\nThe distance a person covers to go from position $(x_1, y_1)$ to $(x_2, y_2)$ is the Manhattan distance, i.e., $|x_1 - x_2| + |y_1 - y_2|$.\n\nThey choose the meeting point such that the sum of distances covered by each of them to reach it is minimum. Find this minimum sum of distances.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10$\n$1 \\leq n \\leq 10^5$\n$0 \\leq x, y ≤ 10^6$",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty."
        ],
        "last_updated": "2024-06-22T02:47:58.931112+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 217,
      "input_format": "The first line of input contains $T$, the number of test cases.\nThe first line of each test case contains $n$.\nEach of the next $n$ lines contains two integers $(x, y)$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "Point $(2, 2)$ is the optimal meeting point in this case.",
      "output_format": "For each test case output one integer: The minimum sum of distances covered by them.",
      "samples": [
        {
          "input": "1\n3\n0 4\n4 0\n2 2\n",
          "output": "8\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Meet at a Point",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "There is an array consisting of n integers. Some values of the array will be updated, and after each update, your task is to report the maximum subarray sum in the array.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i>, <i>m </i>≤ 2 x 10<sup>5</sup><br>−10<sup>9 </sup>≤ <i>x<sub>i </sub></i>≤ 10<sup>9</sup><br>1 ≤ <i>k </i>≤ <i>n</i><br>−10<sup>9 </sup>≤ <i>x </i>≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 200010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nstruct ST\n{\n    ll maxi, lsum, rsum, sum;\n    ST(ll sum = 0, ll maxi = 0, ll lsum = 0, ll rsum = 0) : sum(sum), maxi(maxi), lsum(lsum), rsum(rsum) {}\n};\n\nST operator+(const ST &A, const ST &B)\n{\n    ST temp;\n    temp.lsum = max(A.lsum, A.sum + B.lsum);\n    temp.rsum = max(B.rsum, B.sum + A.rsum);\n    temp.sum = A.sum + B.sum;\n    temp.maxi = max(max(A.maxi, B.maxi), A.rsum + B.lsum);\n    return temp;\n}\n\nstruct segtree\n{\n    vector<ST> tree;\n    segtree(int n = N)\n    {\n        tree.resize(4 * n);\n    }\n\n    void update(int node, int start, int end, int idx, ll val)\n    {\n        if (start == end)\n        {\n            ll x = max(val, 0LL);\n            tree[node] = ST(val, x, x, x);\n        }\n        else\n        {\n            int mid = (start + end) >> 1;\n            if (idx <= mid)\n                update(2 * node, start, mid, idx, val);\n            else\n                update(2 * node + 1, mid + 1, end, idx, val);\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\n        }\n    }\n\n    ll query()\n    {\n        return tree[1].maxi;\n    }\n};\n\nsigned main()\n{\n    // freopen(\"IN\", \"r\", stdin);\n    // freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n\n    segtree T(n);\n\n    for (int i = 0; i < n; i++)\n    {\n        ll val;\n        cin >> val;\n        T.update(1, 0, n - 1, i, val);\n    }\n\n    for (int i = 0; i < q; i++)\n    {\n        int k;\n        ll x;\n        cin >> k >> x;\n        k--;\n        T.update(1, 0, n - 1, k, x);\n        cout << T.query() << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:15:59.345894+00:00"
      },
      "hints": {
        "hint1": "The solution uses a segment tree data structure to efficiently handle updates and queries on the array.",
        "hint2": "Each node of the segment tree stores the information about the maximum subarray sum within that range.",
        "solution_approach": "The main idea is to divide the array into smaller segments recursively and calculate the maximum subarray sum for each segment.\nThe merge operation combines the results from child segments to calculate the maximum subarray sum for the parent segment.\nWhile merging we need to consider the maximum of three subarrays:\n1. maximum possible sum of left subarray\n2. maximum possible sum of right subarray\n3. maximum possible subarray by merging some suffix subarray sum of the left subarray and some prefix subarray sum of the right subarray.  \n\n\nThe update operation modifies the array and updates the corresponding nodes in the segment tree.\nThe query operation retrieves the maximum subarray sum from the root of the segment tree."
      },
      "id": 404,
      "input_format": "The first input line contains integers n and m: the size of the array and the number of updates. The array is indexed 1, 2,…, n.\nThe next line has n integers: x1, x2, …, xn: the initial contents of the array.\nThen there are m lines describing the changes. Each line has two integers k and x: the value at position k becomes x.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "After each update, print the maximum subarray sum. Empty subarrays (with sum 0) are allowed.",
      "samples": [
        {
          "input": "5 3\n1 2 -3 5 -1\n2 6\n3 1\n2 -2",
          "output": "9\n13\n6"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Subarray Sum Queries",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given an undirected graph <i>G</i> with <i>N</i> nodes, indexed from 1 to <i>N</i> and <i>M</i> edges, indexed from 1 to <i>M</i>.</p><p>There are two types of operations:<br><strong>1 X</strong>: Remove the edge numbered <i>X</i>.<br><strong>2</strong>: Print the number of connected components in the graph.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nclass wunionfind {\n  public:\n    int *id, *sz;\n    int cnt = 0;\n    wunionfind(int n = N) {\n        id = new int[n + 1];\n        sz = new int[n + 1];\n        for(int i = 0; i <= n; i++) {\n            id[i] = i;\n            sz[i] = 1;\n        }\n        cnt = n;\n    }\n    int root(int idx) {\n        int x = idx;\n        while(x != id[x]) {\n            id[x] = id[id[x]];\n            x = id[x];\n        }\n        return x;\n    }\n    bool uni(int a, int b) {\n        int x = root(a), y = root(b);\n        if(sz[x] < sz[y]) {\n            swap(x, y);\n        }\n        if (x != y) {\n            cnt--;\n            id[y] = x;\n            sz[x] += sz[y];\n            sz[y] = 0;\n            return false;\n        }\n        return true;\n    }\n};\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n, m, q; cin >> n >> m >> q;\n\n    bool marked[m + 1];\n    memset(marked, false, sizeof(marked));\n\n    pair<int,int> query[q];\n    pair<int,int> edge[m + 1];\n\n    for(int i = 1; i <= m; i++) {\n        int u, v; cin >> u >> v;\n        edge[i] = {u, v};\n    }\n\n    for(int i = 0; i < q; i++) {\n        int t; cin >> t;\n        if(t == 2) query[i] = {2, -1};\n        else {\n            int x; cin >> x;\n            query[i] = {1, x};\n            marked[x] = true;\n        }\n    }\n\n    wunionfind W(n);\n\n    for(int i = 1; i <= m; i++) {\n        if(!marked[i]) {\n            int u = edge[i].first;\n            int v = edge[i].second;\n            W.uni(u, v);\n        }\n    }\n\n    vector<int> ans;\n\n    for(int i = q - 1; i >= 0; i--) {\n        if(query[i].first == 2) ans.push_back(W.cnt);\n        else {\n            int u = query[i].second;\n            W.uni(edge[u].first, edge[u].second);\n        }\n    }\n\n    reverse(ans.begin(), ans.end());\n\n    for(int u : ans) cout << u << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:30:51.765225+00:00"
      },
      "hints": {
        "hint1": "<p>If the first query is about the addition of edge, then it is a simple <i>DSU</i>. But we can convert the removal query to an addition-type query by doing one small trick.<br><i>Can you guess it how?</i></p><p>&nbsp;</p>",
        "hint2": "<p>Reverse all query operations. And instead of removing the edge, the query will be adding an edge in the graph.<br>Yes, now directly apply <i>DSU</i>.</p><p>&nbsp;</p>",
        "solution_approach": "<p>The trick in the problem is to reverse the queries. Instead of addressing them online, we can solve them offline. First, we only add those edges in the graph, which have never occurred in any removal query.<br>Now after reversing the queries, the removal query is now an addition query. Add the edge in the graph for the first type of query.<br>For <i>2nd</i> type of query, find the number of connected components and stored it somewhere at the appropriate index, which is according to the original queries.<br>And print the answer in proper order. The time and space complexities are the same as <i>DSU</i>.</p><p><strong>Time complexity</strong>: Without path compression: <i>O(NlogN) &amp;</i> With path compression: <i>O(N)</i><br><strong>Space complexity</strong>: <i>O(N + M + Q)</i> extra space</p>"
      },
      "id": 41,
      "input_format": "<p>The first line of contains three space-separated numbers <i>N, M, Q</i> (1 ≤ <i>N, M, Q</i> ≤ 100000).</p><p>The next <i>M</i> lines contain <i>2</i> space-separated integers <i>u</i> and <i>v</i> which depicts an edge between nodes <i>u</i> and <i>v</i> (1 ≤ <i>u, v</i> ≤ <i>N</i>). ith line denotes the ith edge.</p><p>This is followed by <i>Q</i> lines, each describing an operation in the following format:<br><strong>1 X</strong>: Remove the edge numbered <i>X</i>.<br><strong>2</strong>: Print the number of connected components in the graph.</p><p>There are no self-loops or multiple edges in the graph.</p><p><i>Note</i>: If there are multiple queries for removal of the same edge, then the last such query should be considered. Also, the index of the edges does not change after the removal of any of the edges between the nodes.</p><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>Initially, the graph is connected.<br>Even after the removal of the 2nd edge, the graph is connected. Now if we remove the 1st edge, node 2 is now isolated. And graph now contains 2 components as {2}, {1, 3}.</p>",
      "output_format": "<p>The output should consist of the answer to each of the operations of the <i>2nd</i> type printed on a new line.</p>",
      "samples": [
        {
          "input": "3 3 5\n1 2\n2 3\n3 1\n2\n1 2\n2\n1 1\n2",
          "output": "1\n1\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Edge Removals",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Consider the following function.</p><pre><code class=\"language-plaintext\">long long get(long long L, long long R, long long m) {\r\n    long long sum = 0;\r\n    for(long long i = L; i &lt;= R; i++) {\r\n        sum += (i % m);\r\n        sum %= 1000000007;\r\n    }\r\n    return sum;\r\n}</code></pre><p>The above program is very inefficient for larger values of <i>L, R, m</i>.<br>Your challenge is to write an efficient program, that will find the value of <strong>get</strong> function in very less time.</p>",
      "complete_approach": "",
      "constraints": "1. $1 \\leq T \\leq 10^5$\n2. $1 \\leq L \\leq R \\leq 10^{18}$\n3. $1 \\leq m \\leq 10^{18}$",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nll cal(ll n) {\n    ll x = n, y = n + 1;\n    if(x % 2 == 0) x /= 2;\n    else y /= 2;\n    x %= mod; y %= mod;\n    ll ans = x * y % mod;\n    if(ans < 0) ans += mod;\n    return ans;\n}\n\nll get(ll n, ll m) {\n    ll t = (n + 1) / m;\n    t %= mod;\n    ll ans = cal(m - 1) * t % mod;\n    n %= m;\n    if(n < 0) n += m;\n    if(n < m - 1) ans += cal(n);\n    ans %= mod;\n    if(ans < 0) ans += mod;\n    return ans;\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int T = 1; cin >> T;\n    assert(T > 0 && T <= 100000);\n    while(T--) {\n        ll L, R, M;\n        cin >> L >> R >> M;\n        assert(L > 0 && R > 0 && L <= R && M > 0 && M <= 1e18);\n        ll ans = get(R, M) - get(L - 1, M);\n        ans %= mod;\n        if(ans < 0) ans += mod;\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:16:47.947507+00:00"
      },
      "hints": {
        "hint1": "<p>Can you solve the problem when '<i>l'</i> is always 1?</p>",
        "hint2": "<p>When <i>l = 1</i>, the pattern will be like that<br>1, 2, 3, ..., <i>m</i> - 1, 0, 1, 2, ..., <i>m</i> - 1, 0, 1, 2, ...., <i>m</i> - 1, ..., 0, 1, 2, ..., (<i>R % m</i>).</p>",
        "solution_approach": "<p>Let's try to solve the problem when '<i>l'</i> is always 1. Let's denote <i>mod = 10<sup>9</sup> + 7</i> and <i>rm = R % m</i>;</p><p>Let <i>F(n, m) = get(1, n, m)</i>. Now <i>get(l, r, m) = (F(r, m) - F(l - 1, m)) % mod.</i> Now how to calculate <i>F(n, m)</i> efficiently?</p><p>Observe the pattern:<br><i>F(n, m) = (0+1+2+3..+(m-1)+0+1+...+(m-1)+0+1+...+(m-1)+...+0+1+2+...+(rm)) % mod.</i></p><p>We can see that the sum <i>0+1+2+3..+(m-1)</i> is repeating <i>(R+1)/m</i> times. And yes, now we can solve the problem.</p><p>If <i>rm</i> == 0: <i>F(n, m) = (m * (m - 1) / 2 * (R / m)) % mod</i><br>Else <i>F(n, m) = (m * (m - 1) / 2 * (R / m) + rm * (rm + 1) / 2) % mod</i></p><p>Now the challenge is that we have to take mod properly so that we can avoid overflow. You can refer through Solution Code to learn how to avoid overflow.</p><p><strong>Time Complexity:</strong> <i>O(1)</i><br><strong>Space Complexity:</strong> <i>O(1) extra space</i></p>"
      },
      "id": 80,
      "input_format": "<p>The first line of input contains one integer <i>T</i> — the number of test cases. Then <i>T</i> test cases follow.<br>The only line of each test case contains three space-separated numbers <i>L, R</i>, and <i>m</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>Sum = (4 % 6 + 5 % 6) % 1000000007 = 9</p><p><i><strong>Explanation 2:</strong></i><br>Sum = (4 % 9 + 5 % 9 + 6 % 9 + 7 % 9 + 8 % 9 + 9 % 9 + 10 % 9) % 1000000007 = 4 + 5 + 6 + 7 + 8 + 0 + 1 = 31</p>",
      "output_format": "<p>For each test case, print a number on a new line denoting the answer return by <strong>get</strong> function in the above program.</p>",
      "samples": [
        {
          "input": "3\n4 5 6\n4 10 9\n1 10000000000000000 93464156618",
          "output": "9\n31\n14972415"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Inefficient Program",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Print all factors of a given number <i>n</i> in ascending order.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n </i>≤ 10<sup>12</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n\nsigned main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\n\tll n;\n\tcin >> n;\n\n\tassert(n > 0 && n <= 1000000000000);\n\n\tset <ll> F;\n\n\tfor(ll i = 1; i * i <= n; i++) {\n\t\tif(n % i == 0) {\n\t\t\tF.insert(i);\n\t\t\tF.insert(n / i);\n\t\t}\n\t}\n\n\tfor(ll u : F) {\n\t\tcout << u << \" \";\n\t}\n\tcout << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:47:31.639928+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p>Use sqrt(n) factor trick discussed in the video.</p>"
      },
      "id": 228,
      "input_format": "<p>The only line of input contains an integer <i>n.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the answer on a new line.</p>",
      "samples": [
        {
          "input": "12",
          "output": "1 2 3 4 6 12"
        },
        {
          "input": "9",
          "output": "1 3 9"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Factorization",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Your task is to find the answer to the following sum.</p><figure class=\"image\"><img src=\"https://lh3.googleusercontent.com/Pg9_ZmO-6k3fD_6Rn2JA5MU8eB4CjF-TwQTPfd2AllMyGWCynn1I-qyqOxvi_CEUtPf8gpBzWrfxAMvpA6_vzuLBRO9gEPUcFzFAgrUIRqbAk2JFsPbqTzwU9TPQHqf1abpAMd2I\"></figure>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i> ≤ 10<sup>12</sup><br>1 ≤ <i>m</i> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint mod = 1e9 + 7;\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\n\ninline void sub(int &a, int b)\n{\n    a -= b;\n    if (a < 0)\n        a += mod;\n}\n\ninline int mul(int a, int b)\n{\n    return (int)((long long)a * b % mod);\n}\n\ninline int power(int a, long long b)\n{\n    int res = 1;\n    while (b > 0)\n    {\n        if (b & 1)\n        {\n            res = mul(res, a);\n        }\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    ll n;\n    int m;\n    cin >> n >> m;\n\n    int ans = 0;\n\n    for (ll i = 1, la; i <= n; i = la + 1)\n    {\n        la = n / (n / i);\n        // n / x yields the same value for i <= x <= la.\n        ll x = n / i;\n        x %= mod;\n        if (x < 0)\n            x += mod;\n        int cur = power(x, m);\n        int y = 1LL * (la - i + 1) % mod;\n        if (y < 0)\n            y += mod;\n        cur = mul(cur, y);\n        add(ans, cur);\n    }\n\n    cout << ans << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:39:47.903518+00:00"
      },
      "hints": {
        "hint1": "Find the largest $x$ such that $\\lfloor\\dfrac{n}{i}\\rfloor = \\lfloor\\dfrac{n}{x}\\rfloor$",
        "hint2": "The value of $\\lfloor\\dfrac{n}{i}\\rfloor$ remains same from $i$ to $la$ where   \nValue of $la=  \\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{i}\\rfloor}\\rfloor$",
        "solution_approach": "So from $i$ to $la$ there are $(la-i+1)$ values. All these will have the same fractional value of $\\lfloor\\dfrac{n}{i}\\rfloor$.  \nThe overall contribution of $\\lfloor\\dfrac{n}{i}\\rfloor$,  will be $(la-i+1)\\times \\lfloor\\dfrac{n}{i}\\rfloor$.   \nIn the same manner we can find the total summation from $i=1$ to $i=N$\n\nThe time complexity of the solution is $O(\\sqrt n * \\log(mod))$.\n\nThe loop in the program iterates over all positive integers $i$ that divide $n$, with a step size of $la-i+1$, where $la$ is the largest integer such that $\\dfrac{n}{la} = \\dfrac{n}{i}$. Since there are $O(\\sqrt n )$ divisors of $n$, the loop iterates $O(\\sqrt n)$ times.\n\nInside the loop, the program uses binary exponentiation to compute the value of $(\\dfrac{n}{i})^m$, which takes $O(\\log(m))$ time."
      },
      "id": 235,
      "input_format": "<p>The only line of input contains two space-separated integers <i>n</i> and <i>m</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the answer on a new line.</p>",
      "samples": [
        {
          "input": "4 2",
          "output": "22"
        },
        {
          "input": "100000000000 100000000",
          "output": "728180943"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Hard Floor",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Find all prime numbers between the range from <i>L</i> to <i>R</i> (endpoints inclusive). Print them in non-decreasing order.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>L</i> ≤ <i>R</i> ≤ 10<sup>12</sup><br><i>R</i> - <i>L</i> + 1 ≤ 10<sup>6</sup>&nbsp;</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvector<bool> segmentedSieve(long long L, long long R)\n{\n    // generate all primes up to sqrt(R)\n    long long lim = sqrt(R);\n    vector<bool> mark(lim + 1, false);\n    vector<long long> primes;\n    for (long long i = 2; i <= lim; ++i)\n    {\n        if (!mark[i])\n        {\n            primes.emplace_back(i);\n            for (long long j = i * i; j <= lim; j += i)\n                mark[j] = true;\n        }\n    }\n\n    vector<bool> isPrime(R - L + 1, true);\n    for (long long i : primes)\n        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)\n            isPrime[j - L] = false;\n    if (L == 1)\n        isPrime[0] = false;\n    return isPrime;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    ll L, R;\n    cin >> L >> R;\n    vector<bool> isPrime = segmentedSieve(L, R);\n\n    set<ll> primes;\n\n    for (int i = 0; i < (int)isPrime.size(); i++)\n    {\n        if (isPrime[i])\n        {\n            primes.insert(i + L);\n        }\n    }\n\n    cout << (int)primes.size() << \"\\n\";\n    for (ll u : primes)\n    {\n        cout << u << \" \";\n    }\n    cout << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:28:05.602453+00:00"
      },
      "hints": {
        "hint1": "To find all primes in a range, we can use the segmented sieve algorithm, which generates primes up to the square root of the upper limit, and then uses those primes to sieve the range in segments.",
        "hint2": "The solution approach uses the segmented sieve algorithm to generate primes in the range [L, R]. First, we generate all primes up to $\\sqrt R$  using the regular sieve of Eratosthenes. Then, we use these primes to sieve the range [L, R] in segments, marking all composite numbers that are multiples of any prime in the prime list. Finally, we output all the unmarked numbers as prime numbers.",
        "solution_approach": "The complete approach begins by generating all primes up to $\\sqrt R$ using the sieve of Eratosthenes. We first initialize a boolean vector mark of size $lim + 1$, where $lim = \\sqrt R $ . We set all elements of mark to false, indicating that all numbers in the range [2, lim] are prime. We then iterate over all numbers from $2$ to $\\sqrt R$, marking all multiples of each prime as composite. At the end of this process, all unmarked numbers are primes, and we store them in a vector called primes.\n\nNext, we use the segmented sieve algorithm to sieve the range [L, R]. We initialize another boolean vector isPrime of size $R - L + 1$, where each element initially corresponds to a number in the range [L, R] and is set to true. For each prime p in the primes vector, we start sieving the range by setting isPrime[j - L] to false for all multiples of p in the range [L, R], starting from the first multiple greater than or equal to $p^2$, to avoid marking composite numbers that are already marked by smaller primes. Finally, we output all unmarked numbers in the isPrime vector as prime numbers.\n\nThe time complexity of the segmented sieve algorithm is $O((R - L + 1) \\log \\log R)$   \n  \nNote: We used a set to store the primes in the solution code to eliminate duplicates and print primes in non-decreasing order. The time complexity of the set operations is O(log n) per insertion or deletion, where n is the number of elements in the set. Since the maximum size of the set is $R - L + 1$ in our case, the total time complexity of set operations is $O((R - L + 1) \\log(R - L + 1))$. However, this is a sub-dominant term in the overall time complexity, and we can ignore it."
      },
      "id": 234,
      "input_format": "<p>The only line of input contains <i>L</i> and <i>R</i>, representing the range.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>The first line of output contains <i>n</i> - the number of prime numbers in between [<i>L, R</i>].<br>The second line contains <i>n</i> space-separated integers denoting the prime numbers between [<i>L, R</i>] in <strong>non-decreasing order</strong>.</p>",
      "samples": [
        {
          "input": "1 20",
          "output": "8\n2 3 5 7 11 13 17 19"
        },
        {
          "input": "100000000000 100000000020",
          "output": "2\n100000000003 100000000019"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Sieve of Eratosthenes Revisited",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an integer array $nums$ of size $n$ and an integer $k$.\n\nFor each index $i$ where $0 \\leq i < n$, change $nums[i]$ to be either $nums[i] + k$ or $nums[i] - k$.\n\nThe **Entropy** of $nums$ is the difference between the maximum and minimum elements in $nums$.\n\nReturn the minimum Entropy of nums after changing the values at each index.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10^{4}$.\n$ 1 \\leq n \\leq 10^{5}$.\n$ 0 \\leq k \\leq 10^{4}$.\n$ 0 \\leq nums[i] \\leq 10^{4}$.\n\nSum of $n$ over all test cases is $\\leq$ $10^{6}$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint Entropy(vector<int>& nums, int k) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    int ans = nums[n - 1] - nums[0];\n    for (int i = 1; i < n; i++) {\n        int mx = max(nums[n - 1] - k, nums[i - 1] + k); // because nums[n-1] may still remain max.\n        int mn = min(nums[0] + k, nums[i] - k); // because nums[0] may still remain min.\n        ans = min(ans, mx - mn);\n    }\n    return ans;\n}\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> v(n);\n    for (int i = 0; i < n; i++)cin >> v[i];\n    cout << Entropy(v, k) << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:47:03.933680+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Assume A is sorted.\n\nIn an optimal solution, some index i will have the maximum item and some index j will have the smallest item. We will iterate from i = 1 to i = len(A) - 2 and consider each index as the maximum item.\n\nImportant Observations:\n\n1. if A[i] is the maximum item, then we must add k to it. (We must either add or subtract; We must add to make the maximum item.)\n2. We must add K to A[0] and subtract K from A[len(A) - 1]\n3. For all indices after i, we must subtract k, in order to maintain A[i] as a maximum. (If after subtracting K from all indices after i, A[i] is not a maximum then we will just pick A[len(A) - 1] to be the maximum as it is not possible for A[i] to be the maximum)\n4. For all indices from 0 ... i - 1 we must add K, because that will allow us to minimize the difference between A[i] and the minimum item if it exists in indices 0 ... i - 1. Remeber we added K to A[i], so adding K to indices 0 ... i -1 maintains the invariant that A[i] is the maximum.\n\n**Time Complexity :** $O(NlogN)$ for sorting."
      },
      "id": 967,
      "input_format": "First-line contains $T$ - the number of test cases.\nFirst line of each test case contains $n$ - the size of the $nums$ and $k$.\nSecond line of each test case contains $n$ elements of $nums$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the minimum Entropy of nums after changing the values at each index.",
      "samples": [
        {
          "input": "3\n3 3\n1 3 6\n1 0\n1\n3 1\n2 2 7\n",
          "output": "3\n0\n3\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Entropy",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "*Gerald of Rivia* also known as *The Witcher* wants to reach the end of the dungeon. The dungeon consists of $n \\times m$ rooms laid out in a $2D$ grid. *Gerald* was initially positioned in the top-left room and must fight his way through, to the bottom-right room of the dungeon, where the exit is located.\n\n*Gerald* has an initial health point represented by a positive integer. If at any point his health point drops to $0$ or below, he dies immediately.\n\nSome of the rooms are guarded by demons (represented by negative integers), so *Gerald* loses health upon entering these rooms; other rooms are either empty (represented as $0$) or contain magic orbs that increase Gerald's health (represented by positive integers).\n\nTo reach the exit as quickly as possible, Gerald decides to move only rightward or downward in each step.\n\nReturn Gerald's minimum initial health so that he can exit the dungeon.\n\nNote that any room can contain threats or power-ups, even the first room Gerald enters and the bottom-right room where the exit is located.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$\n$1 \\leq n \\leq 200$\n$1 \\leq m \\leq 200$\n$-1000 \\leq dungeon[i][j] \\leq 1000$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> dungeon(n, vector<int>(m)), dp(n + 1, vector<int>(m + 1, 1e9));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)cin >> dungeon[i][j];\n    }\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = m - 1; j >= 0; j--) {\n            if (i == n - 1 && j == m - 1)dp[i][j] = max(1, 1 - dungeon[i][j]);\n            else dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\n        }\n    }\n    cout << dp[0][0] << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:27:41.504539+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Let $dp[i][j]$ be the minimum $hp$ we need to reach the exit if we start from point $(i,j)$. Let us consider the following example:\n\n-2\t-3\t+3\n-5\t-10\t+1\n+10\t+30\t-5\n\nLet us add the bottom dummy row and right dummy column to handle border cases more easily. We fill it with infinities, except two ones - neighbors of the exit.\n\nHow we can evaluate $dp[i][j]$? We need to look at two cells: $dp[i+1][j]$ and $dp[i][j+1]$ and evaluate two possible candidates: $dp[i+1][j]-dungeon[i][j]$ and $dp[i][j+1]-dungeon[i][j]$.\n\nIf at least one of these two numbers is negative, it means that we can survive just with $1$ $hp$: (look at number +30 in our table for example)\nIf both these numbers are positive, we need to take the minimum of them, see for example number $-10$ in our table: to survive we need either $5 - -10 = 15$ if we go right and $1 - -10 = 11$ if we go down, of course, we choose $11$.\nThis conditions can be written in one a bit ugly line: $dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1)$.\nFinally, why do we put $1$ to two neighbors of the exit? To make this formula valid for exit cell: if we have a negative number like $-5$ in this cell, we need $6$ $hp$ to survive, if we have a non-negative number in this cell, we need $1$ $hp$ to survive.\n\n7\t5\t2\tinf\n6\t11\t5\tinf\n1\t1\t6\t1\ninf\tinf\t1\t#\n\n**Complexity**: both time and space is $O(m*n)$.\n\n##### Binary Search solution :\nBinary search to choose a $initHealth$ of the Gerald which can survive and reach the bottom left cell.\nMinimum value $left = 1$, maximum value $right = (m+n) * 1000 + 1$ (because in the worst case, value of all cells in the grid is $-1000$).\n\n```\nmid = (left + right) / 2.\nIf isGood(mid) then:\nans = mid\nright = mid - 1 // Minimize init health as much as possible\nElse:\nleft = mid + 1 // Increasing init health\n```\nTo check isGood(initHealth)\n- Gerald has an initial health point in cell $(0, 0)$.\n- Let $dp[r][c]$ denote the maximum health we can get and we can reach from the cell $(0, 0)$ to cell $(r, c)$.\n- Finally, if we found a path which $dp[m-1][n-1] > 0$ means the knight can survive successfully which this initHealth.\n\nTime: $O(M * N * logR)$, where $M <= 200$ is the number of rows, $N <= 200$ is the number of columns, $R = 1000 * (m+n)$ is the binary search range.\nSpace: $O(M * N)$"
      },
      "id": 925,
      "input_format": "First-line contains $T$ - the number of test cases.\nFirst-line of each test case contains $2$ integers $n$ and $m$.\nEach of the next $n$ lines of each test case contains $m$ integers, denoting the values of $n \\times m$ dungeon's rooms.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For test 1: The initial health of Gerald must be at least 7 if he follows the optimal path: Right-> Right -> Down -> Down.",
      "output_format": "For each test case, output Gerald's minimum initial health so that he can exit the dungeon.",
      "samples": [
        {
          "input": "2\n3 3\n-2 -3 3\n-5 -10 1\n10 30 -5\n1 1\n1\n",
          "output": "7\n1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "The Witcher II",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given a dictionary of $N$ words (each word consists of lowercase characters) and $Q$ query words. In each query, you will be given an integer $K$ and a word $S$. We want to design a system that will suggest at most $K$ words from the dictionary after each character of a query word is typed. Suggested words should have a common prefix with the query word. If there are more than $K$ dictionary words with a common prefix, return the $K$ lexicographically minimum words. If there is no word with a common prefix, print a blank line.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ N ≤ 10000.</p><p>1 ≤ MaxLen ≤ 100.</p><p>1 ≤ Q ≤ 100.</p><p>1 ≤ |Length of dictionary or query word| ≤ 100.</p><p>Sum of K across all the queries ≤ 10000.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n// un_coder\n#include <bits/stdc++.h>\ntypedef long long ll;\n#define all(a) a.begin(), a.end()\n#define MOD 1000000007\n#define inf 1e18\n#define ff first\n#define ss second\nusing namespace std;\nvoid solve();\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"error.txt\", \"w\", stderr);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    ll t = 1;\n    // cin>>t;\n    while (t--)\n    {\n        solve();\n        cout << \"\\n\";\n    }\n    cerr << \"time taken : \" << (float)clock() / CLOCKS_PER_SEC << \" secs\" << endl;\n    return 0;\n}\nstruct node\n{\n    int cnt;\n    node *child[26];\n    multiset<string> wend;\n    node()\n    {\n        wend.clear();\n        cnt = 0;\n        for (int i = 0; i < 26; i++)\n            child[i] = NULL;\n    }\n};\nstruct trie\n{\n    node *root;\n    trie()\n    {\n        root = new node;\n    }\n    void insert(string s)\n    {\n        node *cur = root;\n        for (auto c : s)\n        {\n            if (cur->child[c - 'a'] == NULL)\n                cur->child[c - 'a'] = new node;\n            cur = cur->child[c - 'a'];\n            cur->cnt++;\n            cur->wend.insert(s);\n        }\n    }\n    void query(string s, int k)\n    {\n        node *cur = root;\n        for (int i = 0; i < s.length(); i++)\n        {\n            char c = s[i];\n            if (cur->child[c - 'a'] == NULL)\n            {\n                while (i < s.length())\n                {\n                    cout << '\\n';\n                    i++;\n                }\n                continue;\n            }\n            cur = cur->child[c - 'a'];\n            if (cur->wend.size() > 0)\n            {\n                auto it = cur->wend.begin();\n                for (int j = 0; j < k; j++)\n                {\n                    if (it != cur->wend.end())\n                    {\n                        cout << (*it) << \" \";\n                        it++;\n                    }\n                    else\n                        break;\n                }\n            }\n            cout << '\\n';\n        }\n    }\n};\nvoid solve()\n{\n    int n, mlen, q;\n    cin >> n >> mlen >> q;\n    trie t;\n    for (int i = 0; i < n; i++)\n    {\n        int len;\n        string s;\n        cin >> len >> s;\n        t.insert(s);\n    }\n    while (q--)\n    {\n        int len, k;\n        string s;\n        cin >> len >> s >> k;\n        t.query(s, k);\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Editorial code is not passing the Sample cases.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:23:52.138547+00:00"
      },
      "hints": {
        "hint1": "This problem can be solved using Trie data structure.",
        "hint2": "We can insert all the given words in a trie data structure. Then for each query word, we can traverse through the trie starting from the root, and for each character of the query word, we can move to the corresponding child node of the current node in the trie. While traversing, we can keep track of the set of words that end at each node of the trie. Once we reach the end of the query word, we can print the set of words that end at the current node, up to a maximum of K lexicographically smallest words.",
        "solution_approach": "For each query word, we traverse the trie starting from the root, and for each character of the query word, we move to the corresponding child node of the current node in the trie. While traversing, we keep track of the set of words that end at each node of the trie. Once we reach the end of the query word, we print the set of words that end at the current node, up to a maximum of K lexicographically smallest words."
      },
      "id": 426,
      "input_format": "<p>The first line contains 3 space-separated integers <i>N, MaxLen, Q</i>- the number of words in the dictionary, the maximum length of a dictionary or query word, the number of queries.</p><p>The next <i>N</i> lines contain an integer denoting the length of the word and a string denoting the word in the dictionary.</p><p>The next <i>Q</i> lines contain an integer denoting the length of the word, a string denoting the query word, and an integer <i>K</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "For each query, after every character print at most K lexicographically minimum space-separated dictionary words in a new line. Words should be printed in lexicographical order. If there is no word print a blank line.",
      "samples": [
        {
          "input": "5 5 5\n5 abcde\n4 abcd\n4 abcc\n3 abc\n1 a\n5 abcde 2\n3 xyz 100\n2 ae 100\n3 abc 5\n4 abcc 2",
          "output": "a abc \nabc abcc \nabc abcc \nabcd abcde \nabcde \n\n\n\na abc abcc abcd abcde \n\na abc abcc abcd abcde \nabc abcc abcd abcde \nabc abcc abcd abcde \na abc \nabc abcc \nabc abcc \nabcc"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Auto Suggestion",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given an array <i>A</i> of <i>N</i> elements. An <i><strong>Inversion Count</strong></i> of the array is defined as the number of pairs (i, j) such that <i>A<sub>i</sub> &gt; A<sub>j</sub></i> and i &lt; j.<br>Find the <i>Inversion Count</i> in <i>A.</i></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n\n#define ll long long int\n\n#define LD long double\n\n\n\nconst int N = 100010;\n\n\n\nint inf = 1e9;\n\nint mod = 1e9 + 7;\n\n\n\nlong long solve(vector<int> &A, int l, int r) {\n\n    if(l > r) return 0;\n\n    if(l == r) return 0;\n\n    if(r - l == 1) {\n\n        if(A[r] < A[l]) {\n\n            swap(A[r], A[l]);\n\n            return 1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    int mid = (l + r) / 2;\n\n\n\n    long long ans = solve(A, l, mid) + solve(A, mid + 1, r);\n\n\n\n    int ptr = mid + 1;\n\n    for(int i = l; i <= mid; i++) {\n\n        while(ptr <= r && A[ptr] < A[i])\n\n            ptr++;\n\n        ans += 1LL * (ptr - mid - 1);\n\n    }\n\n    vector<int> temp;\n\n    for(int i = l; i <= r; i++)\n\n        temp.push_back(A[i]);\n\n    sort(temp.begin(), temp.end());\n\n    for(int i = l; i <= r; i++)\n\n        A[i] = temp[i - l];\n\n    return ans;\n\n}\n\n\n\nsigned main()\n\n{\n\n    //freopen(\"IN\", \"r\", stdin);\n\n    //freopen(\"OUT\", \"w\", stdout);\n\n\n\n    ios_base::sync_with_stdio(0);\n\n    cin.tie(0); cout.tie(0);\n\n\n\n    int T; cin >> T;\n\n    while(T--) {\n\n        int n; cin >> n;\n\n        vector<int> A(n);\n\n        for(int i = 0; i < n; i++) cin >> A[i];\n\n        cout << solve(A, 0, n - 1) << \"\\n\";\n\n    }\n\n    return 0;\n\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:43:45.493250+00:00"
      },
      "hints": {
        "hint1": "<p>We can solve this problem in <i>O(N<sup>2</sup>)</i>, by maintaining two loops, one for <i>i</i> and other for <i>j</i>. <i>Can you do better?</i></p>",
        "hint2": "<p>Assume that we want to find Inversion Count in the range <i>[l, r]</i>. Let's denote it by <i>I(l, r)</i>. Suppose we know the inversion count in the range <i>[l, mid]</i> and <i>[mid+1, r]</i>, here <i>mid=(l+r)/2</i>. It's assumed that we are handling edge cases correctly. Now observe that <i>I(l, r) = I(l, mid) + I(mid + 1, r) + Extra</i>. How to calculate these <i>\"Extra\"</i> inversions. Yes, you guess correctly, it is <i><strong>Divide and Conquer </strong></i>!!!</p>",
        "solution_approach": "<p>As mentioned in hints, assume that we want to find Inversion Count in the range <i>[l, r]</i>. Let's denote it by <i>I(l, r)</i>. Suppose we know the inversion count in the range <i>[l, mid]</i> and <i>[mid+1, r]</i>, here <i>mid=(l+r)/2</i>. It's assumed that we are handling edge cases correctly. Now observe that <i>I(l, r) = I(l, mid) + I(mid + 1, r) + Extra</i>. To calculate <i>Extra</i>, we have to find all inversion pairs <i>(i, j)</i> such that <i>i</i> belongs to <i>[l, mid]</i> and <i>j</i> belongs to <i>[mid + 1, r]</i> and <i>A<sub>i</sub> &gt; A<sub>j</sub></i>. Yes, it is a divide and conquers trick. It is similar to what we do in Merge Sort.</p><p><strong>Time Complexity:</strong> <i>O(NlogN)</i><br><strong>Space Complexity:</strong> <i>O(N) extra space</i></p>"
      },
      "id": 22,
      "input_format": "<p>The first line of input contains one integer <i>T</i> (1 ≤ <i>T</i> ≤ 10<sup>5</sup>) — the number of test cases. Then <i>T</i> test cases follow.<br>The first line of each test case contains <i>N</i> (2 ≤ <i>N</i> ≤ 10<sup>5</sup>), the number of elements in an array <i>A</i>.<br>The second line contains <i>N</i> space-separated integers <i>A<sub>1</sub>, A<sub>2</sub>, …, A<sub>N, </sub></i>(0 ≤ <i>A<sub>i </sub></i>≤ 10<sup>9</sup>)<br>It is guaranteed that the sum of <i>N</i> over all test cases does not exceed 5 x 10<sup>5</sup>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>Inversion Pairs are (8, 4), (8, 2), (8, 1), (4, 2), (4, 1), (2, 1).</p><p><i><strong>Explanation 2:</strong></i><br>Inversion Pairs are (3, 1), (3, 2).</p><p><i><strong>Explanation 3:</strong></i><br>There are no Inversion Pairs. And hence, 0 Inversion Count.</p>",
      "output_format": "<p>For each test case, print the answer on a new line denoting the <i>Inversion Count</i>.</p>",
      "samples": [
        {
          "input": "3\n4\n8 4 2 1\n3\n3 1 2\n6\n1 2 3 4 5 5",
          "output": "6\n2\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Count Inversions",
      "video_editorial_id": 8128
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have been given a vertical grid of size <i>N</i> x 10, and a number <i>K</i>. Since it's vertical, gravity shows its effect on it. Each cell in the grid contains a ball which has some colour. Colour values can vary between 1 to 9<i>.</i><br>Each cell in the grid is represented by a number, <i>c<sub>ij </sub></i>for cell (<i>i, j</i>). If <i>c<sub>ij</sub> </i>= 0, then the cell (<i>i, j</i>) is empty. Otherwise, it contains a ball with colour <i>c<sub>ij</sub>. </i><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Each cell is either empty (indicated by a 0), or a ball in one of nine different colours (indicated by characters 1..9). Gravity causes balls to fall downward, so there is never a 0 cell below a ball.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Two cells belong to the same connected region if they are directly adjacent either horizontally or vertically, and they have the same non-zero </span>colour<span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">. Any time a connected region exists with at least <i>K</i> cells, its balls all disappear, turning into zeros. If multiple such connected regions exist at the same time, they all disappear simultaneously. Afterwards, gravity might cause balls to fall downward to fill some of the resulting cells that became zeros. In the resulting configuration, there may again be connected regions of size at least <i>K</i> cells. If so, they also disappear (simultaneously, if there are multiple such regions), then gravity pulls the remaining balls downward, and the process repeats until no connected regions of size at least <i>K</i> exist.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Given the initial vertical grid, your task is to output a final picture of the grid after these operations have occurred.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>N</i> ≤ 100<br>1 ≤ <i>K</i> ≤ 10<i>N</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nint N, K, board[100][10], region[100][10], regsizes[1001];\n\nvoid gravity(void)\n{\n    for (int j=0; j<10; j++) {\n        int top = N-1, bottom = N-1;\n        while (top >= 0) {\n            while (top >= 0 && board[top][j] == 0) top--;\n            if (top >= 0)\n                board[bottom--][j] = board[top--][j];\n        }\n        while (bottom >= 0) board[bottom--][j] = 0;\n    }\n}\n\nvoid visit(int i, int j, int r, int c)\n{\n    if (i<0 || i>=N || j<0 || j>9 || board[i][j]!=c || region[i][j]!=0) return;\n    region[i][j] = r;\n    regsizes[r]++;\n    visit(i-1,j,r,c);\n    visit(i+1,j,r,c);\n    visit(i,j-1,r,c);\n    visit(i,j+1,r,c);\n}\n\nbool iterate(void)\n{\n    int r = 1;\n    for (int i=0; i<N; i++)\n        for (int j=0; j<10; j++)\n            region[i][j] = 0;\n    for (int i=0; i<N; i++)\n        for (int j=0; j<10; j++)\n            if (board[i][j] && !region[i][j]) visit(i,j,r++,board[i][j]);\n    bool progress = false;\n    for (int i=0; i<N; i++)\n        for (int j=0; j<10; j++)\n            if (board[i][j] && regsizes[region[i][j]]>=K) {\n                board[i][j] = 0;\n                progress = true;\n            }\n    gravity();\n    while (r) regsizes[r--] = 0;\n    return progress;\n}\n\nint main(void)\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> N >> K;\n    string s;\n\n    for (int i=0; i<N; i++) {\n        cin >> s;\n        for (int j=0; j<10; j++) board[i][j] = s[j]-'0';\n    }\n\n    while (iterate());\n\n    for (int i=0; i<N; i++) {\n        for (int j=0; j<10; j++) cout << board[i][j];\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:47:47.765843+00:00"
      },
      "hints": {
        "hint1": "<p>Try to figure out the different components of the solution.</p>",
        "hint2": "<p>There are three components to this implementation problem:</p><ul><li>Figuring out which cells should be deleted</li><li>Deleting them</li><li>Applying gravity</li></ul><p>Once we have implementations for these, we can simply repeatedly do these things in order until no cells should be deleted, and then output the state.</p>",
        "solution_approach": "<p>To figure out which cells should be deleted, we first consider every cell in the array in sequence. We start a flood fill from that cell if the cell is nonempty (and hasn't already been handled by a previous flood fill). We keep track of all points that we touch with the flood fill in an array. If the array's length ends up being larger than <i>K</i>, then all those points need to be deleted.</p><p>To delete cells, we just replace them in the array with '0'. We can even do this after each flood-fill, and we don't need to wait until we've finished flood-filling all the regions.</p><p>Finally, to apply gravity, we can simply count the number of '0' squares in each column (from the bottom going up) until we reach an occupied square. Then, we shift that column down by that number of squares.</p>"
      },
      "id": 415,
      "input_format": "The first line of input contains *N* and *K*. The remaining *N* lines specify the initial state of the vertical grid.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "In the example above, if *K* = 3, then there is a connected region of size at least *K* with colour 1 and also one with colour 2. Once these are simultaneously removed, the grid temporarily looks like this:\n\n```\n0000000000\n0000000300\n0054000300\n1054500030\n2200000000\n0000000003\n```\n\nThen, gravity takes effect and the balls drop to this configuration:\n\n```\n0000000000\n0000000000\n0000000000\n0000000000\n1054000300\n2254500333\n```\n\nAgain, there is a region of size at least *K* (with colour 3). Removing it yields the final grid configuration:\n\n```\n0000000000\n0000000000\n0000000000\n0000000000\n1054000000\n2254500000\n```",
      "output_format": "Please output *N* lines, describing a picture of the final vertical grid.",
      "samples": [
        {
          "input": "6 3\n0000000000\n0000000300\n0054000300\n1054502230\n2211122220\n1111111223",
          "output": "0000000000\n0000000000\n0000000000\n0000000000\n1054000000\n2254500000"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Vertical Grid",
      "video_editorial_id": 8200
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given an array <i>A</i> of <i>n</i> elements. Your task is to process <i>q</i> queries of the following types.</p><ul><li>1 <i>i j</i> <i>x</i> : Increase each value at positions from [<i>i, j</i>] by <i>x</i>.</li><li>2 <i>i</i> : Print the value at position <i>i</i>.</li></ul>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i>, <i>q </i>≤ 2 x 10<sup>5</sup><br>1 ≤ <i>A<sub>i</sub>, x </i>≤ 10<sup>9</sup><br>1 ≤ <i>i </i>≤ <i>n</i><br>1 ≤ <i>i </i>≤ <i>j </i>≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 200010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nll tree[4 * N];\n\nvoid update(int node, int start, int end, int l, int r, int val) {\n    if(start > r || end < l) return;\n    if(start >= l && end <= r) {\n        tree[node] += val;\n        return;\n    }\n    int mid = (start + end) / 2;\n    update(2 * node, start, mid, l, r, val);\n    update(2 * node + 1, mid + 1, end, l, r, val);\n}\n\nll query(int node, int start, int end, int idx) {\n    if(start == end) return tree[node];\n    int mid = (start + end) / 2;\n    if(idx <= mid) return tree[node] + query(2 * node, start, mid, idx);\n    return tree[node] + query(2 * node + 1, mid + 1, end, idx);\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n\n    for(int i = 0; i < n; i++) {\n        int x; cin >> x;\n        update(1, 0, n - 1, i, i, x);\n    }\n\n    while(q--) {\n        int t;\n        cin >> t;\n        if(t == 1) {\n            int i, j, x;\n            cin >> i >> j >> x;\n            i--; j--;\n            update(1, 0, n - 1, i, j, x);\n        }\n        else {\n            int i;\n            cin >> i;\n            i--;\n            cout << query(1, 0, n - 1, i) << \"\\n\";\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:32:52.106092+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p>Interchange the implementation of <i>query</i> and <i>update</i> part in the segment tree. For each query of the 2nd type, the value at index <i>i</i> will be the sum of values from root to the leaf node representing that index. For the update query of the 1st type, add the value to each logN nodes that completely lies within that range.</p><p>For more clarity, please see the editorial code.</p>"
      },
      "id": 402,
      "input_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">The first input line has two integers <i>n</i> and <i>q</i>: the number of values and queries.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">The second line has <i>n</i> integers <i>A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub></i>: the array values.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Finally, there are <i>q</i> lines describing the queries. Each line has three integers: either \"1 <i>i j x</i>\" or \"2 <i>i</i>\".</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Print the result of each query of type 2.</span></p>",
      "samples": [
        {
          "input": "8 3\n3 2 4 5 1 1 5 3\n2 4\n1 2 5 1\n2 4",
          "output": "5\n6"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Range  Queries II",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$ and a string $S$ of size $N$ consisting of $5$ different uppercase characters only $\\textbf{(V,W,X,Y,Z)}$.\n\n1. $\\textbf{V}$: Adds to the score $5$ points.\n2. $\\textbf{W}$: Adds to the score $2$ points.\n3. $\\textbf{X}$: Removes the next consecutive character from the string.\n4. $\\textbf{Y}$: Moves the next consecutive character to the end of the string.\n5. $\\textbf{Z}$: If the next consecutive character is $V$ it divides the total score by $5$ but if it is $W$ it divides the total score by 2. Then it removes the next consecutive character from the string if and only if the next character is $V$ or $W$.\n\nNote: In case the string ends with $X$ or $Y$ or $Z$ ignore their operations. The score is calculated from $left$ to $right$ and starts with $0$.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N \\leq 10^6 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solution() {\n    int n; cin >> n;\n    string s; cin >> s;\n    int score = 0;\n    for (int i = 0; i < n; i++) {\n        char c = s[i];\n        switch (c) {\n        case 'V':\n            score += 5;\n            break;\n        case 'W':\n            score += 2;\n            break;\n        case 'Z':\n            if (i != n - 1) {\n                if (s[i + 1] == 'W') {\n                    score /= 2;\n                    s[i + 1] = '0';\n                } else if (s[i + 1] == 'V') {\n                    score /= 5;\n                    s[i + 1] = '0';\n                }\n            }\n            break;\n        case 'Y':\n            if (i != n - 1) {\n                s.push_back(s[i + 1]);\n                n++;\n                s[i + 1] = '0';\n            }\n            break;\n        case 'X':\n            if (i != n - 1) {\n                s[i + 1] = '0';\n            }\n        }\n    }\n    cout << score;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:34:30.379323+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Just do the operations according to the question and for deleting the next consecutive element just make it 0 such that it won't contribute anything to the score."
      },
      "id": 1199,
      "input_format": "The first line contains a number $N$ the length of the string.\nThe second line contains a string $S$.\n$\\textbf{It's guaranteed that S consists of only (V,W,X,Y,Z) letters.}$",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "$\\textbf{Test 1}$:\n\nString $S = \"VYWZW\"$ and score initially = $0$ .\n\nFirst char is $'V'$ so add 5 to score and become $5$.\n\nSecond char is $'Y'$ then move $'W'$ to end of string and it become $\"VYZWW\"$ and score = $5$.\n\nThird char is $'Z'$ then divide total score by $2$ because next char is $'W'$ and remove it so string become $\"VYZW\"$ and score = $2$.\n\nFourth char is $'W'$ so add $2$ to score and become $4$.\n\nSo final answer is $4$.",
      "output_format": "The total score of string.",
      "samples": [
        {
          "input": "5\nVYWZW\n",
          "output": "4\n"
        },
        {
          "input": "6\nWZYVXW\n",
          "output": "7\n"
        },
        {
          "input": "5\nVVVVW\n",
          "output": "22\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "String Score",
      "video_editorial_id": 10651
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You need to design and implement a data structure that is able to handle different types of queries. The data structure has a capacity <strong>n </strong>and at any moment it cannot store more than <strong>n </strong>keys. Implement the <strong>LFUCache </strong>class:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\"><strong>LFUCache(int n):</strong> Initializes the object with the capacity n of the data structure.</span></li><li><span style=\"background-color:transparent;color:#000000;\"><strong>int get(int key): </strong>Gets the value of the key if the key exists in the cache. Otherwise, returns <strong>-1</strong>.</span></li><li><span style=\"background-color:transparent;color:#000000;\"><strong>void put(int key, int value): </strong>Update the value of the key if present, or insert the key if not already present. When the cache reaches its capacity, it should invalidate and remove the <strong>least frequently used</strong> key before inserting a new item. For this problem, when there is a<strong> tie</strong> (i.e., two or more keys with the same frequency), the <strong>least recently used</strong> key would be invalidated.</span></li></ol><p><span style=\"background-color:transparent;color:#000000;\">To determine the least frequently used key, a <strong>use counter</strong> is maintained for each key in the cache. The key with the smallest <strong>use counter</strong> is the least frequently used key.</span><br><span style=\"background-color:transparent;color:#000000;\">When a key is first inserted into the cache, its <strong>use counter</strong> is set to 1 (due to the put operation). The <strong>use counter</strong> for a key in the cache is incremented; either a <strong>get</strong> or <strong>put</strong> operation is called on it.</span><br><span style=\"background-color:transparent;color:#000000;\">The <strong>least recently used </strong>key is the key with the smallest frequency which was called on the earliest among all the keys with the smallest frequency.</span></p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 10000\n1 &lt;= q &lt;= 10000 (total number of function calls)\n1 &lt;= key &lt;= 10000\n0 &lt;= value &lt;= 10000</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass LFUCache {\npublic:\n\n\tint siz = 0;\n\tint min_freq;\n\tint capacity;\n\tunordered_map <int, pair<int, int>> cache; //key to {value,freq};\n\tunordered_map <int, list<int>::iterator> freqIter; //key to list iterator;\n\tunordered_map <int, list<int>>  freq;  //freq to key list;\n\n\tLFUCache(int n) {\n\t\tcapacity = n;\n\t}\n\n\tint get(int key) {\n\t\tif (cache.count(key) == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tfreq[cache[key].second].erase(freqIter[key]);\n\t\t\tcache[key].second++;\n\t\t\tfreq[cache[key].second].push_back(key);\n\t\t\tfreqIter[key] = --freq[cache[key].second].end();\n\t\t\tif (freq[min_freq].size() == 0)\n\t\t\t\tmin_freq++;\n\t\t\treturn cache[key].first;\n\t\t}\n\t}\n\n\tvoid put(int key, int value) {\n\t\tif (cache.find(key) != cache.end()) {\n\t\t\tfreq[cache[key].second].erase(freqIter[key]);\n\t\t\tcache[key].second++;\n\t\t\tfreq[cache[key].second].push_back(key);\n\t\t\tfreqIter[key] = --freq[cache[key].second].end();\n\t\t\tif (freq[min_freq].size() == 0)\n\t\t\t\tmin_freq++;\n\t\t\tcache[key].first = value;\n\n\t\t}\n\t\telse {\n\t\t\tif (siz == capacity) {\n\t\t\t\tcache.erase(freq[min_freq].front());\n\t\t\t\tfreqIter.erase(freq[min_freq].front());\n\t\t\t\tfreq[min_freq].pop_front();\n\t\t\t\tsiz--;\n\t\t\t}\n\t\t\tcache[key] = {value, 1};\n\t\t\tfreq[1].push_back(key);\n\t\t\tfreqIter[key] = --freq[1].end();\n\t\t\tmin_freq = 1;\n\t\t\tsiz++;\n\t\t}\n\t}\n\n};\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint n, q;\n\tcin >> n >> q;\n\tLFUCache* obj = new LFUCache(n);\n\twhile (q--) {\n\t\tstring op;\n\t\tcin >> op;\n\t\tif (op == \"get\") {\n\t\t\tint key;\n\t\t\tcin >> key;\n\t\t\tcout << obj->get(key) << \"\\n\";\n\t\t}\n\t\telse if (op == \"put\") {\n\t\t\tint key, value;\n\t\t\tcin >> key >> value;\n\t\t\tobj->put(key, value);\n\t\t}\n\t}\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:32:48.005977+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Can we keep the keys sorted first by frequency and then by the timestamp when they were last called on?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">We can store the keys in a set with a pair { frequency ,timestamp} such that the least frequent key is on the top and if there are multiple keys then the least recently used key is on the top.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">We use a map to store the values of the keys. The frequency of the keys and the last timestamp at which they were used also need to be stored. To answer queries of type 2, the keys need to be sorted by frequency and then by the last timestamp when they were used. To do this we insert the keys into a set with the pair {frequency ,timestamp} so that the keys are sorted by frequency and things having the same frequency are sorted according to the last timestamp when they were called on.</span><br><span style=\"background-color:transparent;color:#000000;\">To answer queries of type 1, we just print the value of the key if it is present and update the frequency and timestamp of the key.</span><br><span style=\"background-color:transparent;color:#000000;\">For type 2 queries, if the key is present the value, timestamp and&nbsp; frequency of the key are updated. If the key is not present, the key is inserted into the cache.</span><br><span style=\"background-color:transparent;color:#000000;\">If the cache had reached its limit, the key present at the beginning of the set is erased.</span><br><span style=\"background-color:transparent;color:#000000;\">This problem can also be solved in O(1) per query using the <strong>list</strong> container in C++ STL (doubly linked-lists) which allows faster insertion and deletion. We store buckets of frequency where each bucket stores all the keys having that frequency. We also have to store the location (iterator in C++) in the bucket for each key so that we can delete the keys in O(1). When we use a key we delete it from its previous bucket and insert the key into the new bucket.</span><br><span style=\"background-color:transparent;color:#000000;\">Since things are added sequentially at the end of each bucket, the Least Recently used key will always be at the front of the bucket. So we can delete the first element of the minimum frequency bucket.</span></p>"
      },
      "id": 641,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">Your LFUCache object will be instantiated and called as such:</span></p><pre><code class=\"language-plaintext\">LFUCache* obj = new LFUCache(n);&nbsp;\nint param_1 = obj-&gt;get(key);\nobj-&gt;put(key,value);</code></pre>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">1) Cache = [5] , cnt[5] = 1</span><br><span style=\"background-color:transparent;color:#000000;\">2) Cache = [7 ,5], cnt[5] = 1 cnt[7] = 1</span><br><span style=\"background-color:transparent;color:#000000;\">3) 6 is printed. Cache = [5 ,7], cnt[5] = 2 cnt[7] = 1</span><br><span style=\"background-color:transparent;color:#000000;\">4) 7 is the least frequently used key so it is removed.</span><br><span style=\"background-color:transparent;color:#000000;\">&nbsp; &nbsp; &nbsp;Cache = [3 ,5] , cnt[5] = 2 cnt[3] =1</span><br><span style=\"background-color:transparent;color:#000000;\">5) 7 is not present. So, -1 is printed.</span><br><span style=\"background-color:transparent;color:#000000;\">6) 3 is printed. Cache = [3 ,5], cnt[5] = 2 cnt[3] =2</span><br><span style=\"background-color:transparent;color:#000000;\">7) 3 and 5 both have the same frequency but 5 is the least recently used so it is removed.</span><br><span style=\"background-color:transparent;color:#000000;\">&nbsp; &nbsp; Cache = [4 ,3] , cnt[4] = 1 cnt[3] =2</span><br><span style=\"background-color:transparent;color:#000000;\">8) 5 is not present. So, -1 is printed.</span><br><span style=\"background-color:transparent;color:#000000;\">9) 3 is printed. Cache = [3 ,4], cnt[4] = 1 cnt[3] = 3</span><br><span style=\"background-color:transparent;color:#000000;\">10) 9 is printed. Cache = [4 ,3], cnt[4] = 2 cnt[3] = 3.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each <strong>get </strong>query the value of the key is printed and if the key is not present, ‘-1’ is printed.</span></p>",
      "samples": [
        {
          "input": "2 10\nput 5 6\nput 7 4\nget 5\nput 3 3\nget 7\nget 3\nput 4 9\nget 5\nget 3\nget 4",
          "output": "6\n-1\n3\n-1\n3\n9"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nclass LFUCache {\npublic:\n\n\tLFUCache(int n) {\n\t\t\n\t}\n\n\tint get(int key) {\n\t\t\n\t}\n\n\tvoid put(int key, int value) {\n\t\t\n\t}\n\n};\n\n<fix>\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint n, q;\n\tcin >> n >> q;\n\tLFUCache* obj = new LFUCache(n);\n\twhile (q--) {\n\t\tstring op;\n\t\tcin >> op;\n\t\tif (op == \"get\") {\n\t\t\tint key;\n\t\t\tcin >> key;\n\t\t\tcout << obj->get(key) << \"\\n\";\n\t\t}\n\t\telse if (op == \"put\") {\n\t\t\tint key, value;\n\t\t\tcin >> key >> value;\n\t\t\tobj->put(key, value);\n\t\t}\n\t}\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "LFU Cache",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Implement a queue using 2 stacks. You will be given the following type of Q queries:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">push x - add x to the queue</span></li><li><span style=\"background-color:transparent;color:#000000;\">pop - pop the front element of the queue, you also have to print the element you have popped.</span></li><li><span style=\"background-color:transparent;color:#000000;\">front - find the element at the front of the queue</span></li></ol>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ Q ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ X ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of Q over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>6</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n  int q;\n  cin >> q;\n  stack<int> s1, s2;\n  while (q--) {\n    string s;\n    cin >> s;\n    if (s == \"push\") {\n      int x;\n      cin >> x;\n      s1.push(x);\n    }\n    if (s == \"pop\") {\n      if (!s2.empty()) {\n        int a = s2.top();\n        s2.pop();\n        cout << a << endl;\n      } else {\n        while (!s1.empty()) {\n          s2.push(s1.top());\n          s1.pop();\n        }\n        int a = s2.top();\n        s2.pop();\n        cout << a << endl;\n      }\n    }\n    if (s == \"front\") {\n      if (!s2.empty()) {\n        int a = s2.top();\n        cout << a << endl;\n      } else {\n        while (!s1.empty()) {\n          s2.push(s1.top());\n          s1.pop();\n        }\n        int a = s2.top();\n        cout << a << endl;\n      }\n    }\n  }\n}\n\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int _t = 1;\n  cin >> _t;\n  while (_t--) {\n    solve();\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:32:54.867498+00:00"
      },
      "hints": {
        "hint1": "A queue is a data structure that follows the First-In-First-Out (FIFO) principle, meaning that the first element added to the queue is the first one to be removed.",
        "hint2": "",
        "solution_approach": "To implement a queue using two stacks, we can use the following idea:\nWe have two stacks, stack1 and stack2.\nTo add an element to the queue, we simply push it onto stack1.\nTo remove an element from the queue, we first check if stack2 is empty. If it is, we transfer all the elements from stack1 to stack2 in reverse order. This ensures that the elements are in the correct order for a queue (the first element added to stack1 becomes the last element in stack2, and so on). After that, we simply pop the top element from stack2.\nTo retrieve the front element of the queue without removing it, we work similarly to the pop method, but instead of popping the top element from stack2, we return it.\n\nFor Time complexity, It's difficult to see for each query. Try to see the number of operations on each element that is inserted at least once. 1. Push on S1, 2. Move from S1 to S2 (Pop and Push), 3. Pop from S2. So total amount of work done on each element is $O(1)$. So sum across all queries is bounded by $O(Q)$ [Armotization in action].\n\nTime Complexity per test case - $O(Q)$\nTherefore, the overall time complexity for processing all the test cases would be $O(TQ)$, where $T$ is the number of test cases."
      },
      "id": 350,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer Q - the number of queries</span></p><p><span style=\"background-color:transparent;color:#000000;\">Each of the next Q lines contain the queries.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<ol><li><span style=\"background-color:transparent;color:#000000;\">Queue becomes: [3]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Queue becomes: [3, 5]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Queue becomes [5] and element at front was 3</span></li><li><span style=\"background-color:transparent;color:#000000;\">Queue becomes [5]&nbsp; and element at front is 5</span></li><li><span style=\"background-color:transparent;color:#000000;\">Queue becomes [5, 7]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Queue becomes [7] and element at front was 5</span></li><li><span style=\"background-color:transparent;color:#000000;\">Queue becomes empty and element at front was 7</span></li></ol>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the required queries.</span></p>",
      "samples": [
        {
          "input": "1\n7\npush 3\npush 5\npop\nfront\npush 7\npop\npop\n",
          "output": "3\n5\n5\n7\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Queue using 2 Stacks AZ101",
      "video_editorial_id": 8184
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a tree consisting of <i>n</i> nodes. The diameter of a tree is the maximum distance between two nodes. Your task is to determine the diameter of the tree.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n </i>≤ 2 x 10<sup>5</sup><br>1 ≤ <i>a</i>, <i>b </i>≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n \n#define ll long long int\n#define LD long double\n \nconst int N = 200010;\n \nint inf = 1e9;\nint mod = 1e9 + 7;\n \nvector<int> graph[N];\nint diameter = 0;\n \nint findDiameter(int cur, int prev) {\n    int maxi1 = 0, maxi2 = 0;\n    for(int u : graph[cur]) {\n        if(u == prev) continue;\n        int len = findDiameter(u, cur);\n        if(len >= maxi1) {\n            maxi2 = maxi1;\n            maxi1 = len;\n        }\n        else if(len > maxi2) {\n            maxi2 = len;\n        }\n    }\n    diameter = max(diameter, maxi1 + maxi2 + 1);\n    return maxi1 + 1;\n}\n \nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n \n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n \n    int n; cin >> n;\n    for(int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n \n    findDiameter(1, -1);\n \n    cout << diameter - 1 << \"\\n\";\n \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:16:40.868910+00:00"
      },
      "hints": {
        "hint1": "To determine the diameter of a tree, which is the maximum distance between any two nodes, you can use a depth-first search (DFS) algorithm.",
        "hint2": "",
        "solution_approach": "Choose any node in the tree as the starting point.\n\nPerform a DFS traversal from the starting node to find the farthest node from it. During the traversal, keep track of the maximum distance reached and the corresponding node.\n\nOnce you've reached the farthest node, perform another DFS traversal starting from that node. Again, keep track of the maximum distance reached and the corresponding node.\n\nThe maximum distance obtained from the second traversal is the diameter of the tree.\n\nTime Complexity : 2 dfs traversals, O(N)"
      },
      "id": 427,
      "input_format": "<p>The first input line contains an integer <i>n</i>: the number of nodes. The nodes are numbered 1, 2, …, <i>n</i>.<br>Then there are <i>n </i>− 1 lines describing the edges. Each line contains two integers <i>a</i> and <i>b</i>: there is an edge between nodes <i>a</i> and <i>b</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>The diameter corresponds to the path 2→1→3→5.</p>",
      "output_format": "<p>Print the diameter of the tree.</p>",
      "samples": [
        {
          "input": "5\n1 2\n1 3\n3 4\n3 5",
          "output": "3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Tree Diameter - I",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given a string $S$ with length $N$. Each character is assigned a cost for removing it. Find the minimum cost for removing characters such that it does not contain any subsequence `hard`.",
      "complete_approach": "",
      "constraints": "<p>1≤ T ≤ 1000</p><p>1≤ N ≤ 10^5</p><p>1≤ Ai ≤ 10^9</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\n\nsigned main() {\n   IOS\n   int t;\n   cin >> t;\n   while(t--) {\n       int n;\n       string s;\n       cin >> n >> s;\n       int a[n];\n       for (int i = 0; i < n; ++i) {\n           cin >> a[i];\n       }\n       int dp[4] = {0};\n       for (int i = 0; i < n; ++i) {\n           if(s[i] == 'h') dp[0] += a[i];\n           else if (s[i] == 'a') dp[1] = min(dp[0], dp[1] + a[i]);\n           else if (s[i] == 'r') dp[2] = min(dp[1], dp[2] + a[i]);\n           else if (s[i] == 'd') dp[3] = min(dp[2], dp[3] + a[i]);\n       }\n       cout << dp[3] << \"\\n\";\n   }\n   return 0;\n}```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-04-08T01:35:42.589297+00:00"
      },
      "hints": {
        "hint1": "Define DP array, DP[4] where DP[i] denotes the cost of not being able to form a prefix of length i of ‘hard’",
        "hint2": "Iterate through the given string, if we encounter any character of ‘hard’, we have two choices, remove the current character or remove the previous character (in case of ‘h’, there is no previous character).",
        "solution_approach": "Iterate through the given string, if we encounter any character $j$ of `hard`, we have two choices and we take the minimum of the two. You can remove the current character, which will make your cost $DP[j] + A[i]$ or you can remove the previous character, which will make your cost $DP[j-1]$.\n\n**Time Complexity per test case:** $O(N)$"
      },
      "id": 182,
      "input_format": "- The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\n- The first line of each test case contains one integer $N$ - the length of the array.\n- The second line of each test case contains a string $S$.\n- The third line of each test case contains $N$ space-separated integers - the cost of removing a character.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the minimum cost for removing characters such that it does not contain any subsequence ‘hard’.",
      "samples": [
        {
          "input": "3\n4\nabcd\n1 2 3 4\n10\nhhhaaarrdd\n1 2 3 4 1 2 3 4 2 3\n4\nhard\n2 1 4 6",
          "output": "0\n5\n1"
        }
      ],
      "status": "CREATED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 6,
      "title": "Hard Problem",
      "video_editorial_id": 8163
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given two polynomials of degree <i>n</i> as:<br><i>A(x) = a<sub>0</sub> + a<sub>1</sub>x + ... + a<sub>n</sub>x<sup>n</sup></i><br><i>B(x) = b<sub>0</sub> + b<sub>1</sub>x + ... + b<sub>n</sub>x<sup>n</sup></i></p><p><i>C(x) = A(x) * B(x) = c<sub>0</sub> + c<sub>1</sub>x + ... + c<sub>n</sub>x<sup>2n</sup></i></p><p>Find <i>c<sub>0</sub>, c<sub>1</sub>, c<sub>2</sub>, ..., c<sub>2n</sub>.</i></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define ll long long\n\nvoid multiply(const ll A[], const ll B[], ll C[], int n)\n{\n    int p = (n + 1) / 2;\n\n    if (n == 1)\n    {\n        C[0] = A[0] * B[0];\n        C[1] = A[0] * B[1] + A[1] * B[0];\n        C[2] = A[1] * B[1];\n        return;\n    }\n    ll A_L[p], A_M[p], A_R[p], B_L[p], B_M[p], B_R[p];\n    ll C_L[n], C_M[n], C_R[n];\n\n    for (int i = 0; i < p; i++)\n    {\n        A_L[i] = A[i];\n        B_L[i] = B[i];\n        A_R[i] = A[p + i];\n        B_R[i] = B[p + i];\n        A_M[i] = A[i] + A[p + i];\n        B_M[i] = B[i] + B[p + i];\n    }\n\n    multiply(A_L, B_L, C_L, p - 1);\n    multiply(A_R, B_R, C_R, p - 1);\n    multiply(A_M, B_M, C_M, p - 1);\n\n    for (int i = 0; i < n; i++)\n    {\n        C_M[i] -= C_L[i];\n        C_M[i] -= C_R[i];\n    }\n\n    for (int i = 0; i < (2 * n) + 1; i++)\n    {\n        C[i] = 0;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        C[i] += C_L[i];\n        C[p + i] += C_M[i];\n        C[(2 * p) + i] += C_R[i];\n    }\n\n    return;\n}\n\nsigned main()\n{\n    int _t;\n    cin >> _t;\n    int n, x;\n    while (_t--)\n    {\n        cin >> n;\n        ll A[n + 1], B[n + 1], C[2 * n + 1];\n        for (int i = 0; i < n + 1; i++)\n        {\n            cin >> A[i];\n        }\n        for (int i = 0; i < n + 1; i++)\n        {\n            cin >> B[i];\n        }\n        multiply(A, B, C, n);\n        for (int i = 0; i < ((2 * n) + 1); i++)\n        {\n            cout << C[i] << \" \";\n        }\n        cout << '\\n';\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:23:44.057541+00:00"
      },
      "hints": {
        "hint1": "The problem is to multiply two polynomials of degree $n$, and find the coefficients of the resulting polynomial of degree $2n$.",
        "hint2": "We can use the Divide and Conquer approach to multiply the polynomials. This can be done using Karatsuba's algorithm, which is a recursive algorithm to multiply two numbers in a more efficient way than the standard multiplication algorithm.\n\nThe algorithm divides each polynomial into two halves, multiplies each half, and then combines the results. We can do this recursively until we reach a base case of multiplying two coefficients, and then combine the results as we move back up the recursion stack.",
        "solution_approach": "$X=x_0+x_1* B+x_2* B^2+..... + x_n* B^n$   \n\n$X = X_L+X_R* B^{\\lfloor{{\\frac{n}{2}}}\\rfloor}$  \n$Y=y_0+y_1* B+y_2* B^2+..... + y_n* B^n$  \n\n$Y = Y_L+Y_R* B^{\\lfloor{{\\frac{n}{2}}}\\rfloor}$\n\nSo now the result Z which is multiplication of the 2 polynomials X and Y comes out to be,     \n$Z = X*Y$  \n\n$Z =(X_L+X_RB^{\\lfloor{{\\frac{n}{2}}}\\rfloor})(Y_L+Y_R B^{\\lfloor{{\\frac{n}{2}}}\\rfloor})$     \n\n\n$Z = Z_L + Z_M*B^{\\frac{n}{2}}+Z_R*B^n$  \n\nThe co-efficients $Z_L$, $Z_R$ and $Z_M$ can be calculated as,  \n$Z_L=X_LY_L$  \n$Z_R=X_RY_R$  \n$Z_M=X_LY_R+X_RY_L$  \n$Z_M=Z - Z_L - Z_R $ \n\n\nThe multiply function takes the two polynomials A and B, and an empty array C to store the product polynomial coefficients. It also takes the degree n of the polynomials.\n\nThe base case of the recursion is when n = 1, in which case we can directly compute the coefficients of the product polynomial using the standard formula for multiplying two polynomials.\n\nFor n > 1, we divide each polynomial into three halves - left, right, and middle. We then recursively multiply the left and right halves, and the middle halves.\n\nWe then subtract the left and right products from the middle product, and add them to the appropriate positions in the array C.\n\nFinally, we return the product polynomial coefficients in the array C.\n\nThe time complexity of Karatsuba's algorithm for polynomial multiplication is $O(n^{\\log_2(3)})$."
      },
      "id": 32,
      "input_format": "<p>The first line of input contains one integer <i>T </i>(1 ≤ <i>T</i> ≤ 10) — the number of test cases. Then <i>T</i> test cases follow.<br>The first line of each test case contains a single integer <i>n</i>.<br>The second line of each test case contains <i>n+1</i> space-separated integers <i>a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n</sub></i> - <i>a<sub>i</sub></i> is the coefficient of <i>x<sup>i</sup></i> in <i>A(x) </i>(0 ≤ <i>a<sub>i</sub></i><sub> </sub>≤ 10<sup>3</sup>).<br>The third line of each test case contains <i>n+1</i> space-separated integers <i>b<sub>0</sub>, b<sub>1</sub>, ..., b<sub>n</sub></i> - <i>b<sub>i</sub></i> is the coefficient of <i>x<sup>i</sup></i> in <i>B(x) </i>(0 ≤ <i>b<sub>i</sub></i><sub> </sub>≤ 10<sup>3</sup>).<br>It is guaranteed that <i>n + 1 = 2<sup>k</sup></i>, 2 ≤ <i>k</i> ≤ 16.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i></p><p><i>A(x) = 5 + 2x + 6x<sup>2</sup> + 8x<sup>3</sup></i><br><i>B(x) = 6x + x<sup>2</sup> + 8x<sup>3</sup></i></p><p><i>C(x) = A(x) * B(x) = 30x + 17x<sup>2</sup> + 78x<sup>3</sup> + 70x<sup>4</sup> + 56x<sup>5</sup> + 64x<sup>6</sup></i></p>",
      "output_format": "<p>For each test case, print <i>2n+1</i> space-separated integers <i>c<sub>0</sub>, c<sub>1</sub>, ..., c<sub>2n</sub></i>, where <i>c<sub>i</sub></i> denotes coefficient of <i>x<sup>i</sup></i> in <i>C(x)=A(x)*B(x)</i>.</p>",
      "samples": [
        {
          "input": "2\n3\n5 2 6 8\n0 6 1 8\n31\n1 7 1 5 0 1 0 5 5 3 4 6 9 2 5 4 4 4 7 3 1 6 8 2 4 1 8 6 0 1 2 6\n4 1 2 7 8 0 0 7 1 3 3 7 2 6 6 0 8 7 2 7 8 8 6 4 4 4 5 7 9 7 3 5",
          "output": "0 30 17 78 70 56 64\n4 29 13 42 64 77 44 69 82 52 124 145 187 124 237 237 208 235 278 296 289 377 393 365 395 465 438 428 534 578 561 582 522 530 569 564 483 524 604 517 530 474 483 494 401 389 374 383 330 293 292 256 239 217 179 170 112 111 97 71 53 28 30"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 15,
      "title": "Karatsuba Multiplication",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given an array $A$ of size $N$. Print the $\\textbf{average(mean)}$ of the array numbers.\n\n$\\textbf{Note:}$ Solve this problem using function.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq N \\leq 10^4 $\n$ 1 \\leq A[i] \\leq 10^3 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solution()\n{\n    int n;\n    cin >> n;\n    double sum = 0.0;\n    for (int i = 0; i < n; i++)\n    {\n        double x;\n        cin >> x;\n        sum += x;\n    }\n    double avg = sum / n;\n    cout << fixed << setprecision(7) << avg << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    solution();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:36:59.482559+00:00"
      },
      "hints": {
        "hint1": "Answer could be a double value also.",
        "hint2": "",
        "solution_approach": "At first take numbers in double format then use the average formula. Sum won't exceed the diuble limits so you can use double only and for printing the average value you can use setprecision()."
      },
      "id": 1223,
      "input_format": "First line will contain a number $N$ length of the array.\nSecond line will contain $N$ numbers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the $\\textbf{average(mean)}$ of the array with 7 digits after the decimal point.",
      "samples": [
        {
          "input": "3\n1.0 2.0 5.0\n",
          "output": "2.6666667\n"
        },
        {
          "input": "4\n1.0 7.0 4.0 9.0\n",
          "output": "5.2500000\n"
        },
        {
          "input": "3\n10.0 2.0 7.0\n",
          "output": "6.3333333\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Average",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You have a convex $n$-sided convex polygon where each vertex has an integer value $v_i$. You are given an integer array values where $v[i]$ is the value of the $i^{th}$ vertex (i.e., clockwise order).\n\nYou will triangulate the convex polygon into $n - 2$ triangles. For each triangle, the value of that triangle is the *product of the values of its vertices*, and the total score of the triangulation is the sum of these values over all $n - 2$ triangles in the triangulation.\n\nOutput the smallest possible total score that you can achieve with some triangulation of the polygon.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^3$\n$3 \\leq n \\leq 100$\n$1 \\leq v[i] \\leq 10^4$\nSum of $n$ over all test cases is $\\leq 5000$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint n;\nvector<vector<ll>> dp;\nvector<ll> a;\nll rec(int i, int j) {\n    if (abs(j - i) == 1)return 0;\n    auto &ans = dp[i][j];\n    if (ans != -1)return ans;\n    ans = 1e18;\n    for (int k = i + 1; k <= j - 1; k++)ans = min(ans, a[i] * a[k] * a[j] + rec(i, k) + rec(k, j));\n    return ans;\n}\nll minTriangulation(vector<ll>& v) {\n    n = v.size();\n    a = v;\n    dp.assign(n + 1, vector<ll>(n + 1, -1));\n    return rec(0, n - 1);\n}\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<ll> v(n);\n    for (int i = 0; i < n; i++)cin >> v[i];\n    auto ans=minTriangulation(v);\n    cout << ans << endl;\n    assert(ans>0);\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:34:52.660686+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We can solve it with Dynamic programming.\n$DP(pos1,pos2) =$ min cost of triangulation of vertices from $pos1$ to $pos2$.\nif $(pos2-pos1<2)$ return 0; //its not possible to get any triangle\nelse $DP(pos1,pos2)= min(DP(pos1,k)+ DP(k,pos2) + Cost(pos1,pos2,k)) )$\nWhere $Cost(pos1,pos2,k)$ is the cost of choose triangle with vertices $(pos1,pos2,k)$ and $k$ go from $pos1+1$ to $pos2-1$.\n\n**Time Complexity:** $O(n ^3)$ per test case\n**Space Complexity:** $O(n^ 2)$ per test case."
      },
      "id": 200,
      "input_format": "First Line contains $T$ - the number of test cases.\nThe First Line of each test case contains $n$ - the number of vertices of the convex polygon.\nThe second line of each test case contains $n$ space-separated values $v[i]$ of the vertices in clockwise order.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For 1st test case, The minimum score triangulation has score $1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13$.",
      "output_format": "For each test case, Output the smallest possible total score that you can achieve with some triangulation of the polygon.",
      "samples": [
        {
          "input": "3\n6\n1 3 1 4 1 5\n3 \n1 2 3\n4\n1 1 1 1\n",
          "output": "13\n6\n2\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Convex Polygon Triangulation",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given <i>N</i> segments with endpoints and a value. <i>L<sub>i</sub></i> and <i>R<sub>i</sub></i> (<i>L<sub>i</sub></i> ≤ <i>R<sub>i</sub></i>) are the endpoints (inclusive) of the <i>i</i>th segment, and <i>X<sub>i</sub></i> is its value.&nbsp;</p><p>Your task is to answer <i>Q</i> queries. Each query contains two integers <i>Y</i> and <i>Z</i>. In each query, you have to find the largest value <i>X</i> within<i> Z,</i> among all the segments which contain point <i>Y</i>. If there is no such segments which contains point Y, then print -1.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>N</i> ≤ 10<sup>5</sup><br>0 ≤ <i>L<sub>i</sub></i> ≤ <i>R<sub>i</sub></i> ≤ 10<sup>9</sup><br>1 ≤ <i>Q</i> ≤ 10<sup>5</sup><br>0 ≤ <i>X, Y, Z</i> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n# include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\nusing lli =  int long long;\nusing ii = pair<lli,lli>;\n//#define ld long double;\n#define F first\n#define S second\n\nconst int tot = 1e5+5;\nconst lli mod = 1e9+7;\nint a[tot];\n\n\nint main(){\n  \n    #ifndef ONLINE_JUDGE\n    // for getting input from input.txt\n    freopen(\"input.txt\", \"r\", stdin);\n    // for writing output to output.txt\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    \n    IOS\n    \n    lli n;\n    cin >> n;\n    vector<pair<int,ii>> event;\n\n    //Firstly insert all events of type 0 and 2.\n    for(int i=0;i<n;i++){\n      int l,r,x;\n      cin >> l >> r >> x;\n      event.push_back({l,{0,x}});\n      event.push_back({r,{2,x}});\n    }\n\n    lli q;\n    cin >> q;\n    ii queries[q];\n\n    //Now process all queries with event type as 1 and value as their order of occurance.\n    for(int i=0;i<q;i++){\n      cin >> queries[i].F >> queries[i].S;\n      event.push_back({queries[i].F,{1,i}});\n    }\n\n    //Sort all events in order of segment points they cover.\n    sort(event.begin(),event.end());\n    \n    int ans[q];\n    multiset<int> mt;   //Multiset to maintain sorted order of values upto current event.\n\n    for(auto i:event){\n\n      //For event of type 0 , simply insert value to multiset\n      if(i.S.F==0){\n        mt.insert(i.S.S);\n      }\n\n      //For query event , find largest value <= Z and covering the segment point Y.\n      else if(i.S.F==1){\n        int z = queries[i.S.S].S;\n        auto it = mt.upper_bound(z);\n        if(it!=mt.begin()){\n          it--;\n          ans[i.S.S] = *it;\n        }\n        else\n          ans[i.S.S] = -1;\n      }\n\n      //For event of type 2 , remove value of that segment which has ended.\n      else\n        mt.erase(mt.find(i.S.S));\n    }\n\n    //Finally print all the query values in order they appear. \n    for(auto i:ans)\n      cout << i << \"\\n\";\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:17:20.247804+00:00"
      },
      "hints": {
        "hint1": "Observe all the segments given,&nbsp; and note that the same segment can value multiple values when they overlap. So when a point is asked in a query, you have to consider the largest value (&lt;= Z ), of the segment containing the point. Think of a greedy way to do these.",
        "hint2": "In this question, the intervals along with their priority values are given. In order to find out the largest value of a segment that covers a particular segment point (Y), and is also less than a certain value Z, we have to keep track of the largest value in that segment. The Sweep Line technique can be used to traverse across all the segments given and maintain the largest value.",
        "solution_approach": "\nWe will need to offline the queries: Take all the queries, save in some data structure, then process in some different order (sorting by $Y$ values), and then report the answers in the order they were asked.\n\nThis problem utilizes the sweep line technique to traverse across the entire length. Mainly three types of operations are taking place:\n\n1. 0 - Start of an interval with value $X$. [Value is $X$]\n2. 1 - Query of an interval which covers segment $Y$ [Value is the index of occurrence of that query]\n3. 2 - End of an interval with value $X$. [Value is $X$]\n\nOperations are ordered in this way because at first the segment starts, if that segment is queried then its value is evaluated, and finally, when the end of the interval is encountered, then that value of the segment is removed.\n\nIn this way, we can maintain a multiset of the maximum values, up to that particular segment.\n\n**EXAMPLE RUN :**\n\n```\n5\n1 3 3\n2 5 6\n4 7 9\n8 10 6\n8 9 2\n4\n3 4\n7 10\n8 1\n10 8\n```\n\nSo as each interval is encountered, events `0` and `1` are processed with value $X$. Then all the queries are processed together, along with their index of occurrence as their event values.\n\n**Events**: (segment point covered, event type, value of the event)  **Sorted segment values**\n\n1. $(1,\\ 0,\\ 3)$ - sweep line covers point 1 with value 3 [3]\n2. $(2,\\ 0,\\ 6)$ - sweep line covers point 2 with value 6 [3,6]\n3. $(3,\\ 1,\\ 0)$ - 1st query $(3,4)$. From the multiset, largest value $\\leq 4$ is **3** [3,6]\n4. $(3,\\ 2,\\ 3)$ - sweep line covers point 3 and segment with value 3 is removed. [6]\n5. $(4,\\ 0,\\ 9)$ - sweep line covers point 4 with value 9 [6,9]\n6. $(5,\\ 2,\\ 6)$ - sweep line covers point 5 and segment with value 6 is removed [9]\n7. $(7,\\ 1,\\ 1)$ - 2nd query $(7,10)$. From the multiset, largest value $\\leq 10$ is **9** [9]\n8. $(7,\\ 2,\\ 9)$ - sweep line covers point 7 and segment with value 9 is removed [ ]\n9. $(8,\\ 0,\\ 2)$ - sweep line covers point 8 with value 2 [2]\n10. $(8,\\ 0,\\ 6)$ - sweep line covers point 8 with value 6 [2,6]\n11. $(8,\\ 1,\\ 2)$ - 3rd query $(8,1)$. From the multiset, largest value $\\leq 1$ **does not exist** [2,6]\n12. $(9,\\ 2,\\ 2)$ - sweep line covers point 9 and segment with value 2 is removed [6]\n13. $(10,\\ 1,\\ 3)$ - 4th query $(10,8)$. From the multiset, largest value $\\leq 8$ is **6** [6]\n14. $(10,\\ 2,\\ 6)$ - sweep line covers point 10 and segment with value 6 is removed [ ]\n\nThe answer is, therefore: $3$ $9$ $-1$ $6$\n\nHence all the queries are processed according to the segment point they cover and the sorted order of the values up to that segment is maintained.\n\n**TIME COMPLEXITY:** $O(n \\log n)$\n"
      },
      "id": 488,
      "input_format": "<p>The first line of input contains <i>N</i> - the number of segments.<br>Each of the next <i>N</i> lines contains three space-separated integers <i>L<sub>i</sub></i>, <i>R<sub>i</sub></i> and <i>X<sub>i</sub>.</i><br>The next line contains <i>Q</i> - the number of queries.<br>Each of the next <i>Q</i> lines contains two space-separated integers <i>Y</i> and <i>Z</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "There are $5$ intervals and $4$ queries asked.\n\nThese segments mark their regions with their respective values. Hence, in total the region and their respective values are:\n\n1. $(1,2)$ - [3]\n2. $(2,3)$ - [3,6]\n3. $(3,4)$ - [6]\n4. $(4,5)$ - [6,9]\n5. $(5,6)$ - [9]\n6. $(6,7)$ - [9]\n7. $(7,8)$ - [ ]\n8. $(8,9)$ - [2,6]\n9. $(9,10)$ - [6]\n\nNow all the $4$ queries are processed:\n\n1. $3$ $4$ - Largest value within $3$ and $\\leq 4$ = $3$\n2. $7$ $10$ - Largest value within $7$ and $\\leq 10$ = $9$\n3. $8$ $1$ - Largest value within $8$ and $\\leq 1$ does not exist. So print $-1$.\n4. $10$ $8$ - Largest value within $10$ and $\\leq 8$ = $6$",
      "output_format": "<p>For each query, print the answer on a new line.</p>",
      "samples": [
        {
          "input": "5\n1 3 3\n2 5 6\n4 7 9\n8 10 6\n8 9 2\n4\n3 4\n7 10\n8 1\n10 8",
          "output": "3\n9\n-1\n6"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Solve Intervals 3",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Design your implementation of the circular double-ended queue (deque).</p><p>Your implementation should support the following operations:</p><ol><li><strong>MyCircularDeque(k)</strong>: Constructor, set the size of the deque to be k.</li><li><strong>insertFront()</strong>: Adds an item at the front of Deque. Return true if the operation is successful.</li><li><strong>insertLast()</strong>: Adds an item at the rear of Deque. Return true if the operation is successful.</li><li><strong>deleteFront()</strong>: Deletes an item from the front of Deque. Return true if the operation is successful.</li><li><strong>deleteLast()</strong>: Deletes an item from the rear of Deque. Return true if the operation is successful.</li><li><strong>getFront()</strong>: Gets the front item from the Deque. If the deque is empty, return -1.</li><li><strong>getRear()</strong>: Gets the last item from Deque. If the deque is empty, return -1.</li><li><strong>isEmpty()</strong>: Checks whether Deque is empty or not.</li><li><strong>isFull()</strong>: Checks whether Deque is full or not.</li></ol><p><i>Do it without using STL in C++. All operations should be O(1).</i></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>k</i>, <i>Q</i> ≤ 10<sup>6</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nclass MyCircularDeque\n{\npublic:\n    struct ListNode\n    {\n        int val;\n        ListNode *next, *back;\n        ListNode() : val(0), next(nullptr), back(nullptr) {}\n        ListNode(int x) : val(x), next(nullptr), back(nullptr) {}\n        ListNode(int x, ListNode *next, ListNode *back) : val(x), next(next), back(back) {}\n    };\n\n    ListNode *head, *tail;\n    int K;\n    int curSize;\n\n    MyCircularDeque(int k)\n    {\n        head = nullptr;\n        tail = nullptr;\n        K = k;\n        curSize = 0;\n    }\n\n    bool insertFront(int value)\n    {\n        if (curSize == K)\n            return false;\n\n        ListNode *curNode = new ListNode(value);\n\n        if (!curSize)\n        {\n            head = tail = curNode;\n        }\n        else\n        {\n            head->next = curNode;\n            curNode->back = head;\n            head = curNode;\n        }\n\n        curSize++;\n        return true;\n    }\n\n    bool insertLast(int value)\n    {\n        if (curSize == K)\n            return false;\n\n        ListNode *curNode = new ListNode(value);\n\n        if (!curSize)\n        {\n            head = tail = curNode;\n        }\n        else\n        {\n            tail->back = curNode;\n            curNode->next = tail;\n            tail = curNode;\n        }\n\n        curSize++;\n        return true;\n    }\n\n    bool deleteFront()\n    {\n        if (!curSize)\n            return false;\n\n        if (curSize == 1)\n        {\n            delete (head);\n            head = nullptr;\n        }\n        else\n        {\n            head = head->back;\n            delete (head->next);\n            head->next = nullptr;\n        }\n\n        curSize--;\n\n        return true;\n    }\n\n    bool deleteLast()\n    {\n        if (!curSize)\n            return false;\n\n        if (curSize == 1)\n        {\n            delete (tail);\n            tail = nullptr;\n        }\n        else\n        {\n            tail = tail->next;\n            delete (tail->back);\n            tail->back = nullptr;\n        }\n\n        curSize--;\n\n        return true;\n    }\n\n    int getFront()\n    {\n        if (!curSize)\n            return -1;\n        return head->val;\n    }\n\n    int getRear()\n    {\n        if (!curSize)\n            return -1;\n        return tail->val;\n    }\n\n    bool isEmpty()\n    {\n        return !curSize;\n    }\n\n    bool isFull()\n    {\n        return (curSize == K);\n    }\n};\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int q;\n    cin >> q;\n\n    int k;\n    cin >> k;\n\n    MyCircularDeque myCircularDeque(k);\n\n    while (q--)\n    {\n        string s;\n        cin >> s;\n\n        if (s == \"insertFront\")\n        {\n            int val;\n            cin >> val;\n            if (myCircularDeque.insertFront(val))\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"insertLast\")\n        {\n            int val;\n            cin >> val;\n            if (myCircularDeque.insertLast(val))\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"deleteFront\")\n        {\n            if (myCircularDeque.deleteFront())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"deleteLast\")\n        {\n            if (myCircularDeque.deleteLast())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"getFront\")\n        {\n            cout << myCircularDeque.getFront() << \"\\n\";\n        }\n        else if (s == \"getRear\")\n        {\n            cout << myCircularDeque.getRear() << \"\\n\";\n        }\n        else if (s == \"isEmpty\")\n        {\n            if (myCircularDeque.isEmpty())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"isFull\")\n        {\n            if (myCircularDeque.isFull())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else\n        {\n            assert(1 == 0); //This never happen\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:47:17.984536+00:00"
      },
      "hints": {
        "hint1": "If we use singly linked list, then all operations, except deleteFront, are O(1). deleteFront will take O(n), since we’re not storing any back information of the front node. How to make this also O(1)?",
        "hint2": "Yes, we use a doubly linked list. Because of this, all operations will be O(1).",
        "solution_approach": "<p>We create a doubly linked list structure, like below:</p><pre><code class=\"language-cpp\">\tstruct ListNode\n  \t{\n        int val;\n        ListNode *next, *back;\n        ListNode() : val(0), next(nullptr), back(nullptr) {}\n        ListNode(int x) : val(x), next(nullptr), back(nullptr) {}\n        ListNode(int x, ListNode *next, ListNode *back) : val(x), next(next), back(back) {}\n    };</code></pre><p>We maintain two pointers: head and tail. head points to the front of the deque, and tail point to the rear side of the deque.</p><ol><li>insertFront(): Check if deque is full or not. Create a new node and attach it after the head. Update back and next pointers. And move the head to the new node.</li><li>insertBack(): Check if deque is full or not. Create a new node and attach it before the tail. Update back and next pointers. And move the tail to the new node.</li><li>deleteFront(): Check if deque is empty or not. Remove front node and travel to the new front using back pointer.</li><li>deleteLast(): Check if deque is empty or not. Remove the last node and travel to the new front using the next pointer.</li></ol>"
      },
      "id": 545,
      "input_format": "<p>The first line of input contains <i>Q</i> - the number of queries.<br>The second line contains <i>k.</i><br>Each of the next lines contains queries of one of the types mentioned in the problem statement.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "9\n3\ninsertLast 1\ninsertLast 2\ninsertLast 3\ninsertLast 4\ngetRear\nisFull\ndeleteLast\ninsertFront 4\ngetFront",
          "output": "True\nTrue\nTrue\nFalse\n3\nTrue\nTrue\nTrue\n4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nclass MyCircularDeque\n{\npublic:\n   \n    MyCircularDeque(int k)\n    {\n       \n    }\n\n    bool insertFront(int value)\n    {\n        \n    }\n\n    bool insertLast(int value)\n    {\n        \n    }\n\n    bool deleteFront()\n    {\n        \n    }\n\n    bool deleteLast()\n    {\n        \n    }\n\n    int getFront()\n    {\n        \n    }\n\n    int getRear()\n    {\n        \n    }\n\n    bool isEmpty()\n    {\n        \n    }\n\n    bool isFull()\n    {\n        \n    }\n};\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int q;\n    cin >> q;\n\n    int k;\n    cin >> k;\n\n    MyCircularDeque myCircularDeque(k);\n\n    while (q--)\n    {\n        string s;\n        cin >> s;\n\n        if (s == \"insertFront\")\n        {\n            int val;\n            cin >> val;\n            if (myCircularDeque.insertFront(val))\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"insertLast\")\n        {\n            int val;\n            cin >> val;\n            if (myCircularDeque.insertLast(val))\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"deleteFront\")\n        {\n            if (myCircularDeque.deleteFront())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"deleteLast\")\n        {\n            if (myCircularDeque.deleteLast())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"getFront\")\n        {\n            cout << myCircularDeque.getFront() << \"\\n\";\n        }\n        else if (s == \"getRear\")\n        {\n            cout << myCircularDeque.getRear() << \"\\n\";\n        }\n        else if (s == \"isEmpty\")\n        {\n            if (myCircularDeque.isEmpty())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else if (s == \"isFull\")\n        {\n            if (myCircularDeque.isFull())\n                cout << \"True\\n\";\n            else\n                cout << \"False\\n\";\n        }\n        else\n        {\n            assert(1 == 0); //This never happen\n        }\n    }\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Circular Deque",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are <i>N</i> piles of stones in front of you. ith pile contains <i>A<sub>i</sub></i> number of stones.<br>You want to find whether it is possible to split each pile into <i>1</i> or more piles of <i>X (</i><span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≥ </span><i>2)</i> stones such that each splitted-pile has exactly <i>X</i> stones.<br>Note that <i>X</i> should be the same for each pile.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int T; cin >> T;\n    while(T--) {\n        int n; cin >> n;\n        int g = 0;\n        for(int i = 0; i < n; i++) {\n            int x; cin >> x;\n            g = __gcd(g, x);\n        }\n        if(g > 1) cout << \"Yes\\n\";\n        else cout << \"No\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:24:28.589132+00:00"
      },
      "hints": {
        "hint1": "$X$ has to be a divisor of each $A_is$.",
        "hint2": "Try to find the maximum number $X$ such that it divides each of $A_is$. That is, find the GCD of all $A_is$.",
        "solution_approach": "$X = GCD(A_1, A_2, ..., A_N)$\nIf $X \\geq 2$, then print \"Yes\". Otherwise, print \"No\"."
      },
      "id": 67,
      "input_format": "<p>The first line contains <i>T</i> (1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>T</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 100000), the number of test cases. The description of each test case is as follows:<br>The first line contains <i>N</i>, the number of piles (1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>N</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 100000).<br>The second line contains <i>N</i> space-separated positive integers <i>A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub></i> (2 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>A<sub>i</sub></i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>9</sup>).<br>It is guaranteed that sum of <i>N</i> over all test cases doesn't exceed 10<sup>6</sup>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>For <i>X = 2</i>, you can divide each pile into smaller piles of size 2.</p><p><i><strong>Explanation 2:</strong></i><br>It is not possible to divide piles into smaller piles with size <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≥</span> 2.</p>",
      "output_format": "<p>For each test case, print \"<i>Yes</i>\" (without quotes) if it is possible to split. Otherwise, print \"<i>No</i>\" (without quotes).</p>",
      "samples": [
        {
          "input": "2\n5\n2 2 6 8 12\n4\n2 6 3 8",
          "output": "Yes\nNo"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Divide the Piles",
      "video_editorial_id": 10678
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given an array of <i>n</i> integers, and your task is to find four values (at distinct positions) whose sum is <i>x</i>.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i> ≤ 1000<br>1 ≤ <i>x, a<sub>i</sub></i> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n, x; \n    cin >> n >> x;\n\n    if(n < 4) {\n        cout << \"NO\\n\";\n        return 0;\n    }\n\n    int a[n];\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    map<int,pair<int,int>> M;\n    M[a[0] + a[1]] = {0, 1};\n\n    for(int i = 2; i < n; i++) {\n        for(int j = i + 1; j < n; j++) {\n            int cur = a[i] + a[j];\n            if(M.find(x - cur) != M.end()) {\n                cout << \"YES\\n\";\n                return 0;\n            }\n        }\n        for(int j = 0; j < i; j++) {\n            int cur = a[j] + a[i];\n            M[cur] = {j, i};\n        }\n    }\n\n    cout << \"NO\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:15:14.267818+00:00"
      },
      "hints": {
        "hint1": "<p>You can apply brute force with <i>O(n<sup>4</sup>)</i> complexity, but this solution won't pass the constraints.</p>",
        "hint2": "<p>Try to optimize the loop, and calculate values in the pairs.</p>",
        "solution_approach": "<p>Maintain two-pointers and one hash table. Let the two pointers are <i>lo</i> and <i>hi</i>. &nbsp;<br>For current {<i>lo, hi</i>} pair, the hash table contains all two-sums possible for all pairs with indices less than <i>lo</i>.<br>So if <i>x - a<sub>lo</sub> - a<sub>hi</sub></i> exists in the hash table then it's good, and we'll return directly from it. If not increment <i>hi</i>.<br>When it's time to increment <i>lo</i> to <i>lo</i> + 1, include all pairs two-sums with one index as <i>lo</i> in the hash table.</p><p>Please refer to the editorial solution for more clarity.</p>"
      },
      "id": 280,
      "input_format": "<p>The first input line has two integers <i>n</i> and <i>x</i>: the array size and the target sum.<br>The second line has <i>n</i> integers <i>a<sub>1</sub>, a<sub>2</sub>, …,a<sub>n</sub></i>: the array values.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>Four values are {2, 8, 3, 2}.</p>",
      "output_format": "<p>Print 'YES' if such four values exist, otherwise 'NO'.</p>",
      "samples": [
        {
          "input": "8 15\n3 2 5 8 1 3 2 3",
          "output": "YES"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Four Values",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given <i>n</i> positive integers <i>A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>.</i> Your task is to find the number of pairs <i>(i, j)</i> such that <i>A<sub>i</sub> * A<sub>j</sub></i> is a <strong>cube number</strong>.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i> ≤ 10<sup>5</sup><br>1 ≤ <i>A<sub>i</sub></i> ≤ 10<sup>6</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n\nsigned main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0); cout.tie(0);\n\n   int n; cin >> n;\n\n   map <ll,int> M;\n\n   ll ans = 0;\n\n   for(int i = 0; i < n; i++) {\n      int x; cin >> x;\n      ll norm = 1;\n      ll tar = 1;\n      for(int j = 2; j * j <= x; j++) {\n         int cnt = 0;\n         while(x % j == 0) {\n            x /= j;\n            cnt++;\n         }\n         cnt %= 3;\n         for(int k = 0; k < cnt; k++) {\n            norm *= j;\n         }\n         if(cnt) {\n            for(int k = 0; k < 3 - cnt; k++) {\n               tar *= j;\n            }\n         }\n      }\n      if(x > 1) {\n         norm *= x;\n         tar *= (x * x);\n      }\n      ans += M[tar];\n      M[norm]++;\n   }\n\n   cout << ans << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:46:28.616567+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p>Consider the number n = p<sub>1</sub><sup>a</sup><sub><sup>1</sup></sub> &nbsp;p<sub>2</sub><sup>a</sup><sub><sup>2</sup></sub> &nbsp;p<sub>3</sub><sup>a</sup><sub><sup>3</sup></sub> &nbsp;…. &nbsp;p<sub>m</sub><sup>a</sup><sub><sup>m</sup></sub>. Lets define normal value of n as norm(n) = p<sub>1</sub><sup>a</sup><sub><sup>1</sup></sub><sup>%3</sup> &nbsp;p<sub>2</sub><sup>a</sup><sub><sup>2</sup></sub><sup>%3</sup> &nbsp;p<sub>3</sub><sup>a</sup><sub><sup>3</sup></sub><sup>%3</sup> &nbsp;…. &nbsp;p<sub>m</sub><sup>a</sup><sub><sup>m</sup></sub><sup>%3 </sup>and inverse-normal of n as invnorm(n) = p<sub>1</sub><sup>(3 - a</sup><sub><sup>1</sup></sub><sup>%3) % 3</sup> &nbsp;p<sub>2</sub><sup>(3 -&nbsp;a</sup><sub><sup>2</sup></sub><sup>%3) % 3</sup> &nbsp;…. &nbsp;p<sub>m</sub><sup>(3 -&nbsp;a</sup><sub><sup>m</sup></sub><sup>%3) % 3</sup>.&nbsp;</p><p>Observe that if products of two numbers x and y is a cube number iff norm(x * y) = 1. That means all powers of prime numbers in xy is multiple of 3. Again observe that norm(n) * invnorm(n) is a cube number.<br>Using these properties we can conclude that the norm(x) = invnorm(y) OR norm(y) = invnorm(x). Se if we maintain the count of norm(x) for all values, to find the number of numbers when multiply by y gives a cube number is basically the count of invnorm(y) in the count table.&nbsp;</p><p><i>These mathematical notations might be confusing, but the main motive behind is to make all powers of prime numbers to a multiple of 3.</i></p><p>For more clarification, see the editorial code.</p>"
      },
      "id": 229,
      "input_format": "<p>The first line of input contains <i>n</i> - the size of the array.<br>The second line of input contains <i>n</i> space-separated integers <i>A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>The pairs are (1, 8), (2, 4), (1, 27), (8, 27).</p>",
      "output_format": "<p>Print the answer on a new line.</p>",
      "samples": [
        {
          "input": "5\n1 2 4 8 27",
          "output": "4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Paired Cubes",
      "video_editorial_id": 8171
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given **N** integers, the price of a given stock on each day. You can buy and sell at most **K** stocks. You cannot buy a stock before you sell the previous stock. You cannot sell a stock before you buy one. You have to find the maximum profit you can make by buying and selling stocks.",
      "complete_approach": "",
      "constraints": "<p>1≤ T ≤ 100</p><p>1 ≤ K ≤ N</p><p>1≤ N ≤ 10<sup>5</sup></p><p>0≤ Ai ≤ 10<sup>5</sup></p><p><span style=\"background-color:transparent;color:#000000;\">Sum of N*K across all test cases ≤ 10^8.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                  \\\n    ios::sync_with_stdio(0); \\\n    cin.tie(0);              \\\n    cout.tie(0);\n\nlong long BuyAndSellStock(vector<int> &a, int k)\n{\n    int n = (int)a.size();\n    if (2 * k > n)\n    {\n        long long ans = 0;\n        for (long long i = 1; i < n; ++i)\n            ans += max(0, a[i] - a[i - 1]);\n        return ans;\n    }\n    else\n    {\n        long long dp[k + 1][n];\n        memset(dp, 0, sizeof(dp));\n        for (long long i = 1; i <= k; ++i)\n        {\n            long long m = -a[0];\n            for (long long j = 1; j < n; ++j)\n            {\n                dp[i][j] = max(dp[i][j - 1], a[j] + m);\n                m = max(m, dp[i - 1][j - 1] - a[j]);\n            }\n        }\n        return dp[k][n - 1];\n    }\n}\n\nint main()\n{\n    IOS int t;\n    cin >> t;\n    while (t--)\n    {\n        long long n, k;\n        cin >> n >> k;\n\n        vector<int> a(n);\n        for (long long i = 0; i < n; ++i)\n            cin >> a[i];\n\n        cout << BuyAndSellStock(a, k) << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:14:56.470035+00:00"
      },
      "hints": {
        "hint1": "<p>A transaction consists of buying and selling. We need to find 2*K points in the stock line, K points for buying, and K points for selling. You can make two case for 2*K&gt;N and 2*K&lt;=N.</p><p>There are four possible actions we can do on a day: keep holding the stock, keep not holding the stock, buy the stock, or sell the stock.</p>",
        "hint2": "<p>When 2*K&gt;N, iterate each day, and if the price of the current day is more than the price on the previous day, buy the stock on the previous day and sell it on the current day. We collect all possible increases in stock price.</p>",
        "solution_approach": "We check the profit we would have made if we make 1 less transaction. If we bought a share on the previous day, then the profit will be the profit till that day minus cost of share on that day. The maximum profit for i-th day can be made by either not making any transaction on that day or selling on that day. If we don't sell our stock on the present day,the maximum profit for the day will be the same as the previous day or we sell on the present day and gain profit. To sell a stock we must have bought it on some previous day.\n\nTime Complexity per test case: O(N*K)"
      },
      "id": 279,
      "input_format": "The first line of the input contains one integer **T** - the number of test cases. Then **T** test cases follow.\nThe first line of each test case contains two space-separated integers **N** and **K** - the length of the array the maximum number of stocks you can buy.\nThe second line of each test case contains **N** space-separated integers.\nSum of **N** x **K** across all test cases ≤ 10<sup>8</sup>.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, you can buy stock on day 2 and sell on day 3. Profit = 8-3 = 5\n\nFor the second test case, you can buy stock on day 2 and sell on day 3 and again buy on day 6 and sell on day 7. Profit = (8-3) + (2-0) = 5+2 = 7\n\nFor the third test case, you can buy stock on day 1 and sell on day 4. Profit = 4-1 = 3\n\nFor the fourth test case, you don’t buy and sell any stock. Profit = 0",
      "output_format": "For each test case, print the maximum profit you can make by buying and selling stocks.",
      "samples": [
        {
          "input": "4\n7 1\n4 3 8 7 6 0 2\n7 4\n4 3 8 7 6 0 2\n4 3\n1 2 3 4\n4 1\n5 3 2 1",
          "output": "5\n7\n3\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                  \\\n    ios::sync_with_stdio(0); \\\n    cin.tie(0);              \\\n    cout.tie(0);\n</fix>\n\nlong long BuyAndSellStock(vector<int> &a, int k)\n{\n    // Complete the function\n}\n\n<fix>\nint main()\n{\n    IOS int t;\n    cin >> t;\n    while (t--)\n    {\n        long long n, k;\n        cin >> n >> k;\n\n        vector<int> a(n);\n        for (long long i = 0; i < n; ++i)\n            cin >> a[i];\n\n        cout << BuyAndSellStock(a, k) << \"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "Buy and Sell Stock - 4",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two integer arrays A and B, you have to implement a data structure that supports queries of two types:\n\n1. **Add** a positive integer to an element of a given index in the array B.\n2. **Count** the number of pairs (i, j) such that A[i] + B[j] equals a given value **total**",
      "complete_approach": "",
      "constraints": "<p><i>1 ≤ A.length ≤ 1000</i></p><p><i>1 ≤ B.length ≤ 10<sup>5</sup></i></p><p><i>1 ≤ A[i],B[i] ≤ 10<sup>5</sup></i></p><p><i>0 ≤ index &lt; B.length</i></p><p><i>1 ≤ val ≤ 10<sup>5</sup></i></p><p><i>1 ≤ total ≤ 2</i><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo>×</mo></math><i>10<sup>9</sup></i></p><p><i>At most 1000 calls are made to <strong>add</strong> and <strong>count</strong> each.</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nclass FindPairswithSum\n{\npublic:\n    unordered_map<int, int> hash;\n    vector<int> v, w;\n    FindPairswithSum(vector<int> &A, vector<int> &B)\n    {\n        for (int i : B)\n        {\n            w.push_back(i);\n            hash[i]++;\n        }\n        for (int i : A)\n            v.push_back(i);\n    }\n\n    void add(int index, int val)\n    {\n        hash[w[index]]--;\n        w[index] += val;\n        hash[w[index]]++;\n    }\n\n    int count(int total)\n    {\n        int ans = 0;\n        for (int i : v)\n        {\n            if (hash.find(total - i) != hash.end())\n                ans += hash[total - i];\n        }\n        return ans;\n    }\n};\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    vector<int> A(n), B(m);\n\n    for (auto &i : A)\n    {\n        cin >> i;\n    }\n\n    for (auto &i : B)\n    {\n        cin >> i;\n    }\n\n    FindPairswithSum *obj = new FindPairswithSum(A, B);\n\n    for (int i = 0; i < q; i++)\n    {\n        string op;\n        cin >> op;\n        if (op == \"add\")\n        {\n            int index, val;\n            cin >> index >> val;\n            obj->add(index, val);\n        }\n        else\n        {\n            int total;\n            cin >> total;\n            cout << obj->count(total) << '\\n';\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:45:43.651083+00:00"
      },
      "hints": {
        "hint1": "<p>Maintain a hash map for the elements in array B.</p>",
        "hint2": "<p>When any element is updated in B make decrease the count of the initial value in the hash map and increment the count of the new value by 1.</p>",
        "solution_approach": "<p>We maintain a &nbsp;hash map <i>hash</i> which stores the count of values in array <i>B</i>. When function <i>add</i> is called:</p><pre><code class=\"language-cpp\">hash[B[i]]--;\nB[i]+=val;\nhash[B[i]]++;</code></pre><p>To find the count of pairs having sum equal to <i>total,</i> iterate over elements in array <i>A,</i> and add the count of <i>total - A[i]</i> to the answer.&nbsp;<br>Time Complexity - O(Q*A.length)</p>"
      },
      "id": 643,
      "input_format": "Implement the **FindPairswithSum** class:\n\n1. FindPairswithSum(vector<int> &A, vector<int> &B) : Initializes the FindPairswithSum object with two integer arrays A and B.\n2. void add(int index, int val) : Adds val to B[index] (**0-indexing**).\n3. int count(int total) : Returns the number of pairs (i, j) such that A[i] + B[j] == total.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "A = {4, 5, 6}\n\nB = {1, 2, 3}\n\nThe first query returns 3 as (0,2), (1,1) and (2,0) are the valid pairs with sum equal to 7.\n\nAfter the second query the arrays are [4,5,6] and [3,2,3].\n\nThe third query returns 2 as (2,0) and (2,2) are the valid pairs with sum equal to 9.",
      "output_format": "For every call to the count function the number of pairs are printed.",
      "samples": [
        {
          "input": "3 3 3\n4 5 6\n1 2 3\ncount 7\nadd 0 2\ncount 9",
          "output": "3\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nclass FindPairswithSum\n{\npublic:\n    \n    FindPairswithSum(vector<int> &A, vector<int> &B)\n    {\n        \n    }\n\n    void add(int index, int val)\n    {\n        \n    }\n\n    int count(int total)\n    {\n        \n    }\n};\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    vector<int> A(n), B(m);\n\n    for (auto &i : A)\n    {\n        cin >> i;\n    }\n\n    for (auto &i : B)\n    {\n        cin >> i;\n    }\n\n    FindPairswithSum *obj = new FindPairswithSum(A, B);\n\n    for (int i = 0; i < q; i++)\n    {\n        string op;\n        cin >> op;\n        if (op == \"add\")\n        {\n            int index, val;\n            cin >> index >> val;\n            obj->add(index, val);\n        }\n        else\n        {\n            int total;\n            cin >> total;\n            cout << obj->count(total) << '\\n';\n        }\n    }\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "SUMPAIR",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are <i>N</i> monsters in front of you. To defeat the <i>i</i>-th of them you need an army of <i>A<sub>i</sub></i> soldiers, <i>B<sub>i</sub></i> of which will be killed during the battle.<br>Now you want to know the minimal number of soldiers you need to recruit in order to kill all the monsters.<br>You don't care about the order of battles: the only thing that matters is that none of the monsters will be left alive.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int T; cin >> T;\n    while(T--) {\n        int n;\n        cin >> n;\n        pair<int,int> monster[n];\n        for(int i = 0; i < n; i++) {\n            cin >> monster[i].first >> monster[i].second;\n        }\n\n        sort(monster, monster + n, [&](pair<int,int> &a, pair<int,int> &b) {\n            return a.first - a.second > b.first - b.second;\n        });\n\n        ll ans = 0, cur = 0;\n\n        for(int i = 0; i < n; i++) {\n            ans += max(0LL, monster[i].first - cur);\n            cur = max(1LL * monster[i].first, cur);\n            cur -= monster[i].second;\n        }\n\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:45:47.449877+00:00"
      },
      "hints": {
        "hint1": "<p>Among all the monsters which are still remaining to defeat, which one is better to defeat first?<br><i>Yes, the one which has the highest value of A<sub>i</sub> - B<sub>i</sub>.</i></p>",
        "hint2": "<p>Sort all the monsters with respect to <i>A<sub>i</sub></i> - <i>B<sub>i</sub></i>. This is the order in which you are sending the soldiers.</p>",
        "solution_approach": "<p>The monster which has the highest value of <i>A<sub>i</sub></i> - <i>B<sub>i</sub></i>, is always better to battle first. Because this monster will leave us the maximum number of soldiers alive.<br>So that we can use these soldiers in the next battle.<br>Sort all the monsters with respect to <i>A<sub>i</sub></i> - <i>B<sub>i</sub></i>. This is the order in which you are sending the soldiers.<br>Now iterate over all monsters in this order, and find the minimum soldiers that will require to defeat them all.</p><p>See the solution code.</p><p><strong>Time complexity:</strong> <i>O(NlogN)</i><br><strong>Space complexity:</strong> <i>O(N) extra space</i></p>"
      },
      "id": 95,
      "input_format": "<p>The first line contains a number <i>T</i> (1 <span style=\"background-color:rgb(255,255,255);color:rgb(77,81,86);\">≤</span> <i>T</i> <span style=\"background-color:rgb(255,255,255);color:rgb(77,81,86);\">≤</span> 10<sup>5</sup>) - the number of test cases. Then <i>T</i> lines follow.<br>The first line of each test cases contains single integer <i>N</i> (1 <span style=\"background-color:rgb(255,255,255);color:rgb(77,81,86);\">≤</span> <i>N</i> <span style=\"background-color:rgb(255,255,255);color:rgb(77,81,86);\">≤</span> 10<sup>5</sup>) - the number of monsters.<br>Each of the next <i>N</i> lines contains two space-separated integers: <i>A<sub>i</sub></i> and <i>B<sub>i</sub></i> (1 <span style=\"background-color:rgb(255,255,255);color:rgb(77,81,86);\">≤</span> <i>B<sub>i</sub></i> <span style=\"background-color:rgb(255,255,255);color:rgb(77,81,86);\">≤</span> <i>A<sub>i</sub></i> <span style=\"background-color:rgb(255,255,255);color:rgb(77,81,86);\">≤</span> 10<sup>9</sup>) - the number of soldiers you need to defeat the <i>i</i>-th monster, &nbsp;and the number of soldiers that will be killed in the battle against him.<br>It is guaranteed that the sum of <i>N</i> over all test cases doesn't exceed 5 x 10<sup>5</sup>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>You need a minimum of 8 soldiers. First, you send 5 soldiers to defeat 2nd monster, after this battle you now have 7 soldiers.<br>Send them to battle with 1st monster.<br>Note that if you try to defeat monsters in order 1 - 2, then you will require 9 soldiers.<br><br><i><strong>Explanation 2:</strong></i><br>There are 3! = 6 order (of monsters) in which you can battle with monsters.<br>1. 1 - 2 - 3 : In this order, you will require, minimum of 10 soldiers.<br>2. 1 - 3 - 2 : In this order, you will require, minimum of 10 soldiers.<br>3. 2 - 1 - 3 : In this order, you will require, minimum of 10 soldiers.<br>4. 2 - 3 - 1 : In this order, you will require, minimum of 11 soldiers.<br>5. 3 - 1 - 2 : In this order, you will require, minimum of 10 soldiers.<br>6. 3 - 2 - 1 : In this order, you will require, minimum of 11 soldiers.<br>The minimum number of soldiers require is 10.</p>",
      "output_format": "<p>For each test case, output a single integer on a new line — the minimal number of soldiers that is sufficient to kill all the monsters.</p>",
      "samples": [
        {
          "input": "2\n2\n7 4\n5 1\n3\n4 1\n6 4\n5 3",
          "output": "8\n10"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Kill Monsters",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>A shop makes n types of cookies. Number of cookies of type i is C<sub>i</sub></p><p>The shop only sells cookies as a pair. Moreover the two cookies in a pair must be of different types.</p><p>Your job is to sell as many pairs as possible and find the minimum number of cookies that remain at the end.</p><p>&nbsp;</p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "<p>T ≤ 10</p><p>1 ≤ n ≤ 10<sup>5</sup></p><p>1 ≤ C<sub>i</sub> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n# include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\nusing lli =  int long long;\n//#define ld long double;\n\nconst int tot = 1e5+5;\nconst lli mod = 1e9+7;\n\nint main(){\n    #ifndef ONLINE_JUDGE\n    // for getting input from input.txt\n    freopen(\"input.txt\", \"r\", stdin);\n    // for writing output to output.txt\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    IOS\n    lli t;\n    cin >> t;\n    while(t--){\n      int n;\n      cin >> n;\n      vector<lli> a;\n      lli x;\n      lli ans = 0;\n      for(int i=0;i<n;i++){\n        cin >> x ;\n        a.push_back(x);\n        ans+=x;\n      }\n      sort(a.begin(),a.end());\n      \n      ans-=a[n-1]; // Substract the largest element first\n\n      //Highest stack is more than sum of cookies in all other stacks , so it won't be exhausted.\n      if(a[n-1]>=ans){\n        ans = a[n-1]-ans;\n      }\n      //It is possible to exhaust the highest stack.\n      else{\n        ans = (ans-a[n-1])%2;\n      }\n        \n      cout << ans << \"\\n\";   \n\n    }  \n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:44:38.423405+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Each cookie needs to be paired with a different cookie. Consider all possible pairs of cookies to get the minimum answer. But this will lead to TLE. Think in a greedy way.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">It is observed clearly that it is optimum to remove cookies from the highest cookie stack present at every step. Try to merge cookies based on this idea , however again to consider all possible combinations you will get a TLE. Now think of the possibilities of the number of cookies left when all possible pairs are sold.&nbsp;</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">The highest cookie stack is removed first. Is it always possible to remove all the cookies from the highest cookie stack? No. It is possible only when the number of cookies in the highest stack is less than or equal to the sum of all other cookies present. Once the highest stack is reduced to zero, the remaining cookies can be paired in between themselves such that there will be either 0 or 1 cookie left.</span></p><p><span style=\"background-color:transparent;color:#000000;\">But if the number of cookies in the highest stack is more than all other cookies present, then all the other cookies will pair with cookies from the highest stack. Now remaining cookies in the highest stack cannot be paired anymore, so its answer will be the remaining number of cookies in the highest stack.</span></p><p><span style=\"background-color:transparent;color:#000000;\"><strong>EXAMPLE RUN :</strong>&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span></p><p><span style=\"background-color:transparent;color:#000000;\">2 4 6 9</span></p><p><span style=\"background-color:transparent;color:#000000;\">The highest number of cookies is 9 and the sum of all other cookies = 2+4+6=12</span></p><p><span style=\"background-color:transparent;color:#000000;\">So the highest stack can be reduced to zero. So from these 12 cookies, 9 will pair with 9 cookies of the highest stack. The remaining 3 cookies can be of any combination of cookies of the 3 smaller stacks. They will pair with themselves optimally to leave only 1 cookie unpaired. So the answer is 1.</span></p>"
      },
      "id": 223,
      "input_format": "<p>First line of input contains T, number of test cases.</p><p>First line of each test case contains n.</p><p>The next line contains n integers, C<sub>i </sub>for i from 1 to n.</p><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><strong>Explanation 1:</strong><br>We can make the following 3 pairs of cookie types : (1,3), (1,3), (2,3) resulting in 0 remaining cookies.</p><p><strong>Explanation 2:</strong><br>Let types of cookies be 1, 2, 3 with count 3, 4, 5 respectively. Pairs: (1, 3), (1, 2), (1, 3), (2, 3), (2, 3), (2, 3).<br>0 cookies left behind.</p>",
      "output_format": "<p>For each test case output one integer: Remaining cookies.</p>",
      "samples": [
        {
          "input": "1\n3\n2 1 3",
          "output": "0"
        },
        {
          "input": "1\n3\n3 4 5",
          "output": "0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Selling cookies",
      "video_editorial_id": 8170
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "*Gerald of Rivia* also known as *The Witcher*, on his journey to find *Ciri*, faced a dangerous labyrinth.\n\nHe's in a tunnel that contains $N$ different rooms. Each room contains $A_i$ monsters inside it. He starts from room $1$. Every time he stays near a room $X$, he may go in and clear it from monsters, or just leave the room locked and move to the room $X+1$. However, if he clears a room with $K$ monsters and the next room he clears consists of $L$ monsters, then the greatest common divisor of $K$ and $L$ must be greater than $1$, otherwise, he will die ( awful curse! ). \n\nFormally, let us say that the order of rooms he visited is $i_{1}, i_{2}, , ..., i_{t}$. Then $gcd(Ai_{j}, Ai_{j + 1}) > 1$ for all $j < t$. Help him cross all the rooms by clearing the maximum number of rooms.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$\n$1 \\leq N \\leq 10^{5}$\n$1 \\leq A_{i} \\leq 10^{7}$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nconst int mx = 1e7;\n\n\nint lpf[mx + 5];\nvoid sieve() {\n    for (int i = 2; i <= mx; i++) {\n        if (lpf[i])continue;\n        for (int j = 1; j * i <= mx; j++)if (lpf[i * j] == 0)lpf[i * j] = i;\n    }\n}\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; i++)cin >> v[i];\n    vector<int> dp(1e7 + 1, 0);\n    int ans = 1;\n    for (auto x : v) {\n        set<int> s;\n        while (x != 1) {\n            int p = lpf[x];\n            x /= p;\n            s.insert(p);\n        }\n        int t = 0;\n        for (auto p : s)dp[p]++, ans = max(ans, dp[p]), t = max(t, dp[p]);\n        for (int p : s)dp[p] = t;\n    }\n    cout << ans << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    sieve();\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:43:33.316697+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We will need to prime-factorize each integer in the array.\n\nWe first use a sieve to find the smallest prime factor of all integers in the range $[1…10^{7}]$.\n\nPseudo-code for pre-computing smallest prime factors using sieve:\n\n```\n  smallest_prime_factor = [1 for all ints uptil 10^7] # initialize\n  for i in [2..10^7]:\n    if smallest_prime_factor[i] == 1:\n      for j in [i..10^7]:\n        smallest_prime_factor[j] = i\n        j += i\n\n```\nPseudo-code for prime-factorization of a number:\n\n```\n  prime_factors = set()\n  while number != 1:\n    prime_factors.add(smallest_prime_factor[number])\n    number /= smallest_prime_factor[number]\n```\nNow, we can use dynamic programming to store the maximum possible sub-sequence length that ends at index $i$, such that $a_{i}$ contains $P$ as a prime factor.\n\nLet the prime factors of $a_{i}$ be $p_{1}, p_{2}, p_{3}, ... , p_{K}$.\nFor each $p_{j}$, let’s say the maximum possible sub-sequence length such that the previously selected number had a common prime factor was $l_{j}$.\nWe choose the maximum length $M$ equal to $max(l_{j})$ for $(1 \\leq j \\leq K)$. We update $dp(p_{j})$ with the value $M$.\n\nWhile performing updates, we maintain a global maximum - the maximum $M$ calculated uptil now.\n\n**Time Complexity**\n\nPre-computation using sieve: $O(X*log(log(X)))$, where $X = 10^{7}$.\nComputation of max length sub-sequence: $O(N * log_{2}(Y))$, where $Y$ is the number in the array with maximum no. of prime factors."
      },
      "id": 923,
      "input_format": "The first line of input contains an integer $T$ denoting the number of test cases.\n\nThe first line of each test case contains one integer $N$ denoting the number of elements in the sequence.\n\nThe second line of each test case contains $N$ integers where $i^{th}$ integer is a number of monsters in a room $A_{i}$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "Test case 1. Gerald can clear the monsters in the rooms $2, 3, 4, 5, 7$ in that order. These rooms consist of $2, 8, 6, 3,$ and $9$ monsters, respectively. You can check that $gcd(2, 8)$, $gcd(8, 6)$, $gcd(6, 3)$ and $gcd(3, 9)$, all are greater than $1$.\n\nTest case 2. Gerald can clear the monsters in the rooms numbered $2, 3$. Each of these two rooms contains two monsters. And we know that $gcd(2, 2) = 2 > 1$.\n\nThere is one more possible solution: Gerald can clear the monsters in the rooms numbered $4, 5$. These rooms contains $3$ monsters each, and he can clear these rooms as $gcd(3, 3) = 3 > 1$.",
      "output_format": "For each test case, output the maximum number of rooms he could clear. (Gerald should survive.)",
      "samples": [
        {
          "input": "3\n7\n13 2 8 6 3 1 9\n6\n1 2 2 3 3 1\n2\n2 3\n",
          "output": "5\n2\n1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "The Witcher",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given the marks of a student in mid-term, final-term and the make-up examinations. If the student does not attend an exam, marks are assigned as -1. You have to find the grade of the student according to the following guidelines:\n\n1. If the student does not take the mid-term or the final-term exam, grade is F\n2. If the total score in mid-term and final-term is greater than or equal to 80, grade is A.\n3. If the total score in mid-term and final-term is greater than or equal to 65 and less than 80, grade is B.\n4. If the total score in mid-term and final-term is greater than or equal to 50 and less than 65, grade is C.\n5. If the total score in mid-term and final-term is greater than or equal to 30 and less than 50, grade is D. However,  if the score of the make-up examination is greater than or equal to 50, the grade will be C.\n6. If the total score in mid-term and final-term is less than 30, grade is F.",
      "complete_approach": "",
      "constraints": "- $1 \\leq T \\leq 10^5$  \n- $1 \\leq M, F \\leq 50$  \n- $1 \\leq R \\leq 100$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nsigned main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int m, f, r;\n        cin >> m >> f >> r;\n        char grade;\n        if(m == -1 || f == -1)\n            grade = 'F';\n        else if(m + f >= 80)\n            grade = 'A';\n        else if(m + f >= 65)\n            grade = 'B';\n        else if(m + f >= 50)\n            grade = 'C';\n        else if(m + f >= 30) {\n            grade = 'D';\n            if(r >= 50)\n                grade = 'C';\n        }\n        else\n            grade = 'F';\n        cout << grade << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:17:05.265641+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Time Complexity per test case: O(1)"
      },
      "id": 343,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains three space-separated integers M, F, R - the marks of the student in the mid-term, final-term and the make-up examinations.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the grade of the student.",
      "samples": [
        {
          "input": "4\n41 48 76\n-1 48 100\n20 25 61\n21 5 20\n",
          "output": "A\nF\nC\nF\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Grading System AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given <i>M</i> binary strings, <i>S<sub>1</sub>, S<sub>2</sub>, ..., S<sub>M</sub></i>. Let <i>T = S<sub>p_1</sub> + S<sub>p</sub></i><sub>_</sub><i><sub>2</sub> + ...+S<sub>p_M</sub></i>, where <i>p</i> is a permutation of {1, 2, ..., <i>M</i>}.<br>Your task is to find the <strong>minimum value of inversion count</strong> in <i>T</i> among all <i>M!</i> possible combinations.<br>The inversion count is the number of pairs <i>(i, j)</i> in <i>T</i> such that <i>i &lt; j</i> and <i>T<sub>i</sub> &gt; T<sub>j</sub></i>.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>T</i> ≤ 10<sup>5</sup><br>1 ≤ <i>M</i> ≤ 10<sup>5</sup><br>1 ≤ |<i>S<sub>i</sub></i>| ≤ 10<sup>5</sup><br>It is guaranteed that sum of all |<i>S<sub>i</sub></i>|s<i><sub> </sub></i>over all test cases doesn't exceed 5 x 10<sup>5</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nsigned main() \n{\n    ios::sync_with_stdio(0); \n    cin.tie(0); cout.tie(0);   \n    \n    int T; cin >> T;\n\n    while(T--) {\n        int m; cin >> m;\n\n        string s[m];\n        for(int i = 0; i < m; i++) {\n            cin >> s[i];\n        }\n\n        ll cnt[m][2];\n        memset(cnt, 0LL, sizeof(cnt));\n\n        for(int i = 0; i < m; i++) {\n            for(char c : s[i]) {\n                if(c == '0') cnt[i][0]++;\n                else cnt[i][1]++;\n            }\n        }\n\n        vector<int> id(m);\n        for(int i = 0; i < m; i++) {\n            id[i] = i;\n        }\n\n        sort(id.begin(), id.end(), [&](int x, int y) {\n            return cnt[x][1] * cnt[y][0] < cnt[x][0] * cnt[y][1];\n        });\n\n        ll ans = 0;\n        ll one = 0;\n\n        for(int i : id) {\n            for(char c : s[i]) {\n                if(c == '0') {\n                    ans += one;\n                }\n                else {\n                    one++;\n                }\n            }\n        }\n\n        cout << ans << \"\\n\";\n\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:30:42.654827+00:00"
      },
      "hints": {
        "hint1": "<p>Consider two strings <i>S<sub>1</sub></i> and <i>S<sub>2</sub></i>. Try to think of the condition on which you decide the order of their concatenation.</p>",
        "hint2": "<p>It's better to put string first which has <i>cnt<sub>1</sub>/cnt<sub>0</sub></i>, here <i>cnt<sub>0</sub></i> and <i>cnt<sub>1</sub></i> are the count of 0s and 1s respectively in the string.</p>",
        "solution_approach": "<p>Consider two strings <i>S<sub>1</sub></i> and <i>S<sub>2</sub></i>. Let <i>S<sub>1</sub></i> contains <i>cnts1<sub>0</sub></i> number of 0s and <i>cnts1<sub>1</sub></i> the number of 1s. Similarly, let <i>S<sub>2</sub></i> contains <i>cnts2<sub>0</sub></i> number of 0s and <i>cnts2<sub>1</sub></i> the number of 1s.</p><p>Suppose inversion count in <i>S<sub>1</sub></i> is <i>I<sub>1</sub></i> and in <i>S<sub>2</sub></i> is <i>I<sub>2</sub></i>.<br>Let <i>T<sub>1</sub> = S<sub>1</sub> + S<sub>2</sub></i> and <i>T<sub>2</sub> = S<sub>2</sub> + S<sub>1</sub></i>.</p><p>Inversion count in <i>T<sub>1</sub> = I<sub>1</sub> + I<sub>2</sub> + cnts1<sub>1</sub> * cnts2<sub>0</sub></i><br>Inversion count in <i>T<sub>2</sub> = I<sub>1</sub> + I<sub>2</sub> + cnts2<sub>1</sub> * cnts1<sub>0</sub></i></p><p>If we compare these two equations, we get that it is better to put <i>S<sub>1</sub></i> before <i>S<sub>2</sub></i> iff <i>cnts1<sub>1</sub> * cnts2<sub>0</sub></i> is lesser than <i>cnts2<sub>1</sub> * cnts1<sub>0</sub></i>, and vice-versa.</p><p>This gives us the result that in the compare function sort the strings according to <i>cnt<sub>1</sub>/cnt<sub>0</sub></i> condition. And append them. That will be the string <i>T</i> with minimum Inversions.</p><p><strong>Time complexity:</strong> <i>O(M*logM + N)</i> where <i>N</i> = sum of the length of all <i>S<sub>i</sub></i>s.</p>"
      },
      "id": 117,
      "input_format": "<p>The first line of input contains <i>T</i> - the number of test cases.<br>The first line of each test case contains <i>M</i> - the number of binary strings.<br>Each of the next <i>M</i> lines contains a binary string <i>S<sub>i</sub></i>.&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>The optimal way is to concatenate string in the order 3, 1, 2. <i>T</i> = 000010111.</p><p><i><strong>Explanation 2:</strong></i><br>The optimal way is to concatenate string in the order 2, 1. <i>T</i> = 0111.</p>",
      "output_format": "<p>Print the minimum value of inversion possible in <i>T</i> in a new line for each test case.</p>",
      "samples": [
        {
          "input": "2\n3\n0010\n111  \n00\n2\n111 \n0",
          "output": "1\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Array Inversions",
      "video_editorial_id": 8153
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "There are $n$ piles of elements arranged in a row. The $i^th$ pile has $arr[i]$ elements.\n\nA move consists of merging exactly $k$ consecutive piles into one pile, and the cost of this move is equal to the total number of elements in these $k$ piles.\n\nFind the minimum cost to merge all piles of elements into one pile. If it is impossible, return $-1$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 900$\n$1 \\leq n \\leq 30$\n$2 \\leq k \\leq 30$\n$1 \\leq arr[i] \\leq 100$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint n, K;\nvector<vector<vector<int>>> dp;\nvector<int> v;\nint rec(int l, int r, int cnt) {\n\tint sum = 0;\n\tfor (int i = l; i <= r; i++)sum += v[i];\n\tif (l == r) {\n\t\tif (cnt == 1)return 0;\n\t\treturn 1e9;\n\t}\n\tauto &ans = dp[l][r][cnt];\n\tif (ans != -1)return ans;\n\tans = 1e9;\n\tif (cnt == 1)cnt = K;\n\tfor (int i = l; i < r; i++) {\n\t\tans = min(ans, rec(l, i, cnt - 1) + rec(i + 1, r, 1) + sum * (cnt == K));\n\t}\n\treturn ans;\n}\nvoid solve() {\n\tint n;\n\tcin >> n >> K;\n\tv.resize(n);\n\tfor (int i = 0; i < n; i++)cin >> v[i];\n\tdp.assign(n + 1, vector<vector<int>>(n + 1, vector<int>(K + 1, -1)));\n\tint ans = rec(0, n - 1, 1);\n\tif (ans == 1e9)ans = -1;\n\tcout << ans << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:24:43.562146+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "**State** \n$dp(i,j,k)$ = means the minimum cost to merge array from index $i$ to index $j$ into $k$ different piles.\n\n\n**Transitions :** \n\n$dp(i,j,1) = dp(i,j,k) + sum[i..j]$ where $sum[i..j]$ represents the sum between index $i$ and index $j$ .Which means that in order to create one pile from index $i$ to index $j$ ($dp(i,j,1)$) in minimum cost , we have to create $k$ piles from index $i$ to index $j$ ($dp(i,j,k)$) and merge the operation cost which is sum of the segment.               \n\n$dp(i,j,k) = dp(i,t,1) + dp(t+1,j,k-1)$ where  $t$ lies between index $i$ to $j$ where $i$ is inclusive and $j$ is exclusive, which means that in order to create $k$ pile from index $i$ to index $j$ , we first choose any segment of arbitary length and try creating the pile from $(i,t)$ and then check for the minimum cost of creating $(k-1)$ piles from the rest of the array .\n\n\n**Base Cases :**\n    \n$dp(i,i,1)$ = Since only merge operation has cost therfore , and we dont need merge in the interval $i$ to $i$ to create $1$ pile, therefore cost is $0$ . \n\n\n**Time Complexity:** $O(n^3 * k)$"
      },
      "id": 974,
      "input_format": "The first line contains $T$ - the number of test cases.\nThe first line of each test case contains two integers $n$ and $k$.\nSecond line of each test case contains $n$ values of $arr[i]$ denoting elements in the $i^{th}$ pile.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, Output the minimum cost to merge all piles of elements into one pile. If it is impossible, return $-1$.",
      "samples": [
        {
          "input": "4\n4 2\n3 2 4 1\n4 3\n3 2 4 1\n5 3\n3 5 1 2 6  \n1 2\n5\n",
          "output": "20\n-1\n25\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Merge Elements 3",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given **N** integers, the price of a given stock on each day. You can buy and sell at most 2 stocks. You cannot buy a stock before you sell the previous stock. You cannot sell a stock before you buy one. You have to find the maximum profit you can make by buying and selling stocks.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤ 100<br>1 ≤ N ≤ 10<sup>5</sup><br>0 ≤ Ai ≤ 10<sup>5</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nlong long BuyAndSellStock(vector<int> &a) \n{\n    int n = (int)a.size();\n    long long pre[n];\n    pre[0] = 0;\n    long long m = a[0];\n    for (long long i = 1; i < n; ++i) {\n        pre[i] = max(pre[i-1], a[i] - m);\n        m = min(m, 1LL * a[i]);\n    }\n    long long post[n];\n    post[n-1] = 0;\n    m = a[n-1];\n    for (long long i = n - 2; i >= 0; --i) {\n        post[i] = max(post[i+1], m  -a[i]);\n        m = max(m, 1LL * a[i]);\n    }\n    long long ans = 0;\n    for (long long i = 0; i < n; ++i) {\n        ans=max(ans, pre[i]+post[i]);\n    }\n    return ans;\n}\n\nint main(){\n   IOS\n   \n   int t;\n   cin>>t;\n   \n   while(t--){\n       int n;\n       cin>>n;\n       \n       vector<int> a(n);\n\n       for (int i = 0; i < n; ++i) {\n           cin>>a[i];\n       }\n       \n       cout << BuyAndSellStock(a) << \"\\n\";\n   }\n\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:14:40.045597+00:00"
      },
      "hints": {
        "hint1": "We are allowed to buy and sell up to 2 stocks, so we can break the array into 2 parts and try all the cases.",
        "hint2": "We try all the cases for breaking the array. For each point, calculate the left maximum profit and the right maximum profit.",
        "solution_approach": "Calculate the maximum profit possible, while traversing from the front of the array and from the back of the array. It can be easily pre-computed by using a prefix array. Then take the maximum profit out of all the points.\n\nTime Complexity per test case: O(N)"
      },
      "id": 278,
      "input_format": "The first line of the input contains one integer **T** - the number of test cases. Then **T** test cases follow.\nThe first line of each test case contains one integer **N** - the length of the array. \nThe second line of each test case contains **N** space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, you can buy stock on day 1 and sell on day 2 and again buy on day 4 and sell on day 5. Profit = (5-1) + (6-2) = 4+4 = 8\n\nFor the second test case, you can buy stock on day 1 and sell on day 4. Profit = 4-1 = 3\n\nFor the third test case, you don’t buy and sell any stock. Profit = 0",
      "output_format": "For each test case, print the maximum profit you can make by buying and selling stocks.",
      "samples": [
        {
          "input": "3\n9\n1 5 2 2 6 0 3 2 1\n4\n1 2 3 4\n4\n5 3 2 1",
          "output": "8\n3\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n</fix>\n\nlong long BuyAndSellStock(vector<int> &a) \n{\n    //Complete the function\n}\n\n<fix>\nint main(){\n   IOS\n   \n   int t;\n   cin>>t;\n   \n   while(t--){\n       int n;\n       cin>>n;\n       \n       vector<int> a(n);\n\n       for (int i = 0; i < n; ++i) {\n           cin>>a[i];\n       }\n       \n       cout << BuyAndSellStock(a) << \"\\n\";\n   }\n\n   return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 3,
      "title": "Buy and Sell Stock - 3",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>A number is represented in the form of a linked list, by storing its digit in the reverse order. Each node of the linked list stores one digit. The head of the linked list is pointed towards the least significant digit of the number.</p><p>Given two <strong>non-empty </strong>linked list representing two numbers, your task is to add them and return the sum as a linked list.</p><p>Complete the function</p><pre><code class=\"language-cpp\">ListNode* addTwoNumbers(ListNode* n1, ListNode* n2)</code></pre><p>n1 and n2 are head of the two numbers' linked lists. And the function returns the head of the linked list of the sum.</p>",
      "complete_approach": "",
      "constraints": "<p>Size of the linked list ≤ 10<sup>5</sup><br>Each node in the linked list stores values between 0 to 9.<br>It is guaranteed that the list represents a number that does not have leading zeros.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* addTwoNumbers(ListNode* n1, ListNode* n2) {\n    ListNode* head = NULL;\n    ListNode* newHead = NULL;\n\n    int carry = 0;\n    \n    while(n1 && n2) {\n        int temp = (n1->val + n2->val + carry);\n        ListNode* cur = new ListNode(temp % 10);\n        carry = temp / 10;\n        if(!head) {\n            head = cur;\n            newHead = cur;\n        }\n        else {\n            head->next = cur;\n            head = cur;\n        }\n        n1 = n1->next;\n        n2 = n2->next;\n    }\n\n    if(n2) swap(n1, n2);\n    \n    while(n1) {\n        int temp = (n1->val + carry);\n        ListNode* cur = new ListNode(temp % 10);\n        carry = temp / 10;\n        if(!head) {\n            head = cur;\n            newHead = cur;\n        }\n        else {\n            head->next = cur;\n            head = cur;\n        }\n        n1 = n1->next;\n    }\n    \n    if(carry) {\n        ListNode* cur = new ListNode(carry);\n        head->next = cur;\n    }\n\n    return newHead;\n}\n\nListNode* GetList(string &num) {\n    ListNode* n1 = nullptr;\n    ListNode* head = nullptr;\n    for(int i = (int)num.length() - 1; i >= 0; i--) {\n        ListNode* temp = new ListNode(num[i] - '0');\n        if(n1) {\n            n1->next = temp;\n            n1 = temp;\n        }\n        else {\n            n1 = temp;\n            head = n1;\n        }\n    }\n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    string num1, num2;\n    cin >> num1;\n    cin >> num2;\n\n    ListNode* n1 = GetList(num1);\n    ListNode* n2 = GetList(num2);\n\n    ListNode* sum = addTwoNumbers(n1, n2);\n\n    string ans = \"\";\n    while(sum) {\n        ans += ('0' + sum->val);\n        sum = sum->next;\n    }\n\n    reverse(ans.begin(), ans.end());\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:41:57.268786+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 525,
      "input_format": "",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "200\n13421",
          "output": "13621"
        },
        {
          "input": "12\n0",
          "output": "12"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\nListNode* addTwoNumbers(ListNode* n1, ListNode* n2) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(string &num) {\n    ListNode* n1 = nullptr;\n    ListNode* head = nullptr;\n    for(int i = (int)num.length() - 1; i >= 0; i--) {\n        ListNode* temp = new ListNode(num[i] - '0');\n        if(n1) {\n            n1->next = temp;\n            n1 = temp;\n        }\n        else {\n            n1 = temp;\n            head = n1;\n        }\n    }\n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    string num1, num2;\n    cin >> num1;\n    cin >> num2;\n\n    ListNode* n1 = GetList(num1);\n    ListNode* n2 = GetList(num2);\n\n    ListNode* sum = addTwoNumbers(n1, n2);\n\n    string ans = \"\";\n    while(sum) {\n        ans += ('0' + sum->val);\n        sum = sum->next;\n    }\n\n    reverse(ans.begin(), ans.end());\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Add Two Numbers",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given Convex <i>N</i>-gon. Draw all diagonals of the convex <i>N</i>-gon. Suppose no three diagonals pass through a point.<br>Into how many parts is the <i>N</i>-gon divided?</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define int long long int\nconst int mod = 1e9 + 7;\n\nint inv(int a, int b = mod - 2) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % mod;\n    a = (a * a) % mod;\n    b /= 2;\n  }\n  return ans;\n}\n\nint inv2 = inv(2);\nint inv24 = inv(24);\n\nvoid solve() {\n  int n;\n  cin >> n;\n  int ans = 1;\n  for (int i = 0; i < 4; i++) ans = (ans * (n - i)) % mod;\n  ans = (ans * inv24) % mod;\n  int temp = (n * (n - 1)) % mod;\n  ans = (ans + 1 + (temp * inv2) % mod);\n  ans -= n;\n  cout << (ans % mod + mod) % mod << endl;\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:17:56.443437+00:00"
      },
      "hints": {
        "hint1": "Start with one part, the N-gon. One part is added for each diagonal, and one more part is added for each intersection point of two diagonals.",
        "hint2": "Initially, we have only $1$ part. We know how to calculate the number of diagonals i.e. ${N\\choose 2} - N$ and the number of intersecting points of diagonals (inside the polygon) i.e. $NC4$.",
        "solution_approach": "Initially there is only 1 part. For each diagonal a new part gets added. If the total number of diagonals be $x$ we would get $x$ new pieces. Therefore the total number of parts would be $1+x$. We also need to take care of the case when there would be intersection among the diagonals. So the number of intersecting diagonals are ${N\\choose 4}$. For each pair of intersecting diagonals an additional part gets added. So the total number of parts now would be $1+x+{N\\choose 4}$.  \nTotal number of parts = $(1 + ({N\\choose 2} - N) + {N\\choose 4}) \\% 1000000007$.   \n\nTime Complexity : $O(\\log N)$ for calculating inverse."
      },
      "id": 70,
      "input_format": "The first line contains $T$ ($1 \\leq T \\leq 100000$), the number of test cases.  \n\nEach of the next $T$ lines contains a positive integer $N$ denoting the number of sides of a convex polygon ($3 \\leq N \\leq 10^9$).",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<figure class=\"image\"><img src=\"https://lh4.googleusercontent.com/uVAyQmm30WDVA6BcrzlHqBI1D96nuS9OlnWSu16XQNHQEtda49jqrwA5WR0uqH41T2c9RytO2pAPbKXx3xekLLI19ETivmP3VFqMT2nT96owqFThSsmqMRkCiUAw3MRlEUJWRw60\"></figure>",
      "output_format": "<p>For each test case, print a single number denoting the number of parts the convex <i>N</i>-gon divided. Since answer can be large, print it with modulo 1000000007.</p>",
      "samples": [
        {
          "input": "2\n4\n5",
          "output": "4\n11"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Number of Parts in Convex Polygon",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given an undirected graph, your task is to determine its girth, i.e., the length of its shortest cycle.",
      "complete_approach": "",
      "constraints": "$ 1 ≤ n ≤ 2500$\n$ 1 ≤ m ≤ 5000$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll int64_t\r\n#define endl '\\n'\r\nvector<int> d;\r\nint g;\r\nvoid bfs(vector<int> adj[], int s) {\r\n\tqueue<int> q;\r\n\tq.push(s);\r\n\r\n\td[s] = 0;\r\n\r\n\twhile (!q.empty()) {\r\n\t\tint v = q.front();\r\n\t\tq.pop();\r\n\r\n\t\tfor (auto x : adj[v]) {\r\n\t\t\tif (d[x] == INT_MAX) {\r\n\t\t\t\tq.push(x);\r\n\t\t\t\td[x] = d[v] + 1;\r\n\t\t\t}\r\n\t\t\telse if (d[v] <= d[x]) {\r\n\t\t\t\tg = min(g, d[v] + d[x] + 1);\r\n\t\t\t\tif (d[v] == d[x]) {   // optimisation.\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid solve() {\r\n\tint n, m, u, v;\r\n\tcin >> n >> m;\r\n\tvector<int> adj[n + 1];\r\n\tfor (int i = 0; i < m; i++) {\r\n\t\tcin >> u >> v;\r\n\t\tadj[u].push_back(v);\r\n\t\tadj[v].push_back(u);\r\n\t}\r\n\tg = INT_MAX;\r\n\tfor (int i = 1; i <= n; i++) {\r\n\t\td.assign(n + 1, INT_MAX);\r\n\t\tbfs(adj, i);\r\n\t}\r\n\tcout << ((g == INT_MAX) ? -1 : g);\r\n}\r\nint main() {\r\n\tios_base :: sync_with_stdio(0);\r\n\tcin.tie(nullptr); cout.tie(nullptr);\r\n\r\n#ifdef Mastermind_\r\n\tfreopen(\"input.txt\", \"r\", stdin); \\\r\n\tfreopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n\tint t = 1;\r\n\t// int i = 1;\r\n\t// cin >> t;\r\n\twhile (t--) {\r\n\t\t// cout << \"Case #\" << i << \": \";\r\n\t\tsolve();\r\n\t\t// i++;\r\n\t}\r\n\treturn 0;\r\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:23:22.266106+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Let's consider a simpler problem: given a graph, find the shortest cycle that\npasses through node 1.\n\nWhat does a cycle through node 1 look like? In any cycle through node 1, there\nexists two nodes $u$ and $v$ on that cycle such that there is a path from 1 to\n$u$ and 1 to $v$, and there is an edge between $u$ and $v$. The length of this\ncycle is $dist(1, u) + dist(1, v) + 1$.\n\nOne might now try to use BFS to find $dist(1, i)$ for each $i$ in\n$\\mathcal{O}(N + M)$ time and then check for each edge $(u, v)$ whether\n$dist(1, u) + dist(1, v) + 1$ is minimal.\n\nOf course, this means that we might count a \"cycle\" like\n$1 \\rightarrow x \\rightarrow u \\rightarrow v \\rightarrow x \\rightarrow 1$.\nHowever, this doesn't matter for our original problem, since the shortest cycle\nwill always be shorter than such a \"cycle\".\n\nThere's one problem with this approach though: if the edge $(u, v)$ is on the\npath from node 1 to node $v$, then $1 \\rightarrow u \\rightarrow v \\rightarrow 1$\nisn't a cycle! And this time, it does matter in our original problem!\n\nFortunately, there's a relatively simple fix.\n\nInstead of first finding all $dist(1, i)$ and then checking for the minimum, do\nboth at the same time during the BFS.\n\nNow to prevent \"backtracking\", we only consider $dist(1, u) + dist(1, v) + 1$ as\na minimum if we're currently at node $u$ and $dist(1, u) \\leq dist(1, v)$.\n\nThis algorithm runs in $\\mathcal{O}(N + M)$ time. Since $N$ and $M$ are so\nsmall, we can just apply this algorithm for all nodes instead of just node 1.\n\nThe final complexity of this solution is thus $\\mathcal{O}(N*(N + M))$."
      },
      "id": 895,
      "input_format": "The first input line has two integers $n$ and $m$: the number of nodes and edges. The nodes are numbered $1,2,…,n$.\n\nAfter this, there are $m$ lines describing the edges. Each line has two integers $a$ and $b$: there is an edge between nodes $a$ and $b$.\n\nYou may assume that there is at most one edge between every two nodes.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print one integer: the girth of the graph. If there are no cycles, print −1.",
      "samples": [
        {
          "input": "5 6\n1 2\n1 3\n2 4\n2 5\n3 4\n4 5\n",
          "output": "3\n"
        },
        {
          "input": "10 9\n5 6\n4 5\n8 9\n9 10\n1 2\n6 7\n3 4\n2 3\n7 8\n",
          "output": "-1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Graph Girth",
      "video_editorial_id": 10689
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string $s$ and a dictionary of strings $words$, output *\"Yes\"* if $s$ can be segmented into a space-separated sequence of one or more dictionary $words$, else output *\"No\"*.\n\n*Note that the same word in the dictionary may be reused multiple times in the segmentation.*",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 1000$\n$1 \\leq n \\leq 1000$\n$1 \\leq |s| \\leq 300$\n$1 \\leq words[i].length() \\leq 20$\nSum of $|s|$ over all test cases is $\\leq$ $3 \\times 10^4$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nbool wordBreak(string s, vector<string>& words) {\n    int n = s.size();\n    unordered_map<string, bool> m;\n    for (auto x : words)m[x] = 1;\n    vector<bool> dp(n + 1, false);\n    dp[0] = true;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= 20 && j <= i; j++) {\n            if (m.find(s.substr(i - j, j)) != m.end())dp[i] = (dp[i] | dp[i - j]);\n        }\n    }\n    return dp[n];\n}\nvoid solve() {\n    string s;\n    int n;\n    cin >> n;\n    cin >> s;\n    vector<string> words(n);\n    for (int i = 0; i < n; i++)cin >> words[i];\n    cout << ((wordBreak(s, words)) ? \"Yes\" : \"No\") << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:25:14.920957+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We use a boolean vector $dp[]$. \n$dp[i]$ is set to true if a valid word (word sequence) ends there. The optimization is to look from current position $i$ back and only substring and do dictionary look up in case the preceding position $j$ with $dp[j] == true$ is found.\n\n**Time Complexity:** $O(|s|^2)$"
      },
      "id": 991,
      "input_format": "First-line contains $T$ - the number of test cases.\nThe first line of each test case contains $n$ - the size of the dictionary $words$.\nThe second line of each test case contains string $s$.\nThe next $n$ lines of each test case contain $n$ words of the dictionary $words$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "for test 1, ilikealgozenith -> i + like + algozenith .",
      "output_format": "For each test case, output *\"Yes\"* if $s$ can be segmented into a space-separated sequence of one or more dictionary $words$, else output *\"No\"*.",
      "samples": [
        {
          "input": "3\n6\nilikealgozenith\nalgozenith\nlove\nlike\ni\nyou\nalgo\n2\napplepenapple\napple\npen\n3\nmississippi\nmiss\nippi\nsis\n",
          "output": "Yes\nYes\nNo\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Word Break",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are <i>N</i> students in section <i>A</i>. The <i>i</i>-th student got <i>A<sub>i</sub></i> marks. The class teacher of section <i>B</i> was absent so sections <i>A</i> and <i>B</i> were merged. The students of section <i>B</i> did not want to humiliate themselves, so they decided to sit with students having the same marks as them. You are given the marks of students of section <i>B</i> in order of their entry in the class. You have to tell whether the <i>i</i>-th student of section <i>B</i> can sit with a student with the same marks as him. If there is at least 1 person in the room with the same marks, print <i>‘YES’</i> else print <i>‘NO’</i>. (without the quotes)</p><p>See Sample Test Cases.</p>",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10$  \n\n$1 \\leq N, M \\leq 10^5$  \n\n$1 \\leq A_i, B_i \\leq 10^{12}$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n#define int long long\n\nsigned main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n, m;\n    cin >> n >> m;\n    map<int, bool> m1;\n    for (int i = 0; i < n; ++i) {\n      int x;\n      cin >> x;\n      m1[x] = 1;\n    }\n    for (int i = 0; i < m; ++i) {\n      int x;\n      cin >> x;\n      if (m1.count(x)) {\n        cout << \"YES\\n\";\n      } else {\n        cout << \"NO\\n\";\n        m1[x] = 1;\n      }\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:13:14.333042+00:00"
      },
      "hints": {
        "hint1": "You have to tell whether a student with the same marks is already present in the class. Try thinking about how you can store the marks of the students already present in the class and for the students as they enter the class.",
        "hint2": "Think of a data structure that can efficiently store if a student with given marks is present in the class.",
        "solution_approach": "The problem can be easily solved by using a $\\frac{map}{set}$. You have to store the marks of students of section `A` in the $\\frac{map}{set}$. As each student of section `B` enters the class, you can check if a student with given marks is present or not. You also have to store the marks of this student in the map/set so that a student who comes after with the same marks can sit with this student.\n\nTime Complexity per test case: $O((N+M)\\log N)$"
      },
      "id": 89,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\n\nThe first line of each test case contains two space-separated integers $N$ and $M$ - the number of students in sections $A$ and $B$, respectively.\n\nThe second line of each test case contains $N$ space-separated integers $A_1, A_2, \\dots, A_N$ - the grades of students in section $A$.\n\nThe third line of each test case contains $M$ space-separated integers $B_1, B_2, \\dots, B_M$ - the grades of students in section $B$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "In the first test case of the example, when the first student enters, there is no student with 7 marks.\nWhen the second student enters, there is 1 student with 4 marks.\nWhen the third student enters, there is no student with 1 mark.\nWhen the fourth student enters, there are 2 students with 4 marks.\nWhen the fifth student enters, there is 1 student with 5 marks.",
      "output_format": "<p>For each test case, print <i>M</i> strings on a new line. Print <i>‘YES’</i> if there is at least 1 person in the room with the same IQ. Otherwise, print <i>‘NO’</i>. (without the quotes)</p>",
      "samples": [
        {
          "input": "2\n3 5\n2 5 4\n7 4 1 4 5\n4 4\n1 1 8 2\n8 3 3 5",
          "output": "NO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNO"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Students and Grades",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of string <strong>products</strong> and a string <strong>searchWord</strong>. We want to design a system that suggests at most three product names from products after <strong>searchWord</strong> is typed. Suggested products should have a common prefix with the <strong>searchWord</strong>. If there are more than three products with a common prefix return the three lexicographically minimums products.</p><p>Return a list of lists of the suggested products after <strong>searchWord</strong> is typed.&nbsp;</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ N ≤ 10<sup>3</sup><br>1 ≤ Q ≤ 10<sup>3</sup><br>1 ≤ |product_name|, |searchWord| ≤ 10<sup>3</sup><br>It's guaranteed that all product names are unique.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass SearchSuggestionSystem\n{\nprivate:\n    struct TrieNode\n    {\n        bool isEnd;\n        struct TrieNode *child[26];\n\n        TrieNode()\n        {\n            isEnd = false;\n            for (int i = 0; i < 26; i++)\n                child[i] = nullptr;\n        }\n    };\n\n    TrieNode *trieRoot;\n\n    void insert(string &word)\n    {\n        TrieNode *temp = trieRoot;\n\n        for (int i = 0; i < (int)word.length(); i++)\n        {\n            int x = word[i] - 'a';\n            if (temp->child[x] == nullptr)\n            {\n                TrieNode *newNode = new TrieNode;\n                temp->child[x] = newNode;\n            }\n            temp = temp->child[x];\n        }\n\n        temp->isEnd = true;\n    }\n\n    void dfs(TrieNode *curNode, string &curString, vector<string> &ans)\n    {\n        if (curNode == nullptr)\n            return;\n\n        if (curNode->isEnd)\n            ans.push_back(curString);\n\n        if ((int)ans.size() == 3)\n            return;\n\n        for (int i = 0; i < 26; i++)\n        {\n            if (curNode->child[i])\n            {\n                curString.push_back('a' + i);\n                dfs(curNode->child[i], curString, ans);\n                curString.pop_back();\n\n                if ((int)ans.size() == 3)\n                    break;\n            }\n        }\n    }\n\npublic:\n    SearchSuggestionSystem(vector<string> products)\n    {\n        trieRoot = new TrieNode;\n\n        for (string productName : products)\n            insert(productName);\n    }\n\n    vector<string> suggestProducts(string searchWord)\n    {\n        TrieNode *curNode = trieRoot;\n        vector<string> ans;\n\n        for (int i = 0; i < (int)searchWord.length(); i++)\n        {\n            int x = searchWord[i] - 'a';\n\n            if (curNode->child[x] == nullptr)\n                return ans;\n\n            curNode = curNode->child[x];\n        }\n\n        dfs(curNode, searchWord, ans);\n\n        return ans;\n    }\n};\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<string> products;\n\n    for (int i = 0; i < n; i++)\n    {\n        string s;\n        cin >> s;\n        products.push_back(s);\n    }\n\n    SearchSuggestionSystem searchSuggestionSystem(products);\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        string searchWord;\n        cin >> searchWord;\n\n        vector<string> ans = searchSuggestionSystem.suggestProducts(searchWord);\n\n        for (string s : ans)\n            cout << s << \" \";\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:43:43.523664+00:00"
      },
      "hints": {
        "hint1": "<p>Brute force is a good choice because the length of the string is ≤ 1000. But how to do an effective search?</p>",
        "hint2": "<p>Use Trie data structure to store the best three matchings. Traverse the Trie.</p>",
        "solution_approach": "<p>Whenever we come across questions with multiple strings, it is best to think if Trie can help us. What we need here is a way to search for all the words with the given prefix, this is a well-known problem that trie can solve. The question also asks for sorted results, if you look closely a trie word is represented by its preorder traversal. It is also worth noting that a preorder traversal of a trie will always result in a sorted traversal of results, thus all we need to do is limit the word traversal to 3.</p>"
      },
      "id": 664,
      "input_format": "<p><span style=\"background-color:transparent;color:#222222;\">The first line of input contains <strong>N </strong>- the number of products.</span><br><span style=\"background-color:transparent;color:#222222;\">The second line contains product names separated by space.</span><br><span style=\"background-color:transparent;color:#222222;\">The third line of input contains <strong>Q </strong>- the number of queries.</span><br><span style=\"background-color:transparent;color:#222222;\">The next Q lines queries contain <strong>searchWord</strong>.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "6\nmobile mouse moneypot monitor mousepad mango\n3\nm\nmous\nmo",
          "output": "mango mobile moneypot\nmouse mousepad\nmobile moneypot monitor"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nclass SearchSuggestionSystem\n{\npublic:\n    SearchSuggestionSystem(vector<string> products)\n    {\n        \n    }\n\n    vector<string> suggestProducts(string searchWord)\n    {\n        \n    }\n};\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<string> products;\n\n    for (int i = 0; i < n; i++)\n    {\n        string s;\n        cin >> s;\n        products.push_back(s);\n    }\n\n    SearchSuggestionSystem searchSuggestionSystem(products);\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        string searchWord;\n        cin >> searchWord;\n\n        vector<string> ans = searchSuggestionSystem.suggestProducts(searchWord);\n\n        for (string s : ans)\n            cout << s << \" \";\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "Search Suggestions System",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "There are $N$ people working on a project, where they have to write exactly $M$ lines of code. The $i$-th person makes $A_i$ bugs in every line of code that they write.  \n\nThe first person writes $X_1$ lines of code, the second person writes $X_2$ lines of code, and so on, such that:  \n\n$\nX_1 + X_2 + \\dots + X_N = M\n$\n\nYou have to find the number of distinct plans $(X_1, X_2, \\dots, X_N)$, where $X_i \\geq 0$ and the sum of bugs across all lines of code is at most $B$.  \n\nSince the answer might be large, print it modulo $10^9 + 7$.",
      "complete_approach": "",
      "constraints": "<p>1≤ N, M ≤ 500</p><p>\n\n0≤ B ≤ 500</p>\n\n<p>0≤ A<sub>i </sub>≤ 500</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\n\nconst int mod = 1e9+7;\n\nint dp[2][501][501];\n\nsigned main() {\n   IOS\n   int t = 1;\n   while(t--) {\n       int n, m, b;\n       cin >> n >> m >> b;\n       int a[n];\n       for (int i = 0; i < n; ++i) {\n           cin >> a[i];\n       }\n       for (int i = 0; i <= 1; ++i) {\n           for (int j = 0; j <= m; ++j) {\n               for (int k = 0; k <= b; ++k) {\n                   dp[i][j][k]=0;\n               }\n           }\n       }\n       dp[0][0][0] = 1;\n       for (int i = 1; i <= n; ++i) {\n           int p = i & 1;\n           for (int j = 0; j <= m; ++j) {\n               for (int k = 0; k <= b; ++k) {\n                   dp[p][j][k] = dp[p^1][j][k];\n                   if(j && k >= a[i-1]) {\n                       dp[p][j][k] = (dp[p][j][k] + dp[p][j-1][k-a[i-1]])%mod;\n                   }\n               }\n           }\n       }\n       int ans = 0;\n       for (int i = 0; i <= b; ++i) {\n           ans = (ans + dp[n&1][m][i]) % mod;\n       }\n       cout << ans << \"\\n\";\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:46:30.780487+00:00"
      },
      "hints": {
        "hint1": "Define DP array, DP[X][Y][Z] where X denotes the number of programmers who have written Y lines of code with Z number of bugs.",
        "hint2": "<p>Using an N*N*N array will result in MLE since array of size 500*500*500 is 400MB. We will only need the previous count of X-1 programmers, so we can make array of size 2*N*N.</p>",
        "solution_approach": "<p>For the X-th programmer, there can be two cases: when he does not write any line of code and when he writes one or more lines of code.</p><p>The DP transition will be: DP[X][Y][Z] = DP[X-1][Y][Z] + DP[X][Y-1][Z-A[i]].</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N*M*B)</p>"
      },
      "id": 174,
      "input_format": "The first line contains four space-separated integers N, M, B.\n\nThe second line contains N space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, there is only one case, i.e., when the first programmer writes the whole code because then all 3 lines of code will have 3 bugs.\n\nFor the second test case, there can be two plans:  \n1. The first programmer writes 2 lines, and the second programmer writes 1 line (Number of bugs would be 4).  \n2. The first programmer writes 3 lines, and the second programmer does not write any lines of code (Number of bugs would be $3 \\leq 4$).\n\nFor the third test case, there can be three plans:\n1. The first programmer writes 2 lines, and the second programmer writes 0 lines (Number of bugs would be $3 \\leq 4$).  \n2. The first programmer writes 1 line, and the second programmer writes 1 line (Number of bugs would be $3 \\leq 4$).  \n3. The first programmer writes 0 lines, and the second programmer writes 2 lines (Number of bugs would be $4 \\leq 4$).",
      "output_format": "<p>Print the number of distinct plans which have exactly B bugs. Since the answer might be large, print it modulo 10<sup>9</sup>+7.</p>",
      "samples": [
        {
          "input": "2 3 3\n1 2",
          "output": "1"
        },
        {
          "input": "2 3 4\n1 2",
          "output": "2"
        },
        {
          "input": "2 2 4\n1 2",
          "output": "3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Bugs in code",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>We are given two equal-length strings S and T. Figure out if we can get string T starting from string S and applying 4 substring reversal operations.</p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 ≤ TC ≤ 10^2\n1 ≤ |S| ≤ 40\n|T|=|S|</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\nusing lli =  int long long;\nlli n,n2;\nlli tot = 1e9+10;\nset<string> gen;\n\nstring reverse1(string s , int l ,int r){\n    reverse(s.begin()+l,s.begin()+r+1);\n    return s;\n}\n\n\n// generates all posible strings from substring reversal with k moves left\nvoid brute(string st , int k){\n\n    if(k==0){ \n        gen.insert(st);\n        return;\n    }\n    int l=0;int r = st.length()-1;\n\n   for(int i=0;i<=r;i++){\n        for(int j=i;j<=r;j++){\n            string s2 = st;\n            s2 = reverse1(st,i,j);\n            brute(s2,k-1);\n        }   \n    }\n    \n}\n\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    // for getting input from input.txt\n    freopen(\"input.txt\", \"r\", stdin);\n    // for writing output to output.txt\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    \n    IOS\n    lli t;\n    \n    cin>>t;\n    while(t--){\n        string s,t;\n        cin >> s >> t;\n        set<string> gen1;\n        set<string> gen2;\n        \n        brute(s,2);\n        gen1=gen;      //Stores all possible values of S2 after 2 step substring reversal from S\n        gen.clear();\n     \n        brute(t,2);\n        gen2=gen;       //Stores all possible values of S2 after 2 step substring reversal from T\n        gen.clear();\n        \n        //Check if any S2 value from the 2 sets are same.\n        int c=0;\n        for(auto it:gen1){\n            if(gen2.find(it)!=gen2.end()){\n                cout << \"YES\" <<\"\\n\";\n                c=1;\n                break;\n            }\n            \n        }\n        if(!c)\n            cout << \"NO\" << \"\\n\";\n    }\n    return 0;\n}\n\n//TIME COMPLEXITY\n// O(N^5 logN)```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:47:33.665916+00:00"
      },
      "hints": {
        "hint1": "For a string of length N, you have to consider all strings obtained by reversal of any substring of that string. Of all such strings generated, check if any one of them is the target string. This is the Brute Force approach to the problem. ",
        "hint2": "For a string of length N, how many substrings are possible? N^2 different strings are possible by their substring reversal. In total there has to be 4 transitions taking place. In the first step, N^2 different strings are formed, then for each of these strings, another set of N^2 different strings is obtained. This process is repeated four times in total, till you get one string the same as the original string. \n\nS → S1 → S2 → S3 → T\n\nAt each of the four recursion stacks, there are N^2 choices of strings. Each of these steps takes O(N^2 ) time. So total Time Complexity becomes O(N*(N^2)^k ) . where k is the total number of steps (i.e. k=4 ). Additional O(N) is because of the reversal of the string, in the recursion stack.\n\nHence, by using Brute Force total time complexity becomes O(N^9). This is too big even with the given constraints. Can you do better than this?",
        "solution_approach": "Here, the above brute force logic can be optimized to a great extent using the Meet in the Middle concept. One crucial observation to the problem is that, from **S**, by reversing some substring, we can obtain **S1**; similarly, by reversing some substring of **S1**, we can obtain **S** again.  \n\nHence, **S ↔ S1**.  \n\nGenerally, in the meet in the middle concept, we try to divide the element in half. So here we are dividing the recursion level (or the number of moves left) in half. From each string, we are going to apply 2 moves to reach a certain **S2** string:  \n**S → S1 → S2**  \n\nAgain, starting from the target string **T**, we are applying two moves to reach **S2**:  \n**S2 ← S3 ← T**  \n\nGenerate all possible values of **S2** from both **S** and **T** strings, and check if there are any two components similar.  \n\n### How does this reduce the Time Complexity?\n\nTo generate all distinct **S2** from **S** will take \\(O((N^2)^k)\\) with \\(k=2\\), i.e., \\(O(N^4)\\) time. Similarly, to generate all **S2** from the **T** string will also take \\(O(N^4)\\) time.  \n\nThey are stored in sets **gen1** and **gen2**, respectively. Also, the reversal of strings in all recursion stacks will be \\(O(N)\\) in total.  \n\nFinally, the sets will contain \\(O(N^4)\\) elements. Checking the set for the presence of the same **S2** string will take \\(O(N^4 \\log N)\\).  \n\nHence, the final time complexity becomes \\(O(N^5 \\log N)\\). Thus, Meet in the Middle greatly reduces the time complexity of the code.  \n\n---\n\n### EXAMPLE RUN:\n\n1  \n**S = abdec**  \n**T = bdaec**  \n\nFrom **S = abdec**, there are two reversals to obtain:  \n**S2 = aecbd**  \n\\[ abdec → abced and abced → aecbd \\]  \n\nFrom **T = bdaec**, there are two reversals to obtain:  \n**S2 = aecbd**  \n\\[ bdaec → bcead and bcead → aecbd \\]\n"
      },
      "id": 487,
      "input_format": "<p>The first line contains an integer TC (number of test cases),</p><p>The next line contains a string S.&nbsp;</p><p>The next line contains a string T.&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "### TEST CASE 1:\n\n**S = prqs**  \n**T = psrq**  \n\n4 transitions are:  \n1. prqs → pqrs  \n2. pqrs → srqp  \n3. srqp → srpq  \n4. srpq → psrq  \n\n---\n\n### TEST CASE 2:\n\n**S = abdec**  \n**T = bdaec**  \n\n4 transitions are:  \n1. abdec → abced  \n2. abced → aecbd  \n3. aecbd → bcead  \n4. bcead → bdaec",
      "output_format": "<p>For each test case print “YES” if it is possible to form a square fence, else print “NO” without double quotes in a new line.</p>",
      "samples": [
        {
          "input": "2\nabacde\nbeacda\nabcdef\nabdefc",
          "output": "YES\nYES"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "4 Reversals",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given two integers L and R. You have to pick any two integers(they may be the same) in the range L to R(both inclusive) such that the xor of those two integers is maximum.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤10<sup>4</sup></p><p>1 ≤ L ≤ R ≤ 10<sup>18</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <set>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n#include <cstring> // For memset\nusing namespace std;\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpi;\ntypedef set<ll, greater<ll>> st;\ntypedef multiset<ll, greater<ll>> mst;\ntypedef unordered_map<ll, ll> mapp;\ntypedef pair<pii, pii> ppii;\ntypedef queue<ll> que;\n\nconst ll mod = 1000000007;\nstring s1, s2;\nll dp[64][2][2][2][2];\n\nll func(ll ind, ll ar, ll al, ll br, ll bl) {\n    if (ind == s1.size())\n        return 0;\n    if (dp[ind][ar][al][br][bl] != -1)\n        return dp[ind][ar][al][br][bl];\n    ll mina = 0, maxa = 1;\n    if (al == 0 && s1[ind] == '1')\n        mina = 1;\n    if (ar == 0 && s2[ind] == '0')\n        maxa = 0;\n    ll maxb = 1, minb = 0;\n    if (br == 0 && s2[ind] == '0')\n        maxb = 0;\n    if (bl == 0 && s1[ind] == '1')\n        minb = 1;\n\n    ll i, j, val = 0;\n    for (i = mina; i <= maxa; i++) {\n        for (j = minb; j <= maxb; j++) {\n            ll temp = (1LL << (s1.size() - ind - 1)) * (i ^ j);\n            ll nar, nal, nbr, nbl;\n            nar = ar == 0 && i == s2[ind] - '0' ? 0 : 1;\n            nal = al == 0 && i == s1[ind] - '0' ? 0 : 1;\n            nbr = br == 0 && j == s2[ind] - '0' ? 0 : 1;\n            nbl = bl == 0 && j == s1[ind] - '0' ? 0 : 1;\n            val = max(val, temp + func(ind + 1, nar, nal, nbr, nbl));\n        }\n    }\n    return dp[ind][ar][al][br][bl] = val;\n}\n\nstring getbin(ll num) {\n    string res = \"\";\n    while (num) {\n        res += ((num & 1) + '0');\n        num /= 2;\n    }\n    if (res == \"\") // Handle case for 0 explicitly\n        res = \"0\";\n    else\n        reverse(res.begin(), res.end());\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while (t--) {\n        ll l, r;\n        cin >> l >> r;\n        s1 = getbin(l);\n        s2 = getbin(r);\n        while (s1.size() != s2.size())\n            s1 = '0' + s1;\n        memset(dp, -1, sizeof(dp));\n        cout << func(0, 0, 0, 0, 0) << \"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:43:58.712395+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 305,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first and only line of each test case contains two space-separated integers L and R.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, 1 and 2 give the maximum xor, which is 3.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, 7 and 8 give the maximum xor, which is 15.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, 5 and 10, 6 and 9, 7 and 8 give the maximum xor, which is 15.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the</span><span style=\"background-color:#ffffff;color:#222222;\"> maximum value of xor of two integers i</span><span style=\"background-color:transparent;color:#000000;\">n the range L to R(both inclusive) on a separate line.</span></p>",
      "samples": [
        {
          "input": "3\n1 3\n3 8\n5 10",
          "output": "3\n15\n15"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Maximum XOR",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an array of N integers. Find the longest subarray with distinct characters.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ N ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ A<sub>i</sub> ≤ 10<sup>9</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of N over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>5</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n// #include \"deb.h\"\n\nusing namespace std;\n\n#define int long long\n\nint freq[1000001] = {0};\n\nvoid solve()\n{\n    int n, k;\n    int distinct = 0;\n\n    cin >> n;\n\n    int arr[n];\n\n    for (int i = 0; i < n; i++)\n        cin >> arr[i];\n\n    int head = -1, tail = 0;\n    int ans = 0;\n\n    while (tail < n)\n    {\n        while (head + 1 < n && freq[arr[head + 1]] == 0)\n        {\n            head++;\n            freq[arr[head]]++;\n        }\n\n        ans = max(ans, head - tail + 1);\n\n        if (tail <= head)\n        {\n            freq[arr[tail]]--;\n            tail++;\n        }\n        else\n        {\n            tail++;\n            head = tail - 1;\n        }\n    }\n\n    cout << ans << '\\n';\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int _t = 1;\n    cin >> _t;\n    while (_t--)\n    {\n        solve();\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:41:28.829906+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Maintain a map with the character frequency.</span></p>",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Take a left pointer and whenever the frequency of the map is more than 1, increase the left pointer until the frequency is not equal to 1. Take the maximum of all the distinct subarrays.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N log N)</span></p>"
      },
      "id": 371,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer N - the length of the array.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">The second line of each test case contains N space-separated integers.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case: <strong>1 2</strong> 2 1 2</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case: 3 3 <strong>3</strong> 3</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case: 1<strong> 3 2 4 1</strong></span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the longest subarray with distinct characters.</span></p>",
      "samples": [
        {
          "input": "3\n5\n1 2 2 1 2\n4\n3 3 3 3\n5\n1 3 2 4 1\n",
          "output": "2\n1\n4\n"
        },
        {
          "input": "1\n7                   \n1 2 3 1 4 5 6\n",
          "output": "6\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Longest Distinct Subarray AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Let us see the following equation,</p><p style=\"text-align:center;\"><i><strong>Ax + By = C</strong></i></p><p>Given three positive integers <i>A</i>, <i>B</i> and <i>C</i>.</p><p>You have to determine whether there exists at least one solution for some integers value of <i>x</i> and <i>y</i> where <i>x, y</i> may be negative or non-negative integers.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int T; cin >> T;\n    while(T--) {\n        int A, B, C;\n        cin >> A >> B >> C;\n        int G = __gcd(A, B);\n        if(C % G == 0) cout << \"Yes\\n\";\n        else cout << \"No\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:44:42.418729+00:00"
      },
      "hints": {
        "hint1": "Try to think in terms of GCD of A and B.",
        "hint2": "The reason why we need to find the GCD of A and B to determine the existence of integer solutions for the equation $Ax + By = C$ is based on Bezout's identity.\n\nBezout's identity states that for any two integers a and b, their greatest common divisor (GCD) can be expressed as the smallest positive integer that can be expressed as a linear combination of a and b, that is:\n\n$gcd(a, b) = ax + by$ where $x$ and $y$ are integers.\n\nThis shows that if the GCD of A and B divides C, then there exists a solution for the equation $Ax + By = C$ in integers.\n\nConversely, if the GCD of A and B does not divide C, then there cannot be a solution for the equation $Ax + By = C$ in integers.\n\nThus, by finding the GCD of A and B and checking whether it divides C, we can determine the existence of integer solutions for the equation $Ax + By = C$.",
        "solution_approach": "If $C\\mod GCD(A, B) ==0$, then answer is \"Yes\". Otherwise \"No\"."
      },
      "id": 66,
      "input_format": "The first line contains $T$ ($1 \\leq T \\leq 100000$), the number of test cases.  \nEach of the next $T$ lines contains three positive integers $A, B, C$ ($1 \\leq A, B, C \\leq 10^9$).",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>For <i>x = 1, y = 3, 6 * 1 + 9 * 3 = 33</i>. The equation is satisfied for (<i>1, 3</i>).</p><p><i><strong>Explanation 2:</strong></i><br>No solution exists in this case. Observe that <i>A</i> and <i>B</i> are even numbers. So <i>Ax + By</i> is always even number, irrespective of the value of <i>x</i> and <i>y</i>.<br>But <i>C</i> is an odd number. So no solution exists in this case.</p>",
      "output_format": "<p>Print \"<i>Yes</i>\" (without quotes) if at least one solution exits, otherwise print \"<i>No</i>\" (without quotes).</p>",
      "samples": [
        {
          "input": "2\n6 9 33\n2 8 1",
          "output": "Yes\nNo"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Can You Make C",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You have a rectangular sheet of paper with dimensions H x W. You make N horizontal and verticals cuts in the sheet. Find the area of the maximum fragment after each cut.\n\nIt is guaranteed that there won't be any two identical cuts. Also, The cut that you make in the previous queries persists on the paper for the next queries.",
      "complete_approach": "",
      "constraints": "- $1 \\leq T \\leq 10^5$\n- $1 \\leq N \\leq 10^5$\n- $2 \\leq W, H \\leq 10^9$\n- $1 \\leq Y \\leq H - 1$\n- $1 \\leq X \\leq W - 1$\n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\n\nsigned main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int w, h, n;\n        cin >> h >> w >> n;\n        set<int> hori, verti;\n        hori.insert(0);\n        hori.insert(h);\n        verti.insert(0);\n        verti.insert(w);\n        multiset<int> w1, h1;\n        w1.insert(w);\n        h1.insert(h);\n        while(n--) {\n            char c;\n            int x;\n            cin >> c >> x;\n            if(c == 'H') {\n                hori.insert(x);\n                auto it = hori.lower_bound(x);\n                auto it1 = it, it2 = it;\n                it1--; it2++;\n                h1.erase(h1.find(*it2 - *it1));\n                h1.insert(*it2 - *it);\n                h1.insert(*it - *it1);\n            }\n            else {\n                verti.insert(x);\n                auto it = verti.lower_bound(x);\n                auto it1 = it, it2 = it;\n                it1--; it2++;\n                w1.erase(w1.find(*it2 - *it1));\n                w1.insert(*it2 - *it);\n                w1.insert(*it - *it1);\n            }\n            int ans = (*prev(w1.end())) * (*prev(h1.end()));\n            cout << ans << \"\\n\";\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:29.408478+00:00"
      },
      "hints": {
        "hint1": "The largest piece would have the largest height and width.",
        "hint2": "",
        "solution_approach": "Store all the height and width in two multisets. Also store all the horizontal and vertical cut marks in separate sets.\n\nTime Complexity per test case: O(N * log(W + H))"
      },
      "id": 374,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains three space-separated integers H W N - the dimensions of the sheet and the number of cuts.\n\nEach of the next N lines is of the form H Y or V X. For H Y, you make a horizontal cut at distance Y from the lower edge of the sheet and for V X, you make a vertical cut at a distance X from the left edges of the sheet.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the area of the maximum fragment after each cut.",
      "samples": [
        {
          "input": "2\n5 3 3\nH 1\nV 1\nV 2\n3 5 4\nH 2\nV 2\nH 1\nV 1",
          "output": "12\n8\n4\n10\n6\n3\n3\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Maximum Area AZ101",
      "video_editorial_id": 8190
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "## Description\n\nWe have to paint **n** boards of length `{A1, A2, ..., An}`. There are **k** painters available, and each takes **1 unit time** to paint **1 unit** of the board. The goal is to find the **minimum time** required to complete this task under the following constraints:\n\n### Constraints\n1. Two painters cannot share a board. A board cannot be partially painted by one painter and partially by another.\n2. A painter can only paint **contiguous** boards. For example, if a painter paints board 1 and 3 but not 2, it is invalid.",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nsigned main(){\n   ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n   int t;\n   cin >> t;\n   while(t--) {\n       int n, k;\n       cin >> n >> k;\n       int x[n];\n       int l = 0, r = 0;\n       for (int i = 0; i < n; ++i) {\n           cin >> x[i];\n           l = max(l, x[i]);\n           r += x[i];\n       }\n       int ans = 0;\n       while(l <= r) {\n           int mid = (l+r)/2;\n           int cnt = 0;\n           int now = 0;\n           for (int i = 0; i < n; ++i) {\n               if(now + x[i] <= mid) {\n                   now += x[i];\n               }\n               else {\n                   now = x[i];\n                   cnt++;\n               }\n           }\n           if(now) cnt++;\n           if(cnt <= k) {\n               ans = mid;\n               r = mid - 1;\n           }\n           else {\n               l = mid + 1;\n           }\n       }\n       cout << ans << \"\\n\";\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:17:09.054216+00:00"
      },
      "hints": {
        "hint1": "If K painters are able to paint the boards in time X, then they can paint the boards in time less than X as well. That means this is a monotonic function. You can use this to apply binary search.",
        "hint2": "<p>We would be doing binary search on the minimum time to paint all the boards by the K painters. We take the left pointer as L = max(Xi) (because 2 painters cannot share a board to paint) and R = Σ(Xi). We take mid = (L+R)/2. Find the number of painters it takes to paint all the boards in time ‘mid’. This can be done by assigning the boards to the painters in contiguous order and at the same time ensuring that the painters are painting the boards in continuous order.</p><p>If the number of painters is ≤ K, that means this is a possible answer and we can minimize the time taken to paint the boards, we continue binary search on L to R = mid-1. Otherwise, we need to increase the time to ensure that only K painters are doing the job, so we continue the binary search on L = mid+1 to R.</p><p>Time Complexity: O(N * log<sub>2</sub>(ΣXi))</p>",
        "solution_approach": ""
      },
      "id": 472,
      "input_format": "<p>The first line contains a single integer T (1 ≤ T ≤ 100000) - the number of test cases.</p><p>The first line of each test case contains 2 space-separated integers N, K (1 ≤ N ≤ 100000, 1 ≤ K ≤ 100000) - the number of boards and the number of painters.</p><p>The second line of each test case contains N space-separated integers (0 ≤ xi ≤ 10^9) - the length of the boards.</p><p>Sum of N across all test cases ≤ 10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the minimum time required to complete the painting in a new line.</p>",
      "samples": [
        {
          "input": "5\n5 2\n1 2 3 4 5\n5 3\n2 5 7 2 5\n5 1\n1 2 3 4 5\n5 5\n1 2 3 4 5\n5 4\n1 7 2 3 5",
          "output": "9\n7\n15\n5\n7"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Famous Painter Partition Problem",
      "video_editorial_id": 10682
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "An integer array is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\nFor example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences, whereas [1,2,4,5] is not an arithmetic sequence.\n\nGiven an integer array A, return the number of arithmetic **subarrays** of A.\n\nA **subarray** of any array can be formed by deleting several, possibly none, elements from either end of the array.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ &nbsp;N ≤ 10<sup>5</sup></p><p>-10<sup>9</sup> ≤ A[i] ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long findArithmeticSeq(int a[], int n)\n{\n    long long dp[n] = {0};\n    for (int i = 2; i < n; i++)\n    {\n        dp[i] = (a[i] - a[i - 1] == a[i - 1] - a[i - 2]) ? 1 + dp[i - 1] : 0;\n    }\n    long long ans = 0;\n    for (int i = 0; i < n; i++)\n        ans += dp[i];\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    cout << findArithmeticSeq(a, n) << '\\n';\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing"
        ],
        "last_updated": "2024-06-22T02:13:41.697833+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "\nCan you think of using Dynamic Programming? Consider this state dp(i) → represents the number of arithmetic sequences ending at i<sup>th</sup> index. Think of transition.",
        "solution_approach": "<p>The <i>dp</i> transition can be written as:</p><pre><code class=\"language-cpp\">if(a[i]-a[i-1]==a[i-1]-a[i-2])\n\tdp[i]=1+dp[i-1]\nelse\n\tdp[i]=0</code></pre><p>The answer will be the sum of all the <i>dp</i> values. The time complexity will be <i>O(N)</i> and space complexity is <i>O(N)</i>. It can be done without any extra space as we only need the <i>dp</i> value for the previous state.</p>"
      },
      "id": 633,
      "input_format": "The first line contains a single integer N -  the size of the array.\nThe second line contains N integers - the elements of the array.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "[1,3,5] [3,5,7] and [1,3,5,7] are the arithmetic sequences in the first test case.\n\n[1,2,3] is the only arithmetic sequence in the second test case.\n\nNo arithmetic sequence in the third test case.",
      "output_format": "Print the number of arithmetic **subarrays** of A.",
      "samples": [
        {
          "input": "4\n1 3 5 7",
          "output": "3"
        },
        {
          "input": "4\n1 2 3 5",
          "output": "1"
        },
        {
          "input": "3\n1 0 1",
          "output": "0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nlong long findArithmeticSeq(int a[], int n)\n{\n    //add code here\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    cout << findArithmeticSeq(a, n) << '\\n';\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "SLICES-I",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a grid of size n*m with non-negative integers, you need to find the maximum path sum from (1, 1) to (n, m). You are allowed to move from (x, y) to (x+1, y) and (x, y) to (x, y+1).</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ t ≤ 10<sup>5</sup></p><p>1 ≤ n, m ≤ 10<sup>3</sup></p><p>0 ≤ a<sub>ij</sub> ≤ 10<sup>7</sup></p><p>It is guaranteed that the sum of n*m over all test cases does not exceed 10<sup>6</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nint dp[1005][1005];\nint grid[1005][1005];\nsigned main(){\n   ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n   int t;\n   cin >> t;\n   while(t--) {\n       int n, m;\n       cin >> n >> m;\n       for (int i = 0; i < n; ++i) {\n           for (int j = 0; j < m; ++j) {\n               cin >> grid[i][j];\n           }\n       }\n       for (int i = 0; i <= n; ++i) {\n           for (int j = 0; j <= m; ++j) {\n               dp[i][j] = 0;\n           }\n       }\n       for (int i = 0; i < n; ++i) {\n           for (int j = 0; j < m; ++j) {\n               dp[i+1][j+1] = grid[i][j] + max(dp[i+1][j], dp[i][j+1]);\n           }\n       }\n       cout << dp[n][m] << \"\\n\";\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:17:22.262967+00:00"
      },
      "hints": {
        "hint1": "The cell (i, j) can only be reached from the cells (i-1, j) and (i, j-1).",
        "hint2": "Since precomputed values are being used, the problem can be solved using dynamic programming.",
        "solution_approach": "Find the maximum path sum for the cell (i, j) using the cells (i-1, j) and (i, j-1). Define dp[i][j] which denotes the maximum path sum to reach (i, j). The maximum path sum for arriving at the cell (i, j) can be given as dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]). Use the same recurrence for finding dp[n][m].\n\nTime Complexity per test case: O(n*m)\n\nSolve the same problem for minimum path sum. Do not forget the boundary condition for the leftmost column and topmost row."
      },
      "id": 491,
      "input_format": "<p>The first line of the input contains one integer t - the number of test cases. Then t test cases follow.</p><p>The first line of each test case contains two space-separated integers n, m - the size of the grid.</p><p>Each of the following n lines contains m space-separated integers, aij - the number at that cell.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For the first test case, path 3 → 4 → 1 → 1 maximises the sum.</p><p>For the second test case, path 1 → 2 → 5 → 1 → 1 and 1 → 3 → 4 → 1 → 1 maximises the sum.</p><p>For the third test case, path 1 → 3 → 4 maximises the sum.</p>",
      "output_format": "<p>For each test case, print the maximum path sum.</p>",
      "samples": [
        {
          "input": "3\n2 3\n3 2 1\n4 1 1\n3 3\n1 2 1\n3 5 1\n4 1 1\n2 2\n1 2\n3 4",
          "output": "9\n11\n8"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Maximum path sum in grid",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You want to visit the country of Wonderland. There are **N** cities in the country. Not all cities are connected by roads, but you know which cities are connected.\n\nYou landed in city **A**, and you want to visit city **B**. You already booked your car, but it doesn’t have any petrol. The capacity of the tank of the car is **C**. You know the **Per Liter cost** of petrol in each city, and you also have the map of the country (i.e., you know the length of the road between two cities). \n\n**To travel one unit of distance, you need one liter of petrol.**\n\nYour task is to find the **minimum cost** to travel from city **A** to city **B**.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ N ≤ 10000<br>1 ≤ M ≤ 100000<br>1 ≤ C ≤ 100<br>1 ≤ u, v ≤ N<br>1 ≤ d ≤ C<br>1 ≤ A, B ≤ N<br>1 ≤ P[i] ≤ 100<br>&nbsp;</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define F first\n#define S second\n#define MP make_pair\nusing ii = pair<int, int>;\n\nint n, m, C;\nvector<ii> g[10010];\nint P[10010];\n\nint dist[10001][101];\nint vis[10001][101];\n\nint dijk(int st, int en)\n{\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j <= C; j++)\n        {\n            dist[i][j] = 1e9;\n            vis[i][j] = 0;\n        }\n    }\n\n    priority_queue<pair<int, ii>> pq;\n    \n    pq.push(MP(0, MP(st, 0)));\n    dist[st][0] = 0;\n    \n    while (!pq.empty())\n    {\n        pair<int, ii> cur = pq.top();\n        pq.pop();\n        \n        int node = cur.S.F;\n        int fuel = cur.S.S;\n        int dis = -cur.F;\n\n        if (vis[node][fuel] == 1)\n            continue;\n        \n        vis[node][fuel] = 1;\n\n        if (fuel < C && dis + P[node] < dist[node][fuel + 1])\n        {\n            dist[node][fuel + 1] = dis + P[node];\n            pq.push(MP(-dist[node][fuel + 1], MP(node, fuel + 1)));\n        }\n        \n        for (auto v : g[node])\n        {\n            if (fuel >= v.S && dist[v.F][fuel - v.S] > dis)\n            {\n                dist[v.F][fuel - v.S] = dis;\n                pq.push(MP(-dist[v.F][fuel - v.S], MP(v.F, fuel - v.S)));\n            }\n        }\n    }\n    \n    int mini = 1e9;\n    \n    for (int i = 0; i <= C; i++)\n    {\n        mini = min(mini, dist[en][i]);\n    }\n\n    assert(mini < 1e9);\n    \n    return mini;\n}\n\nvoid solve()\n{\n\n    cin >> n;\n    cin >> m;\n    \n    for (int i = 0; i < m; i++)\n    {\n        int u, v, w;\n        \n        cin >> u >> v >> w;\n        \n        g[u].push_back({v, w});\n        g[v].push_back({u, w});\n    }\n    \n    for (int i = 1; i <= n; i++)\n    {\n        cin >> P[i];\n    }\n    \n    int st, en;\n    \n    cin >> st >> en >> C;\n\n    cout << dijk(st, en) << \"\\n\";\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //int _t;cin>>_t;while(_t--)\n    solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:45:15.238191+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 615,
      "input_format": "The first line of input contains **N** - the number of cities in the country of Wonderland.  \nThe second line contains **M** - the number of roads in the country.  \n\nThe next **M** lines each contain three integers **u**, **v**, and **d**:  \n- There is a road between city **u** and **v** of length **d**.\n\nThe next line contains **N** space-separated integers:  \n**P[1], P[2], ..., P[N]** - where **P[i]** is the per liter cost of petrol in city **i**.\n\nThe last line of input contains three integers **A**, **B**, and **C**:  \n- **A**: The starting city.  \n- **B**: The destination city.  \n- **C**: The capacity of the car's petrol tank.\n\nIt is guaranteed that it’s always possible to reach city **B** from city **A**.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><strong>Explanation 1:</strong></p><p>Fill petrol of 4 liters in city 1, and travel via path 1 → 2 → 3 → 4 → 5.</p><p><strong>Explanation 2:</strong></p><p>Fill 1 liter of petrol in city 1 of cost 10, travel to city 6. Fill 5 liters of petrol at city 6 of cost 5 x 1 = 5. Travel to city 5. Total cost = 10 + 5 = 15. The path took 1 → 6 → 5.</p>",
      "output_format": "Print the minimum cost to reach city **B** on a new line.",
      "samples": [
        {
          "input": "5\n5\n1 2 1\n2 3 1\n3 4 1\n4 5 1\n1 4 6\n1 10 10 10 1\n1 5 8",
          "output": "4"
        },
        {
          "input": "6\n6\n1 2 1\n2 3 1\n3 4 1\n4 5 1\n1 6 1\n6 5 5\n10 10 10 10 1 1\n1 5 8",
          "output": "15"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Budget Travelling",
      "video_editorial_id": 8218
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array of N integers and a size K. Find the maximum integer for every contiguous subarray of size K.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^6$  \n\n$1 \\leq K \\leq N \\leq 10^6$  \n\n$1 \\leq A_i \\leq 10^6$  \n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include<bits/stdc++.h>\nusing namespace std;\nvoid solve(){\n\tdeque<int> dq;\n\tint N,K;\n\tcin>>N>>K;\n\tint A[N];\n\tfor(int i=0;i<N;i++){\n\t\tcin>>A[i];\n\t}\n\tfor(int i=0;i<K-1;i++){\n\t\t// Use the deletion scheme over here as well.\n\t\t// We always want to keep monotone here\n\t\n\t\t// also check empty before dq.back() ... or else segmentation fault.\n\t\twhile(!dq.empty() && dq.back()<A[i]){\n\t\t\tdq.pop_back();\n\t\t}\n\n\t\tdq.push_back(A[i]);\n\t}\n\tfor(int i=K-1;i<N;i++){\n\t\t//keep the <= as < as we want to keep dublicates of same numer.\n\t\t// Try on sample : 6 4\n\t\t// \t\t\t\t   5 4 5 4 3 2\n\t\twhile(!dq.empty() && dq.back()<A[i]){\n\t\t\tdq.pop_back();\n\t\t}\n\t\tdq.push_back(A[i]);\n\t\tcout<<dq.front()<<\" \";\n\t\tif(dq.front()==A[i-K+1]){\n\t\t\tdq.pop_front();\n\t\t}\n\t}\n\tcout<<\"\\n\";\n  }\n\nsigned main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint T;\n\tcin>>T;\n\twhile(T--){\n\t\tsolve();\n\t}\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:46:17.553434+00:00"
      },
      "hints": {
        "hint1": "Create a deque that will store the index of the array integers.",
        "hint2": "",
        "solution_approach": "Make the deque such that it is non-increasing and hence the first element of the deque would be the answer for each subarray of size K.\n\nTime Complexity per test case: O(N)"
      },
      "id": 354,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains two space-separated integers N and K - the length of the array and the subarray size. \n\nThe second line of each test case contains N space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, contiguous subarrays of size 2 are: [3, 1], [1, 2], [2, 5] and [5, 4]. The maximum integers in them are: 3, 2, 5, 5\n\nFor the second test case, a contiguous subarray of size 1 is: [1, 3, 2, 6]. The maximum integer is: 6.\n\nFor the third test case, contiguous subarrays of size 3 are: [3, 5, 6], [5, 6, 1], [6, 1, 9], [1, 9, 7] and [9, 7, 2]. The maximum integers in them are: 6, 6, 9, 9, 9.",
      "output_format": "For each test case, print the maximum integer for every contiguous subarray of size K.",
      "samples": [
        {
          "input": "3\n5 2\n3 1 2 5 4\n4 4\n1 3 2 6\n7 3\n3 5 6 1 9 7 2\n",
          "output": "3 2 5 5 \n6 \n6 6 9 9 9\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Maximum Element in each subarray AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an integer N with no more than </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>5</sup></span><span style=\"background-color:transparent;color:#000000;\"> digits. You have to find the sum of its digits.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ Number of digits in N ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of the number</span><span style=\"background-color:#ffffff;color:#000000;\"> of digits in N</span><span style=\"background-color:transparent;color:#000000;\"> over all the test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>6</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        string s;\n        cin >> s;\n        int ans = 0;\n        for (char digit : s) {\n            ans += (digit - '0');\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:38:58.303218+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">long long int won’t fit the constraints to input N</span></p>",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Store the given integer as a string and iterate through it to find the sum of digits.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(Number of digits in N)</span></p>"
      },
      "id": 321,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer N.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, 1+2 = 3</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, 1+5+6+1 = 13</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the sum of digits on N on a new line.</span></p>",
      "samples": [
        {
          "input": "3\n12\n1561\n53453451234567876545676540909890989890987987567654567654567656765678765678765\n",
          "output": "3\n13\n443\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Sum of Digits",
      "video_editorial_id": 10694
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a string S consisting of lowercase characters. Some of the characters are good and the rest are bad. A substring S[l..r] is a string S<sub>l</sub>S<sub>l+1</sub>…S<sub>r. </sub>A substring S[l..r] is good if among the letters S<sub>l</sub>S<sub>l+1</sub>…S<sub>r </sub>there are at most K bad ones. You have to find the number of distinct good substrings of the given string S. Two substrings S[l..r] and S[p..q] is distinct if their content is different S[l…r]≠S[p..q].</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n# include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\nusing lli =  int long long;\nusing ii = pair<lli,lli>;\n//#define ld long double;\n#define F first\n#define S second\n\nconst int tot = 1e6+5;\nconst lli mod = 1e9+7;\n\nstring s,a;\nint k,n;\nlli ans=0;\n\n\nstruct node{\n    node *child[26];\n    int cnt;\n    //vector<string> wend;\n    node(){\n        for(int i=0;i<26;i++){\n            child[i]=NULL;\n        }\n        cnt=0;\n    }\n};\n\nstruct trie{\n    node *root;\n    trie(){\n        root = new node();\n    }\n\n};\n\n\ntrie *root_main;\nnode *root1;\n\n//insert the substrings to the nodes\nvoid insert(string s,int start){\n      node *cur = root1;\n      for(int i=start;i<n;i++){\n\n          int x = s[i]-'a';\n          if(cur->child[x]==NULL){\n              cur->child[x]=new node();\n          }\n\n          cur =cur->child[x];\n          cur->cnt = (a[x]=='0');\n      }\n  }\n\n\n\nvoid good_search(node *cur,int k){\n\n  for(int i=0;i<26;i++){\n    if(cur->child[i]!=NULL){\n      if(k-(a[i]=='0')>=0){\n        ans++;        \n        good_search(cur->child[i],k-(a[i]=='0'));\n      }\n    }\n  }\n}\n\nint main(){\n  \n    #ifndef ONLINE_JUDGE\n    // for getting input from input.txt\n    freopen(\"input.txt\", \"r\", stdin);\n    // for writing output to output.txt\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    \n    IOS\n    \n    cin >> s >> a;\n    cin >> k;\n\n    root_main = new trie();\n    root1 = root_main->root;\n\n    n = s.length();\n\n    for(int i=0;i<n;i++){\n      insert(s,i);\n    }\n\n    //search for nodes with count <=k\n    good_search(root1,k);\n\n    cout << ans << \"\\n\";\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:34:58.350638+00:00"
      },
      "hints": {
        "hint1": "### Problem Statement:\n\nFor every substring of the string, we need to count the number of bad characters present in it. As long as the number of bad characters is less than **K**, the substring is valid and should be counted.\n\nA string of length **n** has $\\frac{n \\cdot (n+1)}{2}$ substrings, making it infeasible to check every substring individually and count the number of bad characters.\n\n### Optimized Approach:\n\nInstead, we can use a **Trie data structure** to store the substrings. This approach avoids the need to explicitly check each substring while keeping track of the number of bad characters.\n",
        "hint2": "### Calculating Distinct Substrings Using a Trie:\n\nThe **distinct substrings** can be efficiently calculated using a **Trie**. \n\n- Each **active node** in the Trie corresponds to a substring.\n- For each node, we can maintain a **count of bad characters** in the substring represented by that node.\n\nBy traversing the Trie, we can identify all substrings and determine whether they are valid (i.e., the number of bad characters is less than **K**).\n",
        "solution_approach": "### Building the Trie and Counting Valid Substrings\n\n- In the Trie, we insert all possible substrings **S[i] = substring of S from i to the end of the string** $[0 \\leq i < n]$.\n- In this way, all the nodes of the Trie correspond to a substring of **S**, such as **S[1..n], S[2..n], S[3..n], …, S[n..n]**.\n- This takes $O(N^2)$ time complexity.\n\n### Steps:\n1. While inserting the nodes into the Trie, also keep a **count of the number of bad characters** in that substring.\n2. Finally, traverse through all the nodes of the Trie and count only those nodes that have a number of bad characters $\\leq K$.\n\n---\n\n### Example Run:\n\n#### Input:\n**String:** `abbc`  \n**Bad character indicator string (binary):** `10010100000010100100101100`  \n**K:** 2\n\n#### Process:\nInsert the substrings `abbc`, `bbc`, `bc`, and `c` into the Trie:\n\n```\n                ROOT\n               ↙   ↓   ↘\n              a    b    c\n             ↙     ↓ ↘\n            ab     bb  bc\n           ↙        ↓\n          abb      bbc\n         ↙          \n        abbc\n```\n\n- Each node corresponds to a substring.\n- The highlighted nodes have at most **2 bad characters**.\n\n---\n\n### Output:\n**Answer:** 7\n"
      },
      "id": 421,
      "input_format": "<p>The first line contains a string S. 1 ≤ |S| ≤ 3000.</p><p>The second line contains a binary string of length 26. ‘0’ means ith character is bad and ‘1’ means ith character is good.</p><p>The third line contains an integer K, 1 ≤ K ≤ |S|.</p><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "### Substrings with utmost 2 bad characters are allowed.\n\nIn the given character set, the **bad characters** are:  \n**a, d, f, m, o, w, x, r, u**\n\n#### Examples:\n\n- **Substrings with 0 bad characters:**  \n  `a, o` = 2\n\n- **Substrings with 1 bad character:**  \n  `al, go, oz, z, e, n, i, t, h, l, g` = 11\n\n- **Substrings with 2 bad characters:**  \n  `algo, alg, lgo, goz, oze, lg, ze, en, ni, it, th` = 11\n\n#### Total count of substrings:  \n$2 + 11 + 11 = 24$",
      "output_format": "<p>For each test case print the number of distinct substrings having at most K bad characters.</p>",
      "samples": [
        {
          "input": "algozenith\n10010100000010100100101100\n2",
          "output": "24"
        },
        {
          "input": "acehqnrtuwaealwbqufdmizce\n10000110100000010011101101\n16",
          "output": "316"
        },
        {
          "input": "yqahbyyoxltryqdmvenemaqnbakglgqolxnaifnqtoclnnqiab\n11000001000110100111100001\n41",
          "output": "1243"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Good Substrings",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$. Print the **digits of that number** from right to left separated by space.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 0 \\leq N \\leq 10^9 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n//O(T*log(N_max)) time complexity\n//O(1) space complexity\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        // printing number in reverse order\n        if (n == 0) // corner case if n==0\n        {\n            cout << \"0\";\n        }\n        while (n > 0)\n        {\n            cout << n % 10 << \" \";\n            n /= 10;\n        }\n        cout << \"\\n\"; // linefeed after each case\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:42:37.911672+00:00"
      },
      "hints": {
        "hint1": "Can you do it while **extracting digits** of a number?",
        "hint2": "",
        "solution_approach": "In each **test case**, you can simply **extract** the digits of the number using modulo $10$ and print it. Since you get digits from **right to left** while extracting, there is no need of reversing anything. The time complexity of this approach is $O(T \\times (log_{10}(N))_{max})$ where $(log_{10}(N))_{max}$ is the maximum of all the test cases. The space complexity will be $O(1)$."
      },
      "id": 1207,
      "input_format": "First line contains a number $T$ number of test cases.\nNext $T$ lines will contain a number $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first sample, there are $4$ test cases, each test case is a number which is printed in right to left order accordingly.",
      "output_format": "For each test case print a single line contains the **digits of the number** separated by space.",
      "samples": [
        {
          "input": "4\n121\n39\n123456\n1200\n",
          "output": "1 2 1 \n9 3 \n6 5 4 3 2 1 \n0 0 2 1 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Digits",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Vivek wrote down a sequence containing distinct positive integers. Shubham wanted to reorder the elements to get a \"mountain sequence\". A sequence a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n-1</sub> is called a mountain sequence if there exists an index j, where 0 &lt; j &lt; n-1, such that the sequence a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>j</sub> is strictly increasing, and the sequence a<sub>j</sub>, a<sub>j+1</sub>, ..., a<sub>n-1</sub> is strictly decreasing. A sequence is strictly increasing if each element is strictly greater than the element before it, and a sequence is strictly decreasing if each element is strictly less than the element before it.</p><p>Shubham also wanted the resulting sequence to satisfy one additional rule. The absolute difference between each pair of adjacent elements must be less than or equal to <strong>K</strong>.</p><p>Find the number of valid sequence modulo 10^9+7.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:15:51.350491+00:00"
      },
      "hints": {
        "hint1": "<p>Discussed in the live session.</p>",
        "hint2": "<p>Discussed in the live session.</p>",
        "solution_approach": "<p>Discussed in the live session.</p>"
      },
      "id": 394,
      "input_format": "<p>The first line contains an integer T - number of test cases. ( 1 ≤ T ≤ 50).</p><p>The first line of each test case contains two space-separated integers N, K, (1≤ N ≤ 1000, 1 ≤ K ≤ 1000000000).</p><p>The second line contains N- space-separated <strong>distinct</strong> integers (1 ≤ Ai ≤ 1000000000).</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the number of valid sequence mod 10^9+7 in a newline.</p>",
      "samples": [
        {
          "input": "2\n4 6\n10 4 1 5\n9 44\n96 29 21 90 46 77 31 63 79",
          "output": "4\n126"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Mountain Arrays",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You have N magical candy bag. The i-th bag contains A<sub>i</sub> candies. In each minute you can eat all the candies, A<sub>i</sub> of one bag, after that, the candies become [A<sub>i</sub> / 2] where [x] is the greatest integer less than x. You have K minutes, find the maximum number of candies you can eat.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ N ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">0</span><span style=\"background-color:#ffffff;color:#000000;\">≤ K ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ A<sub>i</sub> ≤ 10<sup>9</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of K over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>6</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n#define int long long\n\nsigned main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    priority_queue<int> q;\n    for (int i = 0; i < n; ++i) {\n      int x;\n      cin >> x;\n      q.push(x);\n    }\n    int ans = 0;\n    for (int i = 0; i < k; ++i) {\n      int x = q.top();\n      ans += x;\n      q.pop();\n      q.push(x / 2);\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:41:25.108412+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Put all the number of candies in each bag in a priority queue and take the maximum number of candies possible in each minute. Erase the maximum number of candies and insert $[candies/2]$.\n\nTime Complexity per test case: $O(K \\log N)$"
      },
      "id": 365,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains two space-separated integers N, K - the number of bags and the number of minutes.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The second line of each test case contains N space-separated integers.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, first take 5 candies then the bag becomes: [4, 3, 2, 1], and then take 4 candies to get a total 5+4 = 9 candies.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, first take 4 candies, then bag becomes: [2] and then take 2 candies to get a total 4+2 = 6 candies.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, first take 5 candies, then bag becomes: [3, 2, 2, 2, 1, 2] and then take 3 candies, then bag becomes: [1, 2, 2, 2, 1, 2], then take 2 candies to get a total 5+3+2 = 10 candies.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the maximum number of candies you can eat.</span></p>",
      "samples": [
        {
          "input": "3\n4 2\n4 3 5 1\n1 2\n4\n6 3\n3 2 2 5 1 2\n",
          "output": "9\n6\n10\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "The Magical Candy Bag AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "There are *n* cities and *m* roads between them. Unfortunately, the condition of the roads is so poor that they cannot be used. Your task is to repair some of the roads so that there will be a decent route between any two cities.\n\nFor each road, you know its reparation cost, and you should find a solution where the total cost is as small as possible.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n </i>≤ 10<sup>5</sup><br>1 ≤ <i>m </i>≤ 2 x 10<sup>5</sup><br>1 ≤ <i>a</i>, <i>b </i>≤ <i>n</i><br>1 ≤ <i>c </i>≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint mod = 1e9 + 7;\n\nconst int N = 100010;\n\nvector<int> graph[N];\n\nclass wunionfind {\n public:\n  int *id, *sz;\n  wunionfind(int n = N) {\n    id = new int[n + 1];\n    sz = new int[n + 1];\n    for (int i = 0; i <= n; i++) {\n      id[i] = i;\n      sz[i] = 1;\n    }\n  }\n  int root(int idx) {\n    int x = idx;\n    while (x != id[x]) {\n      id[x] = id[id[x]];\n      x = id[x];\n    }\n    return x;\n  }\n  bool uni(int a, int b) {\n    int x = root(a), y = root(b);\n    if (sz[x] < sz[y]) {\n      swap(x, y);\n    }\n    if (x != y) {\n      id[y] = x;\n      sz[x] += sz[y];\n      sz[y] = 0;\n      return false;\n    }\n    return true;\n  }\n  bool check(int a, int b) { return (root(a) == root(b)); }\n};\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  int n, m;\n  cin >> n >> m;\n\n  wunionfind W(n + 1);\n\n  pair<int, pair<int, int>> E[m];\n\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    E[i].first = c;\n    E[i].second.first = b;\n    E[i].second.second = a;\n  }\n\n  sort(E, E + m);\n\n  ll cost = 0;\n  int cnt = 0;\n\n  for (int i = 0; i < m; i++) {\n    int a = E[i].second.first;\n    int b = E[i].second.second;\n    if (!W.uni(a, b)) {\n      cost += E[i].first;\n      cnt++;\n    }\n  }\n\n  if (cnt == n - 1)\n    cout << cost << \"\\n\";\n  else\n    cout << \"IMPOSSIBLE\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:02.791035+00:00"
      },
      "hints": {
        "hint1": "To find a solution where the total cost of road repairs is minimized, we can use a minimum spanning tree algorithm, such as Kruskal's algorithm or Prim's algorithm. These algorithms are commonly used to find the minimum cost spanning tree in a connected graph.",
        "hint2": "",
        "solution_approach": "1. First, create a list of all the roads with their associated repair costs. Each road can be represented as a tuple or pair containing the cost and the two cities it connects.\n\n2. Sort the list of roads in ascending order based on their repair costs. This allows us to consider the roads with the lowest costs first.\n\n3. We can use \"union-find\" to keep track of the connectivity between cities. Initially, each city is considered as a separate component.\n\n4. Iterate through the sorted list of roads. For each road, check if the two cities it connects are already connected in the union-find data structure. If they are not connected, repair the road by adding its cost to the total cost and merge the two cities into the same component in the union-find.\n\n5. Repeat this process until all cities are connected or we have processed all the roads.\n\n6. The final total cost will be the sum of the repair costs of the roads that were repaired.\n\nBy using this approach, we will be able to find a solution where the total cost of road repairs is minimized, ensuring that there is a decent route between any two cities."
      },
      "id": 206,
      "input_format": "The first input line has two integers *n* and *m*: the number of cities and roads. The cities are numbered 1, 2, …, *n*.\n\nThen, there are *m* lines describing the roads. Each line has three integers *a*, *b*, and *c*: there is a road between cities *a* and *b*, and its reparation cost is *c*. All roads are two-way roads.\n\nEvery road is between two different cities, and there is at most one road between two cities.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print one integer: the minimum total reparation cost. However, if there are no solutions, print \"IMPOSSIBLE\".",
      "samples": [
        {
          "input": "5 6\n1 2 3\n2 3 5\n2 4 2\n3 4 8\n5 1 7\n5 4 4",
          "output": "14"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Road Reparation",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two arrays *A* and *B* of size *N* and an integer *K*. You have to select *K* indexes $i_1, i_2, i_3, \\dots, i_K$ such that\n\n$$\n\\frac{A[i_1] + A[i_2] + A[i_3] + \\dots + A[i_K]}{B[i_1] + B[i_2] + B[i_3] + \\dots + B[i_K]}\n$$\n\nis maximum.",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nsigned main()\n{\n   ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n   int testcases;\n   cin>>testcases;\n   while(testcases--){\n       int n,k;\n       cin>>n>>k;\n       int arr[n],brr[n];\n       for(int i=0;i<n;i++)\n           cin>>arr[i];\n       for(int i=0;i<n;i++)\n           cin>>brr[i];\n       ld low = 0.0, high = 1e8;\n       ld ans = 0.0;\n       while(abs(low-high)>1e-9){\n           ld mid = (low+high)/2.0;\n           priority_queue <ld, vector<ld>, greater<ld>> pq;\n           for(int i=0;i<n;i++){\n               pq.push(arr[i]-mid*brr[i]);\n               if(pq.size()>k)\n                   pq.pop();\n           }\n           ld s = 0.0;\n           while(pq.size()){\n               s+=pq.top();\n               pq.pop();\n           }\n           if(s>=0.0)\n               ans = mid,low = mid;\n           else\n               high = mid;\n       }\n       cout<<fixed<<setprecision(6)<<ans<<\"\\n\";\n   }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:40:54.500294+00:00"
      },
      "hints": {
        "hint1": "Equate:\n\n$$ \\frac{A[i_1] + A[i_2] + A[i_3] + \\dots + A[i_K]}{B[i_1] + B[i_2] + B[i_3] + \\dots + B[i_K]} \\, \\text{to} \\, X. $$\n\nIf the value of **X** is possible, then the maximum value would be $\\geq X$. Otherwise, it would be $< X$. \n\nThis is a monotonic function, and hence we can use **binary search** to solve this problem.\n",
        "hint2": "Given:\n\n$$ \\frac{A[i_1] + A[i_2] + A[i_3] + \\dots + A[i_K]}{B[i_1] + B[i_2] + B[i_3] + \\dots + B[i_K]} = X $$\n\nWe can rewrite it as:\n\n$$ (A[i_1] + A[i_2] + A[i_3] + \\dots + A[i_K]) - X \\cdot (B[i_1] + B[i_2] + B[i_3] + \\dots + B[i_K]) = 0 $$\n\nOr:\n\n$$ (A[i_1] - X \\cdot B[i_1]) + (A[i_2] - X \\cdot B[i_2]) + \\dots + (A[i_K] - X \\cdot B[i_K]) = 0 $$\n\nThus, we need to select **K** indices such that the above condition is satisfied.\n",
        "solution_approach": "<p>We would be doing binary search on the maximum possible value of (A[i1]+A[i2]+A[i3]+……+A[iK]) / (B[i1]+B[i2]+B[i3]+……+B[iK]). Let’s</p><p>We take the left pointer as L = 0 and the right pointer as R = 10<sup>8</sup>. We take mid = (L+R)/2. We then check if it is possible to have mid as a possible value of the given function. To do this, we take the maximum K values of (A[i] - mid*B[i]) by using a priority queue. If the sum of these values is ≥ 0, then it might be possible to equate the sum to 0. If mid is a possible value, the maximum possible value can be ≥ mid and we continue binary search on L = mid to R. Otherwise, the maximum possible value would be &lt; mid, so we continue binary search on L to R = mid.</p><p>Time Complexity per test case: O(N * log2(ΣAi) * log2K)</p>"
      },
      "id": 105,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases (<i>1&lt;=T&lt;=10000</i>).</p><p>The first line contains an integer <i>N, K </i>where <i>1&lt;=N&lt;=10^4, 1&lt;=K&lt;=N</i>.</p><p>Next line contains <i>N</i> space-separated integers (<i>1&lt;=Ai&lt;=1e4</i>).</p><p>Next line contains <i>N</i> space-separated integers (<i>1&lt;=Bi&lt;=1e4</i>).</p><p>Sum of <i>N</i> across all test cases&lt;=10^5.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><strong>1st test case:</strong><br>Select index → [1,3], result = 17/7.</p>",
      "output_format": "<p>For each test case print the maximum possible value of (A[i<sub>1</sub>]+A[i<sub>2</sub>]+A[i<sub>3</sub>]+……+A[i<sub>K</sub>]) / (B[i<sub>1</sub>]+B[i<sub>2</sub>]+B[i<sub>3</sub>]+……+B[i<sub>K</sub>]). <strong>You have to print the result round off to 6 decimal places.</strong></p>",
      "samples": [
        {
          "input": "3\n3 2\n10 9 7\n3 5 4\n8 3\n4 4 2 1 5 3 2 5\n2 2 2 5 3 5 2 3\n1 1\n1 \n1",
          "output": "2.428571\n1.857143\n1.000000"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Maximise the fraction",
      "video_editorial_id": 8152
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Bob is standing in a park at (0,0) facing north. He is given a series of instructions to move around the park. The instructions can be:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">‘W’: go straight 1 unit</span></li><li><span style=\"background-color:transparent;color:#000000;\">‘L’: turn 90 degrees left</span></li><li><span style=\"background-color:transparent;color:#000000;\">‘R’: turn 90 degrees right</span></li></ol><p><span style=\"background-color:transparent;color:#000000;\">Bob has to perform the given instructions forever. If he is going in a circle forever, print ‘<i>YES</i>’. Otherwise, print ‘<i>NO</i>’ (without the quotes).</span></p>",
      "complete_approach": "",
      "constraints": "<p>1≤ <i>T</i> ≤ 100<br>1≤ |<i>S</i>| ≤ 10<sup>5</sup> where |<i>S</i>| denotes the length of the given series of instructions.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    int x = 0, y = 0;\n    int direction = 0;  // 0-north, 1-west, 2-south, 3-east\n    bool flag = false;\n    for (int i = 0; i < n; i++) {\n      if (s[i] == 'L')\n        direction = (direction + 3) % 4;\n      else if (s[i] == 'R')\n        direction = (direction + 1) % 4;\n      else {\n        if (direction == 0)\n          y++;\n        else if (direction == 1)\n          x--;\n        else if (direction == 2)\n          y--;\n        else\n          x++;\n      }\n    }\n    if ((x == 0 && y == 0) || direction != 0)\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:38:51.288042+00:00"
      },
      "hints": {
        "hint1": "Calculate the final vector of how Bob travels after executing all instructions once - it consists of a change in position plus a change in direction.",
        "hint2": "Bob stays in the circle only if it changes direction or it stays where it started after completion of instructions.",
        "solution_approach": "We use two variables x and y to represent the current position of Bob. Initially, both are set to $0$, as Bob starts at the origin $(0, 0)$.\nWe also use a variable direction to keep track of the direction in which Bob is facing. Initially, Bob is facing north (direction = $0$).\nIf the current instruction is 'L', we turn $90$ degrees to the left by decrementing the direction by $1$ and taking the modulo by $4$.\nIf the current instruction is 'R', we turn $90$ degrees to the right by incrementing the direction by $1$ and taking the modulo by $4$.\nIf the current instruction is 'W', we move forward by $1$ unit in the direction that Bob is facing. We do this by updating the values of x and y based on the current direction.\n\nFinally, if Bob returns to origin or the direction is not 0 (i.e., Bob is not facing north), then we print \"YES\", otherwise, we print \"NO\".\n\nTime Complexity:\nThe time complexity of this solution is $O(N)$, where $N$ is the length of the input string S. This is because we are processing each instruction in the string only once."
      },
      "id": 90,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer <i>T</i> - the number of test cases. Then <i>T</i> test cases follow.</span><br><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains <i>N</i> - the length of the input string of instructions.</span><br><span style=\"background-color:transparent;color:#000000;\">The second line of each test case contains one string <i>S</i> - the series of instructions to move around the park.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">In the first sample test case, Bob moves north indefinitely.</span></p><p><span style=\"background-color:transparent;color:#000000;\">In the second sample test case, Bob moves as follows: (0,0) =&gt; (-1,0) =&gt; (-1,-1) =&gt; (0,-1) =&gt; (0,0). So, Bob goes in a circle forever</span></p><figure class=\"image\"><img src=\"https://docs.google.com/drawings/u/0/d/s6yk4rW7gINCLR9gvCLKoHA/image?w=113&amp;h=94&amp;rev=31&amp;ac=1&amp;parent=1r88r0wHAS-xfy7L9H8t6gxhPHhQyHg5sXRkydJaq9yo\"></figure><p><span style=\"background-color:transparent;color:#000000;\">In the third sample test case, Bob moves from (0,0) to (0,1) turns 180 degress and returns to (0,0). So, Bob goes in a circle forever</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print ‘<i>YES</i>’ if Bob is going in a circle forever. Otherwise, print ‘<i>NO</i>’. (without the quotes)</span></p>",
      "samples": [
        {
          "input": "3\n3\nWWW\n2\nLW\n4\nWLLW",
          "output": "NO\nYES\nYES"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Round and Round",
      "video_editorial_id": 8146
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are n intervals. The i<sup>th</sup> interval covers range [l<sub>i</sub>,r<sub>i</sub>] &nbsp;including points l and r.</p><p>You can destroy intervals by choosing some points. Suppose a point x is chosen, then any interval that covers x will be destroyed.</p><p>Find the minimum number of points to be selected to destroy all intervals.</p><p>&nbsp;</p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "<p>T ≤ 20<br>0 ≤ n ≤ 10<sup>5</sup><br>0 ≤ li ≤ ri ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t, n, i, j;\n\n    cin >> t;\n    while (t--) {\n        cin >> n;\n        vector<pair<int, int>> intervals; \n        for (i = 0; i < n; i++) {\n            int l, r;\n            cin >> l >> r;\n            intervals.push_back({r, l}); \n        }\n        // Sort in increasing order of r\n        sort(intervals.begin(), intervals.end());\n\n        int last_point = INT_MIN, points = 0;\n        for (auto interval : intervals) {\n            int l = interval.second; \n            int r = interval.first; \n            if (l > last_point) {\n                last_point = r;\n                points++;\n            }\n        }\n        cout << points << '\\n';\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:14:16.157843+00:00"
      },
      "hints": {
        "hint1": "<p>If two intervals overlap, it is optimal to destroy the common number between them. Two intervals, (a, b) and (c, d) overlap if max(a, c) ≤ min(b, d)</p>",
        "hint2": "<p>If we sort the given interval according to R, we would only have to check the condition considering L.</p>",
        "solution_approach": "<p>We need to sort the given intervals according to R. If interval i does not have any common point with interval i+1, then it will not have any common point with any interval &gt; i. We can find the common points by taking the first point as cur = A[0].right . We would then traverse through the intervals and check the condition, if the left part of the current interval is ≤ cur, that means the interval has at least one common point i.e. cur. If that is not true, that means the interval does not have any common point and so we destroy the previous value of cur and start the iteration by taking the new value of cur. Finally return the number of points you destroyed.</p><p>Time Complexity per test case: O(N logN)</p>"
      },
      "id": 241,
      "input_format": "<p>First line of input contains T, number of test cases.</p><p>First line of each test case contains n, the number of intervals.</p><p>Each of n next lines contain two integers , l<sub>i </sub>and r<sub>i </sub>.</p><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>You can choose point 3 which destroys interval 1 &amp; 2, and point 7 to destroy interval 3.</p>",
      "output_format": "<p>For each testcase print a single integer, minimum points required.</p>",
      "samples": [
        {
          "input": "1\n3\n1 4\n2 6\n7 10",
          "output": "2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Destroying intervals",
      "video_editorial_id": 8174
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array of N integers. The frequency of exactly one integer is odd. Find that integer.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^6$  \n\n$1 \\leq N \\leq 10^6$ (N is odd)  \n\n$-10^9 \\leq A_i \\leq 10^9$  \n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            cin >> x;\n            ans ^= x;\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:28.093462+00:00"
      },
      "hints": {
        "hint1": "Xor of a number with itself is 0.",
        "hint2": "Take xor of all elements of the array. All the numbers with even frequency would get cancelled out.\n\nTime Complexity per test case: O(N)",
        "solution_approach": "Take xor of all elements of the array. All the numbers with even frequency would get cancelled out.\n\nTime Complexity per test case: O(N)"
      },
      "id": 319,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer N - the length of the array. \n\nThe second line of each test case contains N space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the integer with odd frequency.",
      "samples": [
        {
          "explanation": "",
          "input": "3\n5\n2 5 5 7 2\n3\n2 1 2\n5\n0 1 2 1 0",
          "output": "7\n1\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Odd One Out AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Your class teacher wrote *N* integers on the board. One of your classmates was being mischievous; he replaced the *N* integers with all possible subset sums of the array when the teacher was not in the class.  \n\nSuppose that the integers on the board were [2,1], then the subsets will be: {}, {2}, {1}, {2,1}, and the subset sums will be: {0,2,1,3}.  \n\nYour task is to rebuild the original array given by your teacher.",
      "complete_approach": "",
      "constraints": "1 ≤ *T* ≤ 50  \n1 ≤ *N* ≤ 15  \n0 ≤ *A<sub>i</sub>* ≤ \\( 10^{15} \\)",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define rep(i,s,f) for(i=s;i<f;i++)\n#define print(v) for(auto &z:v) cout<<z<<' ';cout<<'\\n'\n#define db cout<<\"db: \"\n#define pb push_back\n#define pii pair<int,int>\n#define F first\n#define S second\n#define B begin()\n#define E end()\n#define all(v) v.B,v.E\n#define sz(v) (int)((v).size())\n#define vi vector<int>\n#define vii vector<pair<int,int>>\n#define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define clk1 clock_t start_time=clock()\n#define clk2 cout<<(clock()-start_time)/(double)CLOCKS_PER_SEC\n#define clean(arr) memset(arr,0,sizeof(arr))\n#define mod 1000000007\n#define mod2 998244353\n#define space 100005\n//<<fixed << setprecision(9)\n\nint main()\n{\n    ll n,i,j,t;\n    boost;\n\n    cin>>t;\n    while(t--)\n    {\n        cin>>n;\n        ll m = 1<<n;\n        // there are 2^n numbers\n        ll arr[m];\n        rep(i,0,m)\n            cin>>arr[i];\n        // take input\n        sort(arr,arr+m);\n        // sorting the numbers as per logic.\n        \n        map<ll,ll> sums;// stores the possible sums as of now and their frequency\n\n        sums[0]=1;// 0 can be generated as of now \n\n        vi ans;\n        vector<ll> subsums; // subset sums that can be created\n        \n        rep(i,0,m){\n            if(sums[arr[i]]){\n                sums[arr[i]]--; // this can be created so skip this once and \n            }\n            else{                \n            \tans.pb(arr[i]); // creates the final array, freq is 0, so needed.\n                vector<ll> temp; // new subset sums that can be created.\n                for(auto &z:subsums) // with all the previous \n                    temp.pb(z+arr[i]), sums[z+arr[i]]++; // Merging previous subset sums with this elements and increase their generated frequency.\n                for(auto &z:temp)\n                    subsums.pb(z); // add the newly generated ones to the subset sums that are generated.\n                subsums.pb(arr[i]); // also add this single element set (merging with 0).\n            }\n        }\n        print(ans); // print the final generated numbers.\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:47:39.268028+00:00"
      },
      "hints": {
        "hint1": "The original array has non-negative integers.  The first integer of the original array will be the second element of the new sorted array. Try building the original array by taking the smallest integers.",
        "hint2": "Think of a data structure that can efficiently return the smallest integer present in the array.",
        "solution_approach": "The original array has non-negative integers. At each step, we have to take the smallest integer. We can use a multiset for this problem.  \n\nAt each step, when an element *x[i]* is added to the original array, you have to erase all sums formed by *x[i]* and non-empty subsets of {*x[1], x[2], …, x[i – 1]*} from the multiset.\n\n**Time Complexity:** *O(N * 2<sup>N</sup>)*\n"
      },
      "id": 87,
      "input_format": "The first line of the input contains one integer *T* - the number of test cases. Then *T* test cases follow.  \n\nThe first line of each test case contains one integer *N* - the number of elements in the initial array.  \n\nThe second line of each test case contains $( 2^N )$ space-separated integers, the new values on the board.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 1024000,
      "note": "In the first test case of the example, the original array is [1,2], which has the following subsets: {}, {1}, {2}, {1,2}. Their respective sums are 0, 1, 2, 3.  \n\nIn the third test case of the example, the original array is [1,1,1], which has the following subsets: {}, {1}, {1}, {1}, {1,1}, {1,1}, {1,1}, {1,1,1}. Their respective sums are 0, 1, 1, 1, 2, 2, 2, 3.",
      "output_format": "For each test case, print N space-separated integers in non-decreasing order.\nIt is guaranteed that a solution always exists.",
      "samples": [
        {
          "input": "3\n2\n0 1 2 3\n3\n0 1 3 4 5 6 8 9\n3\n0 1 1 1 2 2 2 3",
          "output": "1 2 \n1 3 5 \n1 1 1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Rebuild Original Array",
      "video_editorial_id": 8144
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">You and some monsters are in a matrix. When taking a step to some direction in the matrix, each monster may </span>simultaneously<span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\"> take one as well. Your goal is to reach one of the boundary squares without ever sharing a square with a monster.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Your task is to find out if your goal is possible, and if it is, print the <i>shortest</i> <i>length of </i></span><i>the </i><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\"><i>path</i> that you can follow. Your plan has to work in any situation; even if the monsters know your path beforehand.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n, m</i> ≤ 1000</p>",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nconst int N = 1010;\n\nint mod = 1e9 + 7;\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nbool grid[N][N];\nint distA[N][N];\nqueue<pair<int, int>> monsterOcc, AOcc;\npair<int, int> par[N][N];\nint distMon[N][N];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    memset(grid, false, sizeof(grid));\n\n    memset(distMon, -1, sizeof(distMon));\n    memset(distA, -1, sizeof(distA));\n\n    for (int i = 0; i < n; i++)\n    {\n        string s;\n        cin >> s;\n        for (int j = 0; j < m; j++)\n        {\n            grid[i][j] = true;\n            if (s[j] == '#')\n                grid[i][j] = false;\n            else if (s[j] == 'M')\n            {\n                distMon[i][j] = 0;\n                monsterOcc.push({i, j});\n            }\n            else if (s[j] == 'A')\n            {\n                distA[i][j] = 0;\n                AOcc.push({i, j});\n                par[i][j] = {-1, -1};\n            }\n        }\n    }\n\n    while (!monsterOcc.empty())\n    {\n        auto it = monsterOcc.front();\n        monsterOcc.pop();\n        int x = it.first, y = it.second;\n\n        for (int i = 0; i < 4; i++)\n        {\n            int xx = x + dx[i], yy = y + dy[i];\n            if (xx < 0 || xx >= n || y < 0 || yy >= m)\n                continue;\n            if (grid[xx][yy] && distMon[xx][yy] == -1)\n            {\n                distMon[xx][yy] = distMon[x][y] + 1;\n                monsterOcc.push({xx, yy});\n            }\n        }\n    }\n\n    while (!AOcc.empty())\n    {\n        auto it = AOcc.front();\n        AOcc.pop();\n        int x = it.first, y = it.second;\n\n        for (int i = 0; i < 4; i++)\n        {\n            int xx = x + dx[i], yy = y + dy[i];\n            if (xx < 0 || xx >= n || y < 0 || yy >= m)\n                continue;\n            if (grid[xx][yy] && distA[xx][yy] == -1)\n            {\n                distA[xx][yy] = distA[x][y] + 1;\n                AOcc.push({xx, yy});\n                par[xx][yy] = {x, y};\n            }\n        }\n    }\n\n    int finx = -1, finy = -1, findist = 1e9;\n\n    for (int i = 0; i < n; i++)\n    {\n        if (grid[i][0] && distA[i][0] >= 0 && (distA[i][0] < distMon[i][0] || distMon[i][0] == -1))\n        {\n            finx = i;\n            finy = 0;\n            findist = min(findist, distA[i][0]);\n        }\n        if (grid[i][m - 1] && distA[i][m - 1] >= 0 && (distA[i][m - 1] < distMon[i][m - 1] || distMon[i][m - 1] == -1))\n        {\n            finx = i;\n            finy = m - 1;\n            findist = min(findist, distA[i][m - 1]);\n        }\n    }\n\n    for (int i = 0; i < m; i++)\n    {\n        if (grid[0][i] && distA[0][i] >= 0 && (distA[0][i] < distMon[0][i] || distMon[0][i] == -1))\n        {\n            finx = 0;\n            finy = i;\n            findist = min(findist, distA[0][i]);\n        }\n        if (grid[n - 1][i] && distA[n - 1][i] >= 0 && (distA[n - 1][i] < distMon[n - 1][i] || distMon[n - 1][i] == -1))\n        {\n            finx = n - 1;\n            finy = i;\n            findist = min(findist, distA[n - 1][i]);\n        }\n    }\n\n    if (finx == -1)\n        cout << \"NO\\n\";\n    else\n    {\n        cout << \"YES\\n\";\n        cout << findist << \"\\n\";\n        /*****************************************\n        ----PRINTING PATH---\n        string path = \"\";\n        int x = finx, y = finy;\n        while(true) {\n            int prex = par[x][y].first;\n            int prey = par[x][y].second;\n            if(prex == -1 && prey == -1) break;\n            if(y - prey == 1) path += 'R';\n            else if(y - prey == -1) path += 'L';\n            else if(x - prex == 1) path += 'D';\n            else path += 'U';\n            x = prex; y = prey;\n        }\n        reverse(path.begin(), path.end());\n        cout << path << \"\\n\";\n        ******************************************/\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:44:13.694465+00:00"
      },
      "hints": {
        "hint1": "Apply Multisource BFS.",
        "hint2": "All the monsters will together form the source set to find smallest time in which any one of them can reach anywhere.",
        "solution_approach": "Suppose we have a grid that represents a map, where some cells are empty, some are walls, and some contain monsters and a person. The goal is to determine whether the person can reach any boundary cell without being caught by the monsters, and if so, what is the minimum number of steps required to do so.\n\nTo solve this problem, we can use a combination of multisource BFS and plain BFS algorithms. The steps involved in the solution are as follows:\n\n1. Identify all the monster cells in the grid and perform a multisource BFS from each of these cells to compute the minimum distance of any monster to the boundary. This can be done by starting from each monster cell and exploring its neighboring cells one by one. For each empty cell visited, mark it as visited and store its distance from the nearest boundary cell.\n\n2. After performing the multisource BFS, we can use plain BFS from the person cell to compute the minimum distance of any boundary cell to the person. This can be done by starting from the person cell and exploring its neighboring cells one by one. For each empty cell visited, mark it as visited and store its distance from the person cell.\n\n3. Finally, we can compare the distances computed in steps 1 and 2 to find if there is any boundary cell that can be reached by the person without being caught by the monsters. To do this, we need to iterate over all the empty cells that are adjacent to the boundary cells and check if the distance of that cell from the person is less than or equal to the minimum distance of any monster to the boundary. If we find such a cell, then the person can reach a boundary cell without being caught by the monsters, and the minimum distance required is the distance of that cell from the person. Otherwise, it is not possible to reach a boundary cell without being caught by the monsters.\n\nIn summary, we use multisource BFS to compute the minimum distance of any monster to the boundary, plain BFS to compute the minimum distance of any boundary cell to the person, and then compare the distances to determine if the person can reach a boundary cell without being caught by the monsters. The time complexity of this approach is $O(n*m)$, where $n$ and $m$ are the dimensions of the grid."
      },
      "id": 195,
      "input_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">The first input line has two integers <i>n</i> and <i>m</i>: the height and width of the matrix.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">After this</span>,<span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\"> there are <i>n</i> lines of <i>m</i> characters describing the matrix. Each character is ‘.’ (floor), ‘#’ (wall), ‘A’ (start), or ‘M’ (monster). There is exactly one ‘A’ in the input.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">First</span>,<span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\"> print \"YES\" if your goal is possible, and \"NO\" otherwise.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">If your goal is possible, also print the length of the shortest path that you'll follow.</span></p>",
      "samples": [
        {
          "input": "5 8\n########\n#M..A..#\n#.#.M#.#\n#M#..#..\n#.######",
          "output": "YES\n5"
        },
        {
          "input": "3 3\n###\n#A#\n#M.",
          "output": "NO"
        },
        {
          "input": "1 3\n##A",
          "output": "YES\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Save Yourself",
      "video_editorial_id": 8166
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given a date and you have to print the corresponding day of the week for that date.</span><br><span style=\"background-color:transparent;color:#000000;\">You have to take in three numbers <strong>d</strong>, <strong>m, </strong>and <strong>y </strong>representing the day, month, and year respectively.</span><br><span style=\"background-color:transparent;color:#000000;\">Return the answer as one of the following values {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Can you solve this problem in O(1) time complexity?</span></p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">The given dates are valid dates between the years 1971 and 2100.</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring WeekDay(int day, int month, int year) {\n\tvector<string> days = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\tif (month < 3) {\n\t\tmonth += 12;\n\t\tyear--;\n\t}\n\tint c = year / 100;\n\tyear = year % 100;\n\tint w = (c / 4 - 2 * c + year + year / 4 + 13 * (month + 1) / 5 + day - 1) % 7;\n\treturn days[(w + 7) % 7];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint day, month, year;\n\tcin >> day >> month >> year;\n\t\n\tcout << WeekDay(day, month, year);\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:19:29.145068+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p>Zeller's Algorithm we can use to find the day in O(1). <a href=\"https://en.wikipedia.org/wiki/Zeller%27s_congruence\"><span style=\"background-color:transparent;color:#1155cc;\">https://en.wikipedia.org/wiki/Zeller%27s_congruence</span></a></p>"
      },
      "id": 636,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">Implement the <strong>WeekDay</strong> function that takes in the date. (d,m and y)</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Return the string representing the day of the week for the date given.</span></p>",
      "samples": [
        {
          "input": "25 11 2095",
          "output": "Friday"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nstring WeekDay(int day, int month, int year)\n{\n\t// Complete the function\n}\n\n<fix>\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint day, month, year;\n\tcin >> day >> month >> year;\n\t\n\tcout << WeekDay(day, month, year);\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "WeekDay",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given a string $s$ containing lower case alphabets. You need to answer $q$ queries of the form $(l, r, k)$:\n\nHere $(l,r)$ denotes the end points of a substring of $s$. You are allowed to arrange the characters in this substring in any possible manner. Besides, you can perform atmost $k$ number of substitutions . In each substitution, you can replace the letter at any index of the substring with another letter of your choice. You need to check if the given substring can be converted into a palindrome using these conditons.\n\nAfter processing all the queries, you need to print a string $ans$ of length $q$ which stores the answer to all the queries in the following manner - If the substring in the $i^{th}$ query can be converted into a palindrome, then $ans_i=$'1', otherwise $ans_i=$'0'.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^3$\n\n$1 \\leq |s| \\leq 10^5$\n\n$1 \\leq q \\leq 10^5$\n\n$ 1 \\leq l\\leq r \\leq |s| $\n\n$ 0 \\leq k \\leq (r-l+1)$\n\nIts guaranteed that the sum of $|s|$ and q over all test cases $\\leq 2*10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> arr;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        string s, ans = \"\";\n        int i, j, n, q;\n        cin >> s >> q;\n\n        n = s.length();\n        arr.clear();\n        arr.resize(n);\n\n        for (i = 0; i < n; i++)\n        {\n            arr[i] = vector<int>(26, 0);\n            arr[i][s[i] - 'a']++;\n            for (j = 0; (j < 26 && i > 0); j++)\n            {\n                arr[i][j] += arr[i - 1][j];\n            }\n        }\n\n        while (q--)\n        {\n            int l, r, k, f1 = 0, f2 = 0, req = 0;\n            cin >> l >> r >> k;\n            l--;\n            r--;\n            for (i = 0; i < 26; i++)\n            {\n                f2 = arr[r][i];\n                f1 = 0;\n                if (l)\n                    f1 = arr[l - 1][i];\n                if ((f2 - f1) & 1)\n                    req++;\n            }\n            req /= 2;\n            if (k >= req)\n                ans += '1';\n            else\n                ans += '0';\n        }\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:42:48.664815+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Firstly we need to observe that a substring can be converted into a palindrome if it has $x$ number of letters with odd frequency and $x/2 \\leq k$. To use this observation, we beforehand store the prefix sum of the frequency of every letter $ch$ till the $i^{th}$ index in $arr[i][ch-'a']$. Then while processing the queries, we can keep a count of the number of letters with odd frequency in that particular substring and use the above observation to update $ans$. Refer to the editorial code for more clarity.\n\nTime Complexity per test case: $O(26*(N+Q))$"
      },
      "id": 1046,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\n\nThe first line of each test case contains the string $s$.\n\nThe second line of each test case contains the number of queries $q$.\n\nThe next $q$ lines of each test case contain $3$ space-separated integers - $l$, $r$ and $k$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "In Sample Input 1,\n\nQuery $1$: Substring = '$c$', $k$=0. The substring is a palindrome, so $ans$=\"1\".\n\nQuery $2$: Substring = '$cd$', $k$=1. We can change '$c$' to '$d$' to make a palindrome, so $ans$=\"11\". \n\nQuery $3$: Substring = '$cde$' , $k$=1. We can change '$c$' to '$e$' and keep the original order. So, $ans$=\"111\".\n\nQuery $4$: Substring = '$cdec$' , $k$=0. This substring cannot be rearranged into a palindrome without any substitution. So, $ans$=\"1110\".",
      "output_format": "For each test case, print the string $ans$ on a new line.",
      "samples": [
        {
          "input": "1\ncdecd\n4\n1 1 0\n1 2 1\n1 3 1\n1 4 0\n",
          "output": "1110\n"
        },
        {
          "input": "1\nxxy\n1\n1 3 0\n",
          "output": "1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Make Palindromes",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(39,50,57);\">Given a Binary Search Tree, find the median of it.&nbsp;</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(39,50,57);\">If no. of nodes are even: then median = ((n/2th node + (n+1)/2th node) /2&nbsp;[integer division]. If tree is NULL then print 0. </span><br><span style=\"background-color:rgb(255,255,255);color:rgb(39,50,57);\">If no. of nodes are odd : then median = (n+1)/2th node.</span></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:43:24.179640+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 669,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N the length of the array representing the serialized representation of a tree.</p><p>The next line contains N-space-separated distinct integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Return the median.</p>",
      "samples": [
        {
          "input": "6\n11\n7456 1022 -1 3404 -1 6680 -1 -1 9344 -1 -1 \n11\n6084 3515 686 -1 -1 4778 -1 -1 6961 -1 -1 \n9\n4945 3300 -1 -1 5636 5317 -1 -1 -1 \n17\n1466 -1 2180 -1 2512 -1 2640 -1 2922 -1 5769 -1 6554 -1 7479 -1 -1 \n11\n9999 8664 7374 7342 6284 -1 -1 -1 -1 -1 -1 \n13\n833 622 -1 -1 3935 -1 9318 3991 -1 5233 -1 -1 -1 ",
          "output": "6680\n4778\n5131\n2781\n7374\n3963"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n</fix>\nint getMedian(Node* root){\n// Complete the function.\n}\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++){\n            cin>>arr[i];\n        }\n        int ind = 0;\n        cout<<getMedian(getBinaryTree(arr,&ind))<<\"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Median of BST",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given Q queries and have to perform the following operations:\n\n1. add x - add element x at the top of stack\n2. remove - delete top element of the stack, if stack is not empty\n3. print - print the element at top, if stack is not empty, otherwise print 0",
      "complete_approach": "",
      "constraints": "- $1 \\leq T \\leq 10^6$\n- $1 \\leq Q \\leq 10^6$\n- $1 \\leq X \\leq 10^6$\n\nIt is guaranteed that the sum of $Q$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int q;\n    cin >> q;\n    stack<int> st;\n    while (q--) {\n      string s;\n      cin >> s;\n      if (s == \"add\") {\n        int x;\n        cin >> x;\n        st.push(x);\n      } else if (s == \"remove\") {\n        if (!st.empty()) {\n          st.pop();\n        }\n      } else {\n        if (!st.empty()) {  // print\n          cout << st.top() << \"\\n\";\n        } else {\n          cout << \"0\\n\";\n        }\n      }\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:15:25.446530+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Use `push()` for inserting element at top of stack\nUse `pop()` for deleting element at top of stack. Before popping make sure to check if the stack is empty or not using `empty()` function.\nUse `top()` for printing element at top of stack.Again check emptiness using `empty()` function\nTime Complexity per test case: $O(1)$"
      },
      "id": 347,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer Q - the number of queries.\n\nEach of the next Q ines contains queries.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "1. Stack becomes [3]\n2. Stack becomes [3, 4]\n3. Element at top = 4\n4. Stack becomes [3]\n5. Element at top = 3",
      "output_format": "For each test case, print the required queries.",
      "samples": [
        {
          "input": "1\n5\nadd 3\nadd 4\nprint\nremove\nprint\n",
          "output": "4\n3\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Stack AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two numbers $N$ and $M$, a 2D array $A$ of size $N* 𝑀$ which contains 'x' or '.' only and two numbers $X, Y$ which donates a cell position in $ A $ such that $X$ is the row number and $Y$ is the column number.\n\nDetermine whether all neighbors of the given cell are 'x' or not.\n\n$ \\textbf{Note:} $ The neighbor cell is any cell that shares an $ \\textbf{edge} $ or a $ \\textbf{corner} $ and it should be $ \\textbf{inside} $ 2D array.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N, M \\leq 100 $\n$ A[i] \\in {[x, .]} $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint valid(int x, int y, int n, int m)\n{\n    return x >= 0 && x < n && y >= 0 && y < m;\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n, m;\n        cin >> n >> m;\n\n        char arr[n][m];\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < m; j++)\n            {\n                cin >> arr[i][j];\n            }\n        }\n        bool sur = true;\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};\n        int dy[8] = {0, 0, 1, -1, 1, -1, 1, -1};\n        for (int i = 0; i < 8; i++)\n        {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (valid(nx, ny, n, m) && arr[nx][ny] == '.')\n            {\n                sur = false;\n                break;\n            }\n        }\n        if (sur)\n            cout << \"yes\" << endl;\n        else\n            cout << \"no\" << endl;\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:31:27.399011+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "You only need to check all the eight adjacent positions of the matrix.\nTime Complexity: $O(1)$"
      },
      "id": 1141,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains two space seperated integers $ N $ and $ M $. \n$N$ denotes number of rows, $M$ denotes number of columns. Next $N$ lines contains $M$ symbols. \nLast line contains two space seperated integers $ X $ and $ Y $.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print $ \\textbf{\"yes\"} $ if all neighbors of the given cell are 'x' otherwise, print $ \\textbf{\"no\"} $ without quotations.",
      "samples": [
        {
          "input": "1\n3 3\nxxx\nx.x\nxxx\n2 2\n",
          "output": "yes\n"
        },
        {
          "input": "2\n3 3\nxxx\nx.x\nxxx\n2 2\n3 3\nxxx\nxxx\nxx.\n2 2\n",
          "output": "yes\nno\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "8 Neighbors",
      "video_editorial_id": 10648
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array A of size N and Q queries of the following two types:</p><ol><li>1 X Y: Update the array element at index <strong>X</strong> with<strong> Y.</strong></li><li>2 K: Print the position of the first array element greater than or equal to <strong>K</strong>. If there is no such index, then print <strong>-1</strong></li></ol>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint seg[8000001];\nint arr[1000001];\nvoid build(int low,int high,int pos){\n   if(low==high){\n       seg[pos] = arr[low];\n       return;\n   }\n   int mid = (low+high)/2;\n   build(low,mid,2*pos);\n   build(mid+1,high,2*pos+1);\n   seg[pos]=max(seg[2*pos],seg[2*pos+1]);\n}\nint query(int low,int high,int pos,int k){\n   if(low==high){\n       if(arr[low]>=k)\n           return low;\n       return 1e9;\n   }\n   int mid = (low+high)/2;\n   if(seg[2*pos]>=k)\n       return query(low,mid,2*pos,k);\n   return query(mid+1,high,2*pos+1,k);\n}\nvoid update(int low,int high, int pos,int ind){\n   if(low>ind or high<ind)\n       return;\n   if(low==high){\n       seg[pos] = arr[low];\n       return;\n   }\n   int mid = (low+high)/2;\n   update(low,mid,2*pos,ind);\n   update(mid+1,high,2*pos+1,ind);\n   seg[pos]=max(seg[2*pos],seg[2*pos+1]);\n}\nsigned main()\n{\n   ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n   int n,q;\n   cin>>n>>q;\n   for(int i=1;i<=n;i++)cin>>arr[i];\n   build(1,n,1);\n   while(q--){\n       int type;\n       cin>>type;\n       if(type==1){\n           int x,y;\n           cin>>x>>y;\n           arr[x] = y;\n           update(1,n,1,x);\n       }\n       else{\n           int k;\n           cin>>k;\n           int ans = query(1,n,1,k);\n           if(ans==1e9)\n               ans = -1;\n           cout<<ans<<\"\\n\";\n       }\n   }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:18:20.230058+00:00"
      },
      "hints": {
        "hint1": "<p>Try to think in the direction of the segment tree. You can build a max segment tree, each node storing the maximum element of the range. For query of type 1, simply do a point update. Now you can check the maximum value of a range in logN time. Can you use it to answer query 2?</p>",
        "hint2": "<p>For query of type 2, one of the observations is you can do a binary search on the answer. Suppose maximum value in range [1…mid]≥k, then the maximum value in the range [1…mid+1] will also be ≥k. If the maximum value in the range [1…mid] &lt;k, then you have to look for range [mid+1…n]. Simply do a binary search on the index and find the smallest index such that maximum value in the range 1….index ≥k.</p><p>Time complexity. N(logN)<sup>2</sup></p><p>Can you do it in NlogN?&nbsp;</p>",
        "solution_approach": "<p>You can even do it without using binary search. As you have already stored maximum value in a range. First, check if the left node representing the range 1…mid has maximum value ≥K or not. If it is present then go to the left node and do not traverse the right node. Else traverse right node. Keep on checking that, ultimately when the range reduces to a single element you can check the value and print the answer accordingly. So at every step, we are reducing our search range by half.</p><p>Time complexity: NlogN.</p>"
      },
      "id": 563,
      "input_format": "<p>The first line contains two space-separated integers N, Q (1 ≤ N, Q ≤ 10^6).</p><p>The next line contains N space-separated integers, (1 ≤ A[i] ≤ 10^6).</p><p>The next Q lines contain either of the following queries:</p><ol><li>1 X Y (1 ≤ X ≤ N, 1 ≤ Y ≤ 10^6)</li><li>2 K (1 ≤ k ≤ 10^6).</li></ol><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each query of type 2 print the answer.</p>",
      "samples": [
        {
          "input": "5 5\n1 2 3 4 5\n2 4\n2 6\n1 3 6\n2 6\n2 8",
          "output": "4\n-1\n3\n-1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Array Queries",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given are two sequences a={a<sub>0</sub>,…,a<sub>N−1</sub>} and b={b<sub>0</sub>,…,b<sub>N−1</sub>} of N non-negative integers each.</p><p>You will choose an integer k such that 0≤k&lt;N and an integer x not less than 0, to make a new sequence of length N, a′={a′<sub>0</sub>,…,a′<sub>N−1</sub>}, as follows:</p><ul><li>a′<sub>i</sub>=a<sub>(i+k)modN</sub>&nbsp;XOR&nbsp;x</li></ul><p>Find all pairs (k,x) such that a′ will be equal to b.</p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 ≤ N  ≤ 2*10^5.\n0 ≤ ai &lt; 2^30.\n0 ≤ bi &lt; 2^30.</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n# include <bits/stdc++.h>\n#include <string>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\nusing lli =  int long long;\nusing ii = pair<int,int>;\n#define F first\n#define S second\n//#define ld long double;\n\nconst int tot = 1e6+100;\nconst lli mod = 1e9+7;\nint n;\n\nvector<lli> Z;\n\n//Code for Z algo\nvoid Zalgo(vector<lli> &s){\n\n  int n = s.size();\n  Z.assign(n,0);\n\n  int l = 0, r = 0;\n  for (int i = 1; i < n; i++){\n\n    if (i > r){\n\n      l = r = i;\n      while (r<n && s[r-l] == s[r]){\n        r++;\n      }\n      Z[i] = r-l; \n      r--;\n    } \n    else{\n      int k = i-l;\n      if (Z[k] < r-i+1){\n        Z[i] = Z[k];\n      } \n      else{\n        l = i;\n        while (r < n && s[r-l] == s[r]){\n          r++;\n        }\n        Z[i] = r-l; \n        r--;\n      }\n    }\n  }\n\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n    // for getting input from input.txt\n    freopen(\"input.txt\", \"r\", stdin);\n    // for writing output to output.txt\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    IOS\n    \n    cin >> n;\n    vector<lli> a(n);\n    vector<lli> b(n);\n\n    for(int i=0;i<n;i++){\n        cin >> a[i];\n    }\n\n    for(int i=0;i<n;i++){\n        cin >> b[i];\n    }\n\n    vector<lli> c(n,0); //stores adjacent xor of a\n    vector<lli> d(n,0); //stores adjacent xor of b\n\n    for(int i=0;i<n;i++){\n        c[i] = a[i]^a[(i+1)%n]; \n    }\n\n    for(int i=0;i<n;i++){\n        d[i] = b[i]^b[(i+1)%n]; \n    }\n\n    // form the string S = (d)+(-1)+(c)+(c)\n    vector<lli> s;\n    s.insert(s.end(),d.begin(),d.end());\n    s.push_back(-1);\n    s.insert(s.end(),c.begin(),c.end());\n    s.insert(s.end(),c.begin(),c.end());\n\n\n    Zalgo(s);\n\n    lli x;\n\n    //find the values of k and x.\n    for(int k=0;k<n;k++){\n      if(Z[k+n+1]==n){\n        x = b[0]^a[k];\n        cout << k << \" \" << x << \"\\n\";\n      }\n    }\n\n    return 0;\n}```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:28:12.140940+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Here we have to shift the array a by some distance k such that , on taking xor with a number x , it corresponds to array b. In other words we have to convert array a to array b , after some cyclic shift and taking xor with a number x. &nbsp;</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">For any such pair to exist , every element of array b , must follow this relation:</span></p><p><span style=\"background-color:transparent;color:#000000;\">b<sub>i </sub>= a<sub>(i+k)modN</sub> ^ x.</span></p><p><span style=\"background-color:transparent;color:#000000;\">If we are able to find out the value of k , i.e. (the shift of array a) , then we can easily calculate its corresponding ‘x’ value , by changing the above relation into x = a<sub>(i+k)modN</sub> ^ b<sub>i&nbsp;</sub></span></p><p><br>&nbsp;</p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Take the xor of every adjacent element of a and b in a cyclic way. Eventually if the adjacent xor&nbsp; arrays of both a and b are similar (i.e. shifted by some places) , then it means pairs of k and x exist.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">Let array a = a0 , a1 , a2 , a3 , a4 , a5 and array b = b0 , b1 , b2 , b3 , b4 , b5</span></p><p><span style=\"background-color:transparent;color:#000000;\">Take adjacent xor of a : c = a0^a1 , a1^a2 , a2^a3 , a3^a4 , a4^a5 , a5^a0</span><br><span style=\"background-color:transparent;color:#000000;\">and adjacent xor of b : d = b0^b1 , b1^b2 , b2^b3 , b3^b4 , b4^b5 , b5^b0</span></p><p><span style=\"background-color:transparent;color:#000000;\">For a valid pair of k and x :-</span></p><p><span style=\"background-color:transparent;color:#000000;\">bi ^ bi+1 = aj ^ aj+1&nbsp; s.t. j = (i+k)MOD n</span></p><p><span style=\"background-color:transparent;color:#000000;\">Hence the above relation can also be written as :-</span></p><p><span style=\"background-color:transparent;color:#000000;\">bi ^ bi+1 = a(i+k)modN ^ aj+1 =&gt; bi&nbsp; = (a(i+k)modN ^ aj+1 )^ bi+1</span><br><span style=\"background-color:transparent;color:#000000;\">Which eventually becomes :- b<sub>i </sub>= a<sub>(i+k)modN</sub> ^ x.&nbsp; &nbsp; Where x = aj+1 ^ bi+1</span><br>&nbsp;</p><p><span style=\"background-color:transparent;color:#000000;\">Hence we see that the pattern of b can be obtained from a , when we take adjacent xor of both a and b.</span></p><p><span style=\"background-color:transparent;color:#000000;\">We use a string matching algorithm to match the pattern. We try to match array c with array d. Every valid match (of length n) , of array c with d will give a different value of k (which indicates the shift of array a required to get array b) . And from each k value , we can easily calculate the corresponding x value.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Which string matching algorithm will be suitable for this ? We can use Z algo , where</span></p><p><span style=\"background-color:transparent;color:#000000;\">Z[i] = largest x such that S[0,1,2…...x] = S[i,i+1,i+2…...i+x-1]</span></p><p><br>&nbsp;</p><p><span style=\"background-color:transparent;color:#000000;\">We apply Zalgo to this array :&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">S = b0^b1 , b1^b2 …... bn^b0 , -1 , a0^a1, a1^a2 …... an^a0 , a0^a1 a1^a2 …... an^a0</span></p><p>&nbsp;</p><p><span style=\"background-color:transparent;color:#000000;\">We add the array a twice , because this is a cyclic shift and we have to check at all possible starting points.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">-1 acts like an indicator to the starting point . After that point we start checking , at which index we are getting a match of length n. This gives the value of k and correspondingly x.</span></p><p>&nbsp;</p><p><span style=\"background-color:transparent;color:#000000;\"><strong>EXAMPLE RUN:</strong></span></p><p><span style=\"background-color:transparent;color:#000000;\">6</span></p><p><span style=\"background-color:transparent;color:#000000;\">0 1 3 7 6 4</span></p><p><span style=\"background-color:transparent;color:#000000;\">1 5 4 6 2 3</span></p><p>&nbsp;</p><p><span style=\"background-color:transparent;color:#000000;\">Given : n=6</span></p><p><span style=\"background-color:transparent;color:#000000;\">a = 0 1 3 7 6 4</span></p><p><span style=\"background-color:transparent;color:#000000;\">b = 1 5 4 6 2 3</span></p><p>&nbsp;</p><p><span style=\"background-color:transparent;color:#000000;\">Corresponding adjacent xor array formed from a and b.</span></p><p><span style=\"background-color:transparent;color:#000000;\">c = 1 2 4 1 2 4&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">d = 4 1 2 4 1 2&nbsp;</span></p><p>&nbsp;</p><p><span style=\"background-color:transparent;color:#000000;\">S = 4 1&nbsp; 2 4 1 2 -1 1 2 <strong>4</strong> 1 2<strong> 4</strong> 1 2 4 1 2 4 .</span></p><p><span style=\"background-color:transparent;color:#000000;\">Now corresponding Z array Z = 0&nbsp; 0 0 3 0 0&nbsp; 0&nbsp; 0 0 <strong>6</strong> 0 0 <strong>6</strong> 0 0 4 0 0 1</span></p><p>&nbsp;</p><p><span style=\"background-color:transparent;color:#000000;\">At 2 positions we are getting a n=6 length match i.e. at index (9-6-1 = 2) and index (12-6-1=5).</span></p><p><span style=\"background-color:transparent;color:#000000;\">These are the 2 values of k.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For k=2 x = b[0]^a[k] = 1^3 = 2</span></p><p><span style=\"background-color:transparent;color:#000000;\">For k=5 x = b[0]^a[k] = 1^4 = 5</span></p><p><br><span style=\"background-color:transparent;color:#000000;\">The answer is&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">2 2</span></p><p><span style=\"background-color:transparent;color:#000000;\">5 5 &nbsp;</span></p>"
      },
      "id": 442,
      "input_format": "<p>First line contains an integer N, 1 ≤ N ≤ 2*10^5.</p><p>Second line contains N space-separated integers, &nbsp;0≤ a<i><sub>i </sub>&lt; 2^30.</i></p><p>Third line contains N space-separated integers, &nbsp;0≤ b<i><sub>i </sub>&lt; 2^30.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For Sample 1,</p><p><span style=\"background-color:transparent;color:#000000;\">The array a = 1 4 2 3 0</span></p><p><span style=\"background-color:transparent;color:#000000;\">The array b = 6 7 4 5 0</span></p><p><span style=\"background-color:transparent;color:#000000;\">Convert a such that , a′<sub>i</sub>=a<sub>(i+2)mod5</sub> ^ 4</span></p><p><span style=\"background-color:transparent;color:#000000;\">The converted array : (2 3 0 1 4)</span></p><p><span style=\"background-color:transparent;color:#000000;\">Taking xor with 4 , the array finally becomes :- 6 7 4 5 0</span></p><p><span style=\"background-color:transparent;color:#000000;\">This is the same as array b. Hence only one pair is obtained.</span></p>",
      "output_format": "<p>Print all pairs&nbsp;<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></math>&nbsp;such that&nbsp;<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msup><mi>a</mi><mo>′</mo></msup></math>&nbsp;and&nbsp;<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>b</mi></math>&nbsp;will be equal, using one line for each pair, in ascending order of&nbsp;<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math>&nbsp;(ascending order of&nbsp;<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi></math>&nbsp;for pairs with the same&nbsp;<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math>).</p><p>If there are no such pairs, the output should be empty.</p>",
      "samples": [
        {
          "input": "5\n1 4 2 3 0\n6 7 4 5 0",
          "output": "2 4"
        },
        {
          "input": "6\n0 1 3 7 6 4\n1 5 4 6 2 3",
          "output": "2 2\n5 5"
        },
        {
          "input": "2\n1 2\n0 0",
          "output": ""
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "XORney",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an array of N integers. In one operation, remove any two elements in the array and add their sum to the array. The cost of this operation will be the sum of the two elements. Print the minimum cost till the size of the array does not become 1.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ N ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ A<sub>i</sub> ≤ 10<sup>9</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of N over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>6</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\n\nsigned main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        priority_queue<int, vector<int>, greater<int>> q;\n        int n;\n        cin >> n;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            cin >> x;\n            q.push(x);\n        }\n        int ans = 0;\n        while(q.size() > 1) {\n            int x = q.top();\n            q.pop();\n            int y = q.top();\n            q.pop();\n            ans += x+y;\n            q.push(x+y);\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:39:00.106008+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Use multiset/priority queue.</span></p>",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Store all the elements in the priority queue and in each turn remove the smallest two integers, add their sum to the multiset and to the answer.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N log N)</span></p>"
      },
      "id": 376,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer N - the length of the array.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">The second line of each test case contains N space-separated integers.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, take 5 and 6 to get sum (5+6) = 11</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, take 1 and 1, array becomes [2, 1] and then take 2 and 1 to get sum (1+1) + (2+1) = 5</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, take 1 and 2, array becomes [3, 3, 3] and then take 3 and 3, array becomes [6, 3] and then take 6 and 3 to get sum (1+2) + (3+3) + (6+3) = 18</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the minimum cost till the size of the array does not become 1.</span></p>",
      "samples": [
        {
          "input": "3\n4\n3 1 4 2\n3\n1 1 1\n4\n2 3 1 3\n",
          "output": "19\n5\n18\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Reduce the Array AZ101",
      "video_editorial_id": 10659
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given the $root$ of a binary tree, Find the vertical order traversal of the binary tree.\n\nFor each node at position $(r, c)$, its left and right children will be at positions $(r + 1, c - 1)$ and $(r + 1, c + 1)$ respectively. The root of the tree is at $(0, 0)$.\n\nThe vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\n\nReturn the vertical order traversal of the binary tree.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^4$ - the number of test cases.\n$1 \\leq n \\leq 10^5$ - number of nodes in binary tree.\n$1 \\leq value \\leq 10^5$ - value of nodes in binary tree.\nSum of $n$ over all test cases is $\\leq 10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstruct TreeNode {\n    int data;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : data(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        map<int, vector<pair<int, int>>> mpr;\n        queue<pair<TreeNode*, pair<int, int>>> q;\n        q.push(make_pair(root, make_pair(0, 0)));\n\n        while (!q.empty()) {\n            auto itr = q.front();\n            q.pop();\n\n            int hlev = itr.second.first, vlev = itr.second.second;\n            if (itr.first != NULL) {\n                mpr[hlev].push_back(make_pair(vlev, itr.first->data));\n                q.push(make_pair(itr.first->left, make_pair(hlev - 1, vlev + 1)));\n                q.push(make_pair(itr.first->right, make_pair(hlev + 1, vlev + 1)));\n            }\n        }\n\n        vector<vector<int>> ans;\n        for (auto itr = mpr.begin(); itr != mpr.end(); itr++) {\n            vector<int> temp;\n            sort(itr->second.begin(), itr->second.end());\n            for (int i = 0; i < itr->second.size(); i++) {\n                temp.push_back(itr->second[i].second);\n            }\n            ans.push_back(temp);\n        }\n\n        return ans;\n    }\n};\n\nTreeNode* deserialize(string data) {\n    if (data.empty())\n        return nullptr;\n    stringstream ss(data);\n    string item;\n    vector<string> dat;\n    while (getline(ss, item, ',')) {\n        dat.push_back(item);\n    }\n    int i = 0;\n    queue<TreeNode*> q;\n    TreeNode* root = new TreeNode(stoi(dat[0]));\n    q.push(root);\n    i++;\n    while (!q.empty()) {\n        auto x = q.front();\n        q.pop();\n        if (i < dat.size() && dat[i] != \"x\") {\n            x->left = new TreeNode(stoi(dat[i]));\n            q.push(x->left);\n        }\n        i++;\n        if (i < dat.size() && dat[i] != \"x\") {\n            x->right = new TreeNode(stoi(dat[i]));\n            q.push(x->right);\n        }\n        i++;\n    }\n    return root;\n}\n\nvoid solve() {\n    string tr;\n    cin >> tr;\n    Solution sol;\n    auto root = deserialize(tr);\n    auto ans = sol.verticalTraversal(root);\n    for (auto& x : ans) {\n        for (auto& y : x) cout << y << \" \";\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:43:04.954327+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "This question can be solved by assigning horizontal distance in the order of X coordinate.\n\nNOTE: \n- Distance of the root is considered 0.\t\n- Number written inside the parenthesis denotes the horizontal distance of that node.\n\nNode has distance:    d\nLeft Children:\t           d - 1\nRight Children:\t   d + 1\n\t\t\n\t\n\t\t\t\t1(0)\n\t\t\t  /     \\\n\t\t (-1)2       3(1)\t\n\t\t   /  \\\t\t/   \\\n\t  (-2)4   5(0) 6(0) 7(2)\n\nThe catch point of this question is If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.\n\t\nWhat it means: If two nodes have the same position and both are present on the same level.\n\t\nFor such type of cases, the nodes having smaller value comes first. Like in the above tree 5 and 6 have the same position and are present in the second level. Since 5 is smaller than 6 so there fore 5 should come first.\n\nTo handle it, we maintained the level number along with the node value of a node by using vector<pair<int, int>>.\n\t\nTo get horizontal distances in sorted order we can maintain a map data structure.\n\nContent of _map for the above tree is : map<int, vector<pair<int, int>>> _map\n\t\n     hori_dist(key)     [levl_number, element]    \n\t\t\n\t-2     -->      [(2, 4)]\n\t-1     --> \t\t[(1, 2)]\n\t0      --> \t\t[(0, 1), (2, 5), (2, 6)]\n\t1      --> \t\t[(1, 3)]\n\t2      --> \t\t[(2, 7)]\n\t\nWhile getting the content of _map from top to bottom sort the vector associated with the key based on level number. If levels are the same for the two-element then sort based on values.\n\nWe don't need to pass a custom comparator to the sort function because the sort function will automatically do it.\n\n**Time Complexity:** $O(n*log(n))$.\n**Space Complexity:** $O(n)$."
      },
      "id": 1048,
      "input_format": "Complete the function ```vector<vector<int>> verticalTraversal(TreeNode* root)``` that takes the root of the binary tree as input and returns vertical order traversal of the binary tree.\n\nFor local testing of the sample, the first line contains $T$, the number of test cases. The first line of each test case contains  the level order traversal of the tree, where *'$x$'* denotes the *'nullptr'*.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For test case 1, \n```\n           1\n         /   \\\n       2       3\n     /   \\   /   \\\n   4      6  5     7\n              \\     \\\n               8     9 \n```\nOutput\n```\n[[4],[2],[1,5,6],[3,8],[7],[9]]\n```\nSince nodes 5 and 6 are in the same location and should be ordered by their values. \n\nFor test case 2,\n```\n           3\n         /   \\\n       1       4\n     /   \\   /   \n   7      2  2   \n```\nOutput\n```\n[[7],[1],[3,2,2],[4]]\n```",
      "output_format": "Return vertical order traversal of the binary tree as ```vector<vector<int>>```.\nIn such a case, sort these nodes by their values.",
      "samples": [
        {
          "input": "2\n1,2,3,4,6,5,7,x,x,x,x,x,8,x,9,x,x,x,x\n3,1,4,7,2,2,x,x,x,x,x,x,x\n",
          "output": "4 \n2 \n1 5 6 \n3 8 \n7 \n9 \n\n7 \n1 \n3 2 2 \n4 \n\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstruct TreeNode {\n    int data;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) {\n        this->data = x;\n        this->left = nullptr;\n        this->right = nullptr;\n    }\n};\n\nclass Solution {\n</fix>\n\n<fix>\npublic:\n</fix>\n\n<fix>\n    vector<vector<int>> verticalTraversal(TreeNode *root) {\n</fix>\n        // write code here.\n        return {{}};\n<fix>\n    }\n</fix>\n<fix>\n};\n</fix>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<fix>\nTreeNode *deserialize(string data)\n{\n    if (data.size() == 0)\n        return nullptr;\n    vector<string> dat;\n    string t;\n    for (auto c : data)\n    {\n        if (c == ',')\n        {\n            dat.push_back(t);\n            t.clear();\n        }\n        else\n            t.push_back(c);\n    }\n    dat.push_back(t);\n    int i = 0;\n    queue<TreeNode *> q;\n    TreeNode *root = new TreeNode(stoll(dat[0]));\n    q.push(root);\n    auto cur = root;\n    i++;\n    while (!q.empty())\n    {\n        auto x = q.front();\n        q.pop();\n        if (dat[i] != \"x\")\n        {\n            x->left = new TreeNode(stoll(dat[i]));\n            q.push(x->left);\n        }\n        i++;\n        if (dat[i] != \"x\")\n        {\n            x->right = new TreeNode(stoll(dat[i]));\n            q.push(x->right);\n        }\n        i++;\n    }\n    return root;\n}\n\nvoid solve() {\n    string tr;\n    cin >> tr;\n    Solution sol;\n    auto root = deserialize(tr);\n    auto ans = sol.verticalTraversal(root);\n    for (auto x : ans) {\n        for (auto y : x)cout << y << \" \";\n        cout << endl;\n    }\n    cout << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "Vertical Order Traversal",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a bitonic array <i>A</i> consisting of <i>N</i> integers and an integer <i>Q</i>. In each query, you will be given an integer <i>K</i>, find the positions of <i>K</i> in <i>A</i>. Integer <i>K </i>exists in<i> A.</i></p><p>Bitonic array - A bitonic sequence is a sequence with A[1]&lt;A[2]&lt;A[3]....A[k]&gt;A[k+1]&gt;A[k+2]....&gt;A[N] for some 1&lt;=K≤N.&nbsp;</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint n,q;\nvector<int> arr;\n\nbool check(int i){\n   if(arr[i]>arr[i-1])return 1;\n   else return 0;\n}\n\nvoid solve(){\n   cin>>n>>q;\n   arr.resize(n);\n   for(int i=0;i<n;i++){\n       cin>>arr[i];\n   }\n\n   int lo = 1;\n   int hi = n-1;\n   int peak = 0;\n   while(lo<=hi){\n       int mid = (lo+hi)/2;\n       if(check(mid)){\n           peak = mid;\n           lo = mid + 1;\n       }else{\n           hi = mid - 1;\n       }\n   }\n\n   while(q--){\n       int k;\n       cin>>k;\n\n       vector<int> final;\n       lo = 0;\n       hi = peak-1;\n       while(lo<=hi){\n           int mid = (lo+hi)/2;\n           if(arr[mid]==k){\n               final.push_back(mid+1);\n               break;\n           }else if(arr[mid]>k){\n               hi=mid-1;\n           }else{\n               lo=mid+1;\n           }\n       }\n\n       lo = peak;\n       hi = n-1;\n       while(lo<=hi){\n           int mid = (lo+hi)/2;\n           if(arr[mid]==k){\n               final.push_back(mid+1);\n               break;\n           }else if(arr[mid]>k){\n               lo=mid+1;\n           }else{\n               hi=mid-1;\n           }\n       }\n\n       for(auto v:final){\n           cout<<v<<\" \";\n       }  \n       cout<<endl;\n   }\n}\n\nsigned main(){\n   ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n   int _t;cin>>_t;while(_t--)\n   solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:13:22.248190+00:00"
      },
      "hints": {
        "hint1": "The given array can be seen as two different arrays which are merged together, one is in increasing order and the other in decreasing order.",
        "hint2": "First, find the peak of the given array using binary search and since both the parts of the array are sorted, we can use binary search on both of them to find the given query number.",
        "solution_approach": "<p>We will use binary search on the given array in a different way since the array is not sorted. First we need to find the peak of the array. This would be done by binary search, since the peak point would be the only point that is greater than elements to both sides, its left and right. We take the left pointer L = 1, the right pointer R = N (since the array is 1-indexed) and mid = (L+R)/2. If we get A[mid-1] &lt; A[mid], that means mid could be a possible peak, since the peak cannot exist at any point lower than mid, so we continue binary search on L = mid+1 to R. Otherwise, A[mid-1] &gt; A[mid], the peak would be lower than mid, so we continue binary search on L to R = mid-1. If peak is the index of the given query number, that would be the answer.</p><p>After finding the peak, we apply binary search on both sides of the peak, i.e. from L = 1 to R = peak -1 and L = peak + 1 to R = N, separately. Note that it is possible that an element can exist in the left part as well as the right part of the peak of the array.</p><p>Time Complexity per test case: O(Q log<sub>2</sub>N) (since we are performing binary search on the length of the given array)</p>"
      },
      "id": 107,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases (<i>1&lt;=T&lt;=10000</i>).</p><p>The first line contains two space separated-integer <i>N, Q</i> where <i>1&lt;=N&lt;=10^5, 1&lt;=Q&lt;=10^6.</i></p><p>The second line contains N space-separated integers A<sub>1</sub>,A<sub>2</sub>....A<sub>N</sub> where <i>-1e9&lt;=A<sub>i</sub>&lt;=1e9</i>.</p><p>Next Q lines contains an integer <i>K</i>, <i>-1e9&lt;=K&lt;=1e9</i>.</p><p>Sum of <i>N,</i> <i>Q </i>across all test case<i> ≤10^6</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the positions of <i>K</i> in <i>A</i> in sorted order in a new line.</p><p><strong>Positions are 1-indexed.</strong></p>",
      "samples": [
        {
          "input": "1\n6 4\n1 2 5 3 2 1\n1\n2\n5\n3",
          "output": "1 6\n2 5\n3\n4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Bitonic Array",
      "video_editorial_id": 10661
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "There are N soldiers standing in a row, numbered 1 through N. The height of i-th soldier is Hi. For each non-empty contiguous segment of the line, strength is defined as the minimum height of the soldier in that segment.\nYou have to tell the maximum strength for each x size group, for all groups of size x between 1 to N.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$  \n\n$1 \\leq N \\leq 10^5$  \n\n$1 \\leq H_i \\leq 10^9$  \n\nThe sum of $N$ over all test cases doesn't exceed $5 \\times 10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n \nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        int a[n];\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        stack<int> s;\n        int l[n], r[n];\n        for (int i = 0; i < n; ++i) {\n            while(!s.empty() && a[s.top()] >= a[i]) {\n                s.pop();\n            }\n            if(s.empty()) {\n                l[i] = -1;\n            }\n            else {\n                l[i] = s.top();\n            }\n            s.push(i);\n        }\n        while (!s.empty()) {\n            s.pop();\n        }\n        for (int i = n-1; i >= 0; --i) {\n            while(!s.empty() && a[s.top()] >= a[i])\n                s.pop();\n            if(s.empty()) {\n                r[i] = n;\n            }\n            else {\n                r[i] = s.top();\n            }\n            s.push(i);\n        }\n \n        int ans[n] = {};\n        for (int i = 0; i < n; ++i) {\n            int x = r[i] - l[i] - 2;\n            ans[x] = max(ans[x], a[i]);\n        }\n        for (int i = n-2; i >= 0; --i) {\n            ans[i] = max(ans[i], ans[i+1]);\n        }\n        for (int i = 0; i < n; ++i) {\n            cout << ans[i] << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:13:01.018288+00:00"
      },
      "hints": {
        "hint1": "Note that the answer is non-increasing.",
        "hint2": "Try using a data structure to store the answers in groups.",
        "solution_approach": "For each $i$, find the largest $j$ such that $a_j < a_i$ and $j < i$ (if there is no such $j$, then consider it as $-1$). Let this be $L_i$.  \nSimilarly, find the smallest $j$ such that $a_j < a_i$ and $j > i$ (if there is no such $j$, then consider it as $N$). Let this be $R_i$.\n\nYou can use a stack to compute this in $O(N)$. For each $i$, we know that it can be the minimum element in groups of size $1, 2, \\dots, R_i - L_i - 1$.  \nLet $ans_i$ be the answer for $i$ from $0$ to $N-1$, then $ans_1 \\geq ans_2 \\geq \\dots \\geq ans_N$.\n\n**See solution code.**\n\n**Time Complexity:** $O(N)$\n"
      },
      "id": 88,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\n\nThe first line of each test case contains one integer $N$ - the length of the array.\n\nThe second line of each test case contains $N$ space-separated integers - $H_1, H_2, \\dots, H_N$, the heights of the soldiers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "In the first test case of the example, for x=1, possible answers are 1, 5 and 3 (maximum of them is 5).\nFor x=2, possible answers are 1 and 3 (maximum of them is 3)\nFor x=3, the only possible answer is 1.\n\nIn the second test case of the example, for x=1, possible answers are 1, 6 and 8 (maximum of them is 8).\nFor x=2, possible answers are 1 and 6 (maximum of them is 6)\nFor x=3 and x=4, the only possible answer is 1.",
      "output_format": "For each test case, print N integers in one line. For each x from 1 to N, print the maximum strength among all groups of size x.",
      "samples": [
        {
          "input": "3\n3\n1 5 3\n4\n8 6 1 1\n7\n1 2 3 4 6 3 2",
          "output": "5 3 1 \n8 6 1 1 \n6 4 3 3 2 2 1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Height of Soldiers",
      "video_editorial_id": 8145
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Design a Data Structure which can support the following queries:</p><p><strong>1 </strong><i><strong>x</strong></i>: Add <i>x</i> in structure<br><strong>2 x</strong>: Remove <i>x</i> from the structure if present in the structure. If <i>x</i> doesn't present in the structure, do nothing. If there are multiple occurrences of <i>x</i>, delete only one occurrence of <i>x</i>.<br><strong>3 ?</strong>: Print the minimum number present in the structure. If the structure is empty, print -1.<br><strong>4 ?</strong>: Print the maximum number present in the structure. If the structure is empty, print -1.<br><strong>5 ?</strong>: Print the sum of all numbers present in the structure. If the structure is empty, print 0.</p><p>Initially, the structure is empty.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>Q</i> ≤ 10<sup>5</sup><br>0 ≤ <i>x</i> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n\nstruct data {\n  map<ll, ll> mp;\n  ll sum = 0;\n  void add(ll x) {\n    sum += x;\n    mp[x]++;\n  }\n  void remove(ll x) {\n    if (mp.find(x) != mp.end()) {\n      if (mp[x] != 0) {\n        sum -= x;\n        mp[x]--;\n      }\n      if (mp[x] == 0)\n        mp.erase(x);  // If the element count becomes 0 its better to remove the\n                      // key x from the map\n    }\n  }\n  void min() {\n    if ((int)mp.size() != 0)\n      cout << mp.begin()->first << '\\n';\n    else\n      cout << \"-1\\n\";\n  }\n  void max() {\n    if ((int)mp.size() != 0)\n      cout << (*mp.rbegin()).first << '\\n';\n    else\n      cout << \"-1\\n\";\n  }\n  void cur_sum() { cout << sum << '\\n'; }\n};\n\nvoid solve() {\n  data mystructure;\n  ll q;\n  cin >> q;\n  while (q--) {\n    int x, t;\n    char y;\n    cin >> t;\n    if (t == 1) {\n      cin >> x;\n      mystructure.add(x);\n    } else if (t == 2) {\n      cin >> x;\n      mystructure.remove(x);\n    } else if (t == 3) {\n      cin >> y;\n      mystructure.min();\n    } else if (t == 4) {\n      cin >> y;\n      mystructure.max();\n    } else if (t == 5) {\n      cin >> y;\n      mystructure.cur_sum();\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  // int t;cin >> t;while(t--)\n  solve();\n}\n```\n\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\ntypedef long long ll;\n#define endl '\\n'\n\nstruct data {\n  multiset<int> st;\n  ll sm = 0;\n\n  void insert(int x) {\n    st.insert(x);\n    sm += x;\n  }\n\n  void remove(int x) {\n    auto it = st.find(x);\n    if (it != st.end()) {\n      st.erase(it);\n      sm -= x;\n    }\n  }\n\n  int maximum() {\n    if (!st.empty())\n      return *(--st.end());\n    else\n      return -1;\n  }\n\n  int minimum() {\n    if (!st.empty())\n      return *(st.begin());\n    else\n      return -1;\n  }\n\n  ll sum() {\n    if (!st.empty())\n      return sm;\n    else\n      return 0;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  // freopen(\"IN\", \"r\", stdin);\n  // freopen(\"OUT\", \"w\", stdout);\n  int q;\n  cin >> q;\n  data mystructure;\n  while (q--) {\n    int option;\n    cin >> option;\n    if (option == 1) {\n      int x;\n      cin >> x;\n      mystructure.insert(x);\n    } else if (option == 2) {\n      int x;\n      cin >> x;\n      mystructure.remove(x);\n    } else if (option == 3) {\n      char x;\n      cin >> x;\n      cout << mystructure.minimum() << endl;\n    } else if (option == 4) {\n      char x;\n      cin >> x;\n      cout << mystructure.maximum() << endl;\n    } else if (option == 5) {\n      char x;\n      cin >> x;\n      cout << mystructure.sum() << endl;\n    }\n  }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:13:50.967238+00:00"
      },
      "hints": {
        "hint1": "Decide the data structure which can handle all the queries easily.",
        "hint2": "Finding minimum and maximum is involved so the first thing which comes to mind is to keep the values sorted. Think about containers which can keep elements in sorted order. Sets, Maps, Multisets. Since same value can be present multiple times so using a set would not solve our purpose. Use maps/ multisets.",
        "solution_approach": "To find sum, you can use a variable to store the dynamic sum. To find minimum and maximum there are relevant functions in multisets and maps to find the first and last elements. To remove an occurence of an element use `find` function to get the iterator to that element and then delete its occurence. Why aren't we directly using `erase(x)` functionality available in maps and multisets?? Well think about what would happen to multiple occurences in that case.\n\nTime Complexity : Sum : $O(1)$, Extracting minimum and maximum : $O(1)$.\nThe overall time complexity of this solution is $O(Q \\log N)$, where $Q$ is the number of queries and $N$ is the number of elements in the map/multiset. This is because the map data structure has a logarithmic time complexity for search and insert operations."
      },
      "id": 83,
      "input_format": "<p>The first line of input contains <i>Q</i> - the number of queries.<br>Next, <i>Q</i> lines contain queries of the format specified in the statement.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For queries of type 3, 4 and 5, print the answer in a new line.</p>",
      "samples": [
        {
          "input": "18\n1 5\n1 4\n1 4\n3 ?\n4 ?\n5 ?\n2 4\n3 ?\n4 ?\n5 ?\n2 4\n3 ?\n4 ?\n5 ?\n2 5\n3 ?\n4 ?\n5 ?",
          "output": "4\n5\n13\n4\n5\n9\n5\n5\n5\n-1\n-1\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Support Queries I",
      "video_editorial_id": 10657
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Your city is having people infected with a virus. The city in which you live is represented as a grid consisting of <strong>n</strong> rows and <strong>m</strong> columns. Cells containing <strong>2</strong> are the cells where the people infected with the virus are present and the cells having <strong>1</strong> are the cells having people not yet infected with the virus. There are certain empty cells which are represented by <strong>0</strong>. The infected people in a unit time can infect <strong>all</strong> their adjacent cells, i.e, if they are present at cell [i, j] they can infect cells [i-1, j], [i+1, j], [i, j-1] and [i, j+1]. The virus <strong>cannot</strong> pass through empty cells. Your task is to print the minimum time in which all the people are infected with the virus. If the virus cannot infect everyone, print <strong>-1</strong>.</span></p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 1000\n1 &lt;= m &lt;= 1000</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint n, m;\n\tcin >> n >> m;\n\tvector <vector <int>>grid(n, vector <int> (m));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> grid[i][j];\n\t\t}\n\t}\n\tvector <vector <int>> vis(n, vector <int> (m, 1e9));\n\tqueue <pair<int, int>> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (grid[i][j] == 2) {\n\t\t\t\tvis[i][j] = 0;\n\t\t\t\tq.push({i, j});\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tauto cur = q.front();\n\t\tq.pop();\n\t\tint i, j;\n\t\ti = cur.first;\n\t\tj = cur.second;\n\t\tif (i && grid[i - 1][j] != 0) {\n\t\t\tif (vis[i - 1][j] == 1e9) {\n\t\t\t\tvis[i - 1][j] = vis[i][j] + 1;\n\t\t\t\tq.push({i - 1, j});\n\t\t\t}\n\t\t}\n\t\tif (i + 1 < n && grid[i + 1][j] != 0) {\n\t\t\tif (vis[i + 1][j] == 1e9) {\n\t\t\t\tvis[i + 1][j] = vis[i][j] + 1;\n\t\t\t\tq.push({i + 1, j});\n\t\t\t}\n\t\t}\n\t\tif (j && grid[i][j - 1] != 0) {\n\t\t\tif (vis[i][j - 1] == 1e9) {\n\t\t\t\tvis[i][j - 1] = vis[i][j] + 1;\n\t\t\t\tq.push({i, j - 1});\n\t\t\t}\n\t\t}\n\t\tif (j + 1 < m && grid[i][j + 1] != 0) {\n\t\t\tif (vis[i][j + 1] == 1e9) {\n\t\t\t\tvis[i][j + 1] = vis[i][j] + 1;\n\t\t\t\tq.push({i, j + 1});\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (grid[i][j] != 0) {\n\t\t\t\tans = max(ans, vis[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif (ans == 1e9)\n\t\tans = -1;\n\tcout << ans;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:18:44.806470+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Can we think of the city as a graph?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">For each non-infected person we want the nearest infected person.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">We can think of the city as a graph. Now we need to find the nearest infected person for each cell containing 1. This can be solved using multisource BFS where we do Breadth-first search starting from every infected person. We push all the cells having 2 into a queue. This way the first time a non-infected cell is encountered in the BFS, it is through the shortest possible path.</span><br><span style=\"background-color:transparent;color:#000000;\">After getting the minimum time for all non-infected cells we can take maximum of all these times to find the minimum time after which everyone is infected. We initialise the distance to a very large quantity. So if a cell is not infected at the end, our answer turns out to be that large quantity (10<sup>9</sup> in our case) and we print -1.</span></p>"
      },
      "id": 589,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains two integers <strong>n</strong> and <strong>m</strong>&nbsp; — the number of rows and columns, respectively.</span><br><span style=\"background-color:transparent;color:#000000;\">The following <strong>n</strong> lines contain <strong>m</strong> integers each, the j-th element in the i-th line is the number written in the j-th cell of the i-th row.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">After 1 unit time,</span><br><span style=\"background-color:transparent;color:#000000;\">0 2 2</span><br><span style=\"background-color:transparent;color:#000000;\">0 2 2</span><br><span style=\"background-color:transparent;color:#000000;\">1 2 2.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Still there is a person which has not yet been infected.</span><br><span style=\"background-color:transparent;color:#000000;\">0 2 2</span><br><span style=\"background-color:transparent;color:#000000;\">0 2 2</span><br><span style=\"background-color:transparent;color:#000000;\">2 2 2.</span><br><span style=\"background-color:transparent;color:#000000;\">So the minimum time in which everyone is infected is 2.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For second test case,</span><br><span style=\"background-color:transparent;color:#000000;\">After 1 unit time,</span><br><span style=\"background-color:transparent;color:#000000;\">0 2 2</span><br><span style=\"background-color:transparent;color:#000000;\">0 2 2</span><br><span style=\"background-color:transparent;color:#000000;\">1 0 2.</span><br><span style=\"background-color:transparent;color:#000000;\">No more cells can be infected.</span><br><span style=\"background-color:transparent;color:#000000;\">Still there is a person which has not yet been infected.</span><br><span style=\"background-color:transparent;color:#000000;\">So we print -1.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the minimum time in which everyone can be infected or <strong>-1</strong> if everyone cannot be infected.</span></p>",
      "samples": [
        {
          "input": "3 3\n0 1 2\n0 1 2\n1 1 2",
          "output": "2"
        },
        {
          "input": "3 3\n0 1 2\n0 1 2\n1 0 2",
          "output": "-1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Infected People",
      "video_editorial_id": 10676
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers <i>A</i>. The score of a subarray is the sum of all integers in the subarray. Mr.X calculated the score of all <i>N*(N+1))/2</i> subarray. Mr.X wants you to find the median of the array containing the score of all the subarray.</p><p>&nbsp;</p><p><strong>Note:</strong> The median of a sequence is the value that is in the middle when the sequence is sorted. If the length of the sequence is even, there are two values in the middle and the median is the smaller of these values (or either when they are equal).</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n;\nll arr[100001];\nll func(ll x){ // count number of subarray with sum<=x\n   ll cnt = 0;\n   ll currSum = 0;\n   ll start = 0;\n   ll current = 0;\n   while(current<n){\n       currSum+=arr[current];\n       while(start<=current and currSum>x){\n           currSum-=arr[start];\n           start++;\n       }\n       cnt+=(current-start+1);\n       current++;\n   }\n   return cnt;\n}\nsigned main()\n{\n   ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n   int testcases;\n   cin>>testcases;\n   while(testcases--){\n       cin>>n;\n       ll low = 0,high = 0;\n       for(ll i=0;i<n;i++){\n           cin>>arr[i];\n           high+=arr[i];\n       }\n       ll ans = -1;\n       ll total = (n*(n+1))/2;\n       ll median = (total+1)/2;\n       while(low<=high){\n           ll mid = (low+high)/2;\n           ll cntSub = func(mid);\n           if(cntSub>=median)\n               high = mid-1,ans = mid;\n           else\n               low = mid+1;\n       }\n       cout<<ans<<\"\\n\";\n   }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:21:16.406414+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">If X is a possible value of the median of the new array, then it should exist in the array and it should have (M+1)/2 elements lesser than or equal to X in the array. Here, M is the size of the new array, i.e. M = N*(N+1)/2.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">If we get the number of elements lesser than or equal to X as </span><span style=\"background-color:#ffffff;color:#202124;\">≥ (M+1)/2. The possible value of median could X or any value lesser than X. Otherwise, it would be greater than X. </span><span style=\"background-color:transparent;color:#212529;\">This is a monotonic function and hence we can use binary search in this problem. Here </span><span style=\"background-color:transparent;color:#000000;\">M = N*(N+1)/2.</span></p>",
        "solution_approach": "<p>We would be doing binary search on the possible values of the median. Here, we would be using the array which has the subarray sums of the original array. We take the left pointer as L = 0 or L = minimum value present in the new array and we take the right pointer as R = sum of all the numbers in the original array. We take mid = (L+R)/2. We need to find the number of values ≤ mid.</p><p>It would not be possible to create the new array since N ≤ 10<sup>5</sup> and the new array would be of size N*(N+1)/2. To avoid making the new array, we will use two pointers to calculate the subarray sums. If a sum from i to j is ≤ mid, that means all sums from i to (values than j) is ≤ mid.</p><p>If the number of values ≤ mid is greater than or equal to (M + 1)/2, that means mid can be a possible value of the median or it would be lesser than mid, so we continue binary search on L to R = mid - 1. Otherwise, the value of median would be &gt; mid and so we continue binary search on L = mid+1 to R. Here, M = N*(N+1)/2.</p><p>Time Complexity per test case: O(N * log2(ΣAi))</p>"
      },
      "id": 45,
      "input_format": "<p>The first line contains an integer <i>T</i>, the number of test cases <i>(1&lt;=T&lt;=10000)</i>.</p><p>The first line of each test case contains an integer <i>N</i> where <i>(1&lt;=N&lt;=10^5)</i>.</p><p>Next line contains <i>N</i> space-separated integers <i>(0&lt;=A<sub>i</sub>&lt;=1e9).</i></p><p>Sum of <i>N</i> across all test cases ≤ 10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "<p><strong>1st test case:</strong><br>Subarray and score:<br>1 -&gt; 1<br>1,2 -&gt; 3<br>1,2,3 -&gt; 6<br>2 -&gt; 2<br>2,3 -&gt; 5<br>3 -&gt; 3<br>New array = {1,2,3,3,5,6}, median = 3</p><p><strong>2nd test case:</strong><br>Subarray and Score:<br>5 -&gt; 5<br>New array = {5}, median = 5</p><p><strong>3rd test case:</strong><br>Subarray and score<br>1 -&gt; 1<br>1,5 -&gt; 5<br>5 -&gt; 5<br>New array = {1,5,5}, median = 5.</p>",
      "output_format": "<p>For each test case output the median of the array containing the score of all the subarray in a new line.</p>",
      "samples": [
        {
          "input": "5\n3\n1 2 3\n1\n5\n2\n1 5\n10\n1 2 2 3 3 4 5 4 6 7\n15\n100 222 333 511 555 232 444 555 777 888 999 1000 1112 12345 123456",
          "output": "3\n5\n5\n13\n3629"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Median of Subarray Sum",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given an array of <i>n</i> numbers and a positive integer <i>m</i>. Lets define <i>c(i, j) = |a<sub>i</sub> - a<sub>j</sub>|</i>.<br>Your task is to find the product of <i>c(i, j)</i> for all 1 ≤ <i>i</i> &lt; <i>j</i> ≤ <i>n</i>. Since this product can be very large, print it with modulo <i>m</i>.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint p;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint sub(int a, int b) {\n    int s = (a+p-b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int n;\n    cin>>n>>p;\n    assert(n > 0 && n <= 200000 && p > 0 && p <= 1000);\n    if (n>p) {cout<<0; return 0;}\n    vector<int> a(n);\n    for (int i = 0; i<n; i++) {\n        cin>>a[i];\n        assert(a[i] >= 0 && a[i] <= 1000000000);\n    }\n    int res = 1;\n    for (int i = 0; i<n; i++)\n        for (int j = i+1; j<n; j++) res = mul(res, abs(a[i] - a[j])%p);\n    cout<<res;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:32:19.836378+00:00"
      },
      "hints": {
        "hint1": "<p>Look at the constraints, especially at the range of <i>m</i>.</p>",
        "hint2": "<p>If <i>n</i> &lt; <i>m</i>, then <i>O(n<sup>2</sup>)</i> solution will pass, but what about when <i>n</i> &gt; <i>m</i>?</p>",
        "solution_approach": "<p>Let's consider 2 cases.</p><ol><li><i>n</i> ≤ <i>m</i>. Then we can calculate this product directly in <i>O(n<sup>2</sup>)</i>.</li><li><i>n </i>&gt; <i>m</i>. Note that there are only <i>m</i> possible remainders under division by <i>m</i>, so some 2 numbers of <i>n</i> have the same remainder. Then their difference is divisible by <i>m</i>, so the entire product is 0 mod <i>m</i>.</li></ol>"
      },
      "id": 282,
      "input_format": "<p>The first line contains two integers <i>n</i>, <i>m</i> (2 ≤ <i>n</i> ≤ 2 x 10<sup>5</sup>, 1 ≤ <i>m</i> ≤ 1000) — number of numbers and modulo.<br>The second line contains <i>n</i> integers <i>a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub></i> (0 ≤ <i>a<sub>i</sub></i><sub> </sub>≤ 10<sup>9</sup>).</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>In the first sample, |8 − 5| = 3 ≡ 3 mod 10.<br>In the second sample, |1 − 4| ⋅ |1 − 5| ⋅ |4 − 5| = 3 ⋅ 4 ⋅ 1 = 12 ≡ 0 mod12.</p>",
      "output_format": "<p>Output a single integer.</p>",
      "samples": [
        {
          "input": "2 10\n8 5",
          "output": "3"
        },
        {
          "input": "3 12\n1 4 5",
          "output": "0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Pair Products",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a 2d-array of dimension <i>N*M</i> and <i>Q</i> queries. In each query five integers <i>x1, y1, x2, y2, C</i> is given, you have to increase the value of each cell in the submatrix with <i>(x1,y1)</i> be the leftmost corner and <i>(x2,y2)</i> be the rightmost corner by <i>C</i>. Initially the value of all the cell of the 2d-array is 0.</p><p>After all the query is performed, print the maximum value present in the 2d-array and the number of the cell with the maximum value.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e3 + 10;\nlong long p[N][N];\nlong long a[N][N];\nvoid solve() {\n  int n, m, q;\n  cin >> n >> m >> q;\n  while (q--) {\n    int x1, y1, x2, y2, c;\n    cin >> x1 >> y1 >> x2 >> y2 >> c;\n    a[x1][y1] += c;\n    a[x1][y2 + 1] -= c;\n    a[x2 + 1][y1] -= c;\n    a[x2 + 1][y2 + 1] += c;\n  }\n\n  long long max = a[1][1];\n  long long count = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      p[i][j] = a[i][j] + p[i - 1][j] + p[i][j - 1] - p[i - 1][j - 1];\n      if (p[i][j] == max) {\n        count++;\n      } else if (p[i][j] > max) {\n        max = p[i][j];\n        count = 1;\n      }\n    }\n  }\n\n  cout << max << \" \" << count << '\\n';\n}\n\nsigned main() { solve(); }\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:44:59.319317+00:00"
      },
      "hints": {
        "hint1": "Use Partial Sums in 2D matrix. If new to this concept,\nCheck the video solution - 2D Partial Sums Concept.",
        "hint2": "We need to add a value C to a rectangular region with (x1,y1) as the top left corner and (x2,y2) as the bottom right corner. Lets say we use our idea of partial sums, and just add $+C$ to the top left corner at (x1,y1). What will be its effect on the matrix? We can see that due to this addition all the elements in the rectangle (x1,y1) as the left corner and (n,m) as the right bottom corner would have the effect of $+C$. But we surely don't want this because our aim is only to add C in the smaller rectangle with (x1,y1) and (x2,y2) as corners. How to counter this problem? Well we do a $-C$ at the top right and bottom left corners which are (x1,y2) and (x2,y1). Is that all? Does it take care of everything. What about the region which is to the right and bottom of (x2,y2). Isn't it getting the effect of all the above additions and subtractions? So it will have one $+C$ and two $-C$ contributions. Well we can easily solve this issue by just adjusting this with a $+C$ at the index (x2,y2).",
        "solution_approach": "We solve this problem using the concept of partial sums.\n\nFirst, create a 2d-array of size N*M to store the initial values of all cells as 0.\n\nNext, for each query (x1, y1, x2, y2, C), we need to add C to each cell in the submatrix with (x1,y1) be the leftmost corner and (x2,y2) be the rightmost corner.\n\nTo do this efficiently using partial sums, we need to first precompute a 2d-array called partial sums, where each cell (i,j) stores the sum of all the values in the submatrix with (1,1) as the top-left corner and (i,j) as the bottom-right corner. We can compute this array using the following formula:\n\npartialsums[i][j] = partialsums[i-1][j] + partialsums[i][j-1] - partialsums[i-1][j-1] + values[i][j]\n\nHere, values[i][j] is the value of the cell at (i,j) in the original 2d-array.\n\nOnce we have computed the partial sums array, we can update the values in the submatrix with (x1,y1) as the top-left corner and (x2,y2) as the bottom-right corner by adding C to each cell using the following formula:\n\npartialsums[x2][y2] += C\npartialsums[x1-1][y2] -= C\npartialsums[x2][y1-1] -= C\npartialsums[x1-1][y1-1] += C\n\nAfter all the queries have been processed, we can compute the final values in the original 2d-array by subtracting the partial sums for the overlapping submatrices using the following formula:\n\nvalues[i][j] = partialsums[i][j] - partialsums[i-1][j] - partialsums[i][j-1] + partialsums[i-1][j-1]\n\nThis will give us the final values in the original 2d-array after all the queries have been processed.\nAfter this just iterate over the entire matrix to find the maximum element. \nThe time complexity for this algorithm is $O(Q+N\\times M)$. For each query it almost takes constant time. Finally we iterate over the entire 2D matrix to find the prefix sum of the partial sum matrix and keep updating the maximum value and its position."
      },
      "id": 28,
      "input_format": "<p>The first line contains three space-separated integers <i>N</i>, <i>M</i>, <i>Q</i> where 1&lt;=<i>N</i>, <i>M</i>&lt;=10^3, 1&lt;=<i>Q</i>&lt;=10^6.</p><p>The next <i>Q</i> lines contains five space separated integers <i>x1, y1, x2, y2, C</i> where 1&lt;=<i>x1</i>&lt;=<i>x2</i>&lt;=<i>N</i>, 1&lt;=<i>y1</i>&lt;=<i>y2</i>&lt;=<i>M</i>, -10^9&lt;=<i>C</i>&lt;=10^9.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>After all the query is performed, print 2 space-separated integers representing the maximum value present in the 2d-array and the number of the cell with the maximum value.</p>",
      "samples": [
        {
          "input": "5 5 5\n1 1 2 2 -8\n1 2 3 4 9\n2 3 3 3 -2\n4 4 4 4 -4\n2 3 2 4 0",
          "output": "9 5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Max Value in the Rectangle",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Vivek and Abhishek are playing a game of chips, taking turns alternatively. Initially, there are $x$ chips on the table. On each turn, a player can pick up $2^m$ chips such that $m\\geq0$ and $x\\geq2^m$. A player loses the game if he has no chips to pick from the table.\n\nGiven that Vivek starts the game, Predict the winner of the game.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^6$.\n$0 \\leq x \\leq 2\\times10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvector<int> dp;\nint rec(int x) {\n    if (x == 0)return 0;\n    if (__builtin_popcount(x) == 1)return 1;\n    auto &ans = dp[x];\n    if (ans != -1)return ans;\n    ans = 1;\n    for (int j = 0; (1 << j) <= x; j++) {\n        ans &= rec(x - (1 << j));\n    }\n    ans ^= 1;\n    return ans;\n}\nvoid solve() {\n    dp.assign((int)2e5 + 10, -1);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        auto ans = rec(n);\n        if (ans)cout << \"Vivek\" << endl;\n        else cout << \"Abhishek\" << endl;\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n    solve();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:38:07.178761+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Refer to the Game DP video by Vivek: https://www.youtube.com/watch?v=0RMrTojwPxs"
      },
      "id": 1079,
      "input_format": "The first line contains $T$ - the number of test cases.\nThe next $T$ lines contain an integer $x$, - the number of chips on the table.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, Predict the winner of the chip game. Output \"Vivek\" if Vivek wins; else output \"Abhishek\", on a new line.",
      "samples": [
        {
          "input": "5\n0 \n2\n12783\n1001\n33\n",
          "output": "Abhishek\nVivek\nAbhishek\nVivek\nAbhishek\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Subtraction Game",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given three strings X, Y, and Z. You need to determine if string Z is an interleaving of X and Y. String Z is said to be interleaving X and Y if all the characters of X and Y are present in Z and the order of characters in the individual strings is preserved.\nSee the sample explanation for more details.",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 1000 (length of X)\n1 &lt;= m &lt;= 1000 (length of Y)\nLength of Z = n + m</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[1001][1001];\nstring x, y, z;\nint n, m;\n\nint solve(int i, int j) {\n\tif (dp[i][j] != -1)\n\t\treturn dp[i][j];\n\tif (i == n && j == m)\n\t\treturn dp[i][j] = 1;\n\tif (i == n) {\n\t\tint ans;\n\t\tif (y[j] == z[i + j])\n\t\t\tans = solve(i, j + 1);\n\t\telse\n\t\t\tans = 0;\n\t\treturn dp[i][j] = ans;\n\t}\n\tif (j == m) {\n\t\tint ans;\n\t\tif (x[i] == z[i + j])\n\t\t\tans = solve(i + 1, j);\n\t\telse\n\t\t\tans = 0;\n\t\treturn dp[i][j] = ans;\n\t}\n\tint ans = 0;\n\tif (x[i] == z[i + j])\n\t\tans = solve(i + 1, j);\n\tif (y[j] == z[i + j])\n\t\tans |= solve(i, j + 1);\n\treturn dp[i][j] = ans;\n}\n\nint main() {\n\tcin >> x >> y >> z;\n\tn = x.length();\n\tm = y.length();\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++)\n\t\t\tdp[i][j] = -1;\n\t}\n\tint ans = solve(0, 0);\n\tif (ans)\n\t\tcout << \"Yes\\n\";\n\telse\n\t\tcout << \"No\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:19:01.795069+00:00"
      },
      "hints": {
        "hint1": "Greedy will not work here as there can be many cases. Can we use Dynamic Programming?",
        "hint2": "We will try to reduce the problem into subproblems.",
        "solution_approach": "Let $dp[i][j]$ represent whether the first $i$ characters of $X$ and $j$ characters of $Y$ have been found in $Z$.\n\n- If the remaining part of $Z$ interleaves the remaining part of $X$ and $Y$, then $dp[i][j] = 1$.  \n- Otherwise, $dp[i][j] = 0$.\n\nSo, the answer to the problem is $dp[0][0]$.\n\nWe use **memoization** to solve the problem.  \nThe current character in $Z$ will always be $i + j$, so we do not need to maintain another state for that.\n\n### Base Cases:\n1. $i == n$ and $j == m$:  \n   Both strings $X$ and $Y$ have been found, so we return $1$.\n   \n2. $i == n$ and $j \\neq m$:  \n   String $X$ has been used up. So the next character in $Z$ must be equal to $Y[j]$.  \n   - If it is equal, we go to $dp[n][j+1]$.  \n   - If it is not equal, we return $0$.\n\n3. $i \\neq n$ and $j == m$:  \n   String $Y$ has been used up. So the next character in $Z$ must be equal to $X[i]$.  \n   - If it is equal, we go to $dp[i+1][m]$.  \n   - If it is not equal, we return $0$.\n\n### Transitions:\n1. If $X[i] == Z[i+j]$, we use the $i$-th index of $X$ and go to $dp[i+1][j]$.  \n2. If $Y[j] == Z[i+j]$, we use the $j$-th index of $Y$ and go to $dp[i][j+1]$.\n\nIf in any case we get $1$, then $dp[i][j] = 1$.  \nOtherwise, $dp[i][j] = 0$.\n\nSo, if the string $Z$ is an interleaving of $X$ and $Y$, $dp[0][0] = 1$.\n\n### Time Complexity:\nThe overall time complexity is $O(n \\cdot m)$.\n"
      },
      "id": 602,
      "input_format": "The first line of input contains the string X.\nThe second line of input contains the string Y.\nThe third line of input contains the string Z.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "1. The order of characters is not maintained.\n\n2. **DA**AC**S**A  \n   The characters in bold are from string $Y$, and the others are from string $X$.  \n   The order is maintained, so $Z$ is an interleaving of $X$ and $Y$.",
      "output_format": "Print ‘Yes’ is the string Z is an interleaving of X and Y, and ‘No’ otherwise.",
      "samples": [
        {
          "input": "A\nAB\nBAA",
          "output": "No"
        },
        {
          "input": "ACA\nDAS\nDAACSA",
          "output": "Yes"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Interleaved Strings",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a binary tree, print boundary nodes of the binary tree <strong>Anti-Clockwise</strong> starting from the root. The boundary includes left boundary, leaves, and right boundary in order without duplicate nodes. (The values of the nodes may still be duplicates.)</p><p>The <strong>left boundary</strong> is defined as the path from the root to the <strong>left-most</strong> node. The <strong>right boundary</strong> is defined as the path from the root to the <strong>right-most</strong> node. If the root doesn’t have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not apply to any subtrees.</p><p>The <strong>left-most</strong> node is defined as a <strong>leaf</strong> node you could reach when you always firstly travel to the left subtree if it exists. If not, travel to the right subtree. Repeat until you reach a leaf node.</p><p>The <strong>right-most</strong> node is also defined in the same way with left and right exchanged.</p>",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$\nSum of $N$ across all test cases $\\leq 10^7$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nbool isLeaf(Node * root) {\n  return !root -> left && !root -> right;\n}\n\nvoid addLeftBoundary(Node * root, vector < int > & res) {\n  Node * cur = root -> left;\n  while (cur) {\n    if (!isLeaf(cur)) res.push_back(cur ->val);\n    if (cur -> left) cur = cur -> left;\n    else cur = cur -> right;\n  }\n}\nvoid addRightBoundary(Node * root, vector < int > & res) {\n  Node * cur = root -> right;\n  vector < int > tmp;\n  while (cur) {\n    if (!isLeaf(cur)) tmp.push_back(cur ->val);\n    if (cur -> right) cur = cur -> right;\n    else cur = cur -> left;\n  }\n  for (int i = tmp.size() - 1; i >= 0; --i) {\n    res.push_back(tmp[i]);\n  }\n}\n\nvoid addLeaves(Node * root, vector < int > & res) {\n  if (isLeaf(root)) {\n    res.push_back(root -> val);\n    return;\n  }\n  if (root -> left) addLeaves(root -> left, res);\n  if (root -> right) addLeaves(root -> right, res);\n}\nvoid printBoundary(struct Node* root){\n    vector < int > res;\n    if (!root) return;\n    if (!isLeaf(root)) res.push_back(root ->val);\n    addLeftBoundary(root, res);\n    // add leaf nodes\n    addLeaves(root, res);\n    addRightBoundary(root, res);\n    for(int i=0;i<res.size();i++) cout<<res[i]<<\" \";\n    cout<<endl;\n}\n\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        printBoundary(tree);\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:37:03.895379+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 668,
      "input_format": "The first line contains an integer $T$, the number of test cases.\nThe first line of each test case contains an integer $N$ - the length of the array representing the serialized representation of a tree.\nThe next line contains $N$ space-separated integers. \nThe input is given as a serialized representation of a tree.\n\nThe following function parses the input:\n**Node* getBinaryTree(vector<int> &num, int*ind)**",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the boundary traversal of the tree in a new line.</p>",
      "samples": [
        {
          "input": "9\n9\n8249 -1 609 -1 5681 8332 -1 -1 -1 \n11\n223 4160 6557 -1 -1 4723 -1 -1 992 -1 -1 \n7\n8124 9834 -1 -1 4119 -1 -1 \n11\n7738 -1 5199 -1 7433 -1 1304 -1 3265 -1 -1 \n7\n581 9893 2846 -1 -1 -1 -1 \n11\n1496 2073 -1 5120 2761 -1 3452 -1 -1 -1 -1 \n11\n1754 2272 2699 -1 -1 3912 -1 -1 1114 -1 -1 \n1\n-1 \n7\n370 -1 1215 -1 7021 -1 -1 ",
          "output": "8249 8332 5681 609 \n223 4160 6557 4723 992 \n8124 9834 4119 \n7738 3265 1304 7433 5199 \n581 9893 2846 \n1496 2073 5120 2761 3452 \n1754 2272 2699 3912 1114 \n370 7021 1215 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n</fix>\n\n\nvoid printBoundary(struct Node* root)\n{\n    // Complete the solution.\n}\n\n\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        printBoundary(tree);\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Boundary Traversal",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given N elements, in an array A. You are also given 3 constants X, Y, and Z. You can take any 2 consecutive elements a and b and merge them. On merging you get a single element with value (aX+bY+Z)%50 and this process costs you a*b. After merging you will place this element in place of those 2 elements.<br>&nbsp;</p><p>If the sequence is [A1, A2, A3, A4] and you merge A2 and A3, you incur a cost of A2*A3 and the array becomes [A1, (A2*X+A3*Y+Z)%50, A4].<br>&nbsp;</p><p>Find the Minimum cost to merge all the elements into a single element.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint n,x,y,z;\nint arr[51];\nbool done[51][51];\nint memo[51][51][51];\n\nint dp(int l,int r,int xx){\n    if(l==r){\n        if(arr[l]==xx)return 0;\n        else return 1e9;\n    }\n    if(done[l][r]){\n        return memo[l][r][xx];\n    }\n\n    for(int i=0;i<50;i++)memo[l][r][i]=1e9;    \n\n    for(int mid=l;mid<r;mid++){\n        for(int fs=0;fs<50;fs++){\n            for(int ls=0;ls<50;ls++){\n                memo[l][r][(fs*x+ls*y+z)%50] = min(memo[l][r][(fs*x+ls*y+z)%50], dp(l,mid,fs)+ dp(mid+1,r,ls) + fs*ls);\n            }\n        }\n    }\n    done[l][r]=1;\n    return memo[l][r][xx];\n}\n\nvoid solve(){\n    memset(memo,-1,sizeof(memo));\n    cin>>n>>x>>y>>z;\n    for(int i=0;i<n;i++){\n        cin>>arr[i];\n    }\n    int ans = 1e9;\n    for(int i=0;i<50;i++){\n        ans=min(ans,dp(0,n-1,i));\n    }\n    cout<<ans<<endl;\n}   \n\nsigned main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //int _t;cin>>_t;while(_t--)\n    solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:13:34.548850+00:00"
      },
      "hints": {
        "hint1": "<p>The answer is going to change as the elements are capped by Modulo. How do you design an efficient DP that takes care of all possible ordering? Think Backwards from 1 element.</p>",
        "hint2": "<p>What if we keep DP(l,r,x) as the cost to merge the segment into one element with value x, would that help?&nbsp;</p>",
        "solution_approach": "<p>So we can design a DP with the states<br>DP(l,r,x) = minimum cost to merge the segment into one element of value x. if x is not possible, then this store +INF cost.</p><p><br>Now range (l,r) will form one element from 2 elements in the final step.<br>So let's say the (l, mid) and (mid+1,r) range equivalents merge and produce the final element.</p><p><br>So DP(l,r,(A*X+B*Y+C)%50) = min(DP(l,mid,A) + DP(mid+1,r,B) + A*B ) for all mid,A,B in range [l,r).</p><p>Now if for every l,r,z we iterate on all mid and A, B … it turns out to be O(N^6) solution.</p><p>This can be optimized to O(N^5) using the following logic.</p><p>We can calculate the DP(l,r,z) for all values of z altogether. So keep a done for (l,r) pair.</p><p>For a certain range (L,R) → We iterate on mid, and them lets say the left side has value A and the right side as B. So this particular portion updates at (A*X+B*Y+C)%50 and value is (DP(l,mid,A) + DP(mid+1,r,B) + A*B&nbsp;</p><p>So we are sort of keeping DP(L,R) only and this basically returns an array for all values of merging what is the optimal value.</p><p>This makes the code given below O(N^5).</p>"
      },
      "id": 162,
      "input_format": "<p>The first line contains 4 integers, N, X, Y, Z. 1 &lt;= N &lt;= 50, 0&lt;= X,Y,Z &lt; 50.</p><p>The Second line contains N space-separated integers, the Ai for the Array. &nbsp;0 &lt;= Ai &lt; 50</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Output a single integer, the Minimum cost to Merge all the elements.</p>",
      "samples": [
        {
          "input": "3 1 2 3\n1 2 4",
          "output": "21"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Merge Elements 2",
      "video_editorial_id": 8156
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given an array A of N integers and an integer K. Find the number of pairs (i, j) such that i &lt; j and abs(A<sub>i</sub> - A<sub>j</sub>) = K</p>",
      "complete_approach": "",
      "constraints": "1. $1 \\leq T \\leq 10^5$\n2. $1 \\leq N \\leq 10^5$\n3. $1 \\leq A_i \\leq 10^9$\n4. $1 \\leq K \\leq 10^9$\n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^5$.\n\n**Notice:** $K \\neq 0$. Can you handle the case when $K = 0$?",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\n\nsigned main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        int a[n];\n        map<int, int> m;\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            m[a[i]]++;\n        }\n   \t\tlong long ans = 0;\n        for (int i = 0; i < n; ++i) {\n            m[a[i]]--;\n            ans += m[a[i]-k];\n            ans += m[a[i]+k];\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:16:45.644410+00:00"
      },
      "hints": {
        "hint1": "Store all the integers in a map.",
        "hint2": "",
        "solution_approach": "- As you iterate through the array, check for every possible absolute difference as:  \n  $K = |A_i - A_j|$\n\n- There can be two cases:  \n  1. $A_j = A_i - K$  \n  2. $A_j = A_i + K$\n\n- **Time Complexity per test case:** $O(N \\log N)$\n\n**Note:** This works when $K \\neq 0$.\n"
      },
      "id": 379,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains two space-separated integers N K - the length of the array and the required absolute difference.\n\nThe second line of each test case contains N space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, following pairs have absolute difference 2: [1, 3], [2, 4], [3, 5]\n\nFor the second test case, following pairs have absolute difference 1: [3, 2], [1, 2]\n\nFor the third test case, no pair has absolute difference 10.",
      "output_format": "<p>For each test case, print the number of pairs (i, j) such that i &lt; j and abs(A<sub>i</sub> - A<sub>j</sub>) = K</p>",
      "samples": [
        {
          "input": "3\n5 2\n1 2 3 4 5\n4 1\n3 1 2 6\n3 10\n1 3 2\n",
          "output": "3\n2\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Common Absolute Difference",
      "video_editorial_id": 10650
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given an integer array $nums$, find a contiguous non-empty subarray within the array that has the largest product and return the product.\n\nThe test cases are generated so that the answer will fit in a $64$-bit integer.\n\nA subarray is a contiguous subsequence of the array.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$\n$1 \\leq n \\leq 10^5$\n$-10 \\leq nums[i] \\leq 10$\nThe test cases are generated so that the answer will fit in a $64$-bit integer.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nll maxProduct(vector<ll>& nums) {\n    ll n = nums.size(), ans = LLONG_MIN, mx = 1, mn = 1;\n    for (int i = 0; i < n; i++) {\n        ll t = mn;\n        mn = min({nums[i], mn*nums[i], mx*nums[i]});\n        mx = max({nums[i], mx*nums[i], t*nums[i]});\n        ans = max(ans, mx);\n    }\n    return ans;\n}\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    for (int i = 0; i < n; i++)cin >> a[i];\n    cout << maxProduct(a) << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:36:02.648733+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "**What if the array has just positive numbers including zero ?**\nA solution of this will maintain $maxProd[i]$ where $maxProd[i]$ is the maximum subarray product ending at $i$. Then $maxProd[i+1] = max(maxProd[i] * nums[i+1], nums[i+1])$.\n\n**Now how do we change the solution when we allow negative numbers?**\nImagine that we have both $maxProd[i]$ and $minProd[i]$ i.e. max prod ending at $i$ and min prod ending at $i$. Now if we have a negative number at $nums[i+1]$ and if $minProd[i]$ is negative, then the product of the two will be positive and can potentially be largest product. Key point is to maintain both maxProd and minProd such that at iteration $i$, they refer to the max and min prod ending at index $i -1$.\n\nYou have three choices to make at any position in array.\n\n1. You can get maximum product by multiplying the current element with maximum product calculated so far. (might work when current element is positive).\n2. You can get maximum product by multiplying the current element withminimum product calculated so far. (might work when current element is negative).\n3. Current element might be a starting position for maximum product subarray.\n\n**Time Complexity** : $O(N)$ with $O(1)$ space."
      },
      "id": 953,
      "input_format": "First-line contains $T$ - the number of test cases.\nThe first line of each test case contains $n$ - the size of the array.\nThe second line of each test case contains $n$ elements of the array $nums$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the maximum subarray product on a new line.",
      "samples": [
        {
          "input": "3\n4\n2 3 -2 4\n3\n-2 0 -1\n1\n-10\n",
          "output": "6\n0\n-10\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Maximum Product Subarray",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers and <i>Q</i> queries. Initially, all the elements of the array have value 0.</p><p>In each query 4 integers <i>A</i>, <i>D</i>, <i>L</i>, <i>R</i> is given, which means perform AP addition</p><p><i>Arr[L]+=A</i></p><p><i>Arr[L+1]+=A+D</i></p><p><i>Arr[L+2]+=A+2*D</i></p><p><i>Arr[L+3]+=A+3*D</i></p><p>.</p><p>.</p><p>.</p><p>.</p><p><i>Arr[R]+=A+(R-L)*D.</i></p><p>After performing all the operations. Print the final array % 10^9+7.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n\nconst ll M = 1e9+7;\nconst ll N = 1e6+1;\nll arr[N], arr2[N];\nll pf[N], pf2[N];\n\nll mul(ll a, ll b)\n{\n    ll ans = (1LL*a*b) % M;\n    if(ans<0){\n        ans+=M;\n    }\n    return ans;\n}\nvoid solve()\n{\n    ll n, q;\n    cin >> n >> q;\n    ll a, d, l, r;\n    while(q--){\n        cin >> a >> d >> l >> r;\n        arr[l] += (a - mul(l, d));\n        arr[r+1] -= (a - mul(l, d));\n        arr2[l] += d;\n        arr2[r+1] -= d;\n    }\n    for(ll i=1;i<=n;i++){\n        pf[i] = pf[i-1] + arr[i];\n        pf2[i] = pf2[i-1] + arr2[i];\n    }\n    for(ll i=1;i<=n;i++){\n        cout << (((pf[i] + mul(pf2[i], i)) % M) + M) % M << \" \";\n    }\n}\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    //int t;cin >> t;while(t--)\n    solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:30:31.922805+00:00"
      },
      "hints": {
        "hint1": "Use Ap on Partial Sums. If new to this concept,\nCheck the video solution - AP on Partial Sum.",
        "hint2": "$Arr[i]=A+D\\times(i-L)$  \n$ Arr[i]=A-DL+iD$    \n\n$ Arr[i]=(A-DL)+iD$   \n$ Arr[i]=$ constant for a query $+ iD $  \n$ Arr[i]= C + iD$    \n\nThe `C` is constant across a particular query. So we can make use of partial sums for this this particular constant. Just add `C` at Arr[L] and subtract it from Arr[R+1].  \n\nFor the variable part $iD$ , we use another array arr2 and add `D` at arr2[L] and subtract it from arr2[R+1].   \nFinally we iterate through the arrays arr and arr2 and find their prefix sums as pf and pf2. To find the ans[i] we use the relation $pf[i]+i\\times pf2[i]$, we multiply with `i` for the fact that the variable part is $iD$. The D part we took care from the prefix sum pf2 but we also need to account for the multiplication with the `i` factor here.",
        "solution_approach": "So our steps for a particular query A L R, our steps are as follows;  \n$ Arr[L]+=A-LD $  \n$ Arr[R+1]-=A-LD $  \n$ Arr2[L]+=D $  \n$ Arr2[R+1]-=D $  \nDo this across all queries\nFind prefix sums pf and pf2 as follows  \n$pf[i]=pf[i-1]+arr[i]$,  \n$pf2[i]=pf2[i-1]+arr2[i]$  \nAfter all queries are executed start a loop from the beginning of the array and,  \n$ Ans[i]+=pf[i]+i\\times pf2[i] $  \n   \n\n In the given code, the mul function is used to multiply two numbers by keeping it within the modulo range.  \n\n\n\n\nThe time complexity of the given problem is $O(Q + N)$, where Q is the number of queries and N is the size of the array.\n\nThe while loop in the main function iterates Q times, and each iteration takes $O(1)$ time.   \nAfter processing all the queries, the for loop iterates $3N$ times and performs constant-time operations inside the loop. Therefore, the time complexity of the for loop is also $O(3N) \\approx O(N)$.\n\nSo the overall time complexity of the main function is $O(Q + N)$."
      },
      "id": 29,
      "input_format": "<p>The first line contains two space-separated integers <i>N</i>, <i>Q</i> where 1&lt;=<i>N</i>&lt;=10^6, 1&lt;=<i>Q</i>&lt;=10^6.</p><p>Next <i>Q</i> lines contain four space-separated integers <i>A</i>, <i>D</i>, <i>L</i>, <i>R</i> where 0&lt;=<i>A,D</i>&lt;=10^4, 1&lt;=<i>L</i>&lt;=<i>R</i>&lt;=N.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>Print the <i>N</i> space-separated integer representing the final array %10^9+7.</p>",
      "samples": [
        {
          "input": "5 5\n1 3 1 5\n2 4 2 2\n5 6 3 5\n6 9 5 5\n1 4 2 4",
          "output": "1 7 17 30 36 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "AP Addition",
      "video_editorial_id": 8129
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given the digits of a positive number N. Find the product of its digits. Since the product can be large, print it modulo 10<sup>9</sup> + 7. It is guaranteed that the number begins with a non-zero digit.</p>",
      "complete_approach": "",
      "constraints": "- $1 \\leq T \\leq 10^6$\n- $1 \\leq N \\leq 10^6$\n- $0 \\leq D \\leq 9$\n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n#define int long long\n\nconst int mod = 1e9 + 7;\n\nsigned main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n      cin >> v[i];\n    }\n    int ans = 1;\n    for (int i = 0; i < n; ++i) {\n      ans = (ans * v[i]) % mod;\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:15:21.595183+00:00"
      },
      "hints": {
        "hint1": "The problem is that there can be a maximum of $10^6$ digits given. The product of these digits can be extremely large, for example, if each digit is 2, the product of $10^6$ 2s would be $2^{10^6}$. This number is too large to be expressed as a simple decimal and would exceed the range of a long long int data type, which can store values up to $10^{18}$.",
        "hint2": "",
        "solution_approach": "To handle such large numbers, we can use the long long data type to store the product of digits, and perform the modulus operation after each multiplication to keep it within the range of long long int.\n\nThe time complexity per test case is $O(N)$."
      },
      "id": 346,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer N - the number of digits in the number. \n\nThe second line of each test case contains N space-separated integers - the digits of the number.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For the first test case, 1*5*2*3*4 = 120</p><p>For the second test case, 9*0*5*3 = 0</p><p>For the third test case, 2*2*2 = 8</p>",
      "output_format": "For each test case, print the product of digits of the number modulo 10<sup>9</sup> + 7.",
      "samples": [
        {
          "input": "3\n5\n1 5 2 3 4\n4\n9 0 5 3\n3\n2 2 2\n",
          "output": "120\n0\n8\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Product of Digits AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">There are <i>n</i> cities and <i>m</i> roads between them. Your task is to process <i>q</i> queries where you have to determine the length of the shortest route between two given cities.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n </i>≤ 500<br>1 ≤ <i>m </i>≤ <i>n</i><sup>2</sup><br>1 ≤ <i>q </i>≤ 10<sup>5</sup><br>1 ≤ <i>a</i>, <i>b </i>≤ <i>n</i><br>1 ≤ <i>c </i>≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint mod = 1e9 + 7;\n\nconst int N = 100010;\n\nsigned main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\n\tll dist[n + 1][n + 1];\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tdist[i][j] = 1e18;\n\t\t}\n\t\tdist[i][i] = 0;\n\t}\n\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tdist[a][b] = dist[b][a] = min(dist[a][b], 1LL * c);\n\t}\n\n\tfor(int k = 1; k <= n; k++) {\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= n; j++) {\n\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); \n\t\t\t}\n\t\t}\n\t}\n\n\twhile(q--) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tif(dist[a][b] == 1e18) cout << \"-1\\n\";\n\t\telse cout << dist[a][b] << \"\\n\";\n\t}\n\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:37:26.779631+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p>Use Floyd Warshall Algorithm.</p>"
      },
      "id": 208,
      "input_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">The first input line has three integers <i>n</i>, <i>m</i> and <i>q</i>: the number of cities, roads, and queries.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Then, there are <i>m</i> lines describing the roads. Each line has three integers <i>a</i>, <i>b</i> and <i>c</i>: there is a road between cities <i>a</i> and <i>b</i> whose length is <i>c</i>. All roads are two-way roads.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Finally, there are <i>q</i> lines describing the queries. Each line has two integers <i>a</i> and <i>b</i>: determine the length of the shortest route between cities <i>a</i> and <i>b</i>.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Print the length of the shortest route for each query. If there is no route, print −1 instead.</span></p>",
      "samples": [
        {
          "input": "4 3 5\n1 2 5\n1 3 9\n2 3 3\n1 2\n2 1\n1 3\n1 4\n3 2",
          "output": "5\n5\n8\n-1\n3"
        },
        {
          "input": "2 2 1\n1 2 1\n1 2 2\n1 2",
          "output": "1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Shortest Path II",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Consider lines of slope -1 passing between nodes. Given a Binary Tree, print all diagonal elements in a binary tree belonging to the same line.</p><figure class=\"image\"><img src=\"https://lh4.googleusercontent.com/6iZWvuIvzB444BxUdgF0hKu65etmccB36dTRWEt4xwuFMsFEkYjFO2-yoInaO5bZ8WbO7vZ20D86e4IsP2d3nswr8mbDJblBsS1EcS9oN2jPnIdz0xqx_bY2jAt5EwQRwtPHOc6z\"></figure><p>&nbsp;</p><p>Diagonal Level order traversal -&nbsp;</p><p>4 7</p><p>2 5 8</p><p>1 3 6</p><p>Complete the function:</p><p><i>vector&lt;vector&lt;int&gt;&gt; getDiagonalLevelorderTraversal(Node* root)</i></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "Solution Approach is missing",
          "Editorial Code data is currently empty."
        ],
        "last_updated": "2024-06-22T02:15:39.001481+00:00"
      },
      "hints": {
        "hint1": "<p>Will be discussed in the live session.</p>",
        "hint2": "<p>Will be discussed in the live session.</p>",
        "solution_approach": ""
      },
      "id": 585,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, &nbsp;the length of the array representing the serialized representation of a tree.</p><p>The next line contains N-space-separated integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>Test case 1</p><p>&nbsp; &nbsp; &nbsp; 5<br>&nbsp; &nbsp; &nbsp;/<br>&nbsp; &nbsp; 1<br>&nbsp; &nbsp; /<br>&nbsp; &nbsp;7<br>&nbsp; &nbsp;/<br>&nbsp;6<br>Last diagonal contains 6, then diagonal above it contains 7 and so on…</p><p>&nbsp; &nbsp; &nbsp;4<br>&nbsp; &nbsp; &nbsp;/. &nbsp;\\<br>&nbsp; &nbsp;10. &nbsp;2<br>&nbsp; &nbsp;/. &nbsp;\\<br>&nbsp; 9. &nbsp; 5<br>&nbsp; &nbsp; \\<br>&nbsp; &nbsp; 6</p><p>Last diagonal contains 9,6, then diagonal aboive it contains 10, 5 and diagonal above it 4 2 &nbsp; &nbsp;</p>",
      "output_format": "<p>Return the diagonal level order traversal of the tree.</p>",
      "samples": [
        {
          "input": "11\n9\n5 1 7 6 -1 -1 -1 -1 -1\n13\n4 10 9 -1 6 -1 -1 5 -1 -1 2 -1 -1\n13\n3 6 -1 -1 8 5 -1 -1 1 10 -1 -1 -1\n9\n9 -1 2 -1 7 -1 1 -1 -1\n17\n3 7 3 0 2 4 3 10 -1 -1 -1 -1 -1 -1 -1 -1 -1\n13\n7 1 0 -1 4 -1 -1 -1 7 -1 5 -1 -1\n7\n4 8 -1 -1 9 -1 -1\n7\n10 2 -1 -1 6 -1 -1\n21\n5 -1 3 -1 6 -1 5 -1 9 -1 9 -1 3 -1 7 -1 9 -1 7 -1 -1\n21\n0 9 3 6 8 1 9 4 8 3 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n3\n4 -1 -1 ",
          "output": "6 \n7 \n1 \n5 \n\n9 6 \n10 5 \n4 2 \n\n6 5 10 \n3 8 1 \n\n9 2 7 1 \n\n10 \n3 \n4 \n2 \n0 \n3 \n7 \n3 \n\n0 4 \n1 \n7 7 5 \n\n8 \n4 9 \n\n2 \n10 6 \n\n5 3 6 5 9 9 3 7 9 7 \n\n3 \n8 \n4 \n9 \n1 \n8 \n6 \n3 \n9 \n0 \n\n4 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n</fix>\nvector<vector<int>> getDiagonalLevelorderTraversal(Node* root) {\n  // Complete the function.\n}\n\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        vector<vector<int>> ans = getDiagonalLevelorderTraversal(tree);\n        for(auto u:ans){\n            for(auto v:u){\n                cout<<v<<\" \";\n            }\n            cout<<\"\\n\";\n        }\n        cout<<\"\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Diagonal Level Order Traversal",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "There are $n$ Jobs you can do. For each Job, you know its starting and ending days and the amount of money you would get as reward. You can only do one Job during a day.\n\nWhat is the maximum amount of money you can earn?",
      "complete_approach": "",
      "constraints": "$1$ $\\leq$ $n$ $\\leq$ $2\\times10^{5}$\n$1$ $\\leq$ $a_{i}$ $\\leq$ $b_{i}$ $\\leq$ $10^{9}$\n$1$ $\\leq$ $p_{i}$ $\\leq$ $10^{9}$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll int64_t\r\n#define endl '\\n'\r\n\r\nint n;\r\nvector<array<ll, 3>> v; // { b, a, p }\r\nvector<ll> dp;\r\nint binsearch(int i) {\r\n\tint l = 0, r = i - 1, ans = -1;\r\n\twhile (l <= r) {\r\n\t\tint mid = (l + r) / 2;\r\n\t\tif (v[mid][0] < v[i][1])ans = mid, l = mid + 1;\r\n\t\telse r = mid - 1;\r\n\t}\r\n\treturn ans;\r\n}\r\nvoid solve() {\r\n\tcin >> n;\r\n\tv.resize(n, array<ll, 3>());\r\n\tfor (int i = 0; i < n; i++)cin >> v[i][1] >> v[i][0] >> v[i][2];\r\n\tsort(v.begin(), v.end()); // sorting according to ending time.\r\n\tdp.resize(n);\r\n\tdp[0] = v[0][2];\r\n\tfor (int i = 1; i < n; i++) {\r\n\t\tdp[i] = dp[i - 1]; // not choosing current job ending at v[i][0].\r\n\t\tint idx = binsearch(i);\r\n\t\tif (idx != -1)dp[i] = max(dp[i], v[i][2] + dp[idx]); // choosing job ending at v[i][0].\r\n\t\telse dp[i] = max(dp[i], v[i][2]); // choosing only current Job.\r\n\t}\r\n\tcout << dp[n - 1] << endl;\r\n\tassert(dp[n-1]>=0);\r\n}\r\nint main() {\r\n\tios_base :: sync_with_stdio(0);\r\n\tcin.tie(nullptr); cout.tie(nullptr);\r\n\r\n#ifdef Mastermind_\r\n\tfreopen(\"input.txt\", \"r\", stdin); \\\r\n\tfreopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n\tint t = 1;\r\n\t// int i = 1;\r\n\t// cin >> t;\r\n\twhile (t--) {\r\n\t\t// cout << \"Case #\" << i << \": \";\r\n\t\tsolve();\r\n\t\t// i++;\r\n\t}\r\n\treturn 0;\r\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:44:32.739323+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "- Let's create a jobs array that zips $startTime, endTime, profit$ together.\n- Let's sort our jobs in increasing order of $endTime$.\n- Let $dp[i]$ denote the maximum profit-taking jobs in $jobs[0...i]$ such that there is no overlapping time range.\n- For the current $jobs[i]$, we have 2 choices -:\n    - Don't pick $i^{th}$ job: $dp(i-1)$.\n    - Pick $i^{th}$ job: We earn $profit[i]$ and the next job must have the $endTime < arr[i].startTime$ to avoid time overlapping.\n      So we have to find $j$ from $[0, i-1]$ so that $arr[j].endTime < arr[i].startTime$.\n    - Since our jobs is already sorted in increasing order by $endTime$. So we can binary search to find the job next $j$, so that $arr[j].endTime < arr[i].startTime$.\n    - Then we have choice $dp(j) + profit[i]$.\n- Choose the choice which leads to maximum profits between the 2 above choices.\n- Finally, $dp(n-1)$ is our result.\n\n#####Complexity\n\nTime: $O(NlogN)$, where $N$ is the number of jobs.\nSpace: $O(N)$"
      },
      "id": 906,
      "input_format": "The first input line contains an integer $n$: the number of Jobs.\n\nAfter this, there are $n$ lines. Each such line has three integers $a_{i}$, $b_{i}$, and $p_{i}$: the starting day, the ending day, and the reward.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print one integer: the maximum amount of money you can earn.",
      "samples": [
        {
          "input": "4\n2 4 4\n3 6 6\n6 8 2\n5 7 3\n",
          "output": "7\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Weighted Job Scheduling",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">Given a string </span><code>s</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">, determine if it can be made a palindrome by deleting at most one of its characters. (If </span><code>s[i]</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\"> is deleted, the resulting string is the concatenation of </span><code>s[0 : i - 1]</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\"> and </span><code>s[i + 1 : n - 1]</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">, where </span><i>n</i><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\"> is the size of </span><code>s</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">). If yes, print ‘Y’ else print ‘N’.</span></p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\nbool isPossible(std::string s) {\n int n = s.size();\n int i = 0, j = n - 1;\n\n bool mismatched = false;\n while (i < j) {\n   if (s[i] == s[j]) {\n     i++;\n     j--;\n     continue;\n   } else {\n     mismatched = true;\n     break;\n   }\n }\n\n if (!mismatched) {\n   return true;\n }\n\n //length of substrings (i .. j - 1 and i + 1 .. j)\n int len = j - i;\n\n bool mismatched1 = false;\n //check if substring (i .. j - 1) is a palindrome\n for (int left = 0; left < len / 2; ++left) {\n   int right = i + len - left - 1;\n   if (s[i + left] != s[right]) {\n     mismatched1 = true;\n   }\n }\n\n bool mismatched2 = false;\n //check if substring (i + 1 .. j) is a palindrome\n for (int left = 0; left < len / 2; ++left) {\n   int right = i + len - left;\n   if (s[i + left + 1] != s[right]) {\n     mismatched2 = true;\n   }\n }\n return !(mismatched1 && mismatched2);\n}\nsigned main() {\n ios_base::sync_with_stdio(false);\n cin.tie(0);\n cout.tie(0);\n int testCases;\n cin >> testCases;\n while (testCases--) {\n   string s;\n   cin >> s;\n   if (isPossible(s))\n     cout << \"Y\\n\";\n   else\n     cout << \"N\\n\";\n }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:18:33.030704+00:00"
      },
      "hints": {
        "hint1": "<p>Given a string <code>s</code>, we try to check if it can be converted into a palindrome in the following naive way -</p><p>First, we check if <code>s</code> itself is a palindrome, which can be done in O(<code>|s|</code>) time. If yes, we return <code>true</code> here. If not, we check if <code>s</code> can be made a palindrome by deleting exactly one of its characters.</p><p>For each character in <code>s</code>, we delete that character and concatenate the rest of the string. This can be done in O(<code>|s|</code>) time by constructing a new string by appending each character of <code>s</code> to an empty string but skipping the deleted character. We can check if the resulting string is a palindrome in O(<code>|s|</code>) time. If at least one of the resulting strings is a palindrome, we return <code>true</code>. If none of them are palindromes, we return <code>false</code>.</p><p>However, since we do this for each character of <code>s</code>, this approach takes O(<code>|s|<sup>2</sup></code>) time. As this is slow, we use the following more efficient solution -</p>",
        "hint2": "<p><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">We place two pointers - </span><i>i</i><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">, at the first character, and </span><i>j</i><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\"> at the last character. If </span><code>s[i] != s[j]</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">, we call it a mismatch. If there is no mismatch, we increment </span><i>i</i><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">, decrement </span><i>j</i><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">, and repeat the process. If there is a mismatch, we have two options - delete the </span><i>i</i><sup>th</sup><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\"> character (increment </span><i>i</i><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">) or delete the </span><i>j</i><sup>th</sup><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\"> character (decrement </span><i>j</i><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">). We are allowed to do this only for the first mismatch (as we are allowed to delete at most </span><code>1</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\"> character). This means that we can check both strings (the one obtained by deleting </span><code>s[i]</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\"> and the one obtained by deleting </span><code>s[j]</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">), and if either of them is a palindrome, we can conclude that </span><code>s</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\"> can be made a palindrome. The process ends when </span><code>i &gt;= j</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\">. When this happens, we conclude that </span><code>s</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\"> can be made a valid palindrome. If we find more than one mismatch before this occurs, we can conclude that </span><code>s</code><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.87);\"> cannot be made a palindrome.</span></p>",
        "solution_approach": ""
      },
      "id": 572,
      "input_format": "<p>The first line contains an integer T, the number of test cases. (1 ≤ T ≤ 10000)</p><p>The first line of each test case contains a string S, 1 ≤ |S| ≤ 10^5.</p><p>Sum of |S| across all test cases ≤ 10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print ‘Y/’N' for each test case in a new line.</p>",
      "samples": [
        {
          "input": "2\nabcfdcba\nnitix",
          "output": "Y\nN"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Palindrome",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You have to calculate the GCD of <i>N</i> numbers. Since the numbers are too large to be written as numbers, they are written as products of smaller numbers. Find their GCD.</span></p>",
      "complete_approach": "",
      "constraints": "<p>2≤ <i>N</i> ≤ 10<sup>6</sup><br>1≤ <i>M</i> ≤ 10<sup>6</sup><br>1≤ <i>A<sub>i</sub></i> ≤ 10<sup>7</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\n \nconst int mod=1e9+7;\n \nint prime[10000001];\nvoid sieve() {\n    for(int i = 1; i < 10000001; ++i) {\n        prime[i] = i;\n    }\n    for(int i = 2; i < 10000001; ++i) {\n        if(prime[i] == i) {\n            for(int j = i; j < 10000001; j += i) {\n                prime[j] = i;\n            }\n        }\n    }\n}\n \nint pw (int a, int b, int p) {\n    if(b == 0) return 1;\n    int t = pw(a, b/2, p);\n    t = (t * t) % p;\n    if(b % 2) return (a * t) % p;\n    return t;\n}\n \nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    sieve();\n    int n;\n    cin >> n;\n    map<int, int> m1;\n    for (int i = 0; i < n; ++i) {\n        int m;\n        cin >> m;\n        map<int, int> m2;\n        for (int j = 0; j < m; ++j) {\n            int x;\n            cin >> x;\n            while (x > 1) {\n                m2[prime[x]]++;\n                x /= prime[x];\n            }\n        }\n        if(i == 0) {\n            m1 = m2;\n        }\n        else {\n            for(auto it:m1) {\n                m1[it.first] = min(m1[it.first], m2[it.first]);\n            }\n        }\n    }\n    int ans = 1;\n    for(auto it : m1) {\n        ans = (ans * pw(it.first, it.second,mod)) % mod;\n    }\n    cout << ans;\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:32:07.910021+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">You can factorise <i>A<sub>1</sub>, A<sub>2</sub>, …, A<sub>M</sub></i> for each number and then calculate GCD.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">You can use Sieve of Eratosthenes to find the lowest prime factor of every number and using that lowest prime number you can find all the factors in a much-optimized way.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Precalculate the lowest prime factor of every number using the Sieve of Eratosthenes. For each prime number, take the minimum number of times it is present for each number. You can further use binary exponentiation to calculate the powers.</span></p><p><span style=\"background-color:transparent;color:#000000;\"><strong>Time Complexity:</strong> <i>O(N log (log N) + N*M*log(A<sub>i</sub>))</i></span></p>"
      },
      "id": 94,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer <i>N</i> - the number of numbers.</span><br><span style=\"background-color:transparent;color:#000000;\">Each of the next <i>N</i> lines contains an integer <i>M</i> followed by <i>M</i> space-separated integers, <i>A<sub>1</sub>, A<sub>2</sub>,..., A<sub>M</sub></i> -&nbsp; the numbers whose product is the <i>i</i>-th number.</span><br><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of <i>M</i> over all <i>N</i> numbers doesn't exceed 10<sup>6</sup>.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">The first number will be <i>A<sub>1</sub></i> = 2*3*1*2 = 12</span><br><span style=\"background-color:transparent;color:#000000;\">The second number will be <i>A<sub>2</sub></i> = 3*6*2 = 36</span><br><span style=\"background-color:transparent;color:#000000;\">The third number will be <i>A<sub>3</sub></i> = 2*4*7 = 56</span></p><p><span style=\"background-color:transparent;color:#000000;\">The GCD of these three numbers will be GCD(12, 36, 56) = 4</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the GCD on a single line. Since this number might be pretty big, output it modulo 10<sup>9</sup>+7.</span></p>",
      "samples": [
        {
          "input": "3\n4 2 3 1 2\n3 3 6 2\n3 2 4 7",
          "output": "4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "GCD of Products",
      "video_editorial_id": 8148
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a 2d-array of dimension <i>N*M</i> and <i>Q</i> queries. In each query three integers <i>x1, y1, L</i> are given, you have to find the sum of the triangle ( check the image ) %10^9+7.</p><p>Assume that the value of cell outside the grid has value 0.</p><figure class=\"image\"><img src=\"https://lh5.googleusercontent.com/ytCYRQPvCdVeJJOQ07S47tiA1hxnWyXUHLzyb7z8or3xuUJc8X8Jz-NzcImez2nkk4H0dKQaSWtAoBb4Kicj4YLVAm-w6TQWRx8-tSt0zQmxGKzmjcKWTeNIsnRIPAWddoFq4u6J\"></figure>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define endl '\\n'\nconst int mod = 1000000007;\ntypedef vector<ll> vll;\n\nll n, m;\n\nvoid print(vector<vll> vec) {\n  for (ll i = 1; i <= n; i++) {\n    for (ll j = 1; j <= m; j++) {\n      cout << vec[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nvoid solve() {\n  ll i, j, k, q;\n  cin >> n >> m >> q;\n\n  vector<vll> arr(n + 1, vll(m + 1, 0));\n  vector<vll> rect(n + 1, vll(m + 1, 0));\n  vector<vll> tri(n + 1, vll(m + 1, 0));\n\n  for (i = 1; i <= n; i++) {\n    for (j = 1; j <= m; j++) {\n      cin >> arr[i][j];\n      rect[i][j] =\n          (rect[i - 1][j] + rect[i][j - 1] - rect[i - 1][j - 1] + arr[i][j]) %\n          mod;\n      tri[i][j] = (tri[i - 1][j - 1] + rect[i][j] - rect[i][j - 1]) % mod;\n    }\n  }\n\n  while (q--) {\n    ll x, y, l;\n    cin >> x >> y >> l;\n\n    i = max(0ll, x - l);\n    j = max(0ll, y - l);\n\n    ll ans = tri[x][y] - tri[i][j] - (rect[i][y] - rect[i][j]);\n    ans = (ans % mod + mod) % mod;\n\n    cout << ans << endl;\n  }\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  // #ifndef ONLINE_JUDGE\n  // freopen(“input.txt”, “r”, stdin);\n  // freopen(“output.txt”, “w”, stdout);\n  // #endif\n\n  int t = 1;\n  // cin>>t;\n\n  while (t--) solve();\n\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:33:44.937452+00:00"
      },
      "hints": {
        "hint1": "We need to find the sum of all the values in the triangular region. We already know how to do that if the shape was of rectangles. So lets try to break this problem too into smaller rectangles and triangles.",
        "hint2": "In this approach, we are calculating the triangular summation using prefix sum techniques. Specifically, we are first calculating the rectangular prefix sum `rect`, which is the cumulative sum of the elements of the 2D array arr up to that point. Then, we are using the rectangular prefix sum to calculate the triangular prefix sum `tri`, which is the cumulative sum of the elements of the 2D array `arr` within the lower left triangle.\n\nTo calculate the triangular prefix sum `tri`, we start by initializing tri[0][0] = arr[0][0]. Then, for each subsequent row i and column j, we calculate tri[i][j] as follows\n$tri[i][j] = rect[i][j] - rect[i][j-1] + tri[i-1][j-1]$\n\nHere, $rect[i][j] - rect[i][j-1]$ gives us the sum of the elements in the rectangular submatrix from `(0, j-1)` to `(i, j)`, and $tri[i-1][j-1]$ gives us the sum of the elements in the lower left triangle of the submatrix from `(0, 0)` to `(i-1, j-1)`. We add these two sums to get the sum of the elements in the lower left triangle of the submatrix from `(0, 0)` to `(i, j)`.\n\nOnce we have calculated the triangular prefix sum tri, we can answer each query in constant time. For a query with parameters `x1`, `y1`, and `L`, we first find the indices `i` and `j` of the top left corner of the submatrix with lower left triangle of interest:\n\n$i = max(1, x1 - L)$\n$j = max(1, y1 - L)$\n\nThen, we can compute the sum of the elements within the lower left triangle of the submatrix from `(x1, y1)` to `(x1 - L , y1 - L )` as follows:  \n$ans = tri[x1][y1] - tri[i][j] - (rect[i][y1] - rect[i][y1 - L] - rect[x1 - L][j] + rect[i][j])$.  \n\nHere, tri[x1][y1] gives us the sum of the elements in the lower left triangle of the submatrix from `(0, 0)` to `(x1, y1)`, tri[i][j] gives us the sum of the elements in the lower left triangle of the submatrix from `(0, 0)` to `(i, j)`, rect[i][y1] - rect[i][y1 - L] gives us the sum of the elements in the rectangular submatrix from `(i+1, y1-L+1)` to `(i, y1)`, and rect[x1 - L][j] gives us the sum of the elements in the rectangular submatrix from `(x1-L+1, j+1)` to `(x1, j)`. We subtract the latter two sums to remove the double-counted elements in the rectangular submatrix. Finally, we subtract tri[i][j] from tri[x1][y1] to remove the elements in the lower left triangle of the submatrix from `(1, 1)` to `(i, j)`, which were subtracted twice.",
        "solution_approach": "Check the video solution - 2D Triangular Prefix Sum."
      },
      "id": 33,
      "input_format": "<p>The first line contains three space-separated integers <i>N, M, Q</i> where 1&lt;=<i>N, M</i>&lt;=10^3, 1&lt;=<i>Q</i>&lt;=10^6.</p><p>Next <i>N</i> lines contains <i>M</i> space-separated integers (-1e9&lt;=A<sub>ij</sub>&lt;=1e9).</p><p>Next <i>Q</i> lines contains three space separated integers <i>x1, y1, L</i> where 1&lt;=<i>x1</i>&lt;=<i>N</i>, 1&lt;=<i>y1</i>&lt;=<i>M</i>, 1&lt;=<i>L</i>&lt;=1000.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>For each query print the sum of the triangle.</p>",
      "samples": [
        {
          "input": "5 5 5\n-1 2 3 -4 2\n0 0 0 0 4\n1 2 4 3 5\n-1 -5 -2 3 4\n0 -3 -5 3 -6\n1 1 2\n1 2 3\n2 3 3\n4 4 4\n2 3 2",
          "output": "1000000006\n2\n5\n10\n5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Triangle Sum Query",
      "video_editorial_id": 8131
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given the value of integer <i>N</i> how many solutions does the following equation have?</p><figure class=\"image\"><img src=\"https://lh5.googleusercontent.com/8lQWEknbwrsHZdMJaCyZDfCa77-DW1rTZCOTu_e8qFHHZPpwq8S5y3u6_3OTe7pm5zpc4iROkErQuMyxM_h5QtZdfBgh_CPbebvdo1gqodqojqj0HWpd2_EwgMlnnhnBgD7SzRS_\"></figure><p>If <i>x</i> and <i>y</i> are integers there is only a finite number of solutions but if <i>x</i> and <i>y</i> are real numbers then there can be an infinite number of solutions. What if <i>x</i> and <i>y</i> are floating-point numbers with limited size, e.g. <i>x</i> and <i>y</i> are floating point numbers with d digits after the decimal points, how many different solutions will be there?</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll mod = 1e9 + 7;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    while (true)\n    {\n        ll n, d;\n        cin >> n >> d;\n\n        if (!n && !d)\n            break;\n\n        map<ll, ll> M;\n\n        for (ll i = 2; i * i <= n; i++)\n        {\n            ll cnt = 0;\n            while (n % i == 0)\n            {\n                n /= i;\n                cnt++;\n            }\n            if (cnt)\n                M[i] += 2 * cnt;\n        }\n\n        if (n > 1)\n            M[n] += 2;\n\n        M[2] += 2 * d;\n        M[5] += 2 * d;\n\n        ll ans = 1;\n        bool sqr = true;\n\n        ll mod = 1000007;\n\n        for (auto it : M)\n        {\n            ans *= (it.second + 1);\n            ans %= mod;\n            if (ans < 0)\n                ans += mod;\n            if (it.second % 2)\n                sqr = false;\n        }\n\n        ans *= 2;\n        ans %= mod;\n        if (ans < 0)\n            ans += mod;\n\n        if (sqr)\n            ans = (ans - 1 + mod) % mod;\n\n        cout << ans << \"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:48:03.387632+00:00"
      },
      "hints": {
        "hint1": "Can you frame the given equation to this format? The task will be much easier then.\n$(x-n)(y-n)=n^2$",
        "hint2": "$\\dfrac{1}{x} + \\dfrac{1}{y} = \\dfrac{1}{N}$  \n$xy-nx-ny=0$  \n$xy-nx-ny+n^2=n^2$    \n$x(y-n)-n(y-n)=n^2$ \n$(x-n)(y-n)=n^2$  \nReplace $x-n = a$, and  \n $y-n = b$  \n$a\\times b=n^2$\n\n**Note :**\nWe subtract $1$ at the end to take care of the case when $x=y=0$. Since that is not a valid option so we need to subtract $1$ from the final solution.",
        "solution_approach": "$\\dfrac{1}{x} + \\dfrac{1}{y} = \\dfrac{1}{N}$  \n$xy-nx-ny=0$  \n$xy-nx-ny+n^2=n^2$    \n$x(y-n)-n(y-n)=n^2$ \n$(x-n)(y-n)=n^2$  \nReplace $x-n = a$, and  \n $y-n = b$  \n$a\\times b=n^2$\n\n**Note :**\nWe subtract $1$ at the end to take care of the case when $x=y=0$. Since that is not a valid option so we need to subtract $1$ from the final solution."
      },
      "id": 237,
      "input_format": "<p>Input file contains at most 2000 lines of input. Each line contains two integers <i>N</i> (0 &lt; <i>N</i> ≤ 10000000000) and <i>d</i> (0 ≤ <i>d</i> ≤ 1000), here <i>d</i> means that there can be maximum <i>d</i> digits after the decimal point. Input is terminated by a line containing two zeros. This line should not be processed.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each line of input, produce one line of output which contains an integer <i>T</i>. This line contains the number of different solutions the equation has for the given value of <i>N</i> and <i>d</i>. As the value of <i>T</i> can be very large so output <i><strong>T</strong></i><strong> modulo 1000007</strong>.</p>",
      "samples": [
        {
          "input": "23 10\n10 2\n0 0",
          "output": "2645\n97"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "How Many Solutions",
      "video_editorial_id": 8172
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Through a railway station, <i>N</i> trains pass each having a particular arrival and departure time. Find the minimum number of platforms required such that no train is kept waiting. If a train arrives at time <i>x</i> and other leaves at the same time <i>x</i> then they cannot use the same platform.</span></p>",
      "complete_approach": "",
      "constraints": "<p><i>1 ≤ N ≤ 10<sup>5</sup></i><br><span style=\"background-color:transparent;color:#000000;\"><i>1 ≤ s ≤ t ≤ 10<sup>8</sup></i></span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint MinimumPlatforms(vector<pair<int, int>> &trains)\n{\n    int n = (int)trains.size();\n\n    vector<pair<int, int>> v;\n\n    for (int i = 0; i < n; i++)\n    {\n        int s = trains[i].first, t = trains[i].second;\n        v.push_back({s, 0});\n        v.push_back({t, 1});\n    }\n\n    sort(v.begin(), v.end());\n\n    int ans = 0, curr = 0;\n    for (auto i : v)\n    {\n        if (i.second)\n            curr--;\n        else\n            curr++;\n        ans = max(ans, curr);\n    }\n\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> trains;\n\n    for (int i = 0; i < n; i++)\n    {\n        int s, t;\n        cin >> s >> t;\n        trains.push_back({s, t});\n    }\n\n    cout << MinimumPlatforms(trains) << '\\n';\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:32:14.408804+00:00"
      },
      "hints": {
        "hint1": "<p>Assume arrival and departure are two different events. Sort combine of them in ascending order. Can we make use of this information?</p>",
        "hint2": "<p>If it's arrival, then one train is added to the station. And if it's departure one train is subtracted from the station. We need to find the max of all time.</p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">We store all the arrival and departure times in a single vector and sort it in ascending order. We maintain a count of the number of trains present at the station at the same time. To do this we iterate on our vector and if the current event is arrival we increment the count by 1 and if it is departure we decrement it by 1. The answer is the maximum value of the count.</span></p>"
      },
      "id": 612,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains a single integer <i>N</i> - the number of trains.</span><br><span style=\"background-color:transparent;color:#000000;\"><i>N</i> lines follow each containing two integers <i>s</i> and <i>t</i> - the arrival and departure time of each of these trains.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">At time 1110 3 trains are present simultaneously, so 3 platforms are required to accommodate all the trains in the first test case.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the minimum number of platforms required in a new line.</span></p>",
      "samples": [
        {
          "input": "6\n900 910\n940 1200\n950 1120\n1100 1130\n1500 1900\n1800 2000",
          "output": "3"
        },
        {
          "input": "3\n900 1000\n1100 1200\n1235 1240",
          "output": "1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint MinimumPlatforms(vector<pair<int, int>> &trains)\n{\n    // Complete the function\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> trains;\n\n    for (int i = 0; i < n; i++)\n    {\n        int s, t;\n        cin >> s >> t;\n        trains.push_back({s, t});\n    }\n\n    cout << MinimumPlatforms(trains) << '\\n';\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Minimum Platforms",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a tree consisting of <i>n</i> nodes. Find the center of a tree. If there exist multiple centers, print -1.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n </i>≤ 2 x 10<sup>5</sup><br>1 ≤ <i>a</i>, <i>b </i>≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 200010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nvector<int> graph[N];\n\npair<int,int> bfs(int cur, int n, vector<int> &level) {\n    level.assign(n + 1, -1);\n\n    queue<int> q;\n    level[cur] = 1;\n    q.push(cur);\n\n    int last = cur;\n\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n        last = u;\n        for(int v : graph[u]) {\n            if(level[v] == -1) {\n                level[v] = level[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n\n    return {last, level[last]};\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n; cin >> n;\n    for(int i = 1; i < n; i++) {\n        int u, v; cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    vector<int> level1, level2;\n\n    pair<int,int> it = bfs(1, n, level1);\n    it = bfs(it.first, n, level1);\n    it = bfs(it.first, n, level2);\n\n    int len = it.second;\n\n    if(len % 2 == 0) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    int ans = -2;\n\n    for(int i = 1; i <= n; i++) {\n        if(level1[i] + level2[i] - 1 == len && level1[i] == (len + 1) / 2 && level2[i] == (len + 1) / 2) {\n            assert(ans == -2);\n            ans = i;\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:28:47.555128+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "1. A tree can have at most two centers. The center of a tree is also the center of its diameter. To find the center(s) of a tree, follow these steps:\n\n2. Find the length of the diameter of the tree. The diameter is the longest path between any two nodes in the tree.\n\n3. Once you have the length of the diameter, move from the farthest node towards the center by going up a distance of $\\lfloor\\frac{\\text{diameter}}{2}\\rfloor$ nodes.\n\n4. If the length of the diameter (diameter) is even, there are two centers in the tree. These centers are located at nodes $\\lfloor\\frac{\\text{diameter}}{2}\\rfloor$ and $\\lfloor\\frac{\\text{diameter}}{2}\\rfloor - 1$ on the diameter path.\n\nBy identifying the length of the diameter and then moving towards the center, you can determine the center(s) of the tree. If the diameter length is even, there will be two centers at equal distances from both ends of the diameter."
      },
      "id": 429,
      "input_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">The first input line contains an integer <i>n</i>: the number of nodes. The nodes are numbered 1, 2, …, <i>n</i>.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Then there are <i>n </i>− 1 lines describing the edges. Each line contains two integers <i>a</i> and <i>b</i>: there is an edge between nodes <i>a</i> and <i>b</i>.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the center of a tree. If there exist multiple centers, print -1.</p>",
      "samples": [
        {
          "input": "3\n1 2\n1 3",
          "output": "1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Center of Tree",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given a graph <i>G</i> with <i>n</i> nodes and <i>m</i> edges. Each edge has an integer weight associated with. The weight of an edge may negative, positive or zero. <strong>If the graph contains a cycle with total weight &gt; 0, print -1. Otherwise, find the weight of the highest weighted path from node 1 to </strong><i><strong>n</strong></i><strong>.</strong></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ 2500 ≤ <i>n</i><br>1 ≤ 5000 ≤ <i>m</i><br>1 ≤ <i>a</i>, <i>b </i>≤ <i>n</i><br>−10<sup>9 </sup>≤ <i>x </i>≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint mod = 1e9 + 7;\n\nconst int N = 100010;\n\nstruct edge {\n\tint u, v, w;\n};\n\nsigned main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tedge E[m];\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tE[i].u = a;\n\t\tE[i].v = b;\n\t\tE[i].w = -c;\n\t}\n\n\tll dist[n + 1];\n\tfor(int i = 1; i <= n; i++) {\n\t\tdist[i] = 1e18;\n\t}\n\tdist[1] = 0;\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tint u = E[j].u;\n\t\t\tint v = E[j].v;\n\t\t\tint w = E[j].w;\n\t\t\tdist[v] = min(dist[v], dist[u] + w);\n\t\t}\n\t}\n\n\tbool neg = false;\n\tfor(int i = 0; i < m; i++) {\n\t\tint u = E[i].u;\n\t\tint v = E[i].v;\n\t\tint w = E[i].w;\n\t\tif(dist[v] > dist[u] + w) {\n\t\t\tneg = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(neg) cout << \"-1\\n\";\n\telse {\n\t\tassert(dist[n] != 1e18);\n\t\tcout << -dist[n] << \"\\n\";\n\t}\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:08.838571+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p>Construct a new graph with weights multiplies by -1. Now check for the existence of a negative cycle in this graph. If it does not exist, find the shortest distance from 1 to n. Note that since weights can be negative, use Bellman-Ford Algorithm.</p>"
      },
      "id": 209,
      "input_format": "<p>The first input line has two integers <i>n</i> and <i>m</i>: the number of nodes and edges. The nodes are numbered 1, 2, …, <i>n</i>.<br>Then, there are <i>m</i> lines describing the edges. Each line has three integers <i>a</i>, <i>b</i> and <i>x</i>: the edge starts at node <i>a</i>, ends at node <i>b</i>, and weight of the edge is <i>x</i>. All edges are unidirectional edges.<br>You can assume that it is possible to get from node 1 to node <i>n</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the answer on a new line.</p>",
      "samples": [
        {
          "input": "4 5\n1 2 3\n2 4 -1\n1 3 -2\n3 4 7\n1 4 4",
          "output": "5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Bellman-Ford Revisited",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a grid of size n*m with 0s and 1s, you need to find the area of the largest square containing only 1.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ t ≤ 10<sup>5</sup></p><p>1 ≤ n, m ≤ 10<sup>3</sup></p><p>0 ≤ aij ≤ 1</p><p>It is guaranteed that the sum of n*m over all test cases does not exceed 10<sup>7</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nint dp[1005][1005];\nbool grid[1005][1005];\nsigned main(){\n   ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n   int t;\n   cin >> t;\n   while(t--) {\n       int n, m;\n       cin >> n >> m;\n       for (int i = 0; i < n; ++i) {\n           for (int j = 0; j < m; ++j) {\n               cin >> grid[i][j];\n           }\n       }\n       for (int i = 0; i <= n; ++i) {\n           for (int j = 0; j <= m; ++j) {\n               dp[i][j] = 0;\n           }\n       }\n       int ans = 0;\n       for (int i = 1; i <= n; ++i) {\n           for (int j = 1; j <= m; ++j) {\n               if(grid[i-1][j-1]) {\n                   dp[i][j] = min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;\n               }\n               ans = max(ans, dp[i][j]);\n           }\n       }\n       cout << ans*ans << \"\\n\";\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:47:07.812993+00:00"
      },
      "hints": {
        "hint1": "If the value of the cell at (i,j) is 1, to find the answer for the largest square with bottom right corner at (i, j), you will have to extend the square in left, top and diagonal direction.",
        "hint2": "Instead of the area, store the length of the square in the dp array.",
        "solution_approach": "<p>Define dp[i][j] which denotes the length of the largest square with its bottom right corner at (i, j). This can be given as: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1. The area is equal to length<sup>2</sup>. You need to find the maximum answer for all (i,j). Use the same recurrence for finding length for all i,j.</p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(n*m)</span></p>"
      },
      "id": 494,
      "input_format": "<p>The first line of the input contains one integer t - the number of test cases. Then t test cases follow.</p><p>The first line of each test case contains two space-separated integers n, m - the size of the grid.</p><p>Each of the next n lines contains m space-separated integers, aij - the number at that cell.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print the maximum area.",
      "samples": [
        {
          "input": "3\n2 3\n0 1 1\n0 0 0\n3 3\n1 0 1\n0 1 1\n0 1 1\n2 2\n0 0\n0 0",
          "output": "1\n4\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Maximum Area of Square",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a string, count the number of distinct subsequences(including empty subsequence) in it. A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ t ≤ 10<sup>5</sup></p><p>1 ≤ n ≤ 10<sup>5</sup> where n is the length of the string.</p><p>It is guaranteed that the sum of n over all test cases does not exceed 10<sup>5</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int mod = 1e9 + 7;\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        string s;\n        cin >> s;\n        int n = s.size();\n        int dp[n+1] = {};\n        dp[0] = 1;\n        int lastIndex[26];\n        memset(lastIndex, -1, sizeof(lastIndex));\n        for (int i = 1; i <= n; ++i) {\n            dp[i] = (dp[i-1] * 2)%mod;\n            if(lastIndex[s[i-1]-'A'] != -1) {\n                dp[i] = (dp[i] - dp[lastIndex[s[i-1]-'A']-1] + mod)%mod;\n            }\n            lastIndex[s[i-1]-'A'] = i;\n        }\n        cout << dp[n] << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:17:25.877389+00:00"
      },
      "hints": {
        "hint1": "<p>When all the characters are distinct, the number of distinct subsequences would be 2<sup>n</sup> where n is the length of the string. If there is repetition, the subsequences counted multiple times have to be subtracted.</p>",
        "hint2": "<p>Define dp[i] which denotes the number of distinct subsequences ending at index i. If the current character is occurring for the first time, it may or may not be included in a subsequence, so dp[i] = dp[i-1] * 2.</p>",
        "solution_approach": "<p>If the character has already occurred, subtract the count of repeated subsequences. There would be some subsequences ending at the last occurrence of the character. The same subsequences would be counted for subsequences ending at the current occurrence of the character. Simply subtract the count of subsequences ending at last occurrence.</p><p>Time Complexity per test case: O(n)</p>"
      },
      "id": 501,
      "input_format": "The first line of the input contains one integer t - the number of test cases. Then t test cases follow.\n\nThe first and only line of each test case contains a string with uppercase alphabets.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For the first test case, the following are distinct subsequences: {}, A, AA, AAA.</p><p>For the second test, all characters are distinct so the number of distinct subsequences is 2<sup>3</sup> = 8.</p>",
      "output_format": "<p>For each test case, print the number of distinct subsequences in the string. Since the answer can be large, print the answer modulo 10<sup>9</sup> + 7.</p>",
      "samples": [
        {
          "input": "3\nAAA\nABC\nABCB",
          "output": "4\n8\n14"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Distinct Subsequences",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "For an integer array $arr$, an **inverse pair** is a pair of integers $[i, j]$ where $0 \\leq i < j < |arr|$ and $arr[i] > arr[j]$.\n\nGiven two integers $N$ and $K$, return the number of different permutations consisting of numbers from $1$ to $N$ such that there are exactly $K$ inverse pairs. Since the answer can be huge, return it modulo $10^{9} + 7$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^{6} $\n$1 \\leq N \\leq 1000 $\n$0 \\leq K \\leq 1000 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nll dp[1001][1001], mod = 1e9 + 7;\nvoid solve() {\n    for (int i = 1; i <= 1000; i++)dp[i][0] = 1; // when k==0, base case.\n    dp[2][0] = dp[2][1] = 1; // base case.\n    for (int i = 3; i <= 1000; i++) {\n        for (int j = 1; j <= 1000; j++) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j >= i)dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n        }\n    }\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        cout << dp[n][k] << endl;\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:40:56.438571+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "$dp[n][k]$ denotes the number of arrays that have $k$ inverse pairs for array composed of $1$ to $n$.\nwe can establish the recursive relationship between $dp[n][k]$ and $dp[n-1][i]$:\n\nif we put $n$ as the last number then all the $k$ inverse pair should come from the first $n-1$ numbers\nif we put $n$ as the second last number then there's $1$ inverse pair involves $n$ so the rest $k-1$ comes from the first $n-1$ numbers\n...\nif we put $n$ as the first number then there's $n-1$ inverse pairs involve $n$ so the rest $k-(n-1)$ comes from the first $n-1$ numbers\n\n$dp[n][k] = dp[n-1][k]+dp[n-1][k-1]+dp[n-1][k-2]+...+dp[n-1][k+1-n+1]+dp[n-1][k-n+1]$\n\nIt's possible that somewhere on the right-hand side the second array index becomes negative since we cannot generate negative inverse pairs we just treat them as $0$ but still leave the item there as a placeholder.\n\n$dp[n][k] = dp[n-1][k]+dp[n-1][k-1]+dp[n-1][k-2]+...+dp[n-1][k+1-n+1]+dp[n-1][k-n+1]$\n$dp[n][k+1] = dp[n-1][k+1]+dp[n-1][k]+dp[n-1][k-1]+dp[n-1][k-2]+...+dp[n-1][k+1-n+1]$\n\nso by deducting the first line from the second line, we have\n\n$dp[n][k+1] = dp[n][k]+dp[n-1][k+1]-dp[n-1][k+1-n]$\n\n**Time Complexity** : $O(N*K)$ for pre-computation, $O(1)$ per test case."
      },
      "id": 922,
      "input_format": "First-line contains $T$ - the number of test cases.\nThe first line of each test case contains two integers $N$ and $K$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For test 1, The permutation $[1,3,2]$ and $[2,1,3]$ have exactly $1$ inverse pair",
      "output_format": "For each test case, output the number of different permutations consist of numbers from $1$ to $N$ such that there is exactly $K$ inverse pairs modulo $10^{9} + 7$.",
      "samples": [
        {
          "input": "4\n3 1\n1 0\n4 4\n3 4\n",
          "output": "2\n1\n5\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Inverse Pairs Permutation",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given an integer array $arr$, output the number of longest increasing subsequences.\n\nNotice that the sequence has to be strictly increasing.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$\n$1 \\leq n \\leq 1000$\n$-10^{6} \\leq arr[i] \\leq 10^{6}$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nll MOD = 1000000007;\n\nvoid solve() { // not possible to solve this using O(nlogn) approach, had to use O(n^2) approach.\n    ll n, lis = 1;\n    cin >> n;\n    vector<ll> nums(n), dp(n + 1, 0), cnt(n + 1, 0);\n    for (int i = 0; i < n; i++)cin >> nums[i];\n    for (int i = 0; i < n; i++) {\n        cnt[i] = 1;\n        auto &ans = dp[i] = 1;\n        for (int j = 0; j < i; j++) {\n            if (nums[j] < nums[i]) {\n                if (ans < dp[j] + 1)ans = (dp[j] + 1) % MOD, cnt[i] = cnt[j];\n                else if (ans == dp[j] + 1) cnt[i] = (cnt[i] + cnt[j]) % MOD;\n            }\n        }\n        lis = max(lis, dp[i]);\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; i++)if (lis == dp[i]) ans = (ans + cnt[i]) % MOD;\n    if (ans < 0) ans += MOD;\n    cout << ans << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Editorial code is not passing the Sample cases.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:25:51.046448+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "\nFor a sequence of numbers,\nLet $cnt[k]$ is total number of longest subsequence ending with $nums[k]$;\nLet $len[k]$ is the length of longest subsequence ending with $nums[k]$;\nThen we have following equations\n\n$len[k+1] = max(len[k+1], len[i]+1)$ for all $i <= k$ and $nums[i] < nums[k+1]$;\n$cnt[k+1] = sum(cnt[i])$ for all $i <= k$ and $nums[i] < nums[k+1]$ and $len[i] = len[k+1]-1$;\nStarting case and default case: $cnt[0] = len[0] = 1$;\n\n**Time Complexity**: $O(N^{2})$\n"
      },
      "id": 919,
      "input_format": "First line contains $T$ - the number of test cases.\nFirst line of each test case contains $n$ - the length of the array $arr$.\nSecond line of each test case contains array $arr$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the number of longest increasing subsequences in a newline modulo $1000000007$.",
      "samples": [
        {
          "input": "4\n5\n1 2 2 3 6\n5\n1 3 5 4 7\n6\n1 1 1 1 1 1\n4\n3 1 1 2",
          "output": "2\n2\n6\n2\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Count LIS",
      "video_editorial_id": 10681
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You have $N$ marbles, out of which $C_1$ are red, $C_2$ are blue, and $C_3$ are green. ($C_1 + C_2 + C_3 = N$)  \nYou have to tell the number of different arrangements possible. Since the answer can be quite large, print it modulo $10^9 + 7$.\n\nAssume that marbles of the same color are indistinguishable.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$0 \\leq C_1, C_2, C_3 \\leq N \\leq 10^5$  \n\nIt is guaranteed that $C_1 + C_2 + C_3 = N$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\n \nconst int mod = 1e9+7;\nint fact[100001];\n \nint pw(int a, int b, int p) {\n    if(b == 0) return 1;\n    int t = pw(a, b/2, p);\n    t = (t * t)%p;\n    if(b % 2) return (a * t)%p;\n    return t;\n}\n \nsigned main() {\n    IOS\n    fact[0] = 1;\n    for (int i = 1; i <= 100000; ++i) {\n        fact[i] = (fact[i-1] * i)%mod;\n    }\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, c1, c2, c3;\n        cin >> n >> c1 >> c2 >> c3;\n        int ans = fact[n];\n        ans = (ans * pw(fact[c1], mod-2, mod))%mod;\n        ans = (ans * pw(fact[c2], mod-2, mod))%mod;\n        ans = (ans * pw(fact[c3], mod-2, mod))%mod;\n        cout << ans <<\"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:39:50.039065+00:00"
      },
      "hints": {
        "hint1": "Try using combinatorics to calculate the answer.",
        "hint2": "Use the formula for arrangements of N objects of which there might be groups of indistinguishable objects.",
        "solution_approach": "The following formula can be used for calculating the answer:  \n\n<i><sup>N</sup>C<sub>C1</sub> * <sup>(N-C1)</sup>C<sub>C2</sub> * <sup>(N-C1-C2)</sup>C<sub>C3</sub>&nbsp; = N! / (C<sub>1</sub>! * C<sub>2</sub>! * C<sub>3</sub>!)</i>\n\nThe factorials should be pre-calculated, and the Modular Multiplicative Inverse should be used to calculate the denominator efficiently.\n\n**Time Complexity:** $O(N + T \\cdot \\log(N))$\n\n\n\n\n"
      },
      "id": 93,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\nThe first line of each test case contains four integers N, C1, C2, C3 - the number of marbles, the numbers of red coloured marbles, the number of blue coloured marbles and the number of green coloured marbles respectively.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "In the first test case of the example, the following are the 6 different arrangements possible:\nIn the second test case of the example, only one different arrangement is possible:",
      "output_format": "",
      "samples": [
        {
          "input": "3\n3 1 1 1\n2 0 2 0\n5 4 0 1",
          "output": "6\n1\n5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Coloured Marbles",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given an array <i>A</i> of <i>n</i> elements. Your task is to process <i>q</i> queries of the following types.</p><ul><li>1 <i>i x</i> : Update the value at position <i>i</i> to <i>x</i>.</li><li>2 <i>i j</i> : Print the sum of values in the range [<i>i, j</i>].</li></ul>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i>, <i>q </i>≤ 2 x 10<sup>5</sup><br>1 ≤ <i>A<sub>i</sub>, x </i>≤ 10<sup>9</sup><br>1 ≤ <i>i </i>≤ <i>n</i><br>1 ≤ <i>i </i>≤ <i>j </i>≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 200010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nll tree[4 * N];\n\nvoid update(int node, int start, int end, int idx, int val) {\n    if(start == end) {\n        tree[node] = val;\n        return;\n    }\n    int mid = (start + end) / 2;\n    if(idx <= mid) update(2 * node, start, mid, idx, val);\n    else update(2 * node + 1, mid + 1, end, idx, val);\n    tree[node] = tree[2 * node] + tree[2 * node + 1];\n    return;\n}\n\nll query(int node, int start, int end, int l, int r) {\n    if(start > r || end < l) return 0;\n    if(start >= l && end <= r) return tree[node];\n    int mid = (start + end) / 2;\n    return query(2 * node, start, mid, l, r) + query(2 * node + 1, mid + 1, end, l, r);\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n, q;\n    cin >> n >> q;\n\n    for(int i = 0; i < n; i++) {\n        int x; cin >> x;\n        update(1, 0, n - 1, i, x);\n    }\n\n    while(q--) {\n        int t, a, b;\n        cin >> t >> a >> b;\n        if(t == 1) {\n            a--;\n            update(1, 0, n - 1, a, b);\n        }\n        else {\n            a--; b--;\n            cout << query(1, 0, n - 1, a, b) << \"\\n\";\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:34:16.364165+00:00"
      },
      "hints": {
        "hint1": "Use a segment tree to efficiently handle the queries.",
        "hint2": "",
        "solution_approach": "##### 1. Build the segment tree:\n\n- Initialize the segment tree with the base case when the start and end indices are the same, i.e., a leaf node.\n- Recursively build the left and right subtrees of each node by dividing the range in half.\n- Update each node with the sum of its children.\n\n#####2. Perform the following steps for each query:\n\n- Read the query type (1 or 2) and the corresponding indices or range.\n- If the query is of type 1 (update):\n\n    - Decrease the index by 1 to adjust for 0-based indexing.\n    - Update the value at the specified index in the segment tree.\n- If the query is of type 2 (range sum):\n\n    - Decrease the indices by 1 to adjust for 0-based indexing.\n    - Use the query function to compute the sum of values in the specified range using the segment tree.\n    - Print the computed sum.\n\n######Time Complexity:\n\nBuilding the segment tree takes $O(n)$ time.\nEach update and range sum query takes $O(\\log n)$ time.\nOverall, the time complexity of the solution is $O((n + q) \\log n)$, where $n$ is the size of the array and $q$ is the number of queries."
      },
      "id": 401,
      "input_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">The first input line has two integers <i>n</i> and <i>q</i>: the number of values and queries.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">The second line has <i>n</i> integers <i>A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub></i>: the array values.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Finally, there are <i>q</i> lines describing the queries. Each line has three integers: either \"1 <i>i x</i>\" or \"2 <i>i j</i>\".</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Print the result of each query of type 2.</span></p>",
      "samples": [
        {
          "input": "8 4\n3 2 4 5 1 1 5 3\n2 1 4\n2 5 6\n1 3 1\n2 1 4",
          "output": "14\n2\n11"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Range Queries I",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Design a queue that supports push and pop operations in the front, middle, and back.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ val ≤ 10<sup>9</sup></p><p><span style=\"background-color:transparent;color:#000000;\">At most 10<sup>5</sup> calls will be made to pushFront, pushMiddle, pushBack, popFront, popMiddle, and popBack.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nclass FrontMiddleBackQueue\n{\npublic:\n    deque<int> first, second;\n    FrontMiddleBackQueue()\n    {\n    }\n    void balance()\n    {\n        if (first.size() > second.size())\n        {\n            second.push_front(first.back());\n            first.pop_back();\n        }\n        if (second.size() > first.size() + 1)\n        {\n            first.push_back(second.front());\n            second.pop_front();\n        }\n    }\n    void pushFront(int val)\n    {\n        first.push_front(val);\n        balance();\n    }\n\n    void pushMiddle(int val)\n    {\n        if (first.size() == second.size())\n        {\n            second.push_front(val);\n        }\n        else\n        {\n            first.push_back(val);\n        }\n    }\n\n    void pushBack(int val)\n    {\n        second.push_back(val);\n        balance();\n    }\n\n    int popFront()\n    {\n        if (first.empty() && second.empty())\n        {\n            return -1;\n        }\n        int x;\n        if (first.empty())\n        {\n            x = second.front();\n            second.pop_front();\n        }\n        else\n        {\n            x = first.front();\n            first.pop_front();\n        }\n        balance();\n        return x;\n    }\n\n    int popMiddle()\n    {\n        if (first.empty() && second.empty())\n        {\n            return -1;\n        }\n        int x;\n        if (first.size() == second.size())\n        {\n            x = first.back();\n            first.pop_back();\n        }\n        else\n        {\n            x = second.front();\n            second.pop_front();\n        }\n        return x;\n    }\n\n    int popBack()\n    {\n        if (first.empty() && second.empty())\n        {\n            return -1;\n        }\n        int x = second.back();\n        second.pop_back();\n        balance();\n        return x;\n    }\n};\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int q;\n    cin >> q;\n    FrontMiddleBackQueue *obj = new FrontMiddleBackQueue();\n    for (int i = 0; i < q; i++)\n    {\n        string op;\n        cin >> op;\n        if (op == \"pushFront\")\n        {\n            int val;\n            cin >> val;\n            obj->pushFront(val);\n        }\n        else if (op == \"pushMiddle\")\n        {\n            int val;\n            cin >> val;\n            obj->pushMiddle(val);\n        }\n        else if (op == \"pushBack\")\n        {\n            int val;\n            cin >> val;\n            obj->pushBack(val);\n        }\n        else if (op == \"popFront\")\n        {\n            cout << obj->popFront() << '\\n';\n        }\n        else if (op == \"popMiddle\")\n        {\n            cout << obj->popMiddle() << '\\n';\n        }\n        else if (op == \"popBack\")\n        {\n            cout << obj->popBack() << '\\n';\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:19:32.932379+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Maintain two deques first and second for the two halves of the queue.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">The size of the first deque should be equal to or one less than the second deque so that the middle element will always be added to the end of the first deque or beginning of the second deque.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Maintain two deques first and second for the two halves of the queue. Pushing to the front of the queue will be pushing to the front of the first deque and pushing to the back of the queue is pushing to the back of the second deque. Same is for popping the front and back elements. The size of the first deque should be equal to or one less than the second deque so that the middle element will always be added to the end of the first deque or beginning of the second deque. For popping the middle element, pop the last element of the first deque if the size of the deques are the same, else pop the first element of the second deque. To maintain the size of the first deque equal to or one less than the size of the second deque, shift the last element of the first deque to the front of the second deque, or vice versa, as needed.</span></p>"
      },
      "id": 645,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">Implement the FrontMiddleBack class:</span></p><ul><li><span style=\"background-color:transparent;color:#000000;\">FrontMiddleBack() : Initializes the queue.</span></li><li><span style=\"background-color:transparent;color:#000000;\">void pushFront(int val) : Adds val to the <strong>front</strong> of the queue.</span></li><li><span style=\"background-color:transparent;color:#000000;\">void pushMiddle(int val) : Adds val to the <strong>middle</strong> of the queue.</span></li><li><span style=\"background-color:transparent;color:#000000;\">void pushBack(int val) : Adds val to the <strong>back</strong> of the queue.</span></li><li><span style=\"background-color:transparent;color:#000000;\">int popFront() : Removes the <strong>front</strong> element of the queue and returns it. If the queue is empty, return -1.</span></li><li><span style=\"background-color:transparent;color:#000000;\">int popMiddle() : Removes the <strong>middle</strong> element of the queue and returns it. If the queue is empty, return -1.</span></li><li><span style=\"background-color:transparent;color:#000000;\">int popBack() : Removes the <strong>back</strong> element of the queue and returns it. If the queue is empty, return -1.</span></li></ul><p><span style=\"background-color:transparent;color:#000000;\"><strong>Note: </strong>When there are <strong>two</strong> middle position choices, the operation is performed on the <strong>left</strong> middle position choice. For example:</span></p><ul><li><span style=\"background-color:transparent;color:#000000;\">Pushing 6 into the middle of [1, 2, 3, 4, 5] results in [1, 2, <u>6</u>, 3, 4, 5].</span></li><li><span style=\"background-color:transparent;color:#000000;\">Popping the middle from [1, 2, <u>3</u>, 4, 5, 6] returns 3 and results in [1, 2, 4, 5, 6].</span></li></ul>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>The state of the queue after the operations:<br>[1]<br>[1, 2]<br>[1, 3, 2]<br>[1, 4, 3, 2]<br>[4, 3, 2]<br>[4, 2]<br>[2]<br>[]<br>-1 -&gt; [] (The queue is empty)</p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For every <i>pop</i> function, return the popped element.</span></p>",
      "samples": [
        {
          "input": "9\npushFront 1\npushBack 2\npushMiddle 3\npushMiddle 4\npopFront\npopMiddle\npopMiddle\npopBack\npopFront",
          "output": "1\n3\n4\n2\n-1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nclass FrontMiddleBackQueue\n{\npublic:\n    FrontMiddleBackQueue()\n    {\n    }\n    \n    void pushFront(int val)\n    {\n        \n    }\n\n    void pushMiddle(int val)\n    {\n        \n    }\n\n    void pushBack(int val)\n    {\n        \n    }\n\n    int popFront()\n    {\n        \n    }\n\n    int popMiddle()\n    {\n        \n    }\n\n    int popBack()\n    {\n        \n    }\n};\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int q;\n    cin >> q;\n    FrontMiddleBackQueue *obj = new FrontMiddleBackQueue();\n    for (int i = 0; i < q; i++)\n    {\n        string op;\n        cin >> op;\n        if (op == \"pushFront\")\n        {\n            int val;\n            cin >> val;\n            obj->pushFront(val);\n        }\n        else if (op == \"pushMiddle\")\n        {\n            int val;\n            cin >> val;\n            obj->pushMiddle(val);\n        }\n        else if (op == \"pushBack\")\n        {\n            int val;\n            cin >> val;\n            obj->pushBack(val);\n        }\n        else if (op == \"popFront\")\n        {\n            cout << obj->popFront() << '\\n';\n        }\n        else if (op == \"popMiddle\")\n        {\n            cout << obj->popMiddle() << '\\n';\n        }\n        else if (op == \"popBack\")\n        {\n            cout << obj->popBack() << '\\n';\n        }\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "FMBQUEUE",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array of **n** integers. You need to print the lexicographically next greater permutation of the numbers. If no greater permutation exists, print the lexicographically smallest permutation of the numbers.\n\n*The rearrangement of the numbers must be in place with constant extra memory.*  \n*Do not use built-in functions.*",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 100000\n1 &lt;= v[i] &lt;= 100000</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(vector<int> &v)\n{\n\tint n = (int)v.size();\n\tint i = n - 2;\n\twhile (i >= 0 && v[i + 1] <= v[i])\n\t\ti--;\n\tif (i >= 0) {\n\t\tint j = n - 1;\n\t\twhile (j >= 0 && v[j] <= v[i])\n\t\t\tj--;\n\t\tswap(v[i], v[j]);\n\t}\n\treverse(v.begin() + i + 1, v.end());\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector <int> v(n);\n\tfor (auto &i : v)\n\t\tcin >> i;\n\n\tsolve(v);\n\n\tfor (auto i : v)\n\t\tcout << i << \" \";\n\tcout << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:18:46.695709+00:00"
      },
      "hints": {
        "hint1": "We need to find the rightmost position where we can increase the permutation.",
        "hint2": "",
        "solution_approach": "If the array is sorted in descending order, no next greater permutation is possible so we just reverse the array.\nWe need to find the first pair of two successive numbers a[i] and a[i−1], from the right, which satisfies a[i−1] < a[i]. Now, no rearrangements to the right of a[i−1] can create a larger permutation since that subarray consists of numbers in descending order. Thus, we need to rearrange the numbers to the right of a[i−1] including itself.\nWe want to create the permutation just larger than the current one. Therefore, we need to replace the number a[i−1] with the number which is just larger than itself among the numbers lying to its right section, say a[j]. We swap the numbers a[i−1] and a[j].\nWe now have the correct number at index i−1. But still, the current permutation isn't the permutation that we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of a[i−1]. Therefore, we need to place those numbers in ascending order to get their smallest permutation.\nBut, recall that while scanning the numbers from the right, we simply kept decrementing the index until we found the pair a[i] and a[i−1] where a[i-1] < a[i]. Thus, all numbers to the right of a[i−1] were already sorted in descending order. Furthermore, swapping a[i−1] and a[j] didn't change that order. Therefore, we simply need to reverse the numbers following a[i−1] to get the next smallest lexicographic permutation."
      },
      "id": 593,
      "input_format": "The first line of input contains a single integer **n**.\nThe next line contains **n** integers representing the input array.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "1. The next permutation after 3 1 2 is 3 2 1.\n2. Since 4 3 2 1 is the lexicographically greatest permutation, we print the array in ascending order(lexicographically smallest).",
      "output_format": "Print a single line containing the output array.",
      "samples": [
        {
          "input": "3\n3 1 2",
          "output": "3 2 1"
        },
        {
          "input": "4\n4 3 2 1",
          "output": "1 2 3 4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nvoid solve(vector<int> &v)\n{\n\t// Complete the function\n}\n\n<fix>\nint main() {\n\tint n;\n\tcin >> n;\n\tvector <int> v(n);\n\tfor (auto &i : v)\n\t\tcin >> i;\n\n\tsolve(v);\n\n\tfor (auto i : v)\n\t\tcout << i << \" \";\n\tcout << \"\\n\";\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Next Permutation",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a string S, find the longest string T such that:<br>→ T is the prefix of S.<br>→ T is the suffix of S.<br>→ T is present in the middle of S, such that T is not a prefix and suffix.<br><br>Suppose S = “aaaa”, then T = “aa”.<br>aa is a prefix, S[0..1].<br>aa is a suffix S[2..3].<br>aa is present in the middle and it is not a prefix or suffix, S[1..2].</p><p>If no T exists then print -1.</p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint pi[100005];\n\nvoid prefix(string s)\n{\n    int n = s.size();\n    pi[0] = 0;\n    for (int i = 1; i < n; ++i)\n    {\n        int j = pi[i - 1];\n        while (j > 0 && s[i] != s[j])\n        {\n            j = pi[j - 1];\n        }\n        if (s[i] == s[j])\n        {\n            j++;\n        }\n        pi[i] = j;\n    }\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        prefix(s);\n        if (pi[n - 1] == 0)\n        {\n            cout << \"-1\\n\";\n            continue;\n        }\n        bool f = 0;\n        for (int i = n - 2; i >= 1; --i)\n        {\n            if (pi[i] == pi[n - 1])\n            {\n                cout << s.substr(0, pi[n - 1]) << \"\\n\";\n                f = 1;\n                break;\n            }\n        }\n        if (f)\n            continue;\n        if (pi[pi[n - 1] - 1] == 0)\n        {\n            cout << \"-1\\n\";\n        }\n        else\n        {\n            cout << s.substr(0, pi[pi[n - 1] - 1]) << \"\\n\";\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:37.209966+00:00"
      },
      "hints": {
        "hint1": "Use the KMP algorithm for finding prefix function for the given string.",
        "hint2": "Lets say, the prefix function for substring with length i is p[i]. Using 0-based indexing, if p[n-1] = 0, that means no prefix is the same as the suffix of the entire string and hence the answer does not exist for this case.",
        "solution_approach": "### Case 1\nUsing 0-based indexing. If for any i < n-1, we get p[i] = p[n-1], that means the prefix and suffix of substring(0,i) is the same as the prefix and suffix of substring(0,n-1). So this will be the prefix, suffix and the substring present in the string.\n\nex : string = ababcdababefabab  \np[15]=4 (abab....abab)  \np[9] =4 (abab....abab)  \nWe can see that p[15] = p[9]  \nWhen we find p[9]=4 that means that the suffix of length 4 matches with the suffix of length 4. The suffix of length 4 lies neither in the prefix or suffix of the string and hence is the substring in the middle. Hence we found all the 3 strings.\n\n### Case 2\nIf no such case is found($\\neg\\exists i \\in [1,n]: p[i]=p[n-1]$), we can check for the substring(0, p[n-1]), whether it has a common prefix and suffix, since this would also be present as the suffix of the entire string. If it exists, that substring(0, p[n-1]) would be the answer, otherwise the answer does not exist.\n\nTime complexity per test case: O(N)"
      },
      "id": 424,
      "input_format": "<p>The first line contains an integer <i>T, ( 1 ≤ T ≤ 10000)</i> - the number of test cases.</p><p>The first line of each test case contains an integer <i>N, ( 2 ≤ N ≤ 100000).</i></p><p>The second line contains a string <i>S</i> of length <i>N</i>.</p><p><i><strong>Sum of N across all test cases ≤ 10^6.</strong></i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the string T, if no string T exists print -1.</p>",
      "samples": [
        {
          "input": "3\n9\nabababaab\n6\nffffff\n5\nabcde",
          "output": "ab\nffff\n-1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Prefix Suffix Middle",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an integer N. You have to tell whether the number is a perfect square/cube according to the given query. Do not use inbuilt sqrt() and cube() function. As sqrt(4) can be equal to 1.9999999 and int(1.999999). = 1. Due to precision issue do not use sqrt() if you are dealing with integers. </span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1 </span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 100</span></p><p><span style=\"background-color:#ffffff;color:#000000;\">1 ≤ N ≤ 10<sup>7</sup></span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <iostream>\nusing namespace std;\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t; cin >> t;\n    while (t--) {\n        int q, n; cin >> q >> n;\n        if (q == 1) {\n            bool is_perf_sq = false;\n            for (int i = 1; i * i <= n; ++i) {\n                if (i * i == n) {\n                    is_perf_sq = true;\n                }\n            }\n            if (is_perf_sq) {\n                cout << \"YES\\n\";\n            } else {\n                cout << \"NO\\n\";\n            }\n        } else {\n            bool is_perf_cube = false;\n            for (int i = 1; i * i * i <= n; ++i) {\n                if (i * i * i == n) {\n                    is_perf_cube = true;\n                }\n            }\n            if (is_perf_cube) {\n                cout << \"YES\\n\";\n            } else {\n                cout << \"NO\\n\";\n            }\n        }\n    }\n    return 0;\n}\n```\n\n\n\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t; cin >> t;\n    while (t--) {\n        int q, n; cin >> q >> n;\n        if (q == 1) {\n            int x = sqrt(n);\n            if (x * x == n) {\n                cout << \"YES\\n\";\n            } else {\n                cout << \"NO\\n\";\n            }\n        } else {\n            int x = cbrt(n);\n            if (x * x * x == n) {\n                cout << \"YES\\n\";\n            } else {\n                cout << \"NO\\n\";\n            }\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:45:05.515770+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">If x is a divisor of N, then for x to be the square root of N, it has to be equal to N/x. Either x </span><span style=\"background-color:#ffffff;color:#000000;\">≤ </span><span style=\"background-color:transparent;color:#000000;\">√N </span><span style=\"background-color:#ffffff;color:#000000;\">or N/x ≤ </span><span style=\"background-color:transparent;color:#000000;\">√N. So we iterate from 1 to √N to check if N is a perfect square. Similarly for checking if N is a perfect cube, we iterate from 1 to cube root(N).</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(√N)</span></p><p><span style=\"background-color:transparent;color:#000000;\">We can also solve this using the builtin function, sqrt() and cbrt() but you need to keep in mind that the return type is double for sqrt() and cbrt().&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(1)</span></p>"
      },
      "id": 326,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains two space-separated integers Q, N - Q=1 denotes that you have to check if N is a perfect square and Q=2 denotes that you have to check if N is a perfect cube.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, 8*8 = 64, hence it is a perfect square.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, 4*4*4 = 64, hence it is a perfect cube.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, 9 is not a perfect cube.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the fourth test case, 5 is not a perfect square.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print “YES” if the number is a perfect square/cube and “NO” if the number is not a perfect square/cube, according to the given query.</span></p>",
      "samples": [
        {
          "input": "4\n1 64\n2 64\n2 9\n1 5\n",
          "output": "YES\nYES\nNO\nNO\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Perfect Square Cube Check",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are N problems in a contest and the i<sup>th</sup> problem has a rating R<sub>i</sub>. They are posted in an order top to bottom as given in input.</p><p>Each problem requires at least 1 minute to solve. You also know that if a problem P has a higher rating than a problem just above or just below it, then P must take strictly more time to solve than that problem.&nbsp;</p><p>Find the minimum possible time required to solve all the problems.</p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "<p>T ≤ 10</p><p>1 ≤ n ≤ 10<sup>5</sup></p><p>1 ≤ R<sub>i</sub> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int t, i, n;\n  \n    cin >> t;\n    while (t--)\n    {\n        cin >> n;\n        vector<int> ratings(n+2);\n\n        for(i=1;i<=n;i++) cin>>ratings[i];\n\n        ratings[0]=ratings[n+1]=2e9;\n\n        vector<pair<int, int>> v;\n\n        for (i = 1; i <= n; i++)\n            v.push_back({ratings[i], i});\n        sort(v.begin(), v.end());\n\n        vector<int> minutes(n + 2, 0);\n\n        long long ans = 0;\n        for (auto z : v)\n        {\n            int idx = z.second;\n            int give = 1;\n            if (ratings[idx] > ratings[idx - 1])\n                give = max(give, minutes[idx - 1] + 1);\n\n            if (ratings[idx] > ratings[idx + 1])\n                give = max(give, minutes[idx + 1] + 1);\n\n            minutes[idx] = give;\n            ans += give;\n        }\n        cout<< ans<<'\\n';\n    }\n}\n```\n\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define int long long\n\nvoid solve(){\n   int n;\n   cin>>n;\n   int arr[n];\n   int a1[n];\n   int a2[n];\n   for(int i=0 ; i<n ; i++) cin>>arr[i];\n   \n   a1[0] = 1;\n   for(int i=1 ; i<n; i++){\n\n      if(arr[i] > arr[i-1]) a1[i] = a1[i-1] + 1 ;\n      else a1[i] = 1 ;\n   }\n\n   a2[n-1] = 1;\n   for(int i=n-2 ; i>-1; i--){\n     \n      if(arr[i] > arr[i+1]) a2[i] = a2[i+1] + 1 ;\n      else a2[i] = 1 ;\n   }\n\n   \n   int ans = 0;\n  \n   for(int i=0 ; i<n ; i++){\n      ans+=max(a1[i] , a2[i]);\n   }\n   cout<<ans<<\"\\n\";\n}\n\n\nsigned main(){\n   ios_base::sync_with_stdio(0);\n   cin.tie(0); cout.tie(0);\n   int t;\n   cin>>t;\n   while(t--){\n      solve();\n   }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:45:17.357635+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">If the problem above takes time x and has a rating lesser than the current problem and the problem below takes time y and has a rating greater than the current problem, then the current problem should take time max(x,y)+1.</span></p>",
        "hint2": "<p>Can we sort it and do something?</p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">You can sort all the problems according to their rating, you need to store the index as well while doing this. Then you just need to check for each problem, its rating compared to the problems above and below it. If they are lesser then the time taken for the current problem should be atleast one more than it.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N log N) [for sorting]</span></p>"
      },
      "id": 225,
      "input_format": "<p>First line of input contains T, number of test cases.</p><p>First line of each test case contains N.</p><p>Second line contains N integers, R<sub>i </sub>for i from 1 to N.</p><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>Time for Problem 1 : 2 minutes</p><p>Time for Problem 2 : 1 minutes</p><p>Time for Problem 3 : 2 minutes</p><p>This satisfies the restriction and yields minimum time which is 2+1+2=5</p>",
      "output_format": "<p>For each test case output one integer: The minimum possible time in which all problems could be solved.</p>",
      "samples": [
        {
          "input": "1\n3\n2 1 3",
          "output": "5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Fast Solving",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$. Print the **factorial** of number $N$.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 15 $\n$ 0 \\leq N \\leq 20 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// O(T) time\n// O(N_max) space\ntypedef long long ll;\n\nll fact[21];\n\nvoid precompute()\n{\n    fact[0] = 1LL;\n    for (int i = 1; i <= 20; i++)\n    {\n        fact[i] = fact[i - 1] * i;\n    }\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    precompute();\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        cout << fact[n] << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:40:49.060479+00:00"
      },
      "hints": {
        "hint1": "Factorial of a number $N$, i.e $N! = 1*2*...*N$. Also $0!=1$.",
        "hint2": "",
        "solution_approach": "We can compute the above product for each test case.The time complexity will be $O(T*N_{max})$ where $N_{max}=20$. The space complexity will be $O(1)$.\n\nWe can optimise this by simply **pre-computing** the factorial of every number from $0$ to $20$ in an array.Use the fact that $factorial[i]=factorial[i-1]*i$ for $i \\ge 1$. The time complexity hence will be $O(T)$ and space complexity $O(N_{max})$.\n\nSince $20!$ is greater than size of **int**, we use **long long int** for our computations."
      },
      "id": 1138,
      "input_format": "First line contains a number $T$ which is the number of test cases.\nNext $T$ lines will contain a number $N$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first sample, there are $3$ test cases.\nFor the first test case, $N = 5$ and $5!=1*2*3*4*5=120$.\nFor the second test case, $N = 3$ and $3!=1*2*3=6$.",
      "output_format": "For each test case print a single line contains the **factorial** of $N$.",
      "samples": [
        {
          "input": "2\n5\n3\n",
          "output": "120\n6\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.5,
      "title": "Factorial",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You have given an undirected graph with n nodes, and m edges between them. The goal is to add exactly one edge between two nodes such that the total number of connected components in the graph decreases.\nYour task is to find out the number of ways to add such edge.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i> ≤ 10<sup>5</sup><br>1 ≤ <i>m</i> ≤ 2 x 10<sup>5</sup><br>1 ≤ <i>a, b</i> ≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nconst int N = 100010;\n\nint mod = 1e9 + 7;\n\nvector<int> graph[N];\nbool visited[N];\nll temp = 0;\n\nvoid dfs(int cur)\n{\n    if (visited[cur])\n        return;\n    temp++;\n    visited[cur] = true;\n    for (int u : graph[cur])\n    {\n        dfs(u);\n    }\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    memset(visited, false, sizeof(visited));\n\n    ll sqsum = 0, sum = 0;\n\n    for (int i = 1; i <= n; i++)\n    {\n        temp = 0;\n        dfs(i);\n        sqsum += temp * temp;\n        sum += temp;\n    }\n\n    cout << (sum * sum - sqsum) / 2 << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:13:56.425852+00:00"
      },
      "hints": {
        "hint1": "When will an edge decrease the number of connected components?? Only when the edge is connecting 2 different components right?",
        "hint2": "Perform a DFS or BFS traversal to find the number of connected components in the graph. Let this number be c.\nIf there are k connected components with sizes a1, a2, ..., ak, then the number of ways to connect two different connected components is:\n\n$a1a2 + a1a3 + ... + a1ak + a2a3 + ... + a2*ak + ... + a(k-1)*ak$\n\nwhich can be simplified as:\n\n$\\dfrac{[(a1 + a2 + ... + ak)^2 - (a1^2 + a2^2 + ... + ak^2)]}{2}$",
        "solution_approach": "Perform a DFS or BFS traversal to find the number of connected components in the graph. Let this number be c.\nIf there are k connected components with sizes a1, a2, ..., ak, then the number of ways to connect two different connected components is:\n\n$a1a2 + a1a3 + ... + a1ak + a2a3 + ... + a2*ak + ... + a(k-1)*ak$\n\nwhich can be simplified as:\n\n$\\dfrac{[(a1 + a2 + ... + ak)^2 - (a1^2 + a2^2 + ... + ak^2)]}{2}$"
      },
      "id": 196,
      "input_format": "The first input line has two integers n and m: the number of nodes and edges. The nodes are numbered 1, 2, …, n.\nAfter that, there are m lines describing the edges. Each line has two integers a and b: there is an edge between those nodes.\nAn edge always connects two different nodes, and there is at most one edge between any two nodes.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "<p><strong>Explanation 1:</strong><br>There are 6 ways to add edge so that the number of connected components in the graph decreases: (1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5).</p><p><strong>Explanation 2:</strong><br>The given graph is already connected. Even if add any edge, we can't decrease the number of connected components.</p>",
      "output_format": "<p>Print the number of ways to add such edge, described in the statement.</p>",
      "samples": [
        {
          "input": "5 4\n1 2\n2 3\n1 3\n4 5",
          "output": "6"
        },
        {
          "explanation": "",
          "input": "4 3\n1 2\n2 3\n3 4",
          "output": "0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "One Edge",
      "video_editorial_id": 10670
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an array A of size N. You have to answer the following queries</span></p><ul><li><span style=\"background-color:transparent;color:#000000;\">1 x - Find the smallest Element ≥ x&nbsp;</span></li><li><span style=\"background-color:transparent;color:#000000;\">2 x - Find the smallest Element &gt; x&nbsp;</span></li><li><span style=\"background-color:transparent;color:#000000;\">3 x - Find the number of elements ≤ x</span></li><li><span style=\"background-color:transparent;color:#000000;\">4 x - Find the number of elements &lt; x</span></li></ul><p><span style=\"background-color:transparent;color:#000000;\">If the answer does not exist print -1.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ N, Q ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ A<sub>i</sub> ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ t ≤ 4</span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ x ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of Q over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>5</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n, q;\n    cin >> n >> q;\n    int a[n];\n    for (int i = 0; i < n; ++i) {\n      cin >> a[i];\n    }\n    sort(a, a + n);\n    while (q--) {\n      int t, x;\n      cin >> t >> x;\n      if (t == 1) {\n        int i = lower_bound(a, a + n, x) - a;\n        if (i == n)\n          cout << \"-1 \";\n        else\n          cout << a[i] << \" \";\n      } else if (t == 2) {\n        int i = upper_bound(a, a + n, x) - a;\n        if (i == n)\n          cout << \"-1 \";\n        else\n          cout << a[i] << \" \";\n      } else if (t == 3) {\n        auto it = upper_bound(a, a + n, x) - a;\n        cout << it << \" \";\n      } else {\n        auto it = lower_bound(a, a + n, x) - a;\n        cout << it << \" \";\n      }\n    }\n    cout << \"\\n\";\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:20:34.072310+00:00"
      },
      "hints": {
        "hint1": "Use the STL functions, lower\\_bound() and upper\\_bound()",
        "hint2": "",
        "solution_approach": "`lower_bound()`\nFor finding the smallest element $> x$, use `upper_bound()`\nFor finding  the number of elements $\\leq x$, use `upper_bound()`\nFor finding  the number of elements $< x$, use `lower_bound()`\nTime Complexity per test case: $O(Q \\log N)$ where $\\log N$ is the time taken by `lower_bound` and `upper_bound` functions"
      },
      "id": 395,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains two space-separated integers N Q - the size of the given array and the number of queries</span></p><p><span style=\"background-color:transparent;color:#000000;\">The second line of each test case contains N space-separated integers.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Each of the next Q lines contains the queries in the form of t x.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case,&nbsp;</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">The smallest element ≥ 2 is 2</span></li><li><span style=\"background-color:transparent;color:#000000;\">The smallest element &gt; 2 is 3</span></li><li><span style=\"background-color:transparent;color:#000000;\">The number of elements ≤ 4 is 5 (1, 2, 2, 3, 4)</span></li><li><span style=\"background-color:transparent;color:#000000;\">The number of elements ≤ 2 is 3 (1, 2, 2)</span></li></ol>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the answer of the required queries.</span></p>",
      "samples": [
        {
          "input": "2\n5 4\n1 2 2 3 4\n1 2\n2 2\n3 4\n3 2\n3 2\n5 5 5\n3 5\n4 5\n",
          "output": "2 3 5 3 \n3 0 \n"
        },
        {
          "input": "1\n5 4\n1 2 3 4 5\n1 5\n1 6\n3 2\n3 0",
          "output": "5 -1 2 0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "STL Searching",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a binary tree and a number S, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals the given number. Return false if no such path can be found.",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:46:59.230614+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 667,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, S &nbsp;the length of the array representing the serialized representation of a tree, the number.</p><p>The next line contains N-space-separated integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Return true/false.</p>",
      "samples": [
        {
          "input": "4\n5 10\n1 9 -1 -1 -1 \n5 61\n8 -1 10 -1 -1 \n3 2\n2 -1 -1 \n13 13\n3 5 3 8 9 -1 -1 -1 -1 -1 1 -1 -1 ",
          "output": "yes\nno\nyes\nno"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n</fix>\nbool hasPathSum(Node* node, int sum)\n{\n        //Complete the function\n}\n\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n,sum;\n        cin>>n>>sum;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        if(hasPathSum(tree,sum))\n            cout<<\"yes\\n\";\n        else\n            cout<<\"no\\n\";\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Root to leaf path sum",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given $Q$ queries and have to perform the following operations:\n\n1. **insertback x** - Add element $x$ at the end of the deque.  \n2. **eraseback** - Delete the end element of the deque, if the deque is not empty.  \n3. **insertfront x** - Add element $x$ at the front of the deque.  \n4. **erasefront** - Delete the front element of the deque, if the deque is not empty.  \n5. **printfront** - Print the element at the front of the deque, if the deque is not empty; otherwise, print $0$.  \n6. **printback** - Print the element at the back of the deque, if the deque is not empty; otherwise, print $0$.  \n7. **print x** - Print the $x$-th element of the deque (0-indexed), if it exists; otherwise, print $0$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$1 \\leq Q \\leq 10^5$  \n\n$1 \\leq X \\leq 10^6$  \n\nIt is guaranteed that the sum of $Q$ over all test cases does not exceed $10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int q;\n    cin >> q;\n    deque<int> d;\n    while (q--) {\n      string s;\n      cin >> s;\n      if (s == \"insertback\") {\n        int x;\n        cin >> x;\n        d.push_back(x);\n      } else if (s == \"eraseback\") {\n        if (!d.empty()) {\n          d.pop_back();\n        }\n      } else if (s == \"insertfront\") {\n        int x;\n        cin >> x;\n        d.push_front(x);\n      } else if (s == \"erasefront\") {\n        if (!d.empty()) {\n          d.pop_front();\n        }\n      } else if (s == \"printfront\") {\n        if (!d.empty()) {\n          cout << d.front() << \"\\n\";\n        } else {\n          cout << \"0\\n\";\n        }\n      } else if (s == \"printback\") {\n        if (!d.empty()) {\n          cout << d.back() << \"\\n\";\n        } else {\n          cout << \"0\\n\";\n        }\n      } else {\n        int x;\n        cin >> x;\n        if (x < (int)d.size()) {\n          cout << d[x] << \"\\n\";\n        } else {\n          cout << \"0\\n\";\n        }\n      }\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:32:58.346942+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Use `push_back(x)` for inserting element at end of deque\nUse `pop_back()` for deleting element at end of deque\nUse `push_front(x)` for inserting element at front of deque\nUse `pop_front()` for deleting element at front of deque\nUse `front()` for printing element at end of deque\nUse `back()` for printing element at end of deque\nUse `d[i]` for accessing the i-th element of the deque\nTime Complexity per test case: $O(1)$"
      },
      "id": 353,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\n\nThe first line of each test case contains one integer $Q$ - the number of queries.\n\nEach of the next $Q$ lines contains a query.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "1. Deque becomes [3]  \n2. Deque becomes [3, 5]  \n3. Deque becomes [2, 3, 5]  \n4. Last element of deque is 5  \n5. Element at index 1 is 3  \n6. Deque becomes [2, 3]  \n7. Deque becomes [1, 2, 3]  \n8. First element of deque is 1",
      "output_format": "<p>For each test case, print the required queries.</p>",
      "samples": [
        {
          "input": "1\n8\ninsertback 3\ninsertback 5\ninsertfront 2\nprintback\nprint 1\neraseback\ninsertfront 1\nprintfront\n",
          "output": "5\n3\n1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Deque AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given an array having $n$ elements, the cost to move from $i^{th}$ element to its adjacent element ( *if exist* ) at $i+1$ and $i-1$ is $b$, and the cost to move to other same valued index is $a$.\nFind min cost to reach every index from a given source index of the array.",
      "complete_approach": "",
      "constraints": "$1 ≤ n ≤ 2 \\times 10^{5}$\n$1 ≤ a , b ≤ 10^{9}$\n$1 ≤ arr[i] ≤ 100$\n$1 ≤ src ≤ n$",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nconst int mx = 2e5 + 10;\n\nint n, a, b;\nint arr[mx];\nvector<vector<array<int, 2>>> adj;\nmap<int, vector<int>> sadj; // same value index list.\nvector<ll> dist;\nvoid dijktra(int src) { // ~O(NlogN)\n\tdist.assign(2 * n + 10, 1e18); // now we have 2*n nodes.\n\tpriority_queue<array<ll, 2>, vector<array<ll, 2>>, greater<array<ll, 2> >> pq;\n\tpq.push({0, src});\n\tdist[src] = 0;\n\twhile (!pq.empty()) {\n\t\tauto x = pq.top();\n\t\tpq.pop();\n\t\tint i = x[1];\n\t\tif (x[0] > dist[i])continue;\n\t\tfor (auto y : adj[i]) {\n\t\t\tint j = y[0], w = y[1];\n\t\t\tif (dist[j] > dist[i] + w) {\n\t\t\t\tdist[j] = dist[i] + w;\n\t\t\t\tpq.push({dist[j], j});\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve() {\n\tcin >> n;\n\tcin >> a >> b;\n\tadj.assign(2 * n + 10, vector<array<int, 2>>());\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> arr[i];\n\t\tsadj[arr[i]].push_back(i);\n\t\tif (i != n)adj[i].push_back({i + 1, b});\n\t\tif (i != 1)adj[i].push_back({i - 1, b});\n\t}\n\tint super_node = n + 1;\n\tfor (auto x : sadj) {\n\t\tfor (auto i : x.second) {\n\t\t\tadj[super_node].push_back({i, a});\n\t\t\tadj[i].push_back({super_node, 0});\n\t\t}\n\t\tsuper_node++;\n\t}// now we have at max 2*n nodes in the graph and 4*n-2 edges.\n\tint src;\n\tcin >> src;\n\tdijktra(src);\n\tfor (int i = 1; i <= n; i++)cout << dist[i] << \" \";\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\t// cin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:31:38.856639+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "**Approach**: use the Super Node idea to reduce the number of edges.\nFor each same values nodes, generate a supernode, such that \n\n$i --0-→ SuperNode_i$  and  $SuperNode_i -- a -→ i$  \n\nfor all index $i$ having same value $arr[i]$. \nNow we have at max $2*n$ nodes in the graph and $4*n-2$ edges.\nNow apply Dijkstra's algorithm.\nSo , Time complexity of Dijktra's will be ~ $O( nlogn )$."
      },
      "id": 897,
      "input_format": "First-line contains $n$ - size of the array and costs $a$ and $b$..\nSecond line contains $n$ elements of the array.\nThe third line contains a source index $src$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "In a single line, print the min-cost to reach every index from a given source index $src$.",
      "samples": [
        {
          "input": "10 1 2                                \n1 2 1 1 2 3 2 3 2 1                                  \n1\n",
          "output": "0 2 1 1 3 5 3 5 3 1 \n"
        },
        {
          "input": "1 1 2                                \n7                                  \n1\n",
          "output": "0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Jump Game",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given N strings. You are allowed to reverse the i-th string with a cost c[i]. You have to find the minimum cost needed to sort the strings in lexicographical order.</p><p>String <i>A</i> is lexicographically smaller than string <i>B</i> if it is shorter than <i>B</i> (|<i>A</i>| &lt; |<i>B</i>|) and is its prefix, or if none of them is a prefix of the other and at the first position where they differ character in <i>A</i> is smaller than the character in <i>B</i>.</p>",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$  \n\n$1 \\leq N \\leq 10^5$  \n\n$0 \\leq C_i \\leq 10^9$  \n\n$1 \\leq |S| \\leq 10^5$  \n\nIt is guaranteed that the total length of these strings doesn't exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\n\nsigned main() {\n   IOS\n   int t;\n   cin >> t;\n   while(t--) {\n       int n;\n       cin >> n;\n       int c[n];\n       for (int i = 0; i < n; ++i) {\n           cin >> c[i];\n       }\n       string s[n];\n       string rev[n];\n       for (int i = 0; i < n; ++i) {\n           cin >> s[i];\n           rev[i] = s[i];\n           reverse(rev[i].begin(), rev[i].end());\n       }\n       int dp[n][2];\n       dp[0][0] = 0;\n       dp[0][1] = c[0];\n       for (int i = 1; i < n; ++i) {\n           dp[i][0] = dp[i][1] = 1e18;\n           if(s[i-1] <= s[i]){\n               dp[i][0] = min(dp[i][0], dp[i-1][0]);\n           }\n           if(rev[i-1] <= s[i]){\n               dp[i][0] = min(dp[i][0], dp[i-1][1]);\n           }\n           if(s[i-1] <= rev[i]){\n               dp[i][1] = min(dp[i][1], dp[i-1][0]+c[i]);\n           }\n           if(rev[i-1] <= rev[i]){\n               dp[i][1] = min(dp[i][1], dp[i-1][1]+c[i]);\n           }\n       }\n       int t = min(dp[n-1][0], dp[n-1][1]);\n       if (t == (int)1e18)\n           t = -1;\n       cout << t << \"\\n\";\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:46:01.410280+00:00"
      },
      "hints": {
        "hint1": "We make a DP array, where $DP[i][j]$ is the minimum cost that should be spent to make first $i$ strings sorted in lexicographical order. The $i^{th}$ string will be reversed if $j = 1$.\n\n$\\therefore dp[i][0]$ means that the $i^{th}$ string is not reversed.  \n$\\therefore dp[i][1]$ means that the $i^{th}$ string is  reversed",
        "hint2": "We check if the previous string and the current string should be reversed to make the strings sorted, you can make all the 4 cases.",
        "solution_approach": "The 4 cases would be as follows : \n\nCase 1 : prev string <= current string\n$dp[i][0] = min(dp[i][0], dp[i - 1][0])$\n\nCase 2 : prev string reversed <= current string\n$dp[i][0] = min(dp[i][0], dp[i - 1][1])$\n\nCase 3 : prev string <= current string reversed\n$dp[i][1] = min(dp[i][1], dp[i - 1][0] + c[i])$\n\nCase 4 : prev string reversed <= current string reversed\n$dp[i][1] = min(dp[i][1], dp[i - 1][1] + c[i])$\n\nTime Complexity per test case: O(N)"
      },
      "id": 168,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer N.\n\nThe second line of each test case contains N space-separated integers - the cost.\n\nEach of the next N lines contains a string.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "For the first test case, reverse the second string to get: [aca, daa, fba]\n\nFor the second test case, reverse the first and second strings to get: [cbp, ebc, qbf]\n\nFor the third test case, there is no way to make the strings in lexicographical order.",
      "output_format": "For each test case, print the minimum cost needed to sort the strings in lexicographical order. If it is impossible to sort the strings print -1.",
      "samples": [
        {
          "input": "3\n3\n2 6 7\naca\naad\nfba\n3\n5 1 1\npbc\ncbe\nqbf\n2\n4 5\nbaa\naaa",
          "output": "6\n6\n-1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Sort the strings",
      "video_editorial_id": 8158
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a tree consisting exactly of <span style=\"color:black!important;\">𝑛</span> vertices. Each vertex <span style=\"color:black!important;\">𝑣</span> of this tree has a value <span style=\"color:black!important;\">𝑎<sub>𝑣</sub></span> assigned to it.</p><p>Let <span style=\"color:black!important;\">𝑑𝑖𝑠𝑡(𝑥,𝑦)</span> be the distance between the vertices <span style=\"color:black!important;\">𝑥</span> and <span style=\"color:black!important;\">𝑦</span>. The distance between the vertices is the number of edges on the simple path between them.</p><p>Let's define the cost of the tree as the following value: firstly, let's fix some vertex of the tree. Let it be <span style=\"color:black!important;\">𝑣</span>. Then the cost of the tree is&nbsp;</p><figure class=\"image\"><img src=\"https://lh6.googleusercontent.com/d7cv7_H-WYjQNYDPfOaTm2hq3y1w6OGhAmEc4BfwQRc2_WR7GBBK44ok0V2SDZUy2tA9QD9QKvfy3XGI7CvFaIjilaVepq7sTPMkmw1EW6XXeNw3JMb_xnjQlpsu9CqUwxBaZqOq\"></figure><p>Your task is to calculate the <strong>maximum as well as minimum possible cost</strong> of the tree if you can choose <span style=\"color:black!important;\">𝑣</span> arbitrarily to calculate the answer for both the case.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:42:50.576676+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 451,
      "input_format": "<p>The first line contains an integer T ( 1 ≤ T ≤ 10^5) - the number of test cases.</p><p>The first line of each test case contains an integer N( 1 ≤ N≤ 10^5).</p><p>The second line of each test case contains N space-separated integers &nbsp;1 ≤ a<sub>i </sub>≤ 10^5.</p><p>The next N-1 lines contain a description of an edge → u<sub>i</sub>, v<sub>i</sub> (1 ≤ u<sub>i</sub>, v<sub>i</sub> ≤ N, u<sub>i</sub>≠v<sub>i</sub>,). Vertices u<sub>i</sub> and v<sub>i</sub> are connected by an undirected edge.</p><p>It is guaranteed that sum of all <i>N</i> over all test cases does not exceed 10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test print the maximum and minimum cost in a new line.</p>",
      "samples": [
        {
          "input": "1\n5\n1 2 3 4 5\n1 2\n1 3\n2 4\n2 5",
          "output": "32 16"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Maximum Cost Tree",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a binary tree, a target node with value $tar$ present in the binary tree, and an integer value $k$, find all the nodes that are at distance $k$ from the given $tar$ node. \n\n\n\n#### Note-:\n- No parent pointers are available.\n- All Node values are unique.\n- $tar$ value node always exists in the given tree.\n- return the *vector< int >* in sorted order by node value.\n- If no such nodes are found, then return empty vector { }.\n- Try to solve this problem in $O(N*logN)$ time and $O(H)$ space, where $H$ is the height of the binary tree. \n- Don't forget to clear any global variable in the template code, as input contains multiple test cases.",
      "complete_approach": "",
      "constraints": "$1 \\leq n \\leq 10^4$ - number of nodes.\n$0 \\leq k\\leq 20$ \n$1 \\leq$ *Node Value* $\\leq 10^4$ \n$1 \\leq tar\\leq 10^4$ \n- All Node values are unique.\n- $tar$ value node always exists in the given tree.\n- Don't forget to clear any global variable in the template code, as input contains multiple test cases.\n- Sum of $n$ across all test cases is $\\leq 10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    Node(int x): data(x), left(nullptr), right(nullptr) {};\n};\nvector<int> ans;\nint dfs(Node *v, int &tar, int k, int d) {\n    if (v == nullptr || d > k)return 0; // pruning\n    if (d == k) {\n        ans.push_back(v->data);\n        return 0;\n    }\n    if (v->data == tar) { // target node found.\n        dfs(v->left, tar, k, 1); // search for kth distance node in target subtree.\n        dfs(v->right, tar, k, 1);\n        return 1;\n    }\n    int left, right;\n    if (d == 0) { // searching for target node.\n        left = dfs(v->left, tar, k, d);\n        right = dfs(v->right, tar, k, d);\n    }\n    else { // searching for kth distance nodes.\n        left = dfs(v->left, tar, k, d + 1);\n        right = dfs(v->right, tar, k, d + 1);\n    }\n    if (left == k || right == k) {\n        ans.push_back(v->data);\n        return 0;\n    }\n    if (left > 0) {\n        dfs(v->right, tar, k, left + 1);\n        return left + 1;\n    }\n    if (right > 0) {\n        dfs(v->left, tar, k, right + 1);\n        return right + 1;\n    }\n    return 0;\n}\nvector <int> KDistanceNodes(Node* root, int k, int tar) {\n    if (k == 0)return {tar};\n    ans.clear();\n    dfs(root, tar, k, 0);\n    sort(ans.begin(), ans.end());\n    return ans;\n}\n\nNode *deserialize(string data)\n{\n    if (data.size() == 0)\n        return nullptr;\n    // cout << data << endl;\n    vector<string> dat;\n    string t;\n    for (auto c : data)\n    {\n        if (c == ',')\n        {\n            dat.push_back(t);\n            t.clear();\n        }\n        else\n            t.push_back(c);\n    }\n    dat.push_back(t);\n    int i = 0;\n    queue<Node *> q;\n    auto root = new Node(stoll(dat[0]));\n    q.push(root);\n    auto cur = root;\n    i++;\n    while (!q.empty())\n    {\n        auto x = q.front();\n        q.pop();\n        if (dat[i] != \"x\")\n        {\n            x->left = new Node(stoll(dat[i]));\n            q.push(x->left);\n        }\n        i++;\n        if (dat[i] != \"x\")\n        {\n            x->right = new Node(stoll(dat[i]));\n            q.push(x->right);\n        }\n        i++;\n    }\n    return root;\n}\nvoid solve() {\n    int n, k, tar;\n    cin >> n >> k >> tar;\n    string s;\n    cin >> s;\n    auto root = deserialize(s);\n    auto ans = KDistanceNodes(root, k, tar);\n    for (auto x : ans)cout << x << \" \";\n    cout << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:16:25.981321+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "There are two types of nodes to be considered. \n1) Nodes in the subtree rooted with the target node. In sample test 1, if the target node is 5 and k is 2, then such nodes are 7, 8, and 9. \n2) Other nodes, may be an ancestor of the target, or a node in some other subtree. For target node 5 and k is 2, then node 3 comes in this category.\n\nFinding the first type of nodes is easy to implement. Just traverse subtrees rooted with the target node and decrement $k$ in the recursive call. When the $k$ becomes 0, print the node currently being traversed.\n\nHow to find nodes of the second type? For the output nodes not lying in the subtree with the target node as the root, we must go through all ancestors. For every ancestor, we find its distance from the target node, let the distance be $d$, now we go to another subtree (if the target was found in the left subtree, then we go to the right subtree and vice versa) of the ancestor and find all nodes at $k-d$ distance from the ancestor.\n\nRefer to the Editorial's Code for more details.\n\n**Time Complexity : $O(N*logN)$**\n\n**Space Complexity: $O(H)$**"
      },
      "id": 1030,
      "input_format": "Complete the function \n<pre><code class=\"language-cpp\"> vector< int > KDistanceNodes(TreeNode* root, int k, int tar)</code></pre> \n, that takes $root$ pointer of the binary tree, $k$ and $tar$ as input parameters and return the *vector < int >* having nodes that are at $k$ distance from the $tar$ node in the sorted order by node values.\n\nFor local testing of the sample, the first line contains $T$, the number of test cases. The first line of each test case contains $n$- number of nodes, $k$ and $tar$ . The second line of each test case contains the level order traversal of the tree, where *'$x$'* denotes the *'nullptr'*.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For the given Binary Tree , $n=10$ , $k=2$ , and $tar=5$</p><figure class=\"image image_resized\" style=\"width:38.89%;\"><img src=\"https://algozenith.s3.ap-south-1.amazonaws.com/content/06-06-22/99_1f07e216-b6b3-4bd2-bc75-09f40d5bc4be.png\"></figure><p>Output will be $[ 3,7,8,9 ]$.</p>",
      "output_format": "",
      "samples": [
        {
          "input": "1\n10 2 5\n1,5,3,2,4,10,6,7,x,9,8,x,x,x,x,x,x,x,x,x,x\n",
          "output": "3 7 8 9 \n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    Node(int x): data(x), left(nullptr), right(nullptr) {};\n};\n</fix>\n\n<fix>\nvector <int> KDistanceNodes(Node* root, int k, int tar) { \n</fix>\n    // Write Code Here.\n    return {};\n}\n<fix>\n\nNode *deserialize(string data)\n{\n    if (data.size() == 0)\n        return nullptr;\n    // cout << data << endl;\n    vector<string> dat;\n    string t;\n    for (auto c : data)\n    {\n        if (c == ',')\n        {\n            dat.push_back(t);\n            t.clear();\n        }\n        else\n            t.push_back(c);\n    }\n    dat.push_back(t);\n    int i = 0;\n    queue<Node *> q;\n    auto root = new Node(stoll(dat[0]));\n    q.push(root);\n    auto cur = root;\n    i++;\n    while (!q.empty())\n    {\n        auto x = q.front();\n        q.pop();\n        if (dat[i] != \"x\")\n        {\n            x->left = new Node(stoll(dat[i]));\n            q.push(x->left);\n        }\n        i++;\n        if (dat[i] != \"x\")\n        {\n            x->right = new Node(stoll(dat[i]));\n            q.push(x->right);\n        }\n        i++;\n    }\n    return root;\n}\nvoid solve() {\n    int n, k, tar;\n    cin >> n >> k >> tar;\n    string s;\n    cin >> s;\n    auto root = deserialize(s);\n    auto ans = KDistanceNodes(root, k, tar);\n    for (auto x : ans)cout << x << \" \";\n    cout << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "K Distance Nodes",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You have a box and you want to put numbers into it.  \n\nThe capacity of the box is **n**. If the box has **n** numbers, no more numbers can be added to it.\n\nImplement the **CustomStack** class:\n\n1. **`CustomStack(int n):`**  \n   Initializes the object with $n$, which is the maximum capacity of the box.\n\n2. **`void push(int x):`**  \n   Adds $x$ to the top of the box.  \n   - If the box has already reached its capacity, do nothing.  \n   - $1 \\leq x \\leq 1000$  \n\n3. **`int pop():`**  \n   Returns the number present on top of the box.  \n   - Returns `-1` if the box is empty.\n\n4. **`void inc(int k, int val):`**  \n   Increments the bottom **k** numbers of the box by **val**.  \n   - If there are fewer than **k** numbers in the box, increment all the numbers.  \n   - $1 \\leq k \\leq 10^4$, $0 \\leq val \\leq 1000$",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 100000\n1 &lt;= q &lt;= 100000  (total number of function calls)\n1 &lt;= x &lt;= 1000\n1 &lt;= k &lt;= 105\n0 &lt;= val &lt;= 1000</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass CustomStack {\npublic:\n\tvector <int> box;\n\tvector <int> inc;\n\tint n;\n\tCustomStack(int maxSize) {\n\t\tn = maxSize;\n\t}\n\n\tvoid push(int x) {\n\t\tint siz = box.size();\n\t\tif (siz == n) // box is full\n\t\t\treturn;\n\t\tbox.push_back(x);\n\t\tinc.push_back(0);\n\t}\n\n\tint pop() {\n\t\tint siz = box.size();\n\t\tif (siz == 0) // box is empty\n\t\t\treturn -1;\n\t\telse {\n\t\t\tint z = box[siz - 1] + inc[siz - 1];\n\t\t\tif (siz > 1)\n\t\t\t\tinc[siz - 2] += inc[siz - 1];\n\t\t\tinc.pop_back();\n\t\t\tbox.pop_back();\n\t\t\treturn z;\n\t\t}\n\t}\n\n\tvoid increment(int k, int val) {\n\t\tint siz = box.size();\n\t\tk = min(k, siz);\n\t\tif (k == 0)\n\t\t\treturn;\n\t\tinc[k - 1] += val;\n\t}\n};\n\nint main()\n{\n\tios_base::sync_with_stdio(NULL);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint maxSize;\n\tcin >> maxSize;\n\n\tint q;\n\tcin >> q;\n\n\tCustomStack* customStack = new CustomStack(maxSize);\n\n\tfor (int itr = 0; itr < q; itr++) {\n\t\tstring op;\n\t\tcin >> op;\n\n\t\tif (op == \"push\") {\n\t\t\tint x;\n\t\t\tcin >> x;\n\n\t\t\tcustomStack->push(x);\n\t\t}\n\t\telse if (op == \"pop\") {\n\t\t\tcout << customStack->pop() << \"\\n\";\n\t\t}\n\t\telse if (op == \"inc\") {\n\t\t\tint k, val;\n\t\t\tcin >> k >> val;\n\t\t\tcustomStack->increment(k, val);\n\t\t}\n\t}\n\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:13:10.735598+00:00"
      },
      "hints": {
        "hint1": "The increment always occurs on some prefix of the current box.\n",
        "hint2": "Instead of incrementing all k numbers in the prefix, can we somehow store the information and prevent traversing the box every time?",
        "solution_approach": "The constraints do not allow us to simulate the process. We can maintain a vector of numbers representing the box. If the size of the vector has reached the capacity of the box we will no longer push any number into it. \nWhen we need to increment a prefix of length k, instead of adding k to all the numbers present in the prefix we can just add it to the kth number. When the kth number is popped the value added to the kth number can be passed over to the previous number. This works because we only need to print the number present on the top of the box at a time. So when a number is queried, all numbers present on top of it must already be printed and thus the values added to them would be passed over to the current number.\nTo do this we maintain another vector inc which stores the value added to the last number.\nWhen the ith number is printed the value added to it is passed over to the previous number.\n\n        inc[i-1]+=inc[i]\n\nThe complexity for each function is O(1)."
      },
      "id": 627,
      "input_format": "<p>Your CustomStack object will be instantiated and called as such:</p><pre><code class=\"language-plaintext\">CustomStack* obj = new CustomStack(maxSize);\nobj-&gt;push(x);\nint param_2 = obj-&gt;pop();\nobj-&gt;inc(k,val);</code></pre>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "1. Box will look like [5].\n2. Box will look like [5 ,9]\n3. Box will look like [5 ,9 ,8].\n4. Box will look like [5 ,9 ,8 ,7].\n5. Box will look like [5 ,9 ,8 ,7]. Since the capacity of the box is 4, 6 is not added to the box.\n6. Box will look like [5 ,9 ,8]. 7 is printed since it is at the top.\n7. Box will look like [10 ,14 ,8].\n8. Box will look like [15 ,19 ,13]. Since 6 numbers are not present, all of them are incremented.\n9. Box will look like [15 ,19]. 13 is printed since it is at the top.\n10. Box will look like [15]. 19 is printed since it is at the top.\n11. Box will look like []. 15 is printed since it is at the top.\n12. Box is empty so -1 is printed.",
      "output_format": "Implement the **CustomStack** class.",
      "samples": [
        {
          "input": "4 12\npush 5\npush 9\npush 8\npush 7\npush 6\npop\ninc 2 5\ninc 6 5\npop\npop\npop\npop",
          "output": "7\n13\n19\n15\n-1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\n\nclass CustomStack {\npublic:\n\t\n\tCustomStack(int maxSize) {\n\t\n\t}\n\n\tvoid push(int x) {\n\t\t\n\t}\n\n\tint pop() {\n\t\t\n\t}\n\n\tvoid increment(int k, int val) {\n\t\t\n\t}\n};\n\n<fix>\nint main()\n{\n\tios_base::sync_with_stdio(NULL);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint maxSize;\n\tcin >> maxSize;\n\n\tint q;\n\tcin >> q;\n\n\tCustomStack* customStack = new CustomStack(maxSize);\n\n\tfor (int itr = 0; itr < q; itr++) {\n\t\tstring op;\n\t\tcin >> op;\n\n\t\tif (op == \"push\") {\n\t\t\tint x;\n\t\t\tcin >> x;\n\n\t\t\tcustomStack->push(x);\n\t\t}\n\t\telse if (op == \"pop\") {\n\t\t\tcout << customStack->pop() << \"\\n\";\n\t\t}\n\t\telse if (op == \"inc\") {\n\t\t\tint k, val;\n\t\t\tcin >> k >> val;\n\t\t\tcustomStack->increment(k, val);\n\t\t}\n\t}\n\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Stack Increments",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There is a sequence <i>A = a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n-1</sub></i>. You are given the following information and questions.</p><ol><li><strong>relate(x, y, z)</strong>: <i>a<sub>y</sub></i> is greater than <i>a<sub>x</sub></i> by <i>z</i>.</li><li><strong>diff(x, y)</strong>: report the difference between <i>a<sub>x</sub></i> and <i>a<sub>y</sub></i> i.e. <i>a<sub>y</sub> - a<sub>x</sub></i>.</li></ol>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n# include <bits/stdc++.h>\n#include <string>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\nusing lli =  int long long;\nusing ii = pair<int,int>;\n#define F first\n#define S second\n\n\nconst int tot = 1e6+100;\nconst lli mod = 1e9+7;\n\nvector<pair<int,ii>> edge;\n\nstruct UnionFind {\n    int n,set_size,*parent,*rank,*value;\n    vector<vector<int>> graph;\n\n    UnionFind(){}\n    UnionFind(int a){\n        n = set_size = a;\n        parent = new int[n+1];\n        rank = new int[n+1];\n        value = new int[n+1];\n        graph.resize(n+1);\n        for(int i=0;i<=n;i++){\n            parent[i]=i;\n            rank[i]=1;\n            value[i]=0;\n        }\n    }\n        \n    int find(int x){\n        if(x!=parent[x])\n            return parent[x] = find(parent[x]);\n        return x;\n    }\n\n    void dfs(int cur,int par,int diff){\n        value[cur]+=diff;\n    \n        for(int u:graph[cur]){\n            if(u==par)\n                continue;\n            dfs(u,cur,diff);\n        }\n    }\n\n    void merge(int x,int y,int val){\n        int xroot = find(x) , yroot=find(y) ;\n        set_size -= 1; // No. of connected components decreases by 1.\n\n        if(xroot != yroot){\n            //Merge the smaller DSU to the bigger DSU\n            //Update values of smaller DSU w.r.t root of bigger DSU. \n            if(rank[xroot] >= rank[yroot]){\n                int diff = value[x] - value[y];\n                diff -=val;\n                dfs(yroot,-1,diff);\n                parent[yroot] = xroot;\n                rank[xroot] += rank[yroot];\n            }\n            else{\n                int diff = value[y]-value[x];\n                diff+=val;\n                dfs(xroot,-1,diff);\n                parent[xroot] = yroot;\n                rank[yroot] += rank[xroot];\n            }\n            graph[x].push_back(y);\n            graph[y].push_back(x);\n        }\n    }\n\n    int value1(int x,int y){\n        if(find(x)!=find(y))  //Not connected components.\n            return 1e9;\n        return value[x]-value[y];\n    }\n\n    void reset(){\n        set_size = n;\n        for(int i=0;i<n;i++){\n            parent[i]=i;\n            rank[i]=1;\n        }\n    }\n\n    int size(){\n        return set_size;\n    }\n    \n};\n\nint n,m;\n\n\nint main(){\n    \n    #ifndef ONLINE_JUDGE\n    // for getting input from input.txt\n    freopen(\"input.txt\", \"r\", stdin);\n    // for writing output to output.txt\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    \n    IOS\n    int q;\n    cin >> n >> q ;\n    UnionFind uf(n);\n\n    while(q--){\n        int type;\n        cin >> type;\n        if(type==0){\n            int a,b,c;\n            cin >> a >> b >> c;\n            edge.push_back({c,{a,b}});\n            uf.merge(a,b,c);\n        }\n        else{\n            int a,b;\n            cin >> a >> b;\n            int x = uf.value1(a,b);\n            if(x==1e9)\n                cout << \"?\" << \"\\n\";\n            else\n                cout << x << \"\\n\";\n\n        }\n    }\n\n    \n    return 0;\n}\n\n//\n//TIME COMPLEXITY:\n// O(nlogn)```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:41:42.045746+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">&nbsp;For query of type 1 the difference between the pair of nodes is given .For each query of type 2 , you have to determine the difference between the nodes. Since, only difference between nodes is given , we can assume any node as the zero node or root node.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">For all the nodes that are being added, the value of the node will not be its difference from its adjacent node , rather it will be the&nbsp; difference of that node from the zero or root node. Hence the value of node i, will be (a[root]- a[i]) . Now how can you use Disjoint Set Union small to large merge to determine the node values?</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">The Disjoint Union Set (DSU) has nodes which store its value relative to the root node. I.e.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Value of a DSU = a[root]-a[i]</span></p><p><span style=\"background-color:transparent;color:#000000;\">Initially, all values in DSU are 0. Now when the query of type '0' comes we try to merge two DSUs and update the values in one of the DSUs. Now which DSU we will update, it depends on the size.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The smaller size DSU will merge with the bigger DSU. Suppose there are two DSUs with roots rootx and rooty, and rank[rootx] &lt; rank[rooty]. We will try to merge the first DSU with root rootx to the second DSU, because the second DSU has a larger size. And update the first DSU. Note that now the values at nodes in the first DSU should be according to their new root rooty. This can be corrected by adding one offset. This can be done by using simple DFS on smaller DSU. Using the same logic that we used while computing the time complexity of Weighted Disjont Union, we can show that the whole time required will be O(nlogn).</span></p><p><span style=\"background-color:transparent;color:#000000;\">To answer the query of type '1', if two given indices don't belong to the same DSU, that means we don't have any information yet to connect them. So in this case, we print '?'.</span></p><p><span style=\"background-color:transparent;color:#000000;\">If they belong to the same DSU, then we directly return the difference between them.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Note that the value stored at a particular index in a tree structure in DSU is with reference to the root. So to find the difference between two indices in the same structure we can take the difference between them at their indices, eventually, the root value gets cancelled (Work it out on notebook!).</span></p><p><span style=\"background-color:transparent;color:#000000;\">EXAMPLE RUN :&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">7 8&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">0 1 2 2&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">0 1 3 3</span></p><p><span style=\"background-color:transparent;color:#000000;\">1 2 3</span></p><p><span style=\"background-color:transparent;color:#000000;\">0 0 4 5</span></p><p><span style=\"background-color:transparent;color:#000000;\">1 1 4</span></p><p><span style=\"background-color:transparent;color:#000000;\">1 3 6</span></p><p><span style=\"background-color:transparent;color:#000000;\">0 3 4 2</span></p><p><span style=\"background-color:transparent;color:#000000;\">1 1 4</span></p><p><span style=\"background-color:transparent;color:#000000;\">OUTPUT:</span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span></p><p><span style=\"background-color:transparent;color:#000000;\">?</span></p><p><span style=\"background-color:transparent;color:#000000;\">?</span></p><p><span style=\"background-color:transparent;color:#000000;\">5</span></p><p><span style=\"background-color:transparent;color:#000000;\">There are 7 nodes and 8 queries given.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Query 1 : Node 1 and Node 2 are merged. Node 1 is sent first so it is considered as a root node (Note : any other node could have been a root node).dfs is run from 2 : value_node[1]=0 and value_node[2]= -2</span></p><p><span style=\"background-color:transparent;color:#000000;\">Query 2 : Node 1 and Node 3 are merged. Rank[1] is 2 and Rank[3] is 1. So the node 3 is merged to node 1.dfs is run from 3 : value_node[1]=0 and value_node[3]= -3.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Query 3 : Simply calculate the difference : node_value[2]-node_value[3] = -2-(-3) = 1</span></p><p><span style=\"background-color:transparent;color:#000000;\">Query 4:&nbsp; Node 0 and Node 4 are merged. Rank[0] is 1 and Rank[4] is 1. So the node 4 is&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">merged to node 0.dfs is run from 4 : value_node[0]=0 and value_node[4]= -5.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Query 5: Calculate the difference between Node 1 and Node 4.Node 4 is merged to Node 0&nbsp; Hence the root of Node 1 is different from root of Node 4.i.e they don’t have path merged between them. So print ‘?’</span></p><p><span style=\"background-color:transparent;color:#000000;\">Query 6: Calculate the difference between Node 3 and Node 6. But Node 6 has not been merged yet to any root. Hence the root of Node 3 is different from the root of Node 6. So print ‘?’</span></p><p><span style=\"background-color:transparent;color:#000000;\">Query 7:&nbsp; Node 3 and Node 4 are merged. Rank[1] is 3 and Rank[0] is 2. So the node 4 is merged to node 3.dfs is run from 4 : value_node[3]= -3 and value_node[4]= -5.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Query 8 : Simply calculate the difference : node_value[4]-node_value[1] = -5-(0) = -5</span></p><p><span style=\"background-color:transparent;color:#000000;\">See the solution code for more clarity.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time complexity: O(nlogn)</span></p><p><span style=\"background-color:transparent;color:#000000;\">Space complexity: O(n) extra space</span></p>"
      },
      "id": 42,
      "input_format": "<p>The first line contains two space-separated integers <i>n</i> and <i>q</i>, (1 ≤ <i>n</i> ≤ 10<sup>4</sup>, 1 ≤ <i>q</i> ≤ 2 x 10<sup>5</sup>).<br>Then, q queries are given in the form either <i><strong>0 x y z</strong></i> or <i><strong>1 x y</strong></i> (0 ≤ <i>x, y</i> &lt; <i>n</i>, <i>x != y</i>, 0 ≤ <i>z</i> ≤ 10000). <i>'0'</i> denotes the <strong>relate</strong> information and <i>'1'</i> denotes <strong>diff</strong> question.<br>It is guaranteed that there is no inconsistency in the given information.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><strong>Query 1</strong>: <i>a<sub>2</sub> - a<sub>0</sub> = 5</i><br><strong>Query 2</strong>: <i>a<sub>2</sub> - a<sub>1</sub> = 3</i><br><strong>Query 3</strong>: We can find the difference between <i>a<sub>1</sub></i> and <i>a<sub>0</sub></i> as <i>a<sub>1</sub> - a<sub>0</sub> = 2</i><br><strong>Query 4</strong>: We don't have any information about <i>a<sub>3</sub></i>. That's why we print '?'<br><strong>Query 5</strong>: <i>a<sub>4</sub> - a<sub>1</sub> = 8</i><br><strong>Query 6</strong>: We can find the difference between <i>a<sub>4</sub></i> and <i>a<sub>0</sub></i> as <i>a<sub>4</sub> - a<sub>0</sub> = 10</i></p><p>&nbsp;</p>",
      "output_format": "<p>For each diff question, print the difference between <i>a<sub>x</sub></i> and <i>a<sub>y</sub></i> i.e. <i><strong>a<sub>y</sub> - a<sub>x</sub></strong></i>. If we don't have any information for the current diff query, print <i>'</i><strong>?</strong><i>'</i>.</p>",
      "samples": [
        {
          "input": "5 6\n0 0 2 5\n0 1 2 3\n1 0 1\n1 1 3\n0 1 4 8\n1 0 4",
          "output": "2\n?\n10"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 0.3,
      "title": "Weighted Union Find Trees",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers and <i>Q</i> queries. In each query two integers <i>L</i>, <i>R</i> is given, you have to find <i>(A[L] + A[L+1]*2 + A[L+2]*3 + A[L+3]*4...A[R]*(R-L+1))</i> % 10^9+7.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\nll n, q;\nll arr[1000100];\nll mulArr[1000100];\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> q;\n  for (ll i = 1; i <= n; i++) {\n    cin >> arr[i];\n    mulArr[i] = arr[i] * i % mod;\n  }\n  for (ll i = 1; i <= n; i++) {\n    arr[i] += arr[i - 1];\n    arr[i] %= mod;\n    mulArr[i] += mulArr[i - 1];\n    mulArr[i] %= mod;\n  }\n  for (ll i = 1; i <= q; i++) {\n    int l, r;\n    cin >> l >> r;\n    ll ans = mulArr[r] - mulArr[l - 1];\n    ans -= (l - 1) * (arr[r] - arr[l - 1]);\n    ans = (ans % mod + mod) % mod;\n    cout << ans << endl;\n  }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:39:33.358926+00:00"
      },
      "hints": {
        "hint1": "We will be using AP on prefix sums, if new to this idea, check the video solution - AP on Prefix Sum.",
        "hint2": "",
        "solution_approach": "The mularr stores the sums by taking their index into consideration:\n$mularr[r]=arr[1]*1+arr[2]*2+....+arr[l]*l+......+arr[r]*r$\n\nThe pre array stores the prefix sums till a particular index:  \n$pre[r]=arr[1]+arr[2]+....+arr[l]+......+arr[r]$\n\nNow lets say we wish to find the value of $(A[L] + A[L+1]*2 + A[L+2]*3 + A[L+3]*4...A[R]*(R-L+1))$  \n\nWe can calculate the final answer in the following manner:      \n$ans = x-y$  \nwhere,    \n$x = mularr[r]-mularr[l-1]$, and  $y=(l-1)*(pre[r]-pre[l-1])$   \n$x = arr[l]*l+......+arr[i]*r$       \n$y = (l-1)*(arr[l]+arr[l+1]+.....+arr[r])$  \n$ans = x-y$      \n\n$ans = arr[l]*l+......+arr[r]*r - (l-1)*(arr[l]+arr[l+1]+.....+arr[r])$    \n$ans = arr[l]*[l-(l-1)]+arr[l+1]*[(l+1)-(l-1)]+........+arr[r]*[r-(l-1)]$    \n$ans = A[L] + A[L+1]*2 + A[L+2]*3 + A[L+3]*4...A[R]*(R-L+1)$    \n\n\nTime complexity : $O(N+Q)$"
      },
      "id": 36,
      "input_format": "<p>The first line contains two space-separated integers <i>N</i>, <i>Q</i> where 1&lt;=<i>N</i>&lt;=10^6, 1&lt;=<i>Q</i>&lt;=10^6.</p><p>Next line contains <i>N</i> space-separated integers (-1e9&lt;=<i>A<sub>i</sub></i>&lt;=1e9).</p><p>Next <i>Q</i> lines contain two space-separated integers <i>L</i>, <i>R</i> where 1&lt;=<i>L</i>&lt;=<i>R</i>&lt;=<i>N</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>For each query print the value of <i>(A[L] + A[L+1]*2 + A[L+2]*3 + A[L+3]*4...A[R]*(R-L+1))</i> % 10^9+7 in a new line.</p>",
      "samples": [
        {
          "input": "10 10\n12 -23 -123 2345 2345 44 345 -93945 -5353 1\n1 5\n1 8\n1 10\n2 2\n6 6\n4 8\n2 9\n4 10\n3 6\n5 9",
          "output": "20702\n999271828\n999223661\n999999984\n44\n999538829\n999318004\n999506718\n11778\n999600930"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Multiply Sum Query",
      "video_editorial_id": 8132
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given a string S. You are given Q queries of two types, asking the number of distinct characters in the range [L, R] and changing the i-th character to c. (1-based indexing)",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$1 \\leq |S| \\leq 10^5$  \n\n$1 \\leq Q \\leq 10^6$  \n\n$1 \\leq A_i \\leq 10^5$  \n\nIt is guaranteed that the sum of $|S|$ and the sum of $Q$ over all test cases does not exceed $10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        string s;\n        cin >> s;\n        int q;\n        cin >> q;\n        set<int> st[26];\n        for (int i = 0; i < s.size(); ++i) {\n            st[s[i]-'a'].insert(i+1);\n        }\n        while(q--) {\n            int t;\n            cin >> t;\n            if(t == 1) {\n                int pos;\n                char c;\n                cin >> pos >> c;\n                st[s[pos-1]-'a'].erase(pos);\n                st[c-'a'].insert(pos);\n                s[pos-1] = c;\n            }\n            else {\n                int l, r;\n                cin >> l >> r;\n                int ans = 0;\n                for (int i = 0; i < 26; ++i) {\n                    auto it = st[i].lower_bound(l);\n                    if(it==st[i].end())\n                        continue;\n                    if(l <= *it && *it <= r) {\n                        ans++;\n                    }\n                }\n                cout << ans << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:13:04.223947+00:00"
      },
      "hints": {
        "hint1": "Make an array of $26$ sets and store the position of all the different characters.",
        "hint2": "",
        "solution_approach": "For query of type $1$, delete the previous character, change the character of $i$ to $c$ and add the character $c$ to the new set. For query of type $2$, find the minimum value more than $L$ in each set, if it is $\\leq R$, then it lies in the range $[L, R]$.\n\nTime Complexity per test case: $O(Q \\log |S|)$"
      },
      "id": 384,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\n\nThe first line of each test contains a string $S$.\n\nThe second line of each test case contains one integer $Q$ - the number of queries.\n\nEach of the next $Q$ lines contains two types of queries: either **1 i c** or **2 L R**.  \n- The query **1** is for changing the $i$-th character to $c$.  \n- The query **2** is for finding the number of distinct characters in the range $[L, R]$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, distinct characters from $1$-$3$ in `abbac` are ‘a’ and ‘b’. Changing the string to `acbac`, distinct characters from $1$-$3$ in `abcac` are ‘a’, ‘b’, and ‘c’.\n\nFor the second test case, distinct characters from $2$-$5$ in `flower` are ‘l’, ‘o’, ‘w’, ‘e’. Changing the string to `fllwer` and then to `fllwee`, distinct characters from $1$-$6$ are ‘f’, ‘l’, ‘w’, and ‘e’.",
      "output_format": "For each test case, print the required queries.",
      "samples": [
        {
          "input": "2\nabbac\n3\n2 1 3\n1 2 c\n2 1 4\nflower\n4\n2 2 5\n1 3 l\n1 6 w\n2 1 6\n",
          "output": "2\n3\n4\n4\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Distinct Characters AZ101",
      "video_editorial_id": 8195
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Design a Data Structure which can support the following queries:</p><p>Initially, the structure is empty. You have given an integer <i>K</i>.&nbsp;</p><p>The structure is arranged in the order from greater elements to smaller elements. So when we say top <i>K</i> elements, we mean the top K largest elements.</p><p><strong>1 </strong><i><strong>x</strong></i>: Add <i>x</i> in structure.</p><p><strong>2 </strong><i><strong>x</strong></i>: Remove <i>x</i> from the structure if present in the structure. If <i>x</i> doesn't present in the structure, do nothing. If there are multiple occurrences of <i>x</i>, delete only one occurrence of <i>x</i>.</p><p><strong>3 ?</strong>: Print the sum of the top <i>K</i> elements. If the structure contains less than <i>K</i> elements, then print the sum of all elements present in the structure. If the structure is empty, then print 0.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>Q, K</i> ≤ 10<sup>5</sup><br>0 ≤ <i>x</i> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 200010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\n\nclass MyStructure {\nprivate:\n\tmultiset<int> M1, M2;\n\tll sum;\n\tint K;\n\npublic:\n\tMyStructure(int K) : K(K), sum(0LL) {};\n\n\tvoid add(int x) {\n\t\tM1.insert(x);\n\t\tsum += x;\n\t\tif((int)M1.size() > K) {\n\t\t\tint y = *(M1.begin());\n\t\t\tM1.erase(M1.find(y));\n\t\t\tsum -= y;\n\t\t\tM2.insert(y);\n\t\t}\n\t\treturn;\n\t}\n\n\tvoid remove(int x) {\n\t\tif(M2.find(x) != M2.end()) {\n\t\t\tM2.erase(M2.find(x));\n\t\t}\n\t\telse if(M1.find(x) != M1.end()) {\n\t\t\tsum -= x;\n\t\t\tM1.erase(M1.find(x));\n\t\t\tif(M2.empty()) return;\n\t\t\tint y = *(M2.rbegin());\n\t\t\tsum += y;\n\t\t\tM1.insert(y);\n\t\t\tM2.erase(M2.find(y));\n\t\t}\n\t\treturn;\n\t}\n\n\tll getSum() {\n\t\treturn sum;\n\t}\n};\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int Q, K; cin >> Q >> K;\n\n    MyStructure M(K);\n\n    while(Q--) {\n    \tint t; cin >> t;\n    \tif(t == 1) {\n    \t\tint x; cin >> x;\n    \t\tM.add(x);\n    \t}\n    \telse if(t == 2) {\n    \t\tint x; cin >> x;\n    \t\tM.remove(x);\n    \t}\n    \telse if(t == 3) {\n    \t\tchar c; cin >> c;\n    \t\tcout << M.getSum() << \"\\n\";\n    \t}\n    \telse {\n    \t\t//asserting this condition never happens\n    \t\tassert(1 == 0);\n    \t}\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:13:18.452443+00:00"
      },
      "hints": {
        "hint1": "<p>Try to use STL in C++. Or some similar Data structures in other languages.</p>",
        "hint2": "<p>Use Multiset in C++, and similar structures in other languages.</p>",
        "solution_approach": "<p>Maintain two multisets, lets call them M<sub>1</sub>, M<sub>2</sub>. M<sub>1</sub> multiset will store candidates elements for top <i>K</i> positions, i.e., greatest <i>K</i> elements. M<sub>2</sub> will store other remaining elements.<br>Note that at any point, it may be possible that both M<sub>1</sub> and M<sub>2</sub> are empty, or both M<sub>1</sub> and M<sub>2</sub> are non-empty, or M<sub>1</sub> is non-empty and M<sub>2</sub> is empty.</p><p>When add query comes, the following scenarios can possible to happen.</p><ul><li>If the size of M<sub>1</sub> is less than <i>K</i>, then add that element in M<sub>1</sub>.</li><li>If the current size of M<sub>1</sub> is equal to <i>K</i>, add the element in M<sub>1</sub> and remove the smallest element in M<sub>1</sub> and add that element in M<sub>2</sub>.</li></ul><p>When remove query comes, the following scenarios can possible to happen.</p><ul><li>If the query element <i>x</i> is present in M<sub>2</sub>, remove it directly from M<sub>2</sub>.</li><li>If the query element <i>x</i> is present in M<sub>1</sub>, remove it from M<sub>1</sub>. And<ul><li>if the size of M<sub>1</sub> is equal to <i>K </i>- 1 and M<sub>2</sub> is non-empty, the remove greatest element from M<sub>2</sub> and add that in M<sub>1</sub>. If M<sub>2</sub> is empty, that means so far we have &nbsp;- 1 element present in the structure.</li><li>if the size of M<sub>1</sub> is less than <i>K </i>- 1, that M<sub>2</sub> is empty.</li></ul></li></ul><p>See the code for more clarity.</p>"
      },
      "id": 98,
      "input_format": "<p>The first line of input contains <i>Q</i> and <i>K</i> - the number of queries.<br>Next, <i>Q</i> lines contain queries of the format specified in the statement.&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For queries of type 3, print the answer in a new line.</p>",
      "samples": [
        {
          "input": "17 3\n1 5\n1 2\n1 3\n1 6\n3 ?\n2 3\n3 ?\n2 2\n3 ?\n2 2\n3 ?\n2 5\n3 ?\n2 5\n3 ?\n2 6\n3 ?",
          "output": "14\n13\n11\n11\n6\n6\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Support Queries II",
      "video_editorial_id": 8150
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given <i>N</i> balls and an integer&nbsp;<i>K</i>. The color of each ball is given in an array <i>A</i>. A basket is filled if it contains at least <i>K</i> balls of different colors. Find the maximum number of filled baskets you can get if you optimally put the balls in the baskets.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100001;\nll n, k;\nll arr[N];\nmap<ll, ll> freq;\nbool check(ll minVal)\n{\n    ll totalUsefulBalls = 0;\n    for (auto v : freq)\n    {\n        totalUsefulBalls += min(v.second, minVal);\n    }\n    return totalUsefulBalls >= k * minVal;\n}\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ll testcases;\n    cin >> testcases;\n    while (testcases--)\n    {\n        cin >> n >> k;\n        ll sum = 0;\n        for (ll i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n            freq[arr[i]]++;\n        }\n        ll low = 0, high = n;\n        ll ans = low;\n        while (low <= high)\n        {\n            ll mid = (low + high) / 2;\n            if (check(mid))\n                ans = mid, low = mid + 1;\n            else\n                high = mid - 1;\n        }\n        cout << ans << \"\\n\";\n        freq.clear();\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:31:51.988535+00:00"
      },
      "hints": {
        "hint1": "If we can fill $X$ number of baskets with at least $K$ balls of different colors, then the maximum possible baskets would be $\\geq X$. Otherwise, possible baskets would be $< X$. This is a monotonic function and hence we can use binary search in this problem.",
        "hint2": "The first step in this solution is to use binary search to find the maximum number of filled baskets. We start with $L = 0$ and $R = N/K$, since each basket must have at least K balls. We then calculate the midpoint, $mid = \\dfrac{L+R}{2}$, and check if it is possible to fill mid baskets with at least K distinct colors. To do this, we use a frequency hashmap to count the number of balls of each color. For each color, we cannot use more than mid balls, since we want distinct balls in the baskets. If it is possible to fill mid baskets, then we update our left pointer to mid+1 and continue the binary search on the right half of the array. Otherwise, the maximum number of filled baskets must be less than mid, so we update our right pointer to mid-1 and continue the binary search on the left half of the array. We repeat this process until $L > R$, at which point we return the maximum number of filled baskets.",
        "solution_approach": "Calculate the sum of min(freq[color],mid).  \n\n**If the $sum \\geq mid \\times K$ then there exists a way to fill “mid” baskets.**\n\nThe goal of the construction step is to find a way to fill the baskets with at least K distinct colors while making sure that no basket has the same color ball. To do this, we can use a 2-D grid of size midK where each row represents a basket, and each column represents a color.\n\nStarting from the first column, we fill each basket with the same color ball until we have used up all of the balls of that color or until we have reached the maximum number of balls allowed in each basket, which is mid. Once we have filled all the baskets with the same color ball for the first column, we move on to the next column and repeat the process.\n\nWe continue this process for all the columns until we have filled each basket with at least K distinct colors. At this point, we have constructed a solution that satisfies the problem constraints, since no basket has the same color ball, and each basket has at least K distinct colors.\n\n\n\n**The time complexity of this algorithm is $O(N \\log_2N)$ per test case due to the binary search step.**"
      },
      "id": 104,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases (<i>1&lt;=T&lt;=100000</i>).</p><p>The first line contains three space-separated integers <i>N</i>, <i>K</i> where <i>1&lt;=N&lt;=10^5</i>, <i>1&lt;=K&lt;=N</i>.</p><p>Next line contains N space-separated integers (<i>0&lt;=Ai&lt;=1e9</i>).</p><p>Sum of <i>N</i> across all test cases &lt;=10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><strong>1st test case:</strong><br>1st basket -&gt; {1,2,3,4,5}</p><p><strong>2nd test case:</strong><br>1st basket -&gt; {1,2,3}<br>2nd basket -&gt; {4,5}</p><p><strong>3rd test case:</strong><br>1st basket -&gt; {1,2,3}<br>2nd basket -&gt; {1,2,3}&nbsp;</p>",
      "output_format": "<p>For each test case output the maximum number of filled baskets in a new line.&nbsp;</p>",
      "samples": [
        {
          "input": "3\n5 5\n1 2 3 4 5\n5 2\n1 2 3 4 5\n6 3\n1 2 2 1 3 3",
          "output": "1\n2\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Color Balls",
      "video_editorial_id": 8151
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Design a data structure that follows the constraints of a <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\"><strong>Least Recently Used (LRU) cache</strong></a>.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ capacity ≤ 10<sup>5</sup></p><p>1 ≤ key, value ≤ 10<sup>5</sup></p><p>At most 10<sup>5</sup> calls will be made to functions <i>get</i> and <i>put</i>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass LRUCache\n{\nprivate:\n    /*Node for each key*/\n    struct LRUNode\n    {\n        int key, val;\n        struct LRUNode *prev, *next;\n        LRUNode() : prev(NULL), next(NULL) {}\n        LRUNode(int key, int val) : key(key), val(val), prev(NULL), next(NULL) {}\n    };\n\nint cap;                                //Capacity of LRU cache\n    int curCnt;                         //Current cnt of nodes\n    unordered_map<int, LRUNode *> M;    //Map from key to corresponding node\n\n    LRUNode *oldNode, *newNode;         //Oldest and newest LRU node\n\n    /*Adjust paramters after current query for key*/\n    void curQuery(int key)\n    {\n        LRUNode *temp = M[key];\n        if (temp == newNode)\n            return;\n        LRUNode *prev = temp->prev;\n        LRUNode *next = temp->next;\n        if (temp == oldNode)\n        {\n            oldNode = next;\n            next->prev = NULL;\n            newNode->next = temp;\n            temp->prev = newNode;\n            temp->next = NULL;\n            newNode = temp;\n        }\n        else\n        {\n            prev->next = next;\n            next->prev = prev;\n            newNode->next = temp;\n            temp->prev = newNode;\n            temp->next = NULL;\n            newNode = temp;\n        }\n        return;\n    }\n\n    /*Add key*/\n    void addKey(int key)\n    {\n        if (!newNode)\n        {\n            newNode = M[key];\n            oldNode = newNode;\n            return;\n        }\n        LRUNode *temp = M[key];\n        newNode->next = temp;\n        temp->prev = newNode;\n        newNode = temp;\n        return;\n    }\n\n    /*Removes oldest query in cache*/\n    void removeOldest()\n    {\n        curCnt--;\n        int key = oldNode->key;\n        if (oldNode == newNode)\n        {\n            M.erase(key);\n            oldNode = newNode = NULL;\n            return;\n        }\n        oldNode = oldNode->next;\n        oldNode->prev = NULL;\n        M.erase(key);\n        return;\n    }\n\npublic:\n    LRUCache(int capacity)\n    {\n        cap = capacity;\n        curCnt = 0;\n        oldNode = NULL;\n        newNode = NULL;\n    }\n\n    int get(int key)\n    {\n        if (M.find(key) != M.end())\n        {\n            curQuery(key);\n            return M[key]->val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value)\n    {\n        if (M.find(key) != M.end())\n        {\n            M[key]->val = value;\n            curQuery(key);\n        }\n        else\n        {\n            LRUNode *temp = new LRUNode(key, value);\n            M[key] = temp;\n            if (curCnt == cap)\n                removeOldest();\n            curCnt++;\n            addKey(key);\n        }\n    }\n};\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int q, cap;\n    cin >> q >> cap;\n    LRUCache *obj = new LRUCache(cap);\n    for (int i = 0; i < q; i++)\n    {\n        string op;\n        cin >> op;\n        if (op == \"get\")\n        {\n            int key;\n            cin >> key;\n            cout << obj->get(key) << '\\n';\n        }\n        else\n        {\n            int key, val;\n            cin >> key >> val;\n            obj->put(key, val);\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:19:35.174478+00:00"
      },
      "hints": {
        "hint1": "Can you do the insertion and deletion in the cache in constant time?",
        "hint2": "<p>Maintain a doubly linked list for the cache and a hash map for storing the values of the keys.</p>",
        "solution_approach": "<p>We maintain a queue where we store the key values in the order in which we encounter them. We create a hash set which stores the values associated with each of the keys. When a new key is added, we add it to the end of the queue and update its value in the hash set. If a key is updated or we access its value we remove it from the queue and add it again at the end.&nbsp;</p><p>If the implementation of the queue is done using a vector it takes <i>O(N*Q)</i> time which is insufficient to pass the constraints. It can be improved to <i>O(Q)</i> if we implement it using doubly linked lists, which supports insertion and deletion in constant time.</p>"
      },
      "id": 648,
      "input_format": "Implement the LRUCache class:\n\n1. **LRUCache(int capacity)** : Initialize the LRU cache with **positive** size capacity.\n2. **int get(int key)** : Return the value of the key if the key exists, otherwise return -1.\n3. **void put(int key, int value)** : Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, **evict** the least recently used key.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>The cache after every operation is:</p><pre><code class=\"language-plaintext\">[{1,1}]\n[{1,1},{2,2}]\n[{2,2},{1,1}]\n[{1,1},{3,3}]\n[{1,1},{3,3}]\n[{3,3},{4,4}]\n[{3,3},{4,4}]\n[{4,4},{3,3}]\n[{3,3},{4,4}]</code></pre>",
      "output_format": "For every call to the get function print the value of the key if it exists else print -1.",
      "samples": [
        {
          "input": "9 2\nput 1 1\nput 2 2\nget 1\nput 3 3\nget 2\nput 4 4\nget 1\nget 3\nget 4",
          "output": "1\n-1\n-1\n3\n4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nclass LRUCache\n{\npublic:\n\n    LRUCache(int capacity)\n    {\n        //Complete function\n    }\n\n    int get(int key)\n    {\n        //Complete function\n    }\n\n    void put(int key, int value)\n    {\n        //Complete function\n    }\n};\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int q, cap;\n    cin >> q >> cap;\n    LRUCache *obj = new LRUCache(cap);\n    for (int i = 0; i < q; i++)\n    {\n        string op;\n        cin >> op;\n        if (op == \"get\")\n        {\n            int key;\n            cin >> key;\n            cout << obj->get(key) << '\\n';\n        }\n        else\n        {\n            int key, val;\n            cin >> key >> val;\n            obj->put(key, val);\n        }\n    }\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "LRU Cache",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are in a building with **n** floors labeled from 1 to **n**. You have **k** identical eggs with you.  \n\nYou also know that there exists a floor **f** (0 ≤ **f** ≤ **n**) such that any egg dropped at a floor **higher** than **f** will break, and any egg dropped at floor **f** or below will not break.  \n\nIn one move, you can select an unbroken egg and drop it from any floor **x** (1 ≤ **x** ≤ **n**). If the egg breaks, you can no longer use it. However, if the egg does not break, you can **reuse** it in your further moves.  \n\nFind the minimum number of moves you need to make to determine with certainty the value of **f**.",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 10000\n1 &lt;= k &lt;= 100</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint EggDrop(int N, int K)\n{\n    vector<int> dp(N + 1);\n    for (int i = 0; i <= N; i++)\n        dp[i] = i;\n    for (int k = 2; k <= K; k++)\n    {\n        vector<int> dp2(N + 1, 0);\n        int x = 1;\n        for (int n = 1; n <= N; n++)\n        {\n            while (x < n && max(dp[x - 1], dp2[n - x]) > max(dp[x], dp2[n - x - 1]))\n                x++;\n            dp2[n] = 1 + max(dp[x - 1], dp2[n - x]);\n        }\n        dp = dp2;\n    }\n    return dp[N];\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int N, K;\n    cin >> N >> K;\n\n    cout << EggDrop(N, K) << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:47:27.733925+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "\n### Method 1 - **Dynamic Programming with Binary Search**\n\nWe use dynamic programming to solve the problem. Our **dp** state is:  \n```\ndp[n][k] - moves required when k eggs and n floors are left.\n```\n\nWhen we drop an egg from floor **X**, it either:  \n- Survives and we go to state **dp[n-X][k]**, or  \n- Breaks and we go to state **dp[X-1][k-1]**.  \n\nThis approach leads to an $(O(K \\times N^2))$ algorithm, which is too slow for the given constraints. We can try to speed it up.  \n```\ndp[N][K] = min(max(dp[X-1][K-1], dp[N-X][K])) over all X in [1, N]\n```\n\n**Key Observation:**  \n- \\(dp[N][K]\\) is an increasing function on \\(N\\).  \n- The first term $(T_1 = dp[X-1][K-1])$ in our max expression is an increasing function on \\(X\\), and  \n- The second term $(T_2 = dp[N-X][K])$ is a decreasing function on \\(X\\).  \n\nThus, instead of checking for each \\(X\\), we can **binary search** for the most optimal value of \\(X\\).  \n\n**Time Complexity:**  \nThis gives us an overall time complexity of $(O(K \\times N \\log N))$.  \n\n---\n\n### Method 2 - **Dynamic Programming with Optimality Criterion**\n\n```\ndp[N][K] = min(max(dp[X-1][K-1], dp[N-X][K]))\n```\n\nLet the optimal value of \\(X\\) be \\(X’\\). So,  \n```\ndp[N][K] = max(dp[X'-1][K-1], dp[N-X'][K])\n```\n\nLet \\(X’ = opt[N][K]\\).  \n\n**Observation:**  \nThe important thing to notice here is that \\(opt[N][K]\\) is an increasing function on \\(N\\).  \n- $(T_1)$ is constant with respect to \\(N\\), but  \n- $(T_2)$ is increasing with respect to \\(N\\).  \n\nHence, the optimal value of \\(X\\) increases with an increase in \\(N\\).  \n\nWhen we want to find $(dp[N+1][K])$, instead of searching for \\(opt[N+1][K]\\) from $(1 \\leq X \\leq N)$, we only have to search $(opt[N][K] \\leq X \\leq N)$.  \n\n**Time Complexity:**  \nThis gives us an overall time complexity of $(O(K \\times N))$.  \n"
      },
      "id": 622,
      "input_format": "The only line of input contains two space-separated integers **n** and **k**.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "Drop the egg from floor 1. If it breaks, we know that **f = 0**.  \n   Otherwise, drop the egg from floor 2. If it breaks, we know that **f = 1**.  \n   If it does not break, then we know **f = 2**.  \n\nHence, we need at minimum 2 moves to determine with certainty what the value of **f** is.",
      "output_format": "Print the minimum number of moves you need to make.",
      "samples": [
        {
          "input": "2 1",
          "output": "2"
        },
        {
          "input": "14 3",
          "output": "4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint EggDrop(int N, int K)\n{\n    // Complete the function\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int N, K;\n    cin >> N >> K;\n\n    cout << EggDrop(N, K) << \"\\n\";\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "Egg Drop",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "A game has n levels, connected by m teleporters, and your task is to get from level 1 to level n. The game has been designed so that there are no directed cycles in the underlying graph. In how many ways can you complete the game?",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n </i>≤ 10<sup>5</sup><br>1 ≤ <i>m </i>≤ 2 x 10<sup>5</sup><br>1 ≤ <i>a</i>, <i>b </i>≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint n;\nvector<int> edge[100001];\nvector<int> backedge[100001];\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int m; cin >> n >> m;\n    int in_degree[n+1], dp[n+1];\n    for(int i = 0; i <= n; i++){\n        in_degree[i] = 0;\n        dp[i] = 0;\n    }\n    dp[1] = 1;\n    for(int i = 0; i < m; i++){\n        int a,b; cin >> a >> b;\n        edge[a].push_back(b);\n        backedge[b].push_back(a);\n        in_degree[b]++;\n    }\n    //uses Kahn's algorithm\n    queue<int> q;\n    for(int i = 0; i < n; i++) {\n        if(in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    while(!q.empty()) {\n        int node = q.front();\n        q.pop();\n        for(int next : edge[node]) {\n            in_degree[next]--;\n            if(in_degree[next] == 0) q.push(next);\n        }\n\n        for(int prev : backedge[node]) {\n            dp[node] = (dp[node] + dp[prev]) % 1000000007;\n        }\n    }\n    cout << dp[n] << endl;\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:42.764853+00:00"
      },
      "hints": {
        "hint1": "<p>Topological Sorting.</p>",
        "hint2": "<p>Now think about each node as a dp state, and try to find the transition.</p>",
        "solution_approach": "<p>One useful property of directed acyclic graphs is, as the name suggests, that no cycles exist. If we consider each node in the graph as a state, we can perform dynamic programming on the graph if we process the states in an order that guarantees for every edge u → v that u is processed before v. Fortunately, this is the exact definition of a topological sort!</p><p>Let dp[v] denote the number of paths reaching v. We can see, dp[v]= sum of all dp[u], s.t. u → v edge exists.<br>With an exception of dp[1], or the starting node, having a value of 1. We process the nodes topologically so dp[u] will already have been computed before dp[v].</p>"
      },
      "id": 432,
      "input_format": "The first input line has two integers n and m: the number of levels and teleporters. The levels are numbered 1, 2, …, n.\nAfter this, there are m lines describing the teleporters. Each line has two integers a and b: there is a teleporter from level a to level b.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print one integer: the number of ways you can complete the game. Since the result may be large, print it modulo 10<sup>9</sup>+7.</p>",
      "samples": [
        {
          "input": "4 5\n1 2\n2 4\n1 3\n3 4\n1 4",
          "output": "3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Complete the Game",
      "video_editorial_id": 8204
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array **nums** of **n** integers and an integer **target**.  \n\nYou want to build an expression out of **nums** by adding one of the symbols ‘+’ and ‘-’ before each integer in the array and then concatenate the integers.  \n\n1. For example, if nums = [1, 2], you can add ‘-’ before 1 and ‘+’ before 2 to obtain the expression “-1+2” which evaluates to 1.  \n\nReturn the number of different expressions that you can build, which evaluates to **target**.  \n\nSince the answer can be huge, output it modulo **10<sup>9</sup> + 7**.",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 1000\n0 &lt;= nums[i] &lt;= 1000\n-1000 &lt;= target &lt;= 1000\n0 &lt;= sum(nums[i]) &lt;= 1000</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint BuildingtheSum(vector <int>& nums, int target) {\n\tint n = nums.size();\n\tvector <vector <int>> dp(n + 1, vector<int> (2001, 0));\n\tdp[0][1000] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 2000; j++) {\n\t\t\tif (dp[i][j] == 0)\n\t\t\t\tcontinue;\n\t\t\tdp[i + 1][j + nums[i]] = (dp[i + 1][j + nums[i]] + dp[i][j]) % mod;\n\t\t\tdp[i + 1][j - nums[i]] = (dp[i + 1][j - nums[i]] + dp[i][j]) % mod;\n\t\t}\n\t}\n\treturn dp[n][target + 1000];\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint n;\n\tcin >> n;\n\tint target;\n\tcin >> target;\n\tvector <int> nums(n);\n\tfor (auto &i : nums)\n\t\tcin >> i;\n\tcout << BuildingtheSum(nums, target);\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing"
        ],
        "last_updated": "2024-06-22T02:47:37.502226+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "Try to do it using dynamic programming.  \n\nConsider this state **dp(i, j)** = Number of ways to have sum **j** after considering the first **i** terms of the expression.  \n\nCan you build it further?\n",
        "solution_approach": "We use dynamic programming to solve this problem.  \n\nLet **dp[i][j]** = Number of ways to have sum **j** after considering the first **i** terms of the expression. The range of **j** is -1000 ≤ **j** ≤ 1000. To ensure that we have non-negative indices, we store the number of ways to have sum **j** in index **j + 1000**.  \n\nThus, the final answer is **dp[n][target + 1000]**.  \n\nWhen we are at the i-th term of the expression, we have two choices:  \n\n1. Add ‘+’ sign before this term.  \n   - If the current sum is **j**, we update **dp[i + 1][j + nums[i]]**.\n\n2. Add ‘-’ sign before this term.  \n   - If the current sum is **j**, we update **dp[i + 1][j - nums[i]]**.  \n\nTo ensure that we do not go out of the range of **j**, we only make transitions from **dp[i][j]** when **dp[i][j] > 0**.\n"
      },
      "id": 635,
      "input_format": "Implement the function **BuildingtheSum** that takes in the array **nums** and the integer **target**.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "1. +1+1+1-1 = 2  \n2. +1+1-1+1 = 2  \n3. +1-1+1+1 = 2  \n4. -1+1+1+1 = 2",
      "output_format": "Return the number of different expressions modulo **10<sup>9</sup> + 7** that evaluates to the given target.",
      "samples": [
        {
          "input": "4 2\n1 1 1 1",
          "output": "4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint BuildingtheSum(vector <int>& nums, int target) {\n\t\n}\n\n\n<fix>\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint n;\n\tcin >> n;\n\tint target;\n\tcin >> target;\n\tvector <int> nums(n);\n\tfor (auto &i : nums)\n\t\tcin >> i;\n\tcout << BuildingtheSum(nums, target);\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Building the Sum",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are <i>N</i> objects, and each object has some price. The price of <i>i</i>th object is <i>A<sub>i</sub></i>.<br>You have been asked <i>Q</i> queries. In each query, you have been given total money <i>M</i>, and find the maximum number of objects that you can buy.</p>",
      "complete_approach": "",
      "constraints": "- $1 \\leq N, Q \\leq 10^5$\n- $1 \\leq A_i \\leq 10^8$\n- $1 \\leq M \\leq 10^8$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nvoid solve() {\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  sort(a.begin(), a.end());\n\n  for (int i = 1; i < n; i++) {\n    a[i] += a[i - 1];\n  }\n\n  for (int i = 0; i < q; i++) {\n    int m;\n    cin >> m;\n\n    int idx = upper_bound(a.begin(), a.end(), m) - a.begin();\n    cout << idx << \"\\n\";\n  }\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  // cin >> t;\n  for (int i = 0; i < t; i++) {\n    solve();\n  }\n}\n```\n\n\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main() {\n  // freopen(\"IN\", \"r\", stdin);\n  // freopen(\"OUT\", \"w\", stdout);\n\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  int n, q;\n  cin >> n >> q;\n  ll A[n];\n  for (int i = 0; i < n; i++) cin >> A[i];\n  sort(A, A + n);\n  for (int i = 1; i < n; i++) A[i] += A[i - 1];\n\n  pair<int, int> query[q];\n  for (int i = 0; i < q; i++) {\n    cin >> query[i].first;\n    query[i].second = i;\n  }\n  sort(query, query + q);\n\n  int ans[q];\n  int ptr = -1;\n\n  for (int i = 0; i < q; i++) {\n    int m = query[i].first;\n    while (ptr + 1 < n && A[ptr + 1] <= m) {\n      ptr++;\n    }\n    ans[query[i].second] = ptr + 1;\n  }\n\n  for (int i = 0; i < q; i++) cout << ans[i] << \"\\n\";\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:44:20.865493+00:00"
      },
      "hints": {
        "hint1": "Try to think greedily! Sort the objects with respect to price, and start greedily buying objects.",
        "hint2": "By maintaining prefix sum of prices of objects in sorted order, and using `upper_bound()` or `lower_bound()` you can answer each query in $O(\\log N)$. Can you do better?",
        "solution_approach": "### Solution 1\nIt's always better to buy an object which has a smaller price. So that we can be left with a greater remaining budget. Sort all objects with respect to their prices. And start buying objects in increasing order of price. Maintain the prefix sum of the sorted array. For each money M, we can do an `upper_bound()` to find the number index upto which we can buy.\nTime complexity: $O(N\\log N) + O(N) + O(Q\\log N)$ (sorting + prefix sum + each query upper_bound)\nSpace complexity: $O(1)$ extra space\n\n### Solution 2\nSort the queries. With an increase in M, the number of objects that you can buy cannot decrease. So we can maintain a pointer which will only move in a forward direction. So we can answer all queries in $O(1)$ after preprocessing. Here are the steps in a more elaborate fashion\n\n* Sort the array of prices in non-decreasing order.\n* Compute the prefix sum of the sorted array of prices, i.e., for each index i, compute the sum of the first i prices.\n* Sort the list of queries in non-decreasing order of the amount of money M.\n* Initialize a pointer i to the beginning of the sorted array of prices and a pointer j to the beginning of the sorted list of queries.\n* Lets say for a particular index `j` in list of queries we can buy `i` objects. Lets see how the algorithm calculates the answer for the query number `j+1`. So for query `j` the money given to us was lesser than the money provided for query `j+1` (sorted list) . As a result the number of items we can buy for query `j+1` will be equal or greater than those bought for query `j`. Hence we need to move the pointer `i` in the prefix array of prices forward to check when the cumulative price of objects exceeds the given amount of money.If `i'` is the index at which prefix[i'] exceeds query[j+1] we say that we can buy `i'` objects for the money given in query `j+1`.\n* If the pointer `j` reaches the end of the sorted list of queries, stop the algorithm and output the answers.\n\nTime complexity: $O(N\\log N) + O(Q\\log Q) + O(Q)$ (sorting + sorting of queries + each query takes $O(1)$)\nSpace complexity: $O(Q)$ extra space"
      },
      "id": 74,
      "input_format": "<p>The first line of each test case contains <i>N</i>, the number of objects, and <i>Q</i>, total queries.<br>The second line of each test case contains <i>N</i> space-separated integers <i>A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub></i>.<br>Next, <i>Q</i> lines contain a number <i>M</i>, the total money.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i>M</i> = 1, buy Object with price 1.<br><i>M</i> = 5, buy Objects with prices 1, 4.<br><i>M</i> = 10, buy Objects with prices 1, 2, 4.<br><i>M</i> = 25, buy Objects with prices 1, 2, 4, 9, 6.</p>",
      "output_format": "<p>For each query, print a single number in a new line representing the maximum objects that you can buy.</p>",
      "samples": [
        {
          "input": "5 4\n1 4 2 9 6\n1\n5\n10\n25",
          "output": "1\n2\n3\n5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Buy Maximum Objects II",
      "video_editorial_id": 10665
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Abhishek loves Snakes and Ladders game, he can always roll the die to whatever number he want between $1$ to $6$. Help him to find the least number of dice rolls to reach the destination i.e the $100^{th}$ cell from the $1^{st}$ cell.\n\nRules :- \n1. The game is played with a cubic die of $6$ faces numbered $1$ to $6$.\n\n2. Starting from square $1$, land on square $100$ with the exact roll of the die. If moving the number rolled would place the player beyond square $100$, no move is made.\n\n3. If a player lands at the base of a ladder, the player must climb the ladder. Ladders go up only.\n\n4. If a player lands at the mouth of a snake, the player must go down the snake and come out through the tail. Snakes go down only.",
      "complete_approach": "",
      "constraints": "$1 \\leq t \\leq 10$\n$1 \\leq n,m \\leq 15$\n\nThe board is always $10 \\times 10$ with squares numbered $1$ to $100$ .\nNeither square $1$ nor square $100$ will be the starting point of a ladder or snake.\nA square will have at most one endpoint from either a snake or a ladder.",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nqueue<int> q;\nint go_immediately_to[110], dist[110];\nbool vis[110];\nbool isValid(int node)\n{\n    if(node < 1 || node > 100 || vis[node])\n        return false;\n    else\n        return true;\n}\nint BFS(int source)\n{\n    memset(vis, 0, sizeof(vis));\n    while(!q.empty())\n        q.pop();\n\n    vis[source] = 1;\n    q.push(source);\n    dist[source] = 0;\n    while(!q.empty())\n    {\n        int current_node = q.front();\n        q.pop();\n        for(int i = 1; i<=6; i++)\n        {\n            int next_node = go_immediately_to[current_node+i];\n            if(isValid(next_node))\n            {\n                q.push(next_node);\n                vis[next_node] = 1;\n                dist[next_node] = dist[current_node]+1;\n            }\n        }\n    }\n    if(!vis[100])\n        return -1;\n    else\n        return dist[100];\n}\nint main()\n{\n    int i, j, cs, t, u, v;\n    cin >> t;\n    for(cs = 1; cs<=t; cs++)\n    {\n        cin >> n;\n\n        for(i = 1; i<=100; i++)\n            go_immediately_to[i] = i;\n\n        for(i = 1; i<=n; i++)\n        {\n            cin >> u >> v;\n            go_immediately_to[u] = v;\n        }\n\n        cin >> m;\n\n        for(i = 1; i<=m; i++)\n        {\n            cin >> u >> v;\n            go_immediately_to[u] = v;\n        }\n\n        cout << BFS(1) << endl;\n    }\n\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:42:41.487759+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "**Modeling the board as a graph**\nLet's model the board as a graph. Every square on the board is a node. The source node is square $1$. The destination node is square $100$. From every square, it is possible to reach any of the $6$ squares in front of it in one move. So every square has a directed edge to the $6$ squares in front of it.\n\n**Handling the snakes and ladders**\nFor a snake starting at square $i$ and finishing at $j$, we can consider that there is no node with index $i$ in the graph. Because reaching node $i$ is equivalent to reaching node $j$ since the snake at node $i$  will immediately take us down to node $j$. The same analogy goes for ladders too. To handle the snakes and ladders, let's keep an array *go_immediately_to[]* and initialize it like this.\n\n```\n        if(no snake or ladder starts at node i)\n            go_immediately_to[i] = i.\n        else\n            j = ending node of the snake or the ladder starting at node i.\n            go_immediately_to[i] = j.\n```\n\nNow let's run a standard Breadth-First Search(BFS). Whenever we reach a node $i$, we will consider that we have reached the node *go_immediately_to[i]* and then continue with the BFS as usual. The distance of the destination is the solution to the problem.\n\n**Time Complexity**\n\nThe size of the board is always $10 \\times 10$. You can consider time complexity of each BFS is constant as the number of snakes or ladders won't have much effect. There are T test cases; total complexity is $O(T)$ omitting the constant factor of $10 \\times 10$."
      },
      "id": 927,
      "input_format": "The first line contains the number of tests, $t$.\n\nFor each test case:\n- The first line contains $n$, the number of ladders.\n- Each of the next $n$ lines contains two space-separated integers, the start, and end of a ladder.\n- The next line contains the integer $m$, the number of snakes.\n- Each of the next $m$ lines contains two space-separated integers, the start, and end of a snake.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test:\nThe player can roll a 5 and a 6 to land at square 12. There is a ladder to square 98. A roll of 2 ends the traverse in 3 rolls.\n\nFor the second test:\nThe player first rolls 5 and climbs the ladder to square 80. 'Three' rolls of 6 get to square 98. A final roll of 2 lands on the target square in 5 total rolls.",
      "output_format": "For each of the $t$ test cases, print the least number of rolls to move from start to finish on a separate line. If there is no solution, print $-1$.",
      "samples": [
        {
          "input": "2\n3\n32 62\n42 68\n12 98\n7\n95 13\n97 25\n93 37\n79 27\n75 19\n49 47\n67 17\n4\n8 52\n6 80\n26 42\n2 72\n9\n51 19\n39 11\n37 29\n81 3\n59 5\n79 23\n53 7\n43 33\n77 21 \n",
          "output": "3\n5\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Snakes and Ladders",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Implement a stack that supports the following operations.</p><ol><li>push <i>x</i> -- Push element <i>x</i> onto stack.</li><li>pop -- Remove the element on top of the stack, if the stack is non-empty. Otherwise do nothing.</li><li>top -- Print the top element, if the stack is non-empty. Otherwise, print -1.</li><li>getMin -- Print the minimum element in the stack, if the stack is non-empty. Otherwise, print -1.</li></ol><p>Initially, the stack is empty.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>Q</i> ≤ 10<sup>6</sup><br>0 ≤ <i>x</i> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass MinStack {\npublic:\n    stack<int> st, minSt;\n\n    MinStack() {}\n\n    void push(int x) {\n        if(st.empty()) {\n            st.push(x);\n            minSt.push(x);\n            return;\n        }\n        st.push(x);\n        minSt.push(min(minSt.top(), x));\n        return;\n    }\n\n    void pop() {\n        if(st.empty()) return;\n        st.pop();\n        minSt.pop();\n    }\n\n    int top() {\n        if(st.empty()) return -1;\n        return st.top();\n    }\n\n    int getMin() {\n        if(minSt.empty()) return -1;\n        return minSt.top();\n    }\n};\n\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int q; cin >> q;\n\n    MinStack s;\n\n    while(q--) {\n        string op;\n        cin >> op;\n\n        if(op == \"push\") {\n            int x;\n            cin >> x;\n            s.push(x);\n        }\n        else if(op == \"pop\") {\n            s.pop();\n        }\n        else if(op == \"top\") {\n            cout << s.top() << \"\\n\";\n        }\n        else if(op == \"getMin\") {\n            cout << s.getMin() << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n```\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass MinStack {\nprivate:\n    long long int minele=INT_MAX;\n    stack<long long int> st;\npublic:\n    void push(int x) {\n        if(st.empty()) {\n            minele=x;\n            st.push(x);\n        }\n        else if(x<minele) {\n            long long int temp=x;\n            temp=2*temp-minele;\n            st.push(temp);\n            minele=x;\n        }\n        else\n            st.push(x);\n    }\n\n    void pop() {\n        if(st.top()<minele) {\n            int temp=st.top();\n            minele=2*minele-temp;\n        }\n        st.pop();\n        if(st.empty()) minele=INT_MAX;\n    }\n\n    int top() {\n        if(st.top()<minele) {\n            return minele;\n        }\n        else return st.top();\n    }\n\n    int getMin() {\n        return minele;\n    }\n};\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int q; cin >> q;\n\n    MinStack s;\n\n    while(q--) {\n        string op;\n        cin >> op;\n\n        if(op == \"push\") {\n            int x;\n            cin >> x;\n            s.push(x);\n        }\n        else if(op == \"pop\") {\n            s.pop();\n        }\n        else if(op == \"top\") {\n            cout << s.top() << \"\\n\";\n        }\n        else if(op == \"getMin\") {\n            cout << s.getMin() << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:38:42.287813+00:00"
      },
      "hints": {
        "hint1": "<p>Try to use two stacks.</p>",
        "hint2": "<p>One stack is to maintain the minimum of elements present in the stack on the top of the stack. Let two stacks be st and minSt.</p><ol><li>push <i>x</i> – push <i>x </i>on top of stack st, and push min(<i>x</i>, minSt.top()) on top of minSt.</li><li>pop – pop from both stacks at the same time.</li><li>top – print top of st.</li><li>getMin – print top of minSt.</li></ol><p>You can do it using one stack implicitly by maintaining pairs. But eventually its a same thing.&nbsp;</p>",
        "solution_approach": "<p>Another approach in which we can solve this problem. This is a interesting approach.</p><p>We define a variable <strong>minEle</strong> that stores the current minimum element in the stack. Now the interesting part is, how to handle the case when minimum element is removed. To handle this, we push 2x – minEle into the stack instead of x so that previous minimum element can be retrieved using current minEle and its value stored in stack. Below are detailed steps and explanation of working.</p><ol><li>push x –&nbsp;<ol><li>If stack is empty, insert x into the stack and make minEle equal to x.</li><li>If stack is not empty, compare x with minEle. Two cases arise:<ol><li style=\"text-align:justify;\">If x is greater than or equal to minEle, simply insert x.</li><li style=\"text-align:justify;\">If x is less than minEle, insert (2*x – minEle) into the stack and make minEle equal to x.</li></ol></li></ol></li><li style=\"text-align:justify;\">pop --<ol><li style=\"text-align:justify;\"><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.84);\">Remove element from top. Let the removed element be y. Two cases arise:</span><ol><li style=\"text-align:justify;\">If y is greater than or equal to minEle, the minimum element in the stack is still minEle.</li><li style=\"text-align:justify;\">If y is less than minEle, the minimum element now becomes (2*minEle – y), so update (minEle = 2*minEle – y). This is where we retrieve previous minimum from current minimum and its value in stack.&nbsp;</li></ol></li></ol></li></ol>"
      },
      "id": 459,
      "input_format": "<p>The first line of input contains Q - the number of queries.<br>Each of next line contains input in one of the four formats mentioned in the problem statement.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the answer for the <i>top</i> and <i>getMin</i> operations.</p>",
      "samples": [
        {
          "input": "11\npush 1\npush 3\ntop\ngetMin\npop\ntop\ngetMin\npop\npop\ntop\ngetMin",
          "output": "3\n1\n1\n1\n-1\n-1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include<bits/stdc++.h>\nusing namespace std;\n</fix>\n\nclass MinStack {\nprivate:\n\npublic:\n\n    MinStack() {}\n\n    void push(int x) {}\n\n    void pop() {}\n\n    int top() {}\n\n    int getMin() {}\n};\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int q; cin >> q;\n\n    MinStack s;\n\n    while(q--) {\n        string op;\n        cin >> op;\n\n        if(op == \"push\") {\n            int x;\n            cin >> x;\n            s.push(x);\n        }\n        else if(op == \"pop\") {\n            s.pop();\n        }\n        else if(op == \"top\") {\n            cout << s.top() << \"\\n\";\n        }\n        else if(op == \"getMin\") {\n            cout << s.getMin() << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Min Stack",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a 2d-array of dimension <i>N*M</i> and <i>Q</i> queries. In each query four integers <i>x1, y1, x2, y2 </i>is given, you have to find the sum of submatrix with <i>(x1,y1)</i> be the leftmost corner and <i>(x2,y2)</i> be the rightmost corner %10^9+7.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\nint mod = 1e9 + 7;\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  int n, m, q;\n  cin >> n >> m >> q;\n  long long arr[n + 1][m + 1];\n  memset(arr, 0, sizeof(arr));\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      cin >> arr[i][j];\n      arr[i][j] += arr[i - 1][j] + arr[i][j - 1] - arr[i - 1][j - 1];\n    }\n  }\n  while (q--) {\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    long long ans =\n        arr[x2][y2] - arr[x1 - 1][y2] - arr[x2][y1 - 1] + arr[x1 - 1][y1 - 1];\n    ans %= mod;\n    if (ans < 0) ans += mod;\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:44:57.597349+00:00"
      },
      "hints": {
        "hint1": "Use Prefix Sums in 2D matrix. If new to this concept,\nCheck the video solution - 2D Prefix Sums Concept.",
        "hint2": "",
        "solution_approach": "We solve this problem using the concept of prefix sums.\n\nTo do this efficiently using prefix sums, we need to first precompute a 2d-array called prefix sums, where each cell (i,j) stores the sum of all the values in the submatrix with (1,1) as the top-left corner and (i,j) as the bottom-right corner. We can compute this array using the following formula:\n\npartialsums[i][j] = partialsums[i-1][j] + partialsums[i][j-1] - partialsums[i-1][j-1] + values[i][j]\n\nHere, values[i][j] is the value of the cell at (i,j) in the original 2d-array.\n\nNow to find the answer to each of the queries, where we are given the top left corner (x1,y1) and bottom right corner (x2,y2). We can find the sum of that rectangle by doing  \n\nans=partialsums[x2][y2]-partialsums[x1][y2]-partialsums[x2][y1]+partialsums[x1][y1]\n\nThe time complexity for this algorithm is $O(Q+N\\times M)$. For each query it almost takes constant time. initially we iterate over the entire 2D matrix to find the prefix sum of the matrix."
      },
      "id": 25,
      "input_format": "<p>The first line contains three space-separated integers <i>N, M, Q</i> where 1&lt;=<i>N,</i> <i>M</i>&lt;=10^3, 1&lt;=<i>Q</i>&lt;=10^6.</p><p>Next <i>N</i> lines contains <i>M</i> space-separated integers (-1e9&lt;=<i>A<sub>ij</sub></i>&lt;=1e9).</p><p>Next <i>Q</i> lines contains four space separated integers <i>x1, y1, x2, y2 </i>where 1&lt;=<i>x1</i>&lt;=<i>x2</i>&lt;=<i>N</i>, 1&lt;=<i>y1</i>&lt;=<i>y2</i>&lt;=<i>M</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>For each query print, the sum of submatrix with <i>(x1,y1)</i> be the leftmost corner and <i>(x2,y2)</i> be the rightmost corner in a new line %10^9+7.</p>",
      "samples": [
        {
          "input": "5 5 5\n-1 2 3 -4 2\n0 0 0 0 4\n1 2 4 3 5\n-1 -5 -2 3 4\n0 -3 -5 3 -6\n1 1 2 2\n1 2 3 4\n2 3 3 3\n4 4 4 4\n2 3 2 4",
          "output": "1\n10\n4\n3\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Rectangle Sum Query",
      "video_editorial_id": 10675
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an integer <strong>t </strong>- the number of test cases. For each test case, read an integer <strong>n </strong>and answer the following 6 queries in the given order in a new line -:</p><ol><li>Output the 64 bit binary representation of number <strong>n</strong>.</li><li>Output the <strong>position</strong> of the most significant bit ( <strong>MSB</strong> ) or the leftmost set bit of <strong>n</strong> ( 0- indexed ). If n=0, output -1.</li><li>Output the <strong>position</strong> of the rightmost set bit of <strong>n</strong> ( 0- indexed ). If n=0, output -1.</li><li>Output 1 if <strong>n&nbsp;</strong> is a power of 2 i.e <strong>n==2<sup>X</sup> , x &gt; 0, </strong>else output 0.</li><li>Output the biggest power of 2, that is the divisor of <strong>n. </strong>i.e biggest <strong>2<sup>K</sup> </strong>such that <strong>n%2<sup>K </sup>== 0, k ≥ 0. </strong>If n=0, output -1.&nbsp;</li><li>Output the smallest power of 2, which is not smaller than <strong>n, </strong>i.e smallest <strong>2<sup>K</sup> </strong>such that <strong>2<sup>K </sup>≥ n, k&gt;0.</strong></li></ol>",
      "complete_approach": "",
      "constraints": "<ul><li>1 ≤ t ≤ 10<sup>5</sup></li><li>- 10<sup>18</sup> ≤ n ≤ 10<sup>18</sup>&nbsp;</li></ul>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvoid binary(ll x) {\n    for (int i = 63; i >= 0; i--) {\n        if (x & (1LL << i))cout << 1;\n        else cout << 0;\n    }\n    cout << endl;\n}\nint msb(ll x) {\n    if (x == 0)return -1;\n    if (x < 0)return 63; // negative numbers case.\n    return (int)__lg(x);\n}\nint rsb(ll x) {\n    if (x == 0)return -1;\n    return msb(x ^ (x - 1));\n}\nbool pow2(ll &x) {\n    if (x <= 1)return false;\n    return (__builtin_popcountll(x) == 1);\n}\nll pow2_div(ll x) {\n    if (x == 0)return -1;\n    return (1LL << __builtin_ctzll(x)); // 2^(trailing zeroes in bits).\n}\nll pow2_n(ll x) {\n    if (x <= 1)return 2;\n    return (1LL << (64 - __builtin_clzll(x - 1))); // 2^(64 - leading zeroes in bits).\n}\nvoid solve() {\n    ll n;\n    cin >> n;\n    binary(n);\n    assert(n == 0 || msb(n) == 63 - __builtin_clzll(n));\n    cout << msb(n) << endl;\n    assert(n == 0 || rsb(n) == __builtin_ctzll(n));\n    cout << rsb(n) << endl;\n    cout << pow2(n) << endl;\n    cout << pow2_div(n) << endl;\n    cout << pow2_n(n) << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:39:38.819149+00:00"
      },
      "hints": {
        "hint1": "The problem requires implementing several bit manipulation operations such as finding the most significant bit, the rightmost set bit, checking if a number is a power of two, finding the biggest power of two divisor, and finding the smallest power of two greater than or equal to the given number.",
        "hint2": "To solve this problem, we need to implement the six required queries on the given integer n. The queries are as follows:\n\n1. Binary representation of n: To find the binary representation of n, we can use bitwise operators to extract each bit of the number from right to left and print it out.\n2. Most significant bit (MSB): To find the position of the most significant bit (MSB) or the leftmost set bit of n, we can use the built-in function __lg() in C++, which returns the position of the most significant set bit in the binary representation of a positive integer. If n is $0$, we return -$1$.\n3. Rightmost set bit (RSB): To find the position of the rightmost set bit of n, we can use another built-in function _\\_builtin\\_ctzll(), which returns the position of the rightmost set bit in the binary representation of a positive integer. If n is $0$, we return -$1$.\n4. Power of $2$: To check if n is a power of $2$, we can use the built-in function _\\_builtin\\_popcountll(), which returns the number of set bits in the binary representation of a positive integer. If n has only one set bit, then it is a power of $2$ and we return $1$. Otherwise, we return $0$.\n5. Biggest power of $2$ divisor: To find the biggest power of $2$ that is a divisor of n, we can use the built-in function _\\_builtin\\_ctzll() again, which returns the position of the rightmost set bit in the binary representation of n. The answer is then $2$ to the power of this position. If n is $0$, we return -$1$.\n6. Smallest power of $2$ greater than or equal to n: To find the smallest power of $2$ that is not smaller than n, we can use the built-in function _\\_builtin\\_clzll(), which returns the number of leading zeros in the binary representation of n minus $1$. The answer is then $2$ to the power of $64$ minus this value. If n is less than or equal to $1$, we return $2$.",
        "solution_approach": "To solve this problem, we need to implement the six required queries on the given integer n. The queries are as follows:\n\n1. Binary representation of n: To find the binary representation of n, we can use bitwise operators to extract each bit of the number from right to left and print it out.\n2. Most significant bit (MSB): To find the position of the most significant bit (MSB) or the leftmost set bit of n, we can use the built-in function __lg() in C++, which returns the position of the most significant set bit in the binary representation of a positive integer. If n is $0$, we return -$1$.\n3. Rightmost set bit (RSB): To find the position of the rightmost set bit of n, we can use another built-in function _\\_builtin\\_ctzll(), which returns the position of the rightmost set bit in the binary representation of a positive integer. If n is $0$, we return -$1$.\n4. Power of $2$: To check if n is a power of $2$, we can use the built-in function _\\_builtin\\_popcountll(), which returns the number of set bits in the binary representation of a positive integer. If n has only one set bit, then it is a power of $2$ and we return $1$. Otherwise, we return $0$.\n5. Biggest power of $2$ divisor: To find the biggest power of $2$ that is a divisor of n, we can use the built-in function _\\_builtin\\_ctzll() again, which returns the position of the rightmost set bit in the binary representation of n. The answer is then $2$ to the power of this position. If n is $0$, we return -$1$.\n6. Smallest power of $2$ greater than or equal to n: To find the smallest power of $2$ that is not smaller than n, we can use the built-in function _\\_builtin\\_clzll(), which returns the number of leading zeros in the binary representation of n minus $1$. The answer is then $2$ to the power of $64$ minus this value. If n is less than or equal to $1$, we return $2$."
      },
      "id": 873,
      "input_format": "<p>First-line contains an integer <strong>t -&nbsp;</strong> number of test cases.</p><p>Each next <strong>t</strong> lines contain an integer <strong>n.</strong></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case, answer the 6 queries in the given order in a new line.</p>",
      "samples": [
        {
          "input": "10\n-3\n-2\n-1\n0\n1\n2\n3\n4\n5\n6",
          "output": "1111111111111111111111111111111111111111111111111111111111111101\n63\n0\n0\n1\n2\n1111111111111111111111111111111111111111111111111111111111111110\n63\n1\n0\n2\n2\n1111111111111111111111111111111111111111111111111111111111111111\n63\n0\n0\n1\n2\n0000000000000000000000000000000000000000000000000000000000000000\n-1\n-1\n0\n-1\n2\n0000000000000000000000000000000000000000000000000000000000000001\n0\n0\n0\n1\n2\n0000000000000000000000000000000000000000000000000000000000000010\n1\n1\n1\n2\n2\n0000000000000000000000000000000000000000000000000000000000000011\n1\n0\n0\n1\n4\n0000000000000000000000000000000000000000000000000000000000000100\n2\n2\n1\n4\n4\n0000000000000000000000000000000000000000000000000000000000000101\n2\n0\n0\n1\n8\n0000000000000000000000000000000000000000000000000000000000000110\n2\n1\n0\n2\n8\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Bit Magic II",
      "video_editorial_id": 8233
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given a sequence A of prime numbers. You have to tell the number of subsequences with size at most K and which do not contain any two identical numbers. The empty sequence is good. Since the answer can be large, print it modulo 10<sup>9</sup> + 7.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤ 100</p><p>1 ≤ K ≤ N ≤ 10^5</p><p>2 ≤ Ai ≤ 10000, only prime numbers</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\nconst int mod=1e9+7;\n\nint dp[1230][1230];\n\nsigned main(){\n   IOS\n   int t;\n   cin >> t;\n   while (t--) {\n       int n, k;\n       cin >> n >> k;\n       map<int, int> m;\n       for(int i = 0; i < n; ++i){\n           int x;\n           cin >> x;\n           m[x]++;\n       }\n       vector<int> v;\n       for(auto i :m)  {\n           v.push_back(i.second);\n       }\n       memset(dp,0,sizeof(dp));\n       for(int i = 0; i < v.size(); ++i){\n           dp[i][0] = 1;\n       }\n       dp[0][1] = v[0];\n       for(int i = 1; i < v.size(); ++i){\n           for(int j = 1; j <= v.size(); ++j){\n               dp[i][j] = (dp[i][j] + dp[i - 1][j])%mod;\n               dp[i][j] = (dp[i][j] + (dp[i - 1][j - 1] * v[i]) % mod) % mod;\n           }\n       }\n       int ans[v.size() + 1];\n       ans[0] = 1;\n       for(int i = 1; i <= v.size(); i++){\n           ans[i] = (ans[i - 1] + dp[v.size() - 1][i])%mod;\n       }\n\n       if(k <= v.size()){\n           cout << ans[k] << \"\\n\";\n       }\n       else{\n           cout << ans[v.size()] << \"\\n\";\n       }\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:28:03.817708+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">The number of distinct primes till 10000 is 1229.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">The order of the given array does not matter.</span></p>",
        "solution_approach": "<p>Make a DP array, DP[i][j] which denotes the number of valid subsets of size j using array values upto i. The DP transition will be: DP[i][j] = DP[i-1][j] + DP[i-1][j-1] * cnt[i]. Here cnt[i] is the count of integer i in the given array. For a given value of i,j DP[i-1][j] considers the valid subsets using array values upto i and the second term denotes picking of the number i which has count, cnt[i].</p><p>&nbsp;</p><p>Time Complexity per test case: O(X^2) where X is the number of primes till 10000, which is 1229.</p>"
      },
      "id": 189,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains two space-separated integers N and K - the length of the array and maximum numbers to take in a subsequence.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The second line of each test case contains N space-separated integers.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, there is 1 subsequence with length 0, 5 subsequence with length 1 and 8 subsequence with length 2.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, there is 1 subsequence with length 0, 5 subsequence with length 1, 8 subsequence with length 2 and 4 subsequence with length 3.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, there is 1 subsequence with length 0 and 4 subsequence with length 1.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the fourth test case, there is 1 subsequence with length 0, 4 subsequence with length 1 and 6 subsequence with length 2, 4 subsequence with length 3 and 1 subsequence with length 4.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print a single integer denoting the number of subsequences with size at most K and which do not contain any two identical numbers on a separate line. Since the answer can be large, print it modulo 10<sup>9</sup> + 7.</span></p>",
      "samples": [
        {
          "input": "4\n5 2\n5 5 2 2 3\n5 3\n5 5 2 2 3\n4 2\n5 5 5 5\n4 4\n5 2 3 7",
          "output": "14\n18\n5\n16"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Prime Subsequence",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a number $N$ and an array $A$ of $N$ numbers. Print $\\textbf{the smallest}$ possible result of $A_i + A_j + j - i$, where $1  \\leq  i < j  \\leq  N$.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10^3 $\n$ 2 \\leq N \\leq 3 \\times 10^5$ \n$ -10^6 \\leq A[i] \\leq 10^6 $",
      "editorial_code": [
        {
          "code": "```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n\n        int m = arr[0] - 0;\n        int ans = 1e9;\n        for (int i = 1; i < n; i++) \n        {\n            ans = min(ans, m + arr[i] + i);\n            m = min(m, arr[i] - i);\n        }\n        \n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Editorial code is not passing the Sample cases."
        ],
        "last_updated": "2024-06-22T02:17:42.538911+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We need to minimise $A[i] + A[j] + j - i$, it can be min($A[i] - i$) + min($A[j] + j$) where $j>i$.\nSince sum of two minimums is minumum, so we need to minimise $A[i] - i$ + $A[j] + j$.\nAnd since $i < j$, we can maintain a running minimum from $0...i$\nLet us say this as m.\nSo $m = min(A[k] - k)$ for all $0 \\leq k \\leq i$.\nWhen we reach i, we update ans as, $ans = min(ans, m + A[i] + i);$\nNow the ans will be the smallest possible pair sum with minimum $A[i] + A[j] + j - i$.\n        \n        \n"
      },
      "id": 1152,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains an integer $N$, the number of elements in the array.\nThe second line contains $N$ space separated integers denoting the elements of the array.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "Note\nFirst Case :\nAll possibles (i,j) where (1  ≤  i < j  ≤  N) are :\n$i = 1 , j = 2$ then result = $a1 + a2 + j - i = 20 + 1 + 2-1 = 22.$\n$i = 1 , j = 3$ then result = $a1 + a3 + j - i = 20 + 9 + 3-1 = 31.$\n$i = 1 , j = 4$ then result = $a1 + a4 + j - i = 20 + 4 + 4-1 = 27.$\n$i = 2 , j = 3$ then result = $a2 + a3 + j - i = 1 + 9 + 3-2 = 11.$\n$i = 2 , j = 4$ then result = $a2 + a4 + j - i = 1 + 4 + 4-2 = 7.$\n$i = 3 , j = 4$ then result = $a3 + a4 + j - i = 9 + 4 + 4-3 = 14.$\nSo the smallest possible result is 7.",
      "output_format": "For each test case print a single line contains $ \\textbf{the smallest} $ possible sum for the corresponding test case.",
      "samples": [
        {
          "input": "1\n4\n20 1 9 4\n",
          "output": "7\n\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n;\n        cin >> n;\n\n        int arr[n];\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n        }\n\n        int m = arr[0] - 0;\n        int ans = 1e9;\n        for (int i = 0; i<n; i++) \n        {\n            ans = min(ans, m + arr[i] + i);\n            m = min(m, arr[i] - i);\n        }\n        \n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Smallest Pair",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Find the number of diagonals in the Convex <i>N</i>-gon.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long mod = 1000000007;\n\nvoid solve() {\n  long long n;\n  cin >> n;\n  long long ans = (n * (n - 1)) / 2 - n;\n  cout << (ans % mod) << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long _t;\n  cin >> _t;\n  while (_t--) solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:23:57.648598+00:00"
      },
      "hints": {
        "hint1": "Choose $2$ points as opposite ends of diagonals, but sides are not diagonal",
        "hint2": "If we combinatorially formulate Hint 1, we get ${N\\choose2} - N$.",
        "solution_approach": "$({N\\choose2} - N)\\% 1000000007$.\n\nTime Complexity : $O(1)$"
      },
      "id": 68,
      "input_format": "<p>The first line contains <i>T</i> (1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>T</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 100000), the number of test cases.<br>Each of the next <i>T</i> lines contains a positive integer <i>N</i> denoting the number of sides of convex polygon (3 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>N</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>9</sup>).</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<figure class=\"image\"><img src=\"https://lh6.googleusercontent.com/raeG_AVhmc_YQbwMQlZ5G4tKqP52vZJhIqWGtDC1o9l87w1U0crsIBn5iI_9ZmjRDG7b7GoD79AXs1k4H_ukwdwckLpIO2loNc_l1OD3ve7T1O4RwH87UtwPdB4RjexDG_LD37KW\"></figure>",
      "output_format": "<p>For each test case, print a single number denoting the number of diagonals in the convex N-gon. Since answer can be large, print it with modulo 1000000007.</p>",
      "samples": [
        {
          "input": "2\n4\n5",
          "output": "2\n5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Number of Diagonals",
      "video_editorial_id": 10672
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given $Q$ queries and have to perform the following operations:\n\n1. **add x** - If $x$ doesn't exist in the set, add element $x$ to the set. Otherwise, do nothing.  \n2. **remove x** - Remove element $x$ from the set, if it exists. Otherwise, do nothing.  \n3. **find x** - Find the value at position $x$ (0-indexing) if it exists. Otherwise, print -1.  \n4. **findpos x** - Find the position (0-indexing) of the element with value $x$ if it exists. Otherwise, find the position where the element $x$ would be in the set.\n\nThe set is ordered in non-decreasing order of the elements.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$1 \\leq Q \\leq 10^5$  \n\n$1 \\leq x \\leq 10^5$  \n\nIt is guaranteed that the sum of $Q$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag,\n             tree_order_statistics_node_update>\n    ordered_set;\n/*\n    order_of_key (k)\n    find_by_order(k)\n*/\n\nsigned main() {\n  // freopen(\"IN\", \"r\", stdin);\n  // freopen(\"OUT\", \"w\", stdout);\n\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  int T;\n  cin >> T;\n\n  while (T--) {\n    int Q;\n    cin >> Q;\n\n    ordered_set s;\n\n    while (Q--) {\n      string op;\n      int x;\n      cin >> op >> x;\n\n      if (op == \"add\") {\n        s.insert(x);\n      } else if (op == \"remove\") {\n        if (s.find(x) != s.end()) {\n          s.erase(s.find(x));\n        }\n      } else if (op == \"find\") {\n        if (x >= (int)s.size()) {\n          cout << \"-1\\n\";\n        } else {\n          cout << *(s.find_by_order(x)) << \"\\n\";\n        }\n      } else {\n        cout << s.order_of_key(x) << \"\\n\";\n      }\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:15:32.901546+00:00"
      },
      "hints": {
        "hint1": "For inserting and removing elements from set you already know the stl functions.What about finding element at position `x` and finding position of element `x`.",
        "hint2": "Set does not store the elements in a contiguous fashion in memory, so accessing an element at a position x is not possible like we do in vectors.",
        "solution_approach": "### add x\n `insert(x)` for inserting element x in the set.\n \n### remove x\nUse `erase(x)` for deleting element x from the set.\n\nIn this code, we use the GNU Policy-Based Data Structures library to implement the ordered set. The `tree_order_statistics_node_update` class provides the necessary functions for maintaining the order of the set and querying for the position of an element. The `order_of_key` function returns the number of elements in the set that are strictly less than the given element, while the `find_by_order` function returns an iterator to the element at the given position.\n\n### find x\nUse `find_by_order(x)` for finding the iterator to the xth location. It takes $O(\\log N)$ in place of the linear $O(N)$ time which we would have encountered if we did a complete traversal of the set.\n### findpos x\nUse `order_of_key(x)` to find the index of the element x, if x doesn’t exist it finds the position that the element would have in the set. It takes $O(\\log N)$ in place of the linear $O(N)$ time which we would have encountered if we did a complete traversal of the set.\nTime Complexity per test case: $O(Q \\log N)$"
      },
      "id": 367,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\n\nThe first line of each test case contains one integer $Q$ - the number of queries.\n\nEach of the next $Q$ lines contains a query.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "1. Set becomes: [4]  \n2. Set becomes: [1, 4]  \n3. Set becomes: [1, 4, 6]  \n4. $S[1] = 4$  \n5. 7 doesn’t exist in the set, but if it did, the set would be: [1, 4, 6, 7] and $S[3] = 7$  \n6. $S[3] = 6$",
      "output_format": "For each test case, print the required queries.",
      "samples": [
        {
          "input": "1\n6\nadd 4\nadd 1\nadd 6\nfind 1\nfindpos 7\nfindpos 6",
          "output": "4\n3\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Indexed Set",
      "video_editorial_id": 10686
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers and <i>Q</i> queries. In each query two integers <i>L</i>, <i>R</i> is given, you have to find (<i>A[L] + A[L+1] + A[L+2] + A[L+3]...A[R]</i>) % 10^9+7.<br>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\ntypedef long long ll;\nconst int N = 1000001;\nint arr[N];\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ll n, q;\n  cin >> n >> q;\n  for (int i = 1; i <= n; i++) cin >> arr[i];\n  ll prefixSum[n + 1];\n  prefixSum[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    prefixSum[i] = prefixSum[i - 1] + arr[i];\n    if (prefixSum[i] < 0) prefixSum[i] += mod;\n    if (prefixSum[i] >= mod) prefixSum[i] -= mod;\n  }\n  while (q--) {\n    ll l, r;\n    cin >> l >> r;\n    ll ans = prefixSum[r] - prefixSum[l - 1];\n    if (ans < 0) ans += mod;\n    if (ans >= mod) ans -= mod;\n    cout << ans << \"\\n\";\n  }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:37:16.975741+00:00"
      },
      "hints": {
        "hint1": "Calculate prefixSum array where prefixSum[i] = (A[1] + A[2] + A[3]...A[i]).",
        "hint2": "For each query, answers will be prefixSum[R]-prefixSum[L-1]. \n\nTake the modulus properly.",
        "solution_approach": "Check the video solution - Prefix Sum Concept."
      },
      "id": 18,
      "input_format": "<p>The first line contains two space-separated integers <i>N</i>, <i>Q</i> where 1&lt;=<i>N</i>&lt;=10^6, 1&lt;=<i>Q</i>&lt;=10^6.</p><p>Next line contains <i>N</i> space-separated integers (-1e9&lt;=<i>A<sub>i</sub></i>&lt;=1e9).</p><p>Next <i>Q</i> lines contain two space-separated integers <i>L</i>, <i>R</i> where 1&lt;=<i>L</i>&lt;=<i>R</i>&lt;=<i>N</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>For each query print the value of (<i>A[L] + A[L+1] + A[L+2] + A[L+3]...A[R]</i>) % 10^9+7 in a new line.</p>",
      "samples": [
        {
          "input": "10 10\n12 -23 -123 2345 2345 44 345 -93945 -5353 1\n1 5\n1 8\n1 10\n2 2\n6 6\n4 8\n2 9\n4 10\n3 6\n5 9",
          "output": "4556\n999911007\n999905655\n999999984\n44\n999911141\n999905642\n999905789\n4611\n999903443"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "LR Sum Query",
      "video_editorial_id": 10660
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Given a grid of size n*m, you need to find the number of paths from (1, 1) to (n, m). You are allowed to move from (x, y) to (x+1, y) and (x, y) to (x, y+1). You cannot move more than K consecutive right moves. The grid may have some blocked cells, represented by 1, and it is not allowed to move to a blocked cell. An empty cell is represented by 0.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ t ≤ 10<sup>5</sup></p><p>1 ≤ n, m, k ≤ 200</p><p>0 ≤ aij ≤ 1</p><p>It is guaranteed that the sum of n*m*k over all test cases does not exceed 10<sup>8</sup>.</p>",
      "editorial_code": [
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int mod = 1e9 + 7;\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        int n, m, k;\n        cin >> n >> m >> k;\n        bool grid[n+1][m+1] = {};\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= m; ++j) {\n                cin >> grid[i][j];\n            }\n        }\n        if(grid[1][1]) {\n            cout << \"0\\n\";\n            continue;\n        }\n        int dp[n+1][m+1][k+1];\n        memset(dp, 0, sizeof(dp));\n        dp[1][1][0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= m; ++j) {\n                if(!grid[i][j]) {\n                    for (int l = 0; l <= k; ++l) {\n                        dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][l])%mod;\n                        if(l) {\n                            dp[i][j][l] = (dp[i][j][l] + dp[i][j-1][l-1])%mod;\n                        }\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for (int l = 0; l <= k; ++l) {\n            ans = (ans + dp[n][m][l])%mod;\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n\n\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nusing lli = long long;\n\nconst lli mod = 1e9+7;\n\nlli n,m,k;\nlli grid[202][202];\nlli previousBlock[202][202];\n\nlli ways(lli i,lli j);\n\nlli prefix[202][202];\nlli getPrefix(int row,int col){\n\t// rowwise prefix sum of the main dp for optimization. \n\tif(row<0||col<0)return 0;\n\tif(prefix[row][col]!=-1){\n\t\treturn prefix[row][col];\n\t}\n\treturn prefix[row][col] = (getPrefix(row,col-1)+ways(row,col))%mod;\n}\n\nlli dp[202][202];\nlli ways(lli i,lli j){// reach (i,j) with a down move\n\tif(i<0||j<0||grid[i][j]==1)return 0;\n\tif(i==0&&j==0)return 1;\n\telse if(i==0)return 0; //  imp so that i-1 doesn't give error (we need some previous row anyways)\n\t\n\tif(dp[i][j]!=-1){\n\t\treturn dp[i][j];\n\t}\n\tint cole = j; //  finding a range in the previous row such that \n\tint cols = max(j-k-1,previousBlock[i-1][j]); // in the previous row, from which cells can we come to this with a down move.\n\t// now use the prefix sum to get the value fast.\n\treturn dp[i][j] = (getPrefix(i-1,cole)-getPrefix(i-1,cols)+mod)%mod;\n}\n\nvoid solve(){\n\tcin>>n>>m>>k;\n\tfor(lli i=0;i<n;i++){\n\t\tlli last = -1;\n\t\tfor(lli j=0;j<m;j++){\n\t\t\tcin>>grid[i][j];\n\t\t\tif(grid[i][j]==1){\n\t\t\t\tlast = j;\n\t\t\t}\n\t\t\tpreviousBlock[i][j] = last;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[i][j] = prefix[i][j] = -1;\n\t\t}\n\t}\n\tint cole = m-1;\n\tint cols = max(m-1-k-1,previousBlock[n-1][m-1]);\n\tlli ans = (getPrefix(n-1,cole)-getPrefix(n-1,cols)+mod)%mod;\n\tcout<<ans<<endl;\n}\t\n\nsigned main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tlli _t;cin>>_t;while(_t--)\n\tsolve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:25:19.296573+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">The cell (i, j) can only be reached from the cells (i-1, j) and (i, j-1). Consider both the cases for right and down moves separately.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">When cell (i, j) is reached from (i-1, j), the count of consecutive right moves becomes zero and when the cell(i, j) is reached from (i, j-1), the count of consecutive right moves becomes one more than the count of consecutive right moves for (i, j-1).</span></p>",
        "solution_approach": "<p>Find the number of paths from (1, 1) to (i, j) using the cells (i-1, j) and (i, j-1). Define dp[i][j][l] which denotes the number of paths to reach (i, j) with l consecutive right moves. The number of paths for arriving at an unblocked cell (i, j) can be found separately for right and down moves. When cell (i, j) is reached from cell (i-1, j), dp[i][j][0] += dp[i-1][j][l] where 0 ≤ l ≤ k. When cell (i, j) is reached from cell (i, j-1), dp[i][j][l] += dp[i][j-1][l-1] where 1 ≤ l ≤ k. The base case would be at cell (1, 1), there is only one way to reach it. Since at most k consecutive right moves can be there, the final answer would be, Σdp[n][m][l] from 0 ≤ l ≤ k.</p><p>Time Complexity per test case: O(n*m*k)</p><p>Another approach is to use optimization of prefix sum of previous rows:</p><p>DP(row, col) → number of ways to reach the (row, col) such that the last move down moved.</p><p>This will be like a sum of K cells of the previous row. Look into the code for more details.</p>"
      },
      "id": 499,
      "input_format": "<p>The first line of the input contains one integer t - the number of test cases. Then t test cases follow.</p><p>The first line of each test case contains three space-separated integers n, m, k - the size of the grid and the number of right moves you can make.</p><p>Each of the following n lines contains m space-separated integers, aij - the number at that cell.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the second test case, there is only one path with 2 consecutive right moves, so the answer is 0.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, the following 2 paths are possible: (1,1) → (1,2) → (2,2) → (2,3) and (1,1) → (2,1) → (2,2) → (2,3).</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the number of paths modulo 10^9 + 7.</span></p>",
      "samples": [
        {
          "input": "3\n3 3 1\n0 0 0\n0 0 0\n0 0 0\n3 3 1\n0 1 0\n0 1 0\n0 0 0\n2 3 2\n0 0 1\n0 0 0",
          "output": "3\n0\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Number of Paths in Grid - 3",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two numbers $X$ and $Y$. Print the summation and $\\textbf{multiplication}$ and $\\textbf{subtraction}$ of these $2$ numbers.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq X,Y \\leq 10^5 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int x, y;\n    cin >> x >> y;\n    cout << x << \" + \" << y << \" = \" << x + y << endl;\n    cout << x << \" * \" << y << \" = \" << 1ll * x * y << endl; // multiply by 1ll to convert int to long long\n    cout << x << \" - \" << y << \" = \" << x - y << endl;\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:33:20.664240+00:00"
      },
      "hints": {
        "hint1": "Use simple addition, subtraction and multiplication operations.",
        "hint2": "",
        "solution_approach": "In addition and subtraction, the answer is simple and they also fit into a _32-bit integer_ but the problem arises in multiplication because in the worst case, the multiplication answer may overflow so at first we have to convert the _32-bit integers_ into _64-bit integers_ and then multiply them. </br>\n\nThe time and Space Complexity of this approach is $O(1)$ because $\\textbf{summation}$, $\\textbf{multiplication}$ and $\\textbf{subtraction}$ all are constant time and space operations."
      },
      "id": 1174,
      "input_format": "Only one line containing two separated numbers $X$ and $Y$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print 3 lines that contain the following in the same order: \n\n1. \"X + Y = summation result\" without quotes.\n2. \"X * Y = multiplication result\" without quotes.\n3. \"X - Y = subtraction result\" without quotes.",
      "samples": [
        {
          "input": "5 10\n",
          "output": "5 + 10 = 15\n5 * 10 = 50\n5 - 10 = -5\n"
        },
        {
          "input": "17 2\n",
          "output": "17 + 2 = 19\n17 * 2 = 34\n17 - 2 = 15\n"
        },
        {
          "input": "12345 54321\n",
          "output": "12345 + 54321 = 66666\n12345 * 54321 = 670592745\n12345 - 54321 = -41976"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Simple Calculator",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an integer N and a decimal number M. M can be represented as Y.Z where . is the decimal point and N as X. You have to find (Z+X).(Y+X)",
      "complete_approach": "",
      "constraints": "<p>1≤ T ≤ 10<sup>6</sup></p><p>1≤ N, M ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp \n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); \n\nint main() { // Correct the return type of main here\n    IOS int t; cin >> t;\n\n    string s;\n    // Add a dummy getline to clear the effect of cin.\n    getline(cin, s); \n    while (t--) {\n        // Take the full expression in string s\n        // s now contains N M\n        getline(cin, s);\n        // We make 3 part strings x, y, z so that N=x, M=y.z, z is the fractional part.\n        \n        string x, y, z;\n        bool doub = 0; // Flag to check if we have seen the space to know if we are now processing M.\n        bool dot = 0;  // Flag to check if we are now processing the z part.\n        for (int i = 0; i < s.size(); ++i) {\n            if(s[i] == ' ') { // If ' ' seen in s, now put things in y and z\n                doub = 1;\n            }\n            else if(s[i] == '.') { // If '.' seen in s, now put things in z.\n                dot = 1;\n            }\n            else if(!doub) { // If not seen ' ', keep adding at the end of x.\n                x += s[i];\n            }\n            else if(!dot) {\t// If seen ' ' and not '.', keep adding at the end of y.\n                y += s[i];\n            }\n            else { // If seen '.', keep adding at the end of z.\n                z += s[i];\n            }\n        }\n        int x1 = stoll(x), y1 = stoll(y), z1 = stoll(z); // Convert the strings into numbers\n        z1 += x1; // Do what is asked in the questions.\n        y1 += x1;\n        cout << z1 << \".\" << y1 << \"\\n\"; // Print two parts separately only, no need to create a float number.\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:24:50.810660+00:00"
      },
      "hints": {
        "hint1": "<p>Process the numbers in the string to get the floating-point.</p>",
        "hint2": "Imagine you have two numbers. The first one is a whole number, which we'll call \"N\" (like 3, 4, 5, etc.), and the second one is a number with a decimal point, which we'll call \"M\". For example, if M is 12.34, it has two parts: the part before the decimal point is \"Y\" (which is 12 in our example), and the part after the decimal point is \"Z\" (which is 34 here).\n\nNow, the question asks you to do a little bit of math with these numbers. You're supposed to add the whole number \"N\" to both parts of the decimal number \"M\" separately and then combine them back into a new number with a decimal point. So, if we're adding N to Z and Y (following our example, let's say N is 5), you'd do this:\n\n1. Add N to Z: If Z is 34 and N is 5, you add them to get 39.\n2. Add N to Y: If Y is 12 and N is 5, you add them to get 17.\n3. Now, put them back together with a decimal point to get the new number, which in this example would be 39.17.\n\nThat's the essence of what you're being asked to do: take a whole number and a decimal number, add the whole number to both parts of the decimal number separately, and then put those results back together to form a new decimal number.\n\nTo make it a bit more formal:\n\n1. **Input:** The problem starts by telling you how many times (T) you're going to do this operation. For each time, you are given a whole number (N) and a decimal number (M, which is made up of Y and Z).\n\n2. **Process:** For each pair of numbers you're given, you do the math as described: (Z+N).(Y+N).\n\n3. **Output:** You write down the result for each pair of numbers after doing the calculation.\n\nIt's a bit like a recipe where you're given ingredients (N and M) and steps to follow (add N to parts of M), and in the end, you present the dish (the calculated result).",
        "solution_approach": "Use stoll() to convert string to long long and getline(cin, string) to input string with spaces in a single line.\nTime Complexity per test case: O(1)\n\n*Note:* We must take the input in string format for the decimal number to solve this problem. Avoid using floating point numbers as much as possible, specifically when precision is important like in this problem. Because 2 can be stored as 1.99999999999 in the system. And it'll affect the logic."
      },
      "id": 338,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer N and a decimal number M.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, X = 14, Y = 1, Z = 2. So ans = (2+14).(1+14) = 16.15\n\nFor the second test case, X = 3, Y = 4, Z = 5. So ans = (5+3).(4+3) = 8.7\n\nFor the third test case, X = 31, Y = 0, Z = 143. So ans = (143+31).(0+31) = 174.31",
      "output_format": "For each test case, print the value of (Z+X).(Y+X)",
      "samples": [
        {
          "input": "3\n14 1.2\n3 4.5\n31 0.143\n",
          "output": "16.15\n8.7\n174.31\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "IO Problem AZ101",
      "video_editorial_id": 10687
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You may recall that an array $arr$ is a mountain array if and only if:\n\n- $arr.length \\geq 3$\n- There exists some index $i$ ($0$-indexed) with $0 < i < arr.length - 1$ such that:\n    $arr[0] < arr[1] < ... < arr[i - 1] < arr[i]$\n    $arr[i] > arr[i + 1] > ... > arr[arr.length - 1]$\n\nGiven an integer array​​​, output the minimum number of elements to remove to make $arr$​​​ a mountain array.\nIf mountain array is not possible, output -1.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 1000$\n$1 \\leq n \\leq 10^{4}$\n$1 \\leq arr[i] \\leq 10^{6}$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\n\nvoid solve() {\n\tint n, ans = 0;\n\tcin >> n;\n\tvector<int> nums(n);\n\tfor (int i = 0; i < n; i++)cin >> nums[i];\n\tvector<int> dp1(n), dp2(n), lis, lds;\n\tfor (int i = 0; i < n; i++) {\n\t\tauto it = lower_bound(lis.begin(), lis.end(), nums[i]);\n\t\tif (it != lis.end())*it = nums[i], dp1[i] = (it - lis.begin()) + 1;\n\t\telse lis.push_back(nums[i]), dp1[i] = lis.size();\n\t}\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tauto it = lower_bound(lds.begin(), lds.end(), nums[i]);\n\t\tif (it != lds.end())*it = nums[i], dp2[i] = it - lds.begin() + 1;\n\t\telse lds.push_back(nums[i]), dp2[i] = lds.size();\n\t\tif (dp1[i] >= 2 && dp2[i] >= 2)ans = max(ans, dp1[i] + dp2[i] - 1);\n\t}\n\tif (ans == 0)cout << -1 << endl;\n\telse cout << n - ans << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:23:32.990521+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "The basic idea of this problem is that the minimum number of removals to make a mountain array is equal to $arr.length-(longest$ $mountain$ $subsequence)$. We can calculate the longest mountain subsequence by first calculating the $LIS$ from the left and the right and storing the answers in $dpLeft$ and $dpRight$. Then consider each $0 < i < n$ to be the middle of a mountain subsequence only if $dpLeft[i]>1$ and $dpRight[i]>1$ the length of this mountain subsequence is $dpLeft[i]+dpRight[i]-1$ (we subtract $1$ to not double count the middle element)\n\n**Time Complexity** : $O(n*logn)$"
      },
      "id": 917,
      "input_format": "First-line contains $T$ - the number of test cases.\nFirst-line of each test case contains $n$ - the length of the array $arr$.\nSecond-line of each test case contains $n$ elements of array $arr$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the minimum number of elements to remove to make $arr$​​​ a mountain array.\nIf mountain array is not possible, output -1.",
      "samples": [
        {
          "input": "3\n3\n1 5 1\n8\n2 1 1 5 6 2 3 1\n5\n1 2 3 4 5\n",
          "output": "0\n3\n-1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Mountain Array II",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(74,74,74);\">For a (possibly empty) sequence of positive integers <i>S</i>, mex is defined as <i>f</i>(<i>S</i>) as the smallest positive integer that does not appear in <i>S</i>. For example, <i>f</i>([]) = 1, <i>f</i>([3,4,3,5]) = 1, <i>f</i>([2,5,1,1,2,3]) = 4.</span></p><p><span style=\"background-color:rgb(255,255,255);color:rgb(74,74,74);\">You have given a sequence of <i>N</i> integers <i>A<sub>1</sub>, A<sub>2</sub>, …, A<sub>N</sub></i>. Your task is to find the sum of <i>f</i>(<i>S</i>) over all 2<i><sup>N</sup></i> possible subsequences <i>S</i> of this sequence.</span></p><p><span style=\"background-color:rgb(255,255,255);color:rgb(74,74,74);\">Since the resulting sum can be very big, compute it modulo 998244353.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>T </i>≤ 10<br>1 ≤ <i>N </i>≤ 10<sup>5</sup><br>1 ≤ <i>A<sub>i</sub> </i>≤ 10<sup>9</sup> for each valid <i>i</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 200010;\nconst int MOD = 998244353;\n\nint t, n; \nll two[N], a[N], freq[N], sf[N];\n\nint main() {\n  two[0] = 1;\n  for (int i = 1; i < N; ++i) two[i] = 2 * two[i - 1] % MOD;\n  cin >> t;\n  while (t--) {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t  scanf(\"%lld\", a + i);\n\t  ++freq[min(a[i], n + 1LL)];\n\t}\n\tsf[n + 69] = 0;\n\tfor (int i = n + 68; i; --i) sf[i] = sf[i + 1] + freq[i];\n\tll ans = 0, pf = 1;\n\tfor (ll i = 1; i <= n + 1; ++i) {\n\t  ans = (ans + i * (pf * two[sf[i + 1]] % MOD)) % MOD;\n\t  pf = pf * (two[freq[i]] - 1) % MOD;\n\t}\n\tans += MOD, ans %= MOD;\n\tprintf(\"%lld\\n\", ans);\n\tfor (int i = 0; i <= n + 69; ++i) freq[i] = 0;\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:40:23.765163+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">The mex of a subsequence of length <i>N</i> cannot exceed <i>N</i>. So we can replace all elements greater than <i>N</i> with <i>N</i>.</span></p>",
        "hint2": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">Fixing the value of mex, let’s try to count the number of subsequences with specific mex.</span></p>",
        "solution_approach": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">The mex of a subsequence of length <i>N</i> cannot exceed <i>N</i>. So we can replace all elements greater than <i>N</i> with <i>N</i>.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">Fixing the value of mex, let’s try to count the number of subsequences with specific mex.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">For a given mex, we need each positive value smaller than mex to be present at least once, value mex shouldn’t be present, and values greater than mex do not affect us.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">If <i>f<sub>x</sub></i>​ denote the frequency of value <i>x</i>, the number of non-empty subsets of these <i>f<sub>x</sub></i>​ elements is 2<i><sup>f</sup><sub><sup>x</sup></sub></i>​−1. We need to select one of the subsets for each <i>x</i> less than current mex, giving us (2<sup>f1</sup> - 1) * (2<sup>f2</sup> - 1)&nbsp;<i> …. * </i>(2<sup>f(x-1)</sup> - 1).</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">To consider elements greater than mex, we can take any subset of those. If there are <i>y</i> elements greater than mex, it contributes 2<i><sup>y</sup></i> subsets for each choice of subsets of smaller values.</span></p>"
      },
      "id": 202,
      "input_format": "<p>The first line of the input contains a single integer <i>T</i> denoting the number of test cases. The description of <i>T</i> test cases follows.<br>The first line of each test case contains a single integer <i>N</i>.<br>The second line contains <i>N</i> space-separated integers <i>A<sub>1</sub>, A<sub>2</sub>, …, A<sub>N</sub></i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><strong>Example case 1:</strong> The values for all possible subsequences are <i>f</i>([]) = 1, <i>f</i>([1]) = 2, <i>f</i>([1]) = 2, <i>f</i>([1,1]) = 2.</p><p><strong>Example case 2:</strong> The values for all possible subsequences are <i>f</i>([]) = 1, <i>f</i>([1]) = 2, <i>f</i>([2]) = 1, <i>f</i>([1]) = 2, <i>f</i>([1,2]) = 3, <i>f</i>([2,1]) = 3, <i>f</i>([1,1]) = 2, <i>f</i>([1,2,1]) = 3.</p>",
      "output_format": "<p>For each test case, print a single line containing one integer ― the sum of <i>f</i>(<i>S</i>) over all subsequences modulo 998244353.</p>",
      "samples": [
        {
          "input": "2\n2\n1 1\n3\n1 2 1",
          "output": "7\n17"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Tough Mex",
      "video_editorial_id": 8168
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Find the number of unordered pairs of intersecting diagonals in the Convex <i>N</i>-gon. The intersecting point should be inside the polygon.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define int long long int\n#define mod 1000000007\nconst int size = 1000002;\n\nint bin_pow(int a, int b) {  // required since answer needs to be in modulo\n  int ans = 1;\n  while (b) {\n    if (b % 2 == 1) ans = (ans * a) % mod;\n    a = (a * a) % mod;  // since we needed to take %, we did not take a*=a;\n    b /= 2;\n  }\n  return ans;\n}\n\ninline int mul(int a, int b) {  // preventing multiplication overflow\n  return (a * b) % mod;\n}\n\nvoid solve() {\n  // time complexity:O(log N)\n  // space complexity:O(1)\n  int N;\n  cin >> N;\n  int answer = mul(N, N - 1);\n  answer = mul(answer, N - 2);\n  answer = mul(answer, N - 3);\n  answer = mul(answer, bin_pow(24, mod - 2));  // O(log N)\n  if (answer < 0) answer += mod;\n  cout << answer % mod << endl;\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:43:51.338108+00:00"
      },
      "hints": {
        "hint1": "Choose 4 points as opposite ends of diagonals. Now can you draw 2 diagonals using these 4 points, s.t. they intersect inside the polygon.",
        "hint2": "If we combinatorially formulate Hint 1, we get ${N\\choose4} $.",
        "solution_approach": "${N\\choose4} \\% 1000000007$.  \n\nTime Complexity : $O(\\log N)$"
      },
      "id": 69,
      "input_format": "<p>The first line contains <i>T</i> (1 ≤ <i>T</i> ≤ 100000), the number of test cases.<br>Each of the next <i>T</i> lines contains a positive integer <i>N</i> denoting the number of sides of convex polygon (3 ≤ <i>N</i> ≤ 10<sup>9</sup>).</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>(1, 2)</p><p><i><strong>Explanatino 2:</strong></i><br>(1, 3), (1, 5), (2, 3), (2, 4), (4, 5)</p><figure class=\"image\"><img src=\"https://lh4.googleusercontent.com/Y_IFXMFo7Qnr3L72adAP-KtmYyihFb2vJSrO8mAdH1qMrWxyzWQdDxEN48eNPoHyMFt0K0RQy72gs5pWIsxciMXVh9afUQm7LDY_-J5fOEkY450HwJWS6p1s5H-XlL6PCXgr75li\"></figure>",
      "output_format": "<p>For each test case, print a single number denoting the number of intersecting diagonals in the convex <i>N</i>-gon. Since answer can be large, print it with modulo 1000000007.</p>",
      "samples": [
        {
          "input": "2\n4\n5",
          "output": "1\n5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Number of Intersecting Diagonals",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">There are <strong>n</strong> stones. Initially, you are at stone 1 and you want to reach stone n. You can jump from one stone to another. The maximum length of the jump that you can make from each stone is given in input as an array of <strong>n </strong>integers.</span><br><span style=\"background-color:transparent;color:#000000;\">For example, if the maximum length of jump you can make from stone 1 is 2, you can jump to stone 2 and stone 3 from stone 1. You cannot jump to stone 4 from stone 1 because the length of this jump will be 3 which is greater than the maximum jump allowed from stone 1.</span><br><span style=\"background-color:transparent;color:#000000;\">You need to determine if you will be able to reach the last stone <strong>n</strong> by any set of valid jumps.</span></p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= n &lt;= 100000\n0 &lt;= jump[i] &lt;= 100000</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isReach(vector<int> jump)\n{\n\tint n = (int)jump.size();\n\tint reach = 1; // maximum stone that can be reached\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (reach >= i)\n\t\t{\n\t\t\treach = max(reach, jump[i - 1] + i);\n\t\t}\n\t}\n\treturn reach >= n;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> jump(n);\n\tfor (auto &i : jump)\n\t\tcin >> i;\n\n\tif (isReach(jump))\n\t\tcout << \"Yes\\n\";\n\telse\n\t\tcout << \"No\\n\";\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:19:07.553880+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Do we ever need to jump backwards?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">If we can reach a stone i we can reach all stones less than i.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">We maintain a variable <strong>reach</strong> that stores the maximum stone that we can reach. If we can reach a stone x, we can reach all stones &lt; x because the length of jumps required to reach those cells will always be smaller. So we never need to jump backward.</span><br><span style=\"background-color:transparent;color:#000000;\">We iterate from the first stone to the last one and maintain the maximum stone that can be reached. If we are at stone <strong>i</strong> and <strong>reach &gt;= i</strong> means that we can reach stone <strong>i</strong>. So at index <strong>i</strong> we can update <strong>reach</strong> with the following equation:</span></p><p><span style=\"background-color:transparent;color:#000000;\">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <strong>reach = max(reach, i + jump[i])</strong></span></p><p><span style=\"background-color:transparent;color:#000000;\">If after traversing all the stones <strong>reach &gt;= n</strong>, then we can reach the last stone.</span></p>"
      },
      "id": 616,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains a single integer <strong>n</strong>.</span><br><span style=\"background-color:transparent;color:#000000;\">The second line contains <strong>n</strong> space-separated integers denoting the length of the maximum jump allowed for each stone.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<ol><li><span style=\"background-color:transparent;color:#000000;\">Jump from stone 1 to stone 3 and then to stone 6.</span></li><li><span style=\"background-color:transparent;color:#000000;\">No matter what jumps you make, you will get stuck at stone 4 and never reach stone 6.</span></li></ol>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print ‘<strong>Yes</strong>’ if you can reach the last stone and ‘<strong>No</strong>’ otherwise.</span></p>",
      "samples": [
        {
          "input": "6\n2 1 3 1 1 1",
          "output": "Yes"
        },
        {
          "input": "6\n3 1 1 0 1 1",
          "output": "No"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nbool isReach(vector<int> jump)\n{\n\t// Complete the function\n}\n\n<fix>\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> jump(n);\n\tfor (auto &i : jump)\n\t\tcin >> i;\n\n\tif (isReach(jump))\n\t\tcout << \"Yes\\n\";\n\telse\n\t\tcout << \"No\\n\";\n\treturn 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Stone Jumps",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Gotham is in ruins. After the destruction caused by the Joker's latest rampage, the city is in chaos. Bruce Wayne has returned as Batman and has neutralised most of the Joker's associates. However, the city needs to be rebuilt and most of the people need urgent medical attention. City's prominent Gotham General hospital has already been blown up by the Joker. Hence instead of building one large hospital which may easily become the next target for the Joker, Batman asks the mayor to build small clinics throughout the city.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The city consists of <i>N</i> blocks. The mayor also has to ensure that every block has access to at least one clinic. The connectivity is established by repairing the existing roads.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The cost to build a new clinic is <i>C</i> and to repair a road is <i>r</i>.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">Since you are working for the Mayor and want to help the Batman, your job is to find the minimum cost such that for every block in the city.&nbsp;</span></p><ul><li><span style=\"background-color:transparent;color:#000000;\">Either there is a clinic in the block&nbsp;</span></li><li><span style=\"background-color:transparent;color:#000000;\">Or the block has a path via repaired roads to a block with a clinic.</span></li></ul><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "<ul><li><span style=\"background-color:transparent;color:#000000;\"><i>1 ≤ T ≤ 10</i></span></li><li><span style=\"background-color:transparent;color:#000000;\"><i>1 ≤ N ≤ 10<sup>5</sup></i></span></li><li><span style=\"background-color:transparent;color:#000000;\"><i>0 ≤ R ≤ 10<sup>5</sup></i></span></li><li><span style=\"background-color:transparent;color:#000000;\"><i>1 ≤ x, y ≤ N, x != y</i></span></li><li><span style=\"background-color:transparent;color:#000000;\"><i>0 ≤ c ≤ 10<sup>9</sup></i></span></li><li><span style=\"background-color:transparent;color:#000000;\"><i>0 ≤ r ≤ 10<sup>9</sup></i></span></li></ul>",
      "editorial_code": [
        {
          "code": "```cpp\n// the logic is:\n// if(c<r) build clinics in each hall\n// else build a clinic in any node and x-1 roads\n// in a connected component\n// where x is the number of nodes in that component.\n// USE DFS\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int lli;\nlli N, R, c, r, col;\nvector<vector<lli>> g;\nvector<lli> vis;\nvoid dfs(lli node) {\n  vis[node] = col;\n  for (auto i : g[node]) {\n    if (!vis[i])\n      dfs(i);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> N >> R >> c >> r;\n    g.resize(N + 1);\n    vis.resize(N + 1);\n    for (int i = 1; i <= R; ++i) {\n      lli x, y;\n      cin >> x >> y;\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n    lli ans = 0;\n    if (c < r)\n      ans = N * c;\n    else {\n      col = 1;\n      for (int i = 1; i <= N; ++i) {\n        if (!vis[i]) {\n          dfs(i);\n          col++;\n        }\n      }\n      lli comp_cnt = col - 1;\n      vector<lli> f(comp_cnt + 1);\n      for (int i = 1; i <= N; ++i) {\n        f[vis[i]]++;\n      }\n      for (int i = 1; i <= comp_cnt; ++i) {\n        ans += c;\n        ans += (r * (f[i] - 1));\n      }\n    }\n    cout << ans << '\\n';\n    g.clear();\n    vis.clear();\n  }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:36:36.145097+00:00"
      },
      "hints": {
        "hint1": "<p>Use DFS</p>",
        "hint2": "<p>If(c&lt;r) build clinics in each hall, else build a clinic in any node and x-1 roads in a connected component where x is the number of nodes in that component.</p>",
        "solution_approach": "<p>If <i>c&lt;r</i> =&gt; <strong>ans=N*c</strong>,</p><p>else, Do DFS and find the number of nodes in each connected component of the graph. Hence,</p><p>for each connected component,</p><p><strong>ans += c + (component.size() - 1) * r</strong></p><p><strong>Time Complexity : O(N)</strong></p><p><strong>Space Complexity : O(N)</strong></p>"
      },
      "id": 866,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">First-line comprises T - the number of test cases.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For each test case, the first line comprises four space-separated integers N R c r - number of blocks, number of roads, the cost for building a clinic, the cost for repairing a road.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">Next R lines comprise 2 space-separated integers <i>x, y</i> - denoting road connection(undirected) between block <i>x</i> and block <i>y.</i></span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\"><strong>Explanation</strong></span></p><figure class=\"image\"><img src=\"https://lh4.googleusercontent.com/Dg8LOVWKpRl4Bs3ZcX1LZWAdkIKq9rvn2BZimTXDltaWY8FuH30yOd5AtZRPZQRMSsJCFtypPXkTxIhveEvar1UUxdsE42shleqyfkQELis6neOrGdQathXOB68H-2_XuhmnG62p=s0\" alt=\"Screenshot 2021-03-22 051346.png\"></figure><p><span style=\"background-color:transparent;color:#000000;\">We can build 2 clinics let's say one clinic at block 2, and another at block 4, at the cost of 2 times 3 =6 and repair 3 roads let's say roads 1-2,2-3, and 4-5 at the cost of 3 times 2 =6. Hence the minimum cost =6+6=12.</span></p><p><br>&nbsp;</p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Output the minimum cost for each test case on a new line.</span></p>",
      "samples": [
        {
          "input": "1\n5 4 3 2\n1 2\n2 3\n3 1\n4 5",
          "output": "12"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Gotham rises",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given N elements, in an array A. You can take any 2 consecutive elements a and b and merge them. On merging you get a single element with value (a+b)%100 and this process costs you a*b. After merging you will place this element in place of those 2 elements.<br>&nbsp;</p><p>If the sequence is [A1, A2, A3, A4] and you merge A2 and A3, you incur a cost of A2*A3 and the array becomes [A1, (A2+A3)%100, A4].<br>&nbsp;</p><p>Find the Minimum cost to merge all the elements into a single element.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint arr[501];\nint dp[501][501];\n\nint rec(int l,int r){\n    if(l==r){\n        return 0;\n    }\n    if(dp[l][r]==-1){\n        int ans = 1e9;\n        int tot = 0;\n        for(int i=l;i<=r;i++){\n            tot+=arr[i];\n        }\n        int sum = 0;\n        for(int mid=l;mid<r;mid++){\n            sum += arr[mid];\n            ans = min(ans,rec(l,mid)+rec(mid+1,r)+ ((sum)%100)*((tot-sum)%100));\n        }\n        dp[l][r]=ans;\n    }\n    return dp[l][r];\n}\n\nvoid solve(){\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>arr[i];\n    }\n    memset(dp,-1,sizeof(dp));\n    cout<<rec(0,n-1)<<endl;\n}    \n\nsigned main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //int _t;cin>>_t;while(_t--)\n    solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:37:13.400826+00:00"
      },
      "hints": {
        "hint1": "<p>The answer is going to change as the elements are capped by Modulo. How do you design an efficient DP that takes care of all possible ordering? Think Backwards from 1 element.</p>",
        "hint2": "<p>What if we keep DP(l,r) as the cost to merge the segment into one element, would that help? What would be the final value of the element if we merge range [l,r]?</p>",
        "solution_approach": "<p>The nice observation here is the value of the Final element remains fixed and is the sum of the range %100.</p><p>So we can design a DP with the states<br>DP(l,r) = minimum cost to merge the segment into one element.</p><p>Now range (l,r) will form one element from 2 elements in the final step.<br>So let's say the (l, mid) and (mid+1,r) range equivalents merge and produce the final element.</p><p>So DP(l,r) = min(DP(l,mid) + DP(mid+1,r) + (sum(l,mid)%100)*(sum(mid+1,r)%100) ) for all mid in range [l,r).</p>"
      },
      "id": 161,
      "input_format": "<p>The first line contains a single element N. 1 &lt;= N &lt;= 500</p><p>The Second line contains N space separated integers, the Ai for the Array. &nbsp;0 &lt;= Ai &lt; 100</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>If you merge elements 1 and 2 first, You get [3,4] and pay a cost of 1*2=2. Then if you merge 3 and 3, You get [7] and pay a cost of 3*4=12.</p><p>Total cost incurred = 2+12 = 14.</p><p>If you merge elements 2 and 4 first, You get [1,6] and pay a cost of 2*4=8. Then if you merge 1 and 6, You get [7] and pay a cost of 1*6=6.</p><p>Total cost incurred = &nbsp;8+6 = 14.</p><p>So the best you can do is at cost 14.</p>",
      "output_format": "<p>Output a single integer, the Minimum cost to Merge all the elements.</p>",
      "samples": [
        {
          "input": "3\n1 2 4 ",
          "output": "14"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Merge Elements 1",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "**Check if a binary tree is BST or not.**\n\nA binary search tree (BST) is a node-based binary tree data structure which has the following properties.\n\n- The left subtree of a node contains only nodes with keys less than the node’s key.\n- The right subtree of a node contains only nodes with keys greater than the node’s key.\n- Both the left and right subtrees must also be binary search trees.\n- From the above properties it naturally follows that:\n  - Each node (item in the tree) has a distinct key.",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:20:19.130830+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 671,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N the length of the array representing the serialized representation of a tree.</p><p>The next line contains N-space-separated integers (1 <= N < 10000000).&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Return true/false.</p>",
      "samples": [
        {
          "input": "6\n17\n113169 111387 -1 -1 209114 -1 957726 786099 643981 -1 -1 821914 -1 -1 990181 -1 -1 \n7\n566098 413153 -1 -1 797870 -1 -1 \n3\n964901 -1 -1 \n19\n14136 -1 35825 -1 37940 -1 264128 -1 370052 -1 545817 -1 659383 -1 678544 -1 682492 -1 -1 \n13\n7813 6718 -1 5816 -1 -1 5249 -1 3912 8623 -1 -1 -1 \n15\n8359 8305 9109 6276 -1 -1 6626 -1 -1 2942 -1 -1 8575 -1 -1 ",
          "output": "yes\nyes\nyes\nyes\nno\nno"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n</fix>\nbool isBst(Node* root) {\n    //Complete the function\n}\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin>>n;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++)\n            cin>>arr[i];\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        if(isBst(tree)){\n            cout<<\"yes\\n\";\n        } else {\n            cout<<\"no\\n\";\n        }\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "IsBst",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given Q queries and have to perform the following operations:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">add x - add element x at the end of vector</span></li><li><span style=\"background-color:transparent;color:#000000;\">remove - delete last element of the vector, if vector is not empty</span></li><li><span style=\"background-color:transparent;color:#000000;\">print x - print the x-th character of the vector, if it exists, otherwise print 0. (0-indexing)</span></li><li><span style=\"background-color:transparent;color:#000000;\">clear - empty the vector</span></li></ol>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ Q ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ X ≤ 10<sup>6</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of Q over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>6</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main() {\n  // freopen(\"IN\", \"r\", stdin);\n  // freopen(\"OUT\", \"w\", stdout);\n\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n  int t;\n  cin >> t;\n  while (t--) {\n    int q;\n    cin >> q;\n    vector<int> v;\n    while (q--) {\n      string s;\n      cin >> s;\n      if (s == \"add\") {\n        int x;\n        cin >> x;\n        v.push_back(x);\n      } else if (s == \"remove\") {\n        if (!v.empty()) v.pop_back();\n      } else if (s == \"print\") {\n        int x;\n        cin >> x;\n        if (x < (int)v.size())\n          cout << v[x] << \"\\n\";\n        else\n          cout << \"0\\n\";\n      } else if (s == \"clear\") {\n        v.clear();\n      }\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:21:43.807202+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "* Use `push_back(x)` for inserting at the end of the vector.\n* Use `pop_back()` for deleting the last element of the vector. `v.size()` can be used to obtain the size of the vector and check if the vector is empty or not. Also, `vector.empty()` can be used to check if the vector is empty or not, which returns true if the vector is empty.\n* Use `v.size()` to obtain the size of the vector. If it is greater than `x`, use `v[x]` to access the `x^{th}` element of the vector.\n* Use `v.clear()` for emptying the vector.\n\nTime Complexity per test case : $O(Q)$ where $Q$ is the number of queries.\nFor each query, if it is an \"add\" or \"remove\" operation, the time complexity is $O(1)$, as these operations can be performed in constant time. If it is a \"print\" operation, the time complexity is $O(1)$, as it only involves accessing an element at a specific index, which is also a constant-time operation. If it is a \"clear\" operation, the time complexity is $O(n)$, where $n$ is the number of elements in the vector, as this operation involves deallocating the memory occupied by the elements in the vector.\n\nTherefore, the overall time complexity of this problem would be $O(Q)$, where $Q$ is the number of queries performed in each test case. This is because the number of operations performed in each query is constant, so the total time taken would depend linearly on the number of queries."
      },
      "id": 344,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer Q - the number of queries.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Each of the next Q ines contains queries.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<ol><li><span style=\"background-color:transparent;color:#000000;\">Vector becomes: [3]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Vector becomes: [3, 4]</span></li><li><span style=\"background-color:transparent;color:#000000;\">V[1] = 4</span></li><li><span style=\"background-color:transparent;color:#000000;\">Vector becomes: [3]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Vector becomes: [3, 7]</span></li><li><span style=\"background-color:transparent;color:#000000;\">Vector becomes: [3, 7, 2]</span></li><li><span style=\"background-color:transparent;color:#000000;\">V[0] = 3</span></li><li><span style=\"background-color:transparent;color:#000000;\">Vector becomes: []</span></li><li><span style=\"background-color:transparent;color:#000000;\">Vector is empty, hence no element at 0 index</span></li></ol>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the required queries.</span></p>",
      "samples": [
        {
          "input": "1\n9\nadd 3\nadd 4\nprint 1\nremove\nadd 7\nadd 2\nprint 0\nclear\nprint 0\n",
          "output": "4\n3\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Vector AZ101",
      "video_editorial_id": 10671
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are standing on the lowest row of a chessboard and can only move, upwards and leftwards or upwards and rightwards. There is a predefined score on each cell of the chessboard. You can start from any cell in the lowest row and you have to reach the uppermost row such that your score is the maximum possible and it is divisible by K. You have to find the maximal score you can achieve.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1≤ T ≤ 100</p><p>1 ≤ N, M ≤ 100</p><p>1≤ K ≤ 11</p><p>&nbsp;</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint n,m,k;\nint a[101][101];\nint dp[101][101][12];\nint main(){\n    IOS\n    int t;\n    cin>>t;\n    while(t--){\n        cin>>n>>m>>k;\n        for(int i=1; i<=n; ++i){\n            for(int j=1; j<=m; ++j){\n                char c;\n                cin>>c;\n                a[i][j]=c-'0';\n            }\n        }\n        memset(dp,-1,sizeof(dp));\n        for(int j=1; j<=m; ++j){\n            int t=a[n][j]%k;\n            dp[n][j][t] = a[n][j];\n        }\n        for(int i=n-1; i>=1; --i){\n            for(int j=1; j<=m; ++j){\n                for(int l=0; l<k; ++l){\n                    if(j>1 && dp[i+1][j-1][l]>=0){\n                        int t=dp[i+1][j-1][l]+a[i][j];\n                        if(dp[i][j][t%k]<t){\n                            dp[i][j][t%k]=t;\n                        }\n                    }\n                    if(j<m && dp[i+1][j+1][l]>=0){\n                        int t=dp[i+1][j+1][l]+a[i][j];\n                        if(dp[i][j][t%k]<t){\n                            dp[i][j][t%k]=t;\n                        }\n                    }\n                }\n            }\n        }\n        int ans=-1;\n        for(int j=1; j<=m; ++j){\n            if(ans < dp[1][j][0]){\n                ans=dp[1][j][0];\n            }\n        }\n        cout<<ans<<\"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:33:46.862779+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">For each cell of the table store K + 1 values, where the i-th value is the maximum number of peas the pawn can take while he is at that cell and this number mod K + 1 is i.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Make a DP array DP[n][m][k] where DP[i][j][l] denotes the maximum score </span><span style=\"background-color:#ffffff;color:#222222;\">you</span> <span style=\"background-color:#ffffff;color:#222222;\">can obtain in the i-th row and j-th column while the remainder divided by k is l.</span></p>",
        "solution_approach": "<p><span style=\"background-color:#ffffff;color:#222222;\">Suppose that another array A[i][j] denotes the score in the i-th row and j-th column. Then,</span></p><p><span style=\"background-color:#ffffff;color:#222222;\">DP[i][j][l]=max(DP[i-1][j-1][(l-A[i][j])%k], DP[i-1][j+1][(l-A[i][j])%k]).</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N*M*K)</span></p>"
      },
      "id": 185,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains three space-separated integers N, M</span>,<span style=\"background-color:transparent;color:#000000;\"> and K - the length of the array.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Each of the next N lines </span>contains<span style=\"background-color:transparent;color:#000000;\"> M digits from 0-9 indicating the score at that cell.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, we start from A[4][3] and get the score as 3+3+7+9 = 22 which is divisible by 11.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, we start from A[2][1] and get the score as 9+9 = 18, which is divisible by 2. You can also start from A[2][3] to get the same result.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, there is no way to reach the top row with </span>the <span style=\"background-color:transparent;color:#000000;\">score as a multiple of k.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, if it is possible, you have to find the maximal score you can achieve. If it is impossible print -1.</span></p>",
      "samples": [
        {
          "input": "3\n4 3 11\n194\n707\n733\n633\n2 4 2\n3916\n9593\n2 2 4\n15\n52",
          "output": "22\n18\n-1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Maximum Score",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>A number which is both a prime number as well as palindrome is called a <i>Prime Palindrome. </i>151 is a prime as well as a palindrome, hence 151 is a prime palindrome.<br>Your task is to find the count of Prime Palindromes belonging to the given range <i>[a, b]</i>.</p>",
      "complete_approach": "",
      "constraints": "<p>2 ≤ <i>a</i> ≤ <i>b</i> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nll ans = 0;\n\nbool isPrime(ll x) {\n\tfor(ll i = 2; i * i <= x; i++) {\n\t\tif(x % i == 0) \n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid solve(ll cur, ll totalLen, ll curLen, ll a, ll b) {\n\tif(curLen == (totalLen + 1) / 2) {\n\t\tvector<int> d;\n\t\tll temp = cur;\n\t\twhile(temp) {\n\t\t\td.push_back(temp % 10);\n\t\t\ttemp /= 10;\n\t\t}\n\t\ttemp = cur;\n\t\tfor(int i = (totalLen % 2); i < (int)d.size(); i++) {\n\t\t\ttemp *= 10;\n\t\t\ttemp += d[i];\n\t\t}\n\t\tif(temp <= b && temp >= a && isPrime(temp)) {\n\t\t\tans++;\n\t\t}\n\t\treturn;\n\t}\n\n\tfor(ll i = 0; i < 10; i++) {\n\t\tcur *= 10; cur += i;\n\t\tsolve(cur, totalLen, curLen + 1, a, b);\n\t\tcur /= 10;\n\t}\n\treturn;\n} \n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    ll a, b;\n    cin >> a >> b;\n\n    ll len = 0, temp = b;\n    while(temp) {\n    \tlen++;\n    \ttemp /= 10;\n    }\n\n    for(ll i = 1; i <= len; i++) {\n    \tfor(ll j = 1; j < 10; j++) {\n    \t\tsolve(j, i, 1LL, a, b);\n    \t}\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:18:36.055588+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.75);\">Generate the palindromes and see if they are prime.</span></p>",
        "hint2": "<p><span style=\"background-color:rgb(255,255,255);color:rgba(0,0,0,0.75);\">Find all palindrome numbers and then judge whether they are prime numbers (prime numbers).</span></p>",
        "solution_approach": "<p>Generate all palindrome numbers and see if they are prime or not. One optimization that you can do, generate only the first half of the number and the second half will be opposite of first. And now check for whether it is a prime number or not. You can do it with square root trick discussed in math module.</p><p><strong>Time complexity: </strong>O(10<sup>MAXLEN / 2</sup> x sqrt(MAXNUM))</p>"
      },
      "id": 274,
      "input_format": "<p>The only line of input contains two space-separated numbers: <i>a</i> and <i>b</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the count to Prime Palindromes in-between the range <i>[a, b].</i></p>",
      "samples": [
        {
          "input": "5 500",
          "output": "12"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Prime Palindromes",
      "video_editorial_id": 8179
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array A of size N. You need to find the number of pairs (i, j) , i != j, such that A[i]+A[j] ≤ X.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n\n$1 \\leq N \\leq 10^5$  \n\n$1 \\leq A_i \\leq 10^6$  \n\n$1 \\leq X \\leq 10^6$  \n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^5$.",
      "editorial_code": [
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n#define int long long int\n\nsigned main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n, x;\n    cin >> n >> x;\n    int a[n];\n    for (int i = 0; i < n; ++i) {\n      cin >> a[i];\n    }\n    sort(a, a + n);\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n      int j = upper_bound(a, a + n, x - a[i]) - a;\n      if (a[i] <= x - a[i]) j--;\n      ans += j;\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n```\n\n",
          "language": "C++14"
        },
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n#define pb push_back\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define output(x) cout << (x ? \"YES\\n\" : \"NO\\n\")\n#define int long long\nconst int inf = 1e8;\nconst int N = 3e6;\nconst int mod = 1e9 + 7;\nvoid solve() {\n  int n, x;\n  cin >> n >> x;\n  int arr[n];\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n  sort(arr, arr + n);\n  int i = 0, j = n - 1, cnt = 0;\n  while (i < j) {\n    if ((arr[i] + arr[j]) > x) {\n      j--;\n    } else {\n      cnt = cnt + 2 * (j - i);\n      i++;\n    }\n  }\n  cout << cnt << endl;\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:31:42.948687+00:00"
      },
      "hints": {
        "hint1": "Change the equation to: $A[j] \\leq X - A[i]$",
        "hint2": "",
        "solution_approach": "# Solution 1\nUse upper_bound to find the number of elements satisfying $A[j] \\leq X - A[i]$\nTime Complexity per test case: Sorting takes $O(N logN)$\n\n# Solution 2\nUsing 2 pointer type approach.\nWe initialize two pointers, i and j, that point to the first and last elements of the array, respectively.\nIn each iteration of the while loop, we check if the sum of the elements pointed by i and j is less than or equal to x. If yes, we add the number of pairs that sum up to a value less than or equal to x by incrementing the count cnt by $2\\times(j-i)$ and incrementing i by $1$.\nIf the sum of the elements pointed by i and j is greater than x, we decrement j by 1 as all the pairs with a higher sum would also be greater than x.\nRepeat the process until i becomes greater than or equal to j.\nFinally, we print the value of cnt, which is the number of pairs that sum up to a value less than or equal to x.\n\nTime Complexity per test case: Sorting takes $O(N logN)$"
      },
      "id": 396,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains two space-separated integers N  X.\n\nThe second line of each test case contains N space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, the following pairs have sum ≤ 4: (1,2), (1,2), (1,3), (2,1), (2,2), (2,1), (2,2), (3,1)\n\nFor the second test case, the following pairs have sum ≤ 10: (5,5), (5,5), (5,5), (5,5), (5,5), (5,5)",
      "output_format": "For each test case, print the number of pairs (i, j) , i != j, such that A[i]+A[j] ≤ X.",
      "samples": [
        {
          "input": "2\n5 4\n1 2 2 3 4\n3 10\n5 5 5",
          "output": "8\n6"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Count the Pairs",
      "video_editorial_id": 10662
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given $2$ numbers $ N, M $ and an array $A$ of $N$ numbers. For every number from $1$ to $𝑀$, print how many times this number $ \\textbf{appears} $ in this array.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ 1 \\leq N, M \\leq 1*10^5 $\n$ 1 \\leq A[i] \\leq M $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        int n, m;\n        cin >> n >> m;\n\n        int arr[n];\n        int count[(int)(1e5+1)] = {0};\n        for (int i = 0; i < n; i++)\n        {\n            cin >> arr[i];\n            count[arr[i]]++;\n        }\n\n        for (int i = 1; i <= m; i++)\n        {\n            cout << count[i] << \"\\n\";\n        }\n        \n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:37:18.844663+00:00"
      },
      "hints": {
        "hint1": "Did you notice the max value of any element in the array?",
        "hint2": "How about we use each element as index of some other frequency array? Then we can count the number of times an element appears in the array.",
        "solution_approach": "Take a count array with size $ 10^5 + 1 $.\nWhile taking input, store the count of each element in the count array.\nLoop the count array to print the answer.\nTime Complexity: $O(n)$"
      },
      "id": 1140,
      "input_format": "The first line contains $T$, the number of test cases.\nFor each testcase: The first line contains two space seperated integers $ N $ and $ M $. The second line contains $N$ space separated integers each denoting an element of the array $A$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "$ \\textbf{Note} $\nNumbers from 1 to 5 appearance are :\n\n$ \\bullet $ 1 appears $ \\textbf{2} $ times in the array .\n$ \\bullet $ 2 appears $ \\textbf{2} $ times in the array.\n$ \\bullet $ 3 appears $ \\textbf{3} $ times in the array.\n$ \\bullet $ 4 appears once in the array.\n$ \\bullet $ 5 appears $ \\textbf{2} $ times in the array.",
      "output_format": "Print $M$ lines, the $i^{th}$ line should contain number of times that the number $i$ appears in $A$.",
      "samples": [
        {
          "input": "1\n10 5\n1 2 3 4 5 3 2 1 5 3\n",
          "output": "2\n2\n3\n1\n2\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Frequency Array",
      "video_editorial_id": 10649
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given an array A of n integers and a value k. You can select zero or more non-empty subarrays A[l..r] such that no two subarrays have any index in common, i.e., no two subarrays should overlap. For each chosen subarray A[l..r] add the value A[r]-A[l]-k to your score which is initially zero. Print the max score possible.</p>",
      "complete_approach": "",
      "constraints": "<p>T ≤ 100</p><p>1 ≤ n ≤ 2*10<sup>5</sup></p><p>0 ≤ A<sub>i</sub> , k ≤ 10<sup>9</sup></p><p>Sum of n over all test cases is ≤ 2*10<sup>5</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        int n, k;\n        cin >> n >> k;\n        int a[n];\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        \n        vector<ll> done(n), in_progress(n);\n        done[0] = 0;\n        in_progress[0] = - a[0];\n        \n        for (int i = 1; i < n; ++i) {\n            done[i] = max(done[i - 1], a[i] + in_progress[i - 1] - k);\n            in_progress[i] = max(in_progress[i - 1], done[i - 1] - a[i]);\n        }\n        \n        cout << done[n - 1] << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:14:25.800561+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "At each step $i$, let's maintain two values - $done(i)$ and $in\\_progress(i)$.\n\n$done(i)$ - For the subarray $[0...i]$, we've partitioned them into subarrays such that the value is maximum.\n\n$in\\_progress(i)$ - For the subarray $[0...i]$, we've partitioned them into subarray, and the last subarray is still incomplete, i.e., no closing $r$ is found for the last $l$.\n\nHow to populate $done(i)$? We have two options.\n1. Do nothing, i.e., do not select $i$-th element in any subarray  $\\rightarrow$ $done(i-1)$.\n2. Complete the open subarray at $i$-th element $\\rightarrow$ $in\\_progress(i - 1) + A[i] - k$.\n\n$done(i) = max(done(i-1), in\\_progress(i - 1) + A[i] - k)$\n\nHow to populate $in\\_progress(i)$? We have two options.\n1. Do nothing, i.e., keep the $i$-th within the current open subarray  $\\rightarrow$ $in\\_progress(i-1)$.\n2. Start a new open subarray with the current element as starting one $\\rightarrow$ $done(i - 1) - A[i]$.\n\n$in\\_progress(i) = max(in\\_progress(i-1), done(i - 1) - A[i])$\n\nThe final answer will be $done(n-1)$."
      },
      "id": 251,
      "input_format": "<p>First line of input contains <strong>T</strong>, number of test cases.</p><p>First line of each test case contains two integers <strong>n</strong> and <strong>k</strong>.</p><p>Second line contains <strong>n</strong> integers, <strong>A<sub>i</sub></strong><sub> , </sub>the array A.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>t=1: Chosen subarrays= ((2,4)) &nbsp;[1 indexed]</p><p>t=2: Chosen subarrays= ((2,4), (5,6)) &nbsp;[1 indexed]</p>",
      "output_format": "<p>For each test case print the max score possible in a new line.</p>",
      "samples": [
        {
          "input": "2\n6 2\n4 2 3 7 5 6\n6 0 \n4 2 3 7 5 6",
          "output": "3\n6"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Like Stocks",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You can see N stars in the sky. You know the coordinates and the brightness of the stars. The maximum brightness of any star can be C. If at moment M, a star has brightness S, then at moment M+1, the star will have brightness S+1, if S+1 &lt;= C, otherwise 0. You look at the sky Q times, you want to know the total brightness of the stars lying in the viewed rectangle, with the lower-left corner (X<sub>1i</sub>, Y<sub>1i</sub>) and upper right corner (X<sub>2i</sub>, Y<sub>2i</sub>) at moment M<sub>i</sub>.</p>",
      "complete_approach": "",
      "constraints": "<p>1≤ T ≤ 100</p><p>1≤ N, Q ≤ 10<sup>5</sup></p><p>0≤ S<sub>i</sub> ≤ C ≤ 10</p><p>1≤ X<sub>i</sub>, Y<sub>i</sub> ≤ 100</p><p>1≤ M<sub>i </sub>≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\n\nint dp[101][101][11];\n\nsigned main() {\n   IOS\n   int t;\n   cin >> t;\n   while(t--) {\n       int n, q, c;\n       cin >> n >> q >> c;\n       for (int p = 0; p <= c; ++p) {\n           for (int i = 0; i <= 100; ++i) {\n               for (int j = 0; j <= 100; ++j) {\n                   dp[i][j][p] = 0;\n               }\n           }\n       }\n       for (int i = 1; i <= n; ++i) {\n           int x, y, s;\n           cin >> x >> y >> s;\n           dp[x][y][s]++;\n       }\n       for (int p = 0; p <= c; ++p) {\n           for (int i = 0; i <= 100; ++i) {\n               for (int j = 0; j <= 100; ++j) {\n                   dp[i][j][p] += dp[i-1][j][p] + dp[i][j-1][p] - dp[i-1][j-1][p];\n               }\n           }\n       }\n       while (q--) {\n           int t, x1, y1, x2, y2;\n           cin >> t >> x1 >> y1 >> x2 >> y2;\n           int ans = 0;\n           for (int i = 0; i <= c; ++i){\n               int cur = (i+t)%(c+1);\n               ans += (dp[x2][y2][i] - dp[x1-1][y2][i] - dp[x2][y1-1][i] + dp[x1-1][y1-1][i])*cur;\n           }\n           cout << ans << \"\\n\";\n       }\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Editorial code is not passing the Sample cases."
        ],
        "last_updated": "2024-06-22T02:13:39.736072+00:00"
      },
      "hints": {
        "hint1": "The brightness of a star can be between 0 and C. When a star has brightness S, at the next moment it's brightness becomes 0. This means that we need to take modulo (C+1).",
        "hint2": "<p>We define DP array, DP[X][Y][S] represents the number of stars with brightness S where X<sub>1</sub> ≤ X and Y<sub>1</sub> ≤ Y.<></p>",
        "solution_approach": "We can make the DP array using 2-D prefix sums, DP[X][Y][S] += DP[X-1][Y][S] + DP[X][Y-1][S]  - DP[X-1][Y-1][S] for each brightness S ≤ C. For finding the answer to each query, iterate through all the possible values of brightness.\n\nTime Complexity per test case: (N + $Q*C$ + $X*Y*C$)"
      },
      "id": 173,
      "input_format": "<p>The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</p><p>The first line of each test case contains three space-separated integers N, Q, C - the number of the stars, the number of the views, and the maximum brightness of the stars.</p><p>Each of the next N lines contains three space-separated integers, X<sub>i</sub>, Y<sub>i</sub>, S<sub>i</sub> - the description of each star.</p><p>Each of the next Q lines contains M, X<sub>1</sub>, Y<sub>1</sub>, X<sub>2</sub>, Y<sub>2</sub> - the moment when you look at the sky and the coordinates of the viewed rectangle. X<sub>1</sub>≤X<sub>2</sub>, Y<sub>1</sub>≤Y<sub>2</sub></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, for the first query, at moment 1, the brightness of all-stars becomes S+1, if S+1 <= C, otherwise 0. From 1≤ X ≤ 3 and 3 ≤ Y ≤ 3, there is only one star at X=1, Y=3 with brightness 0+1 = 1. For the second query, at moment 2, from 1≤ X ≤ 1 and 1 ≤ Y ≤ 4, there are two stars at X=1, Y=2 with brightness 1+2 = 3 and at X=1, Y=3, with brightness 0+2 = 2.\n\nFor the second test case, for the first query, at moment 0, from 1≤ X ≤ 5 and 1 ≤ Y ≤ 5, there are two stars at X=3, Y=3 with brightness 2+0 = 2 and at X=1, Y=1, with brightness 4+0 =4.\n\nFor the second query, at moment 2, from 1≤ X ≤ 2 and 1 ≤ Y ≤ 3, there is one star1 at X=1, Y=1 with brightness 4+2 = 6, which will be 0. For the third query, at moment 3, from 1≤ X ≤ 3 and 1 ≤ Y ≤ 3, there are two stars at X=3, Y=3 with brightness 2+3 = 5 and at X=1, Y=1, with brightness 4+3 =7, which will be 1.",
      "output_format": "For each query, print the total brightness of the stars lying in the viewed rectangle.",
      "samples": [
        {
          "input": "2\n3 2 3\n1 2 1\n1 3 0\n2 3 3\n1 1 3 3 3\n2 1 1 1 4\n2 3 5\n3 3 2\n1 1 4\n0 1 1 5 5\n2 1 1 2 3\n3 1 1 3 3",
          "output": "1\n5\n6\n0\n6"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Sky",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Find the number of solutions of following equation.</p><p><i>x<sub>1</sub></i> + <i>x<sub>2</sub></i> + <i>x<sub>3</sub></i> + … + <i>x<sub>n</sub></i> = <i>k</i>, satisfying that 0 ≤ <i>x<sub>i</sub></i> &lt; <i>m</i>, modulo 1000000007.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n, m, k</i> ≤ 10<sup>5</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nconst int N = 500010;\n\nint mod = 1e9 + 7;\n\nint power(int a, int b, int M) {\n    if(!b) return 1;\n    int temp = power(a, b / 2, M);\n    temp = 1LL * temp * temp % M;\n    if(b % 2) temp = 1LL * temp * a % M;\n    return temp;\n}\n\nint fact[N];\n\nvoid pre() {\n    fact[0] = 1;\n    for(int i = 1; i < N; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n}\n\nint ncr(int n, int r) {\n    if(n < r) return 0;\n    assert(n >= 0 && n < N && r >= 0 && r < N);\n    int ans = fact[n];\n    ans = 1LL * ans * power(fact[n - r], mod - 2, mod) % mod;\n    ans = 1LL * ans * power(fact[r], mod - 2, mod) % mod;\n    if(ans < 0) ans += mod;\n    assert(ans >= 0 && ans < mod);\n    return ans;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    pre();\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    int ans = 0;\n\n    for(int i = 0; i <= n; i++) {\n        int temp = ncr(n, i);\n        if(n + k - i * m - 1 < n - 1) break;\n        temp = 1LL * temp * ncr(n + k - i * m - 1, n - 1) % mod;\n        if(temp < 0) temp += mod;\n        if(i % 2) ans = (ans - temp + mod) % mod;\n        else ans = (ans + temp) % mod;\n    }\n\n    assert(ans >= 0 && ans < mod);\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:32:33.407510+00:00"
      },
      "hints": {
        "hint1": "<p>The number of non-negative integer solutions to <i>x<sub>1</sub> + x<sub>2</sub> + …+ x<sub>n</sub> = k</i> is given by <i>(n + k - 1) C (k)</i>.</p>",
        "hint2": "<p>Try to think of how to remove the constraint on <i>x<sub>i</sub></i>s, by doing inclusion-exclusion.</p>",
        "solution_approach": "<p>The only thing we need to handle is to get rid of that annoying constraint <i>x<sub>i</sub> &lt; m</i>. To do that, we apply the inclusion-exclusion principle. Let <i>e<sub>i</sub> = x<sub>i</sub> ≥ m</i>, then <i>N<sub>o</sub></i> is our desired answer. Clearly, this set of properties is homogeneous. Take <i>T = {1, 2, …, j} (j ≤ n)</i>, then <i>N<sub>T</sub></i> is the number of solutions with <i>x<sub>1</sub> ≥ m, x<sub>2</sub> ≥ m, …, x<sub>j</sub> ≥ m</i>. Setting <i>y<sub>i</sub> = x<sub>i</sub> - m(i ≤ j), y<sub>i</sub> = x<sub>i</sub>(i &gt; j)</i>, and it's the same as the number of solutions of the system</p><p><i>y<sub>1</sub> + y<sub>2</sub> + … + y<sub>n</sub> = k - jm</i>,</p><p>thus the answer is therefore</p><p><i>N<sub>o</sub> = Summation over j = [0, n] (-1)<sup>j</sup> * nCj * (n + k - jm - 1) C (n - 1)</i></p><p><strong>Time complexity:</strong> <i>O(n)</i> with some preprocessing.</p>"
      },
      "id": 177,
      "input_format": "<p>The only line of input contains three space-separated integers <i>n, m, k</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For the first test cases, only two solutions exist (2, 3) and (3, 2).</p>",
      "output_format": "<p>Print the number of solutions.</p>",
      "samples": [
        {
          "input": "2 4 5",
          "output": "2"
        },
        {
          "input": "20 10 50",
          "output": "366736536"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Character Encoding",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given an array A of n non-negative integers.</p><p>Define function F = Summation of |Ai-X|<sup>2</sup> for all i from 1 to n.</p><p>Find the minimum value of the function F by choosing an appropriate integer X.</p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "<p>T ≤ 10</p><p>1 ≤ n ≤ 10<sup>5</sup></p><p>0 ≤ A<sub>i</sub> ≤ 10<sup>6</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int t, n, i, j;\r\n\r\n    cin >> t;\r\n    while (t--)\r\n    {\r\n        int n;\r\n        cin >> n;\r\n        vector<int> arr(n);\r\n        long long sum = 0;\r\n        for (i = 0; i < n; i++)\r\n        {\r\n            cin >> arr[i];\r\n            sum += arr[i];\r\n        }\r\n        double avg = sum / (double)n;\r\n        int c1 = ceil(avg);\r\n        int c2 = floor(avg);\r\n        long long sum1 = 0, sum2 = 0;\r\n        for (auto z : arr)\r\n        {\r\n            sum1 += (z - c1) * (long long)(z - c1);\r\n            sum2 += (z - c2) * (long long)(z - c2);\r\n        }\r\n        cout << min(sum1, sum2) << '\\n';\r\n    }\r\n}\r\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:42:36.119412+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">You can start the solution by taking examples for N=2 and N=3 and then generalise the solution for N.</span></p>",
        "hint2": "<p>It can be either of the 2 extremes, either all in one or equally distributed.</p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">The most optimal choice for choosing the value of X would be the average of the numbers. This can be shown by taking the general case of an array with N numbers.</span></p><p><span style=\"background-color:transparent;color:#000000;\">(A1-X)</span><span style=\"background-color:#ffffff;color:#000000;\"><sup>2</sup></span><span style=\"background-color:transparent;color:#000000;\"> + (A2-X)</span><span style=\"background-color:#ffffff;color:#000000;\"><sup>2</sup></span><span style=\"background-color:transparent;color:#000000;\"> + … + (AN-X)</span><span style=\"background-color:#ffffff;color:#000000;\"><sup>2</sup></span><span style=\"background-color:transparent;color:#000000;\"> = NX</span><span style=\"background-color:#ffffff;color:#000000;\"><sup>2</sup></span><span style=\"background-color:transparent;color:#000000;\"> - 2*(A1 + A2 + … + AN)*X + (A1</span><span style=\"background-color:#ffffff;color:#000000;\"><sup>2</sup></span><span style=\"background-color:transparent;color:#000000;\"> + A2</span><span style=\"background-color:#ffffff;color:#000000;\"><sup>2</sup></span><span style=\"background-color:transparent;color:#000000;\"> + … + AN</span><span style=\"background-color:#ffffff;color:#000000;\"><sup>2</sup></span><span style=\"background-color:transparent;color:#000000;\">)</span></p><p><span style=\"background-color:transparent;color:#000000;\">Let S = A1 + A2 + … + AN. The last term is independent of X so we can discard it. The remaining function,&nbsp; NX</span><span style=\"background-color:#ffffff;color:#000000;\"><sup>2</sup></span><span style=\"background-color:transparent;color:#000000;\"> - 2*S*X forms a parabola with roots X = 0 and X = 2*S/N. The minimum value of the parabola would be at X = S/N, which is the average of the given numbers. We could have also taken the differentiation of the function, to get the minimum value.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Since X can be an integer only, we take the ceil and floor of S/N.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N)</span></p>"
      },
      "id": 255,
      "input_format": "<p>First line of input contains <strong>T</strong>, number of test cases.</p><p>First line of each test case contains <strong>n</strong> .</p><p>Second line contains <strong>n</strong> integers, <strong>A<sub>i</sub></strong><sub> , </sub>the array A.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the minimum value of F.</p>",
      "samples": [
        {
          "input": "1\n3\n2 2 3",
          "output": "1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Square sum",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given an undirected graph of <strong>N </strong>vertices and <strong>M</strong> edges. Edge weight <strong>d</strong> on edge between nodes <strong>u</strong> and <strong>v</strong> represents that <strong>u</strong> and <strong>v</strong> are connected by a thread of length <strong>d</strong> units.&nbsp;<br>You set node <strong>A</strong> on to the fire. It takes to fire 1 unit of time to travel 1 unit of distance via threads.<br>Let <strong>T</strong> be the minimum time in which all the threads will be burned out.&nbsp;</p><p>Your task is to find <strong>10T</strong>. We can prove that <strong>10T</strong> will always be an integer number.</p><p>See the sample test cases for more explanation.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ N ≤ 2 x 10<sup>5</sup><br>1 ≤ M ≤ 2 x 10<sup>5</sup><br>1 ≤ u, v ≤ N<br>1 ≤ d ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    int m;\n    cin >> m;\n\n    vector<pair<int, ll>> graph[n + 1];\n    vector<pair<pair<int, int>, ll>> edges;\n\n    for (int i = 0; i < m; i++)\n    {\n        int u, v;\n        ll d;\n        cin >> u >> v >> d;\n        graph[u].push_back({v, d});\n        graph[v].push_back({u, d});\n        edges.push_back({{u, v}, d});\n    }\n\n    int st;\n    cin >> st;\n\n    ll dist[n + 1];\n\n    for (int i = 1; i <= n; i++)\n    {\n        dist[i] = 1e18;\n    }\n\n    priority_queue<pair<ll, int>> q;\n\n    q.push({0, st});\n    dist[st] = 0;\n\n    bool visited[n + 1];\n    memset(visited, false, sizeof(visited));\n\n    while (!q.empty())\n    {\n        auto it = q.top();\n        q.pop();\n\n        ll w = -it.first;\n        int u = it.second;\n\n        if (visited[u])\n            continue;\n\n        visited[u] = true;\n\n        for (auto it : graph[u])\n        {\n            int v = it.first;\n            ll d = it.second;\n\n            if (dist[v] > w + d)\n            {\n                dist[v] = w + d;\n                q.push({-dist[v], v});\n            }\n        }\n    }\n\n    ll ans = -1e18;\n\n    for (int i = 1; i <= n; i++)\n        assert(visited[i]);\n\n    for (auto it : edges)\n    {\n        int u = it.first.first;\n        int v = it.first.second;\n        ll d = it.second;\n\n        ans = max(ans, (dist[u] + dist[v] + d) * 5);\n    }\n\n    assert(ans > 0);\n\n    cout << ans << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing"
        ],
        "last_updated": "2024-06-22T02:19:13.547294+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 618,
      "input_format": "<p>The first line of input contains <strong>N - </strong>the number of nodes in the graph.<br>The second line contains <strong>M </strong>- the number of edges in the graph.<br>Next <strong>M</strong> lines contain three integers <strong>u</strong>, <strong>v</strong>, <strong>d</strong> - there is a thread between node <strong>u</strong> and <strong>v</strong> of length <strong>d</strong>.<br>The last line of input contains <strong>A</strong> - the node on which we set fire.</p><p>It’s guaranteed that graph is connected.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "**Explanation 1:**\n\n1. At t = 0, node 1 is at fire.\n2. At t = 1, thread 1-2 is half burned.\n3. At t = 2, thread 1-2 is fully burned.\nSo T = 2. And 10T = 20.\n\n**Explanation 2:**\n\n1. At t = 0, node 1 is at fire.\n2. At t = 2, thread 1-2 is fully burned, and thread 1-3 is 1/3rd burned.\n3. At t = 4, threads 1-2 and 2-3 are fully burned, and 4 units of thread 1-3 are burned. For the remaining 2 units of thread 1-3, fire is approaching from both ends.\n4. At t = 5, all threads are fully burned.\nSo T = 5. And 10T = 50.\n\n**Explanation 3:**\n\n1. At t = 0, node 1 is starting to burn.\n2. At t = 2, threads 1-2 and 1-3 are fully burned. Now for thread 2-3, fire is approaching from both ends at equal speed.\n3. At t = 2.5, thread 2-3 is fully burned.\nSo T = 2.5. And 10T = 25.",
      "output_format": "<p>Print the value of <strong>10T</strong>.</p>",
      "samples": [
        {
          "input": "2\n1\n1 2 2\n1",
          "output": "20"
        },
        {
          "input": "3\n3\n1 2 2\n2 3 2\n1 3 6\n1",
          "output": "50"
        },
        {
          "input": "3\n3\n1 2 2\n1 3 2\n2 3 1\n1",
          "output": "25"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Burn them All",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>A state with <strong>n</strong> flags of ON or OFF can be represented by a sequence of bits where <strong>0,1,...,n−1</strong> -th flag corresponds to 1 (ON) or 0 (OFF). The state can be managed by the corresponding decimal integer because the sequence of bits is a binary representation where each bit is 0 or 1.</p><p>Given a sequence of bits with <strong>60 flags</strong> that represent a state, perform the following operations. Note that each flag of the bits is initialized by OFF.</p><ol><li>test(i): Print 1 if <strong>i<sup>th</sup></strong> flag is ON, otherwise 0.</li><li>set(i): Set <strong>i<sup>th</sup></strong> flag to ON</li><li>clear(i): Set <strong>i<sup>th</sup></strong> flag to OFF</li><li>flip(i): Inverse <strong>i<sup>th</sup></strong> flag</li><li>all: Print 1 if all flags are ON, otherwise 0</li><li>any: Print 1 if at least one flag is ON, otherwise 0</li><li>none: Print 1 if all flags are OFF, otherwise 0</li><li>count: Print the number of ON flags</li><li>val: Print the decimal value of the state</li></ol>",
      "complete_approach": "",
      "constraints": "<ul><li>1 ≤ q ≤ 200,000</li><li>0 ≤ i &lt; 60</li></ul>",
      "editorial_code": [
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvoid solve() {\n    int q;\n    cin >> q;\n    ll val = 0;\n    while (q--) {\n        int t, i;\n        cin >> t;\n        //t++;\n        if (t == 1) {\n            cin >> i;\n            cout << ((val >> i) & 1) << endl;\n        }\n        if (t == 2) {\n            cin >> i;\n            val |= (1LL << i);\n        }\n        if (t == 3) {\n            cin >> i;\n            val &= (~(1LL << i));\n        }\n        if (t == 4) {\n            cin >> i;\n            val ^= (1LL << i);\n        }\n        if (t == 5) {\n            if (__builtin_popcountll(val) == 60) {\n                cout << 1 << endl;\n            }\n            else {\n                cout << 0 << endl;\n            }\n        }\n        if (t == 6) {\n            if (__builtin_popcountll(val) >= 1) {\n                cout << 1 << endl;\n            }\n            else {\n                cout << 0 << endl;\n            }\n        }\n        if (t == 7) {\n            if (__builtin_popcountll(val) == 0) {\n                cout << 1 << endl;\n            }\n            else {\n                cout << 0 << endl;\n            }\n        }\n        if (t == 8) {\n            cout << __builtin_popcountll(val) << endl;\n        }\n        if (t == 9) {\n            cout << val << endl;\n        }\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```\n",
          "language": "C++14"
        },
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvoid solve() {\n    std::bitset<64> b(0);\n    int q, op, x;\n    std::cin >> q;\n\n    while (q--) {\n        std::cin >> op;\n        op--;\n        if (op == 0) {\n            std::cin >> x;\n            std::cout << b[x] << \"\\n\";\n        }\n        else if (op == 1) {\n            std::cin >> x;\n            b[x] = 1;\n        }\n        else if (op == 2) {\n            std::cin >> x;\n            b[x] = 0;\n        }\n        else if (op == 3) {\n            std::cin >> x;\n            b[x] = ~b[x];\n        }\n        else if (op == 4) {\n            std::cout << b.all() << \"\\n\";\n        }\n        else if (op == 5) {\n            std::cout << b.any() << \"\\n\";\n        }\n        else if (op == 6) {\n            std::cout << b.none() << \"\\n\";\n        }\n        else if (op == 7) {\n            std::cout << b.count() << \"\\n\";\n        }\n        else {\n            std::cout << b.to_ullong() << \"\\n\";\n        }\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Editorial code is not passing the Sample cases.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:32:57.102547+00:00"
      },
      "hints": {
        "hint1": "The problem can be solved by using bit manipulation techniques. We need to manipulate bits to represent the state of flags, and then perform the required operations on them.",
        "hint2": "To represent the state of the flags, we can use a binary number, where each bit of the number corresponds to the state of a flag. We can then use bit manipulation operations to manipulate the state of the flags and perform the required operations.",
        "solution_approach": "* We can represent the state of the flags as a binary number, where each bit of the number corresponds to the state of a flag. To perform the required operations, we can use the following bit manipulation operations:\n\n* To test if the i-th flag is ON, we can use the bitwise AND operation with a mask that has only the i-th bit set to 1. If the result is non-zero, then the i-th flag is ON, otherwise it is OFF.\n\n* To set the i-th flag to ON, we can use the bitwise OR operation with a mask that has only the i-th bit set to 1.\n\n* To set the i-th flag to OFF, we can use the bitwise AND operation with a mask that has only the i-th bit set to 0.\n\n* To flip the state of the i-th flag, we can use the bitwise XOR operation with a mask that has only the i-th bit set to 1.\n\n* To check if all flags are ON, we can use the _\\_builtin\\_popcountll() function, which returns the number of 1 bits in a 64-bit integer. If the result is equal to 60, then all flags are ON.\n\n* To check if at least one flag is ON, we can use the _\\_builtin\\_popcountll() function again. If the result is greater than or equal to 1, then at least one flag is ON.\n\n* To check if all flags are OFF, we can use the _\\_builtin\\_popcountll() function again. If the result is equal to 0, then all flags are OFF.\n\n* To count the number of ON flags, we can use the _\\_builtin\\_popcountll() function again.\n\n* To get the decimal value of the state, we can simply print the value of the binary number as a decimal number.\n\n**Time Complexity**:\nThe time complexity of the solution is O(q), where q is the number of queries. This is because each query requires only constant time operations."
      },
      "id": 884,
      "input_format": "<p>The input is given in the following format.</p><pre><code class=\"language-plaintext\">q\nquery1\nquery2\n:\nqueryq</code></pre><p>Each query <strong>query<sub>j</sub></strong> is given in the following format: either only <strong>t</strong> &nbsp;or &nbsp;<strong>t</strong> &nbsp;<strong>i &nbsp;</strong>, where <strong>t</strong> is the query type.</p><p>The first digit <strong>t = 1, 2, 3 ,...,8, 9</strong> represents the operation test(i), set(i), clear(i), flip(i), all, any, none, count or val respectively.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the result in a line for each test, all, any, none, count and val operation.</p>",
      "samples": [
        {
          "input": "14\n2 0\n2 1\n2 2\n3 1\n1 0\n1 1\n1 2\n1 3\n4 3\n5\n6\n7\n8\n9",
          "output": "1\n0\n1\n0\n0\n1\n0\n3\n13"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Bit Magic I",
      "video_editorial_id": 8234
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given an array <i>a</i> consisting of <i>n</i> integers, and additionally an integer <i>m</i>. You have to choose some sequence of indices <i>b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>k</sub></i> (1 ≤ <i>b<sub>1</sub></i> &lt; <i>b<sub>2</sub></i> &lt; ... &lt; <i>b<sub>k</sub></i> ≤ <i>n</i>) in such a way that the value of <strong>(</strong><i><strong>a[b<sub>1</sub>] + a[b<sub>2</sub>] + ... + a[b<sub>k</sub>]</strong></i><strong>) mod </strong><i><strong>m</strong></i> is maximized. The chosen sequence can be empty.</p><p>Print the maximum possible value of <strong>(</strong><i><strong>a[b<sub>1</sub>] + a[b<sub>2</sub>] + ... + a[b<sub>k</sub>]</strong></i><strong>) mod </strong><i><strong>m</strong></i>.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\nint main() \n{ \n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    if (n == 1) {\n        cout << a[0] % m << '\\n';\n        return 0;\n    }\n    int mid = ((n + 1) / 2);\n    vector<int> sums;\n    for (int conf = 0; conf < (1 << mid); ++conf) {\n        int sum = 0;\n        for (int i = 0; i < mid; ++i) {\n            if ((conf & (1 << i)) != 0) {\n                sum = (sum + a[i]) % m;\n            }\n        }\n        sums.push_back(sum);\n    }\n    sort(sums.begin(), sums.end());\n    int ans = 0;\n    for (int64_t conf = 0; conf < (1LL << n); conf += 1LL << mid) {\n        int sum = 0;\n        for (int i = mid; i < n; ++i) {\n            if ((conf & (1LL << i)) != 0) {\n                sum = (sum + a[i]) % m;\n            }\n        }\n        int need = (m - 1 - sum + m) % m;\n        int pos = upper_bound(sums.begin(), sums.end(), need) - sums.begin() - 1;\n        if (pos < 0) {\n            pos = SZ(sums) - 1;\n        }\n        ans = max(ans, (sum + sums[pos]) % m);\n    }\n    cout << ans << '\\n';\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:17:02.908862+00:00"
      },
      "hints": {
        "hint1": "<p>Generate all 2<sup>n</sup> subsets and for each subset take mod w.r.t. <i>m</i>, and print the one which is the maximum.<br>But this solution won't pass the constraints. We've to optimize it.</p>",
        "hint2": "<p>Use the <i>meet-in-the-middle</i> to optimize the brute solution.</p>",
        "solution_approach": "<p>We can use <strong>meet-in-the-middle</strong> technique to optimize it to <i>O(2<sup>n/2</sup>*log(2<sup>n/2</sup>))</i>. Preprocess the first <i>n / 2</i> elements naively and push sums modulo m to some array. After this process the second half with the following algorithm.</p><p>Now we have two bigger sets, first one with first <i>n / 2</i> elements, and the second one with the later <i>n / 2</i> elements.</p><p>Iterate over each smaller sets from the first bigger set. Let the modulo sum of the current set is <i>x</i>. We know that the sum of modulo values of two different sets won't increase beyond <i>2m</i>. So now our target is to find the largest modulo sum in the second bigger set with modulo sum &lt; <i>m - x</i>. We can find this using binary search, or upper_bound/lower_bound. Note that if we choose a subset with module sum greater than <i>m - x</i> from the second bigger set, then the net modulo sum will be less than <i>x</i>.&nbsp;</p>"
      },
      "id": 281,
      "input_format": "<p>The first line contains two integers <i>n</i> and <i>m</i> (1 ≤ <i>n</i> ≤ 35, 1 ≤ <i>m</i> ≤ 10<sup>9</sup>).<br>The second line contains <i>n</i> integers <i>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></i> (1 ≤ <i>a<sub>i</sub></i> ≤ 10<sup>9</sup>).</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>You can choose a sequence b = {1, 2}, so the sum (5 + 2) is equal to 7 (and that's 3 after taking it modulo 4).</p>",
      "output_format": "<p>Print the maximum possible value of <strong>(</strong><i><strong>a[b<sub>1</sub>] + a[b<sub>2</sub>] + ... + a[b<sub>k</sub>]</strong></i><strong>) mod </strong><i><strong>m</strong></i>.</p>",
      "samples": [
        {
          "input": "4 4\n5 2 4 1",
          "output": "3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Modulo Subsequences",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Design the following data structure.</p><p>Implement the AllOne class:</p><ul><li><i>AllOne()</i> Initializes the object of the data structure.</li><li><i>inc(String key)</i> Increments the count of the string key by 1. If the key does not exist in the data structure, insert it with count 1.</li><li><i>dec(String key)</i> Decrements the count of the string key by 1. If the count of the key is 0 after the decrement, remove it from the data structure. It is guaranteed that a key exists in the data structure before the decrement.</li><li><i>getMaxKey()</i> Returns the key with the maximal count. If there are multiple keys with the maximal count, then return the lexicographically largest key. If no element exists, return an empty string \"\".</li><li><i>getMinKey()</i> Returns the key with the minimal count. If there are multiple keys with minimal count, then return the lexicographically largest key. If no element exists, return an empty string \"\".</li></ul>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ Q ≤ 10<sup>5</sup><br>1 ≤ |key| ≤ 20</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass AllOne\n{\npublic:\n\t\n\tmap<string, int> m_key;\n\tmap<int, set<string>> m_freq;\n\t\n\tAllOne() {\n\n\t}\n\n\tvoid inc(string key) {\n\t\t\n\t\tif (m_key.find(key) != m_key.end()) {\n\t\t\tint val = m_key[key];\n\t\t\tm_freq[val].erase(key);\n\t\t\tif (m_freq[val].empty()) m_freq.erase(val);\n\t\t}\n\t\t\n\t\tm_key[key]++;\n\n\t\tint val = m_key[key];\n\n\t\tm_freq[val].insert(key);\n\t}\n\n\tvoid dec(string key) {\n\n\t\tif (m_key.find(key) != m_key.end()) {\n\t\t\tint val = m_key[key];\n\t\t\tm_freq[val].erase(key);\n\t\t\tif (m_freq[val].empty()) m_freq.erase(val);\n\t\t}\n\n\t\tm_key[key]--;\n\n\t\tint val = m_key[key];\n\n\t\tif (!val) m_key.erase(key);\n\t\telse m_freq[val].insert(key);\n\t}\n\n\tstring getMaxKey() {\n\t\tif (m_key.empty()) return \"\";\n\t\tint max_freq = (*m_freq.rbegin()).first;\n\t\treturn (*m_freq[max_freq].rbegin());\n\t}\n\n\tstring getMinKey() {\n\t\tif (m_key.empty()) return \"\";\n\t\tint min_freq = (*m_freq.begin()).first;\n\t\treturn (*m_freq[min_freq].rbegin());\n\t} \n\t\n};\n\nint main()\n{\n\tios_base::sync_with_stdio(NULL);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint Q;\n\tcin >> Q;\n\t\n\tAllOne allOne;\n\n\twhile (Q--)\n\t{\n\t\tstring op;\n\t\tcin >> op;\n\n\t\tif (op == \"inc\") {\n\t\t\tstring key;\n\t\t\tcin >> key;\n\n\t\t\tallOne.inc(key);\n\t\t}\n\t\telse if (op == \"dec\") {\n\t\t\tstring key;\n\t\t\tcin >> key;\n\n\t\t\tallOne.dec(key);\n\t\t}\n\t\telse if (op == \"getMaxKey\") {\n\t\t\tcout << allOne.getMaxKey() << \"\\n\";\n\t\t}\n\t\telse if (op == \"getMinKey\") {\n\t\t\tcout << allOne.getMinKey() << \"\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:15:16.334593+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p>We maintain two maps.</p><ol><li><strong>m_key: </strong>Stores <i>key</i> → <i>frequency</i> data.</li><li><strong>m_freq</strong>: Stores <i>frequency</i> → <i>keys</i> data.</li></ol><p>It may be possible that there are multiple keys with the same frequency. So our <strong>m_freq</strong> is storing a set of strings for the same <i>frequency</i>.</p><ol><li><strong>inc key</strong> : Delete key from m_freq from older frequency value. Update frequency in m_key. And update m_freq as well for this new frequency.</li><li><strong>dec key</strong> : Delete key from m_freq from older frequency value. Update frequency in m_key. And update m_freq as well for this new frequency. If new frequency is 0, then we don't need to update m_freq and m_key.</li><li><strong>getMaxKey</strong> : Find the maximum frequency from m_freq, and using <i>rbegin</i> operation on the set find the lexicographically largest string.&nbsp;</li><li><strong>getMinKey</strong> : Find the minimum frequency from m_freq, and using <i>rbegin</i> operation on the set find the lexicographically largest string.&nbsp;</li></ol><p>All operations are logarithmic to the size of the map in time.</p>"
      },
      "id": 567,
      "input_format": "<p>The first line contains Q - the number of queries.<br>Each of the next Q lines contains the query of one of the types mentioned in the problem statement.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "7\ninc hello\ninc hello\ngetMaxKey\ngetMinKey\ninc bye\ngetMaxKey\ngetMinKey",
          "output": "hello\nhello\nhello\nbye"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nclass AllOne\n{\npublic:\n\t\n\tAllOne() {\n\n\t}\n\n\tvoid inc(string key) {\n\t\t\n\t}\n\n\tvoid dec(string key) {\n\n\t}\n\n\tstring getMaxKey() {\n\t}\n\n\tstring getMinKey() {\n\t\t\n\t} \n\t\n};\n\n<fix>\nint main()\n{\n\tios_base::sync_with_stdio(NULL);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint Q;\n\tcin >> Q;\n\t\n\tAllOne allOne;\n\n\twhile (Q--)\n\t{\n\t\tstring op;\n\t\tcin >> op;\n\n\t\tif (op == \"inc\") {\n\t\t\tstring key;\n\t\t\tcin >> key;\n\n\t\t\tallOne.inc(key);\n\t\t}\n\t\telse if (op == \"dec\") {\n\t\t\tstring key;\n\t\t\tcin >> key;\n\n\t\t\tallOne.dec(key);\n\t\t}\n\t\telse if (op == \"getMaxKey\") {\n\t\t\tcout << allOne.getMaxKey() << \"\\n\";\n\t\t}\n\t\telse if (op == \"getMinKey\") {\n\t\t\tcout << allOne.getMinKey() << \"\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "All One",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a bracket sequence with ‘?’ at some places, you need to find the number of ways you can replace ‘?’ with ‘(‘ or ‘)’ to form a regular bracket sequence. A bracket sequence is called regular if it is possible to obtain the correct arithmetic expression by inserting characters + and 1 into this sequence.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ t ≤ 10<sup>5</sup></p><p>1 ≤ n ≤ 10<sup>3</sup> where n is the length of the string.</p><p>It is guaranteed that the sum of n<sup>2</sup> over all test cases does not exceed 10<sup>6</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\nconst int mod=1e9+7;\nint dp[1001][1001];\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        string s;\n        cin >> s;\n        int n = s.size();\n        for(int i=0;i<=n;i++)\n            for(int j=0;j<=n;j++)\n                dp[i][j]=0;\n        dp[0][0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            if(s[i-1] == '(') {\n                for (int j = 1; j < n; ++j) {\n                    dp[i][j] += dp[i-1][j-1];\n                    dp[i][j]%=mod;\n                }\n            }\n            else if(s[i-1] == ')') {\n                for (int j = 0; j < n; ++j) {\n                    dp[i][j] += dp[i-1][j+1];\n                    dp[i][j]%=mod;\n                }\n            }\n            else {\n                for (int j = 1; j < n; ++j) {\n                    dp[i][j] += dp[i-1][j-1];\n                    dp[i][j]%=mod;\n                }\n                for (int j = 0; j < n; ++j) {\n                    dp[i][j] += dp[i-1][j+1];\n                    dp[i][j]%=mod;\n                }\n            }\n        }\n        cout << dp[n][0] << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:47:35.716999+00:00"
      },
      "hints": {
        "hint1": "At any point, the number of ‘(‘ is always greater than equal to the number of ‘)’ and total count of ‘(‘ and ‘)’ in the string is equal.",
        "hint2": "Define dp[i][j] which denotes the number of ways to form a balanced bracket sequence such that the prefix sum till i is j. Denote ‘(‘ with 1 and ‘)’ with -1.",
        "solution_approach": "<p>For ?, consider both the cases for ‘(‘ and ‘)’. At any point, the prefix sum should not be negative. The answer would be dp[n][0] since the prefix sum should be 0 at the end of the string.</p><p>Time Complexity per test case: O(n<sup>2</sup>)</p>"
      },
      "id": 502,
      "input_format": "The first line of the input contains one integer t - the number of test cases. Then t test cases follow.\n\nThe first and only line of each test case contains a string with characters, ‘(‘, ‘)’ and ‘?’.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, following strings are possible: ()() and (()).\n\nFor the second test case, only one string is possible: ().\n\nFor the third test case, only one string is possible: ()()().\n\nFor the fourth test case, n is odd hence no string is possible.",
      "output_format": "For each test case, print the number of ways to replace ‘?’ with ‘(‘ or ‘)’ to form a balanced bracket sequence mod 10^9+7.",
      "samples": [
        {
          "input": "5\n(??)\n??\n()()()\n???\n??????",
          "output": "2\n1\n1\n0\n5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Balanced Bracket Sequence",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>X wants to transform a given string s into a palindrome.&nbsp;</p><p>X can interchange the position of any two adjacent characters of the string. X can do this as many time as it wants. What is the minimum number of times it must do this to get a palindrome. In case it's impossible, output -1.</p>",
      "complete_approach": "",
      "constraints": "<p>T ≤ 20</p><p>n ≤ 100</p><p>s consists of lowercase alphabets.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int t, n, i, j;\r\n\r\n    cin>>t;\r\n    while(t--)\r\n    {\r\n        cin>>n;\r\n        string s;\r\n        cin>>s;\r\n\r\n        int cnt[26]={0};\r\n        for(auto z:s) cnt[z-'a']++;\r\n\r\n        int l=0, r=s.size()-1;\r\n        int swaps=0;\r\n        bool ok=1;\r\n        while(l<r)\r\n        {\r\n            pair<int,int> cost={1e9,-1};\r\n            for(int letter=0;letter<26;letter++)\r\n            {\r\n                if(cnt[letter]<2) continue;\r\n                int costL=0, costR=0;\r\n                for(i=l;;i++)\r\n                {\r\n                    if(s[i]-'a'==letter) break;\r\n                    costL++;\r\n                }\r\n                for(i=r;;i--)\r\n                {\r\n                    if(s[i]-'a'==letter) break;\r\n                    costR++;\r\n                }\r\n                cost=min(cost,{costL+costR,letter});\r\n            }\r\n            if(cost.second==-1)\r\n            {\r\n                ok=0;break;\r\n            }\r\n            swaps+=cost.first;\r\n            \r\n            cnt[cost.second]-=2;\r\n            for(i=l;;i++)\r\n            {\r\n                if(s[i]-'a'==cost.second)break;\r\n            }\r\n            while(i>l)\r\n            {\r\n                swap(s[i],s[i-1]);\r\n                i--;\r\n            }\r\n            for(i=r;;i--)\r\n            {\r\n                if(s[i]-'a'==cost.second)break;\r\n            }\r\n            while(i<r)\r\n            {\r\n                swap(s[i],s[i+1]);\r\n                i++;\r\n            }\r\n            l++,r--;\r\n        }\r\n        if(!ok) cout<<\"-1\\n\";\r\n        else cout<<swaps<<'\\n';\r\n    }\r\n    \r\n}\r\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:34.971449+00:00"
      },
      "hints": {
        "hint1": "If the length of string is even, frequency of each character should be even and if the length of string is odd, frequency of exactly one character should be odd and for others it should be even.",
        "hint2": "<p>You can proceed to the complete solution.</p>",
        "solution_approach": "We take two pointers at the front and back of the string, say L and R, if they are equal then there is no need to swap them. Otherwise we can either make S[R] to be equal to S[L] or we can make S[L] to be equal to S[R]. So we need to find another character between L and R such that it is equal to the character S[L]/S[R]. Since we need to minimise the number of swaps, we should change S[L]/S[R] depending on where the smaller moves would be there.\n\nTime Complexity per test case: O(N^2)"
      },
      "id": 264,
      "input_format": "<p>First line of input contains <strong>T</strong>, number of test cases.</p><p>First line of each test case contains <strong>n, </strong>size of string .</p><p>Second line contains the string <strong>s</strong>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case if it's possible to trasnform s to a palindrome print the minimum number of swaps, else print -1.</p>",
      "samples": [
        {
          "input": "2\n4\naabb\n3\nabc",
          "output": "2\n-1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Palindrome swaps",
      "video_editorial_id": 8176
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a grid of size **n x m with integers, you need to find the maximum sum Subgrid.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ t ≤ 10<sup>5</sup><br>1 ≤ n, m ≤ 10<sup>5</sup><br>-10<sup>5</sup> ≤ a[i][j] ≤ 10<sup>5</sup></p><p>It is guaranteed that the sum of n x m over all test cases does not exceed 10<sup>5</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint t;\n\tcin >> t;\n\n\twhile (t--)\n\t{\n\t\tint n, m;\n\t\tcin >> n >> m;\n\n\t\tint grid[n][m];\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < m; ++j)\n\t\t\t{\n\t\t\t\tcin >> grid[i][j];\n\t\t\t}\n\t\t}\n\n\t\tlong long ans = -2e18;\n\n\t\tif (n >= m)\n\t\t{\n\t\t\tfor (int l = 0; l < m; ++l)\n\t\t\t{\n\t\t\t\tlong long temp[n];\n\t\t\t\tbool allNeg = true;\n\t\t\t\tlong long num = -2e18;\n\n\t\t\t\tmemset(temp, 0, sizeof(temp));\n\n\t\t\t\tfor (int r = l; r < m; ++r)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp[k] += grid[k][r];\n\t\t\t\t\t\tnum = max(num, 1LL * grid[k][r]);\n\n\t\t\t\t\t\tif (grid[k][r] >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tallNeg = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (allNeg)\n\t\t\t\t\t{\n\t\t\t\t\t\tans = max(ans, num);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long maxSum = temp[0], curSum = 0;\n\n\t\t\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurSum += temp[k];\n\t\t\t\t\t\t\tmaxSum = max(maxSum, curSum);\n\t\t\t\t\t\t\tcurSum = max(0ll, curSum);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tans = max(ans, maxSum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int l = 0; l < n; ++l)\n\t\t\t{\n\t\t\t\tlong long temp[m];\n\t\t\t\tbool allNeg = true;\n\t\t\t\tlong long num = -2e18;\n\n\t\t\t\tmemset(temp, 0, sizeof(temp));\n\n\t\t\t\tfor (int r = l; r < n; ++r)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k < m; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp[k] += grid[r][k];\n\t\t\t\t\t\tnum = max(num, 1LL * grid[r][k]);\n\n\t\t\t\t\t\tif (grid[r][k] >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tallNeg = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (allNeg)\n\t\t\t\t\t{\n\t\t\t\t\t\tans = max(ans, num);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long maxSum = temp[0], curSum = 0;\n\n\t\t\t\t\t\tfor (int k = 0; k < m; ++k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurSum += temp[k];\n\t\t\t\t\t\t\tmaxSum = max(maxSum, curSum);\n\t\t\t\t\t\t\tcurSum = max(0ll, curSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tans = max(ans, maxSum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:34:01.928703+00:00"
      },
      "hints": {
        "hint1": "If the left and right columns of the subgrid are fixed, think of an algorithm to find the consecutive rows which should be taken to maximise the sum.",
        "hint2": "Kadane’s Algorithm is used to find the maximum sum subarray. Same can be used for the grid.",
        "solution_approach": "<p>In Kadane’s algorithm, the maximum sum is found between two indexes. Here, the maximum sum between two rows can be found. Since the columns are fixed, a rectangle would be there. Consider the edge case when all elements in the grid are negative.</p><p>Time Complexity per test case: O(n x m<sup>2</sup>), if m ≤ n</p>"
      },
      "id": 497,
      "input_format": "<p>The first line of the input contains one integer <strong>t</strong> - the number of test cases. Then <strong>t</strong> test cases follow.<br>The first line of each test case contains two space-separated integers <strong>n</strong>, <strong>m</strong> - the size of the grid.<br>Each of the next <strong>n</strong> lines contains <strong>m</strong> space-separated integers, a[i][j] - the number at the cell (i, j).</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, the top left 2 x 2 subgrid, 10 + 2 - 4 + 5 = 13.\n\nFor the second test case, all cells have a maximum sum which is -1.\n\nFor the third test case, all cells are positive, maximum sum subgrid is the entire grid with sum 10.",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the maximum sum.</span></p>",
      "samples": [
        {
          "input": "3\n2 3\n10 2 -1\n-4 5 -1\n2 2\n-1 -1\n-1 -1\n2 2\n1 2\n3 4",
          "output": "13\n-1\n10"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Maximum Sum in Grid",
      "video_editorial_id": 8214
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two numbers $X, \\; Y$ which donate coordinates of a point in 2D plan. Determine in which quarter does it belong.\n\n$ \\textbf{Note:} $\n$ \\bullet $ Print $ \\textbf{Q1, Q2, Q3, Q4}$ according to the quarter in which the point belongs to.\n$ \\bullet $ Print $ \\textbf{\"Origem\"}$ If the point is at the origin.\n$ \\bullet $ Print $ \\textbf{\"Eixo X\"}$ If the point is over X axis.\n$ \\bullet $ Print $ \\textbf{\"Eixo Y\"}$ if the point is over Y axis.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 10 $\n$ -1000 \\leq X, Y \\leq 1000 $",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--)\n    {\n        double x, y;\n        cin >> x >> y;\n        if (x == 0 && y == 0) {\n            cout << \"Origem\" << \"\\n\";\n        } else if (x == 0) {\n            cout << \"Eixo Y\" << \"\\n\";\n        } else if (y == 0) {\n            cout << \"Eixo X\" << \"\\n\";\n        } else {\n            if (x>0 && y>0) {\n                cout << \"Q1\" << \"\\n\";\n            } else if (x<0 && y>0) {\n                cout << \"Q2\" << \"\\n\";\n            } else if (x<0 && y<0) {\n                cout << \"Q3\" << \"\\n\";\n            } else {\n                cout << \"Q4\" << \"\\n\";\n            }\n        }\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:32:12.380670+00:00"
      },
      "hints": {
        "hint1": "Try to use if else conditional statements in logical way to determine the quadrant..",
        "hint2": "",
        "solution_approach": "Q1 : x>0, y>0\nQ2 : x<0, y>0\nQ3 : x<0, y<0\nQ4 : x>0, y<0"
      },
      "id": 1163,
      "input_format": "The first line contains T. The number of test cases.\nFor each testcase: The first line contains two space seperated floating point numbers $ X $ and $ Y $.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print the output of each test case in a separate line.",
      "samples": [
        {
          "input": "1\n4.5 -2.2\n",
          "output": "Q4\n"
        },
        {
          "input": "1\n0.1 0.1\n",
          "output": "Q1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Coordinates of a Point",
      "video_editorial_id": 10656
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Given the x and y coordinates of 4 points on a 2D plane, determine whether it forms a valid square.</span></p><p>A <strong>valid square</strong> has four equal sides with positive length and four equal angles (90-degree angles).</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ x,y ≤ 10<sup>6</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*Returns square distance between two points p1 and p2*/\nlong long getDist(vector<long long> &p1, vector<long long> &p2) {\n    return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\n}\n\n/*Returns true if p1-p2-p3 forms right angle*/\nbool isRight(vector<long long> &p1, vector<long long> &p2, vector<long long> &p3) {\n    return !((p2[0] - p1[0]) * (p3[0] - p2[0]) + (p2[1] - p1[1]) * (p3[1] - p2[1]));\n}\n\nbool check(vector<long long>& p1, vector<long long>& p2, vector<long long>& p3, vector<long long>& p4) {\n    if(getDist(p1, p2) == getDist(p1, p4) && getDist(p2, p3) == getDist(p1, p4) && getDist(p3, p4) == getDist(p1, p4) && isRight(p4, p1, p2) && isRight(p2, p3, p4))\n        return true;\n    return false;\n}\n\nbool isValidSquare(vector<vector<long long> > &v) {\n    vector<long long> p1 = v[0];\n    vector<long long> p2 = v[1];\n    vector<long long> p3 = v[2];\n    vector<long long> p4 = v[3];\n\n    if(p1 == p2 || p1 == p3 || p1 == p4 || p2 == p3 || p2 == p4 || p3 == p4)\n        return false;\n    \n    if(check(p1, p2, p3, p4) || check(p1, p2, p4, p3) || check(p1, p3, p2, p4))\n        return true;\n    return false;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    vector<vector<long long>> v(4, vector<long long>(2));\n    for (int i = 0; i < 4; i++)\n        cin >> v[i][0] >> v[i][1];\n    cout << isValidSquare(v) << '\\n';\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:19:20.358771+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Check for all 4! possible ways if a square can be formed.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">What's the condition for 4 points to form a square?</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">If the vertices of the given figure are A,B, C, and D then the condition for it to be a square is:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">The sides AB, BC, CD and DA should be equal and be non-zero.</span></li><li><span style=\"background-color:transparent;color:#000000;\">The diagonals AC and BD should be equal.</span></li></ol><p><span style=\"background-color:transparent;color:#000000;\">To check this you can arrange the 4 vertices in all 4! = 24 ways and check for each arrangement. You can improve this by noticing that several of these arrangements will be the same. For example, ABCD, BCDA, CDAB, DABC, ADCB, DCBA, CBAD, and BADC are equal. So you can just check for the 3 distinct arrangements.</span></p>"
      },
      "id": 629,
      "input_format": "<p>There are 4 lines in the input each containing 2 integers <i>x</i> and <i>y </i>- the coordinates of the points.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>The given points form a valid square of unit area.</p>",
      "output_format": "<p>Print 1 if it is a valid square, else print 0.</p>",
      "samples": [
        {
          "input": "0 0\n1 0\n0 1\n1 1",
          "output": "1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nbool isValidSquare(vector<vector<long long>> &v)\n{\n    //add code here\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    vector<vector<long long>> v(4, vector<long long>(2));\n    for (int i = 0; i < 4; i++)\n        cin >> v[i][0] >> v[i][1];\n    cout << isValidSquare(v) << '\\n';\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "SQUARE",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a list of <i>N</i> intervals. The <i>i</i>-th interval is <i>[l<sub>i</sub>, r<sub>i</sub>)</i>, which denotes a range of numbers greater than or equal to <i>l<sub>i</sub></i> and strictly less than <i>r<sub>i</sub></i>.&nbsp;<br>Find the minimum integer <i>x</i> such that you can select <i>x</i> intervals from the given <i>N</i> intervals so that the union of the selected intervals is <i>[0, L)</i>.</p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 ≤ N ≤ 2×10^5\n1 ≤ L ≤ 10^12\n0 ≤ li &lt; ri ≤ L</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nint solve(vector<pair<ll,ll>> &v, ll L) {\n    map<ll,ll> M;\n    for(auto it : v) {\n        M[it.first] = max(M[it.first], it.second);\n    }\n\n    int ans = 0;\n    ll last = 0, maxi = 0;\n\n    for(auto it : M) {\n        if(it.first == last) {\n            maxi = max(maxi, it.second);\n            last = maxi;\n            ans++;\n        }\n        else if(it.first > last) {\n            ans++;\n            last = maxi;\n        }\n        maxi = max(maxi, it.second);\n    }\n\n    if(last < L) ans++;\n\n    return ans;\n}\n\nsigned main() \n{\n    ios::sync_with_stdio(0); \n    cin.tie(0); cout.tie(0);   \n    \n    int n;\n    ll L;\n    cin >> n >> L;\n    \n    vector<pair<ll,ll>> v;\n    for(int i = 0; i < n; i++) {\n        ll l, r;\n        cin >> l >> r;\n        v.push_back({l, r});\n    }\n\n    cout << solve(v, L) << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:15:12.191819+00:00"
      },
      "hints": {
        "hint1": "\nIt is given that the union of all the N intervals will be [0,L). But it is asked to find out the minimum count of intervals that’ll cover the entire number line. Is it feasible to take up all possible combinations of intervals whose union is [0,L) and find the minimum count? Think in a greedy way.",
        "hint2": "The number of intervals possible and the length of the number line is way too large, to consider the different possibilities of union that cover the entire length. Therefore it is recommended to use the sweep-line technique, to traverse across the entire number line in one go. Think about this approach.",
        "solution_approach": "This problem utilizes the sweep-line technique. The sweep line is dragged along the entire number line. At each point of the number line, the count of the minimum number of intervals that cover all regions upto that point is maintained. This process is continued until the end of the number line is reached, and the value of count gives the desired answer.\n\n\n**EXAMPLE RUN :**\n\nIntervals are given as [L,R)\n\n6 8\n\n0 2\n\n0 4\n\n5 8\n\n2 5\n\n3 6\n\n3 8\n\nThere are 6 intervals given, and the length is L=8\n\nSort all the intervals : [0,2)[0,4) [2,5) [3,6) [3,8) [5,8)\n\nInitially, covered point c is 0. So the first interval with L>c is [2,5). Till here, we take the interval that covers maximum distance, including start=0 i.e., interval [0,4), and the count of the interval is 1.\n\nPoints covered till now are c=4. Again take the first interval with L>c i.e.[5,8). In between, take the interval that covers maximum distance after [0,4) and starts before or at 4. Here such an interval is [3,8). Again count of interval increments by now.\n\nThe points covered till now are 8 which is the length of the total number line. So the value of count = 2 is the minimum number of intervals required. The intervals are [0,4) and [3,8).\n\nTIME COMPLEXITY: O(NlogN)"
      },
      "id": 118,
      "input_format": "<p>The first line contains two integers <i>N</i> (1 ≤ <i>N </i>≤ 2×10<sup>5</sup>) and <i>L</i> (1 ≤ <i>L </i>≤ 10<sup>12</sup>), where <i>N</i> is the number of intervals and <i>L</i> is the length of the range to be covered, respectively.&nbsp;<br>The <i>i</i>-th of the following <i>N</i> lines contains two integers <i>l<sub>i</sub></i> and <i>r<sub>i</sub></i> (0 ≤ <i>l<sub>i </sub></i>&lt; <i>r<sub>i </sub></i>≤ <i>L</i>), representing the range of the <i>i</i>-th interval <i>[l<sub>i</sub>, r<sub>i</sub>)</i>.&nbsp;<br>You can assume that the union of all the <i>N</i> intervals is <i>[0, L)</i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "**For Testcase 1:**\n\nConsider the interval from 0 to 8. There are 5 different intervals given . \n\nThe intervals which on union give the interval [0,8) are\n\n1.  [0,4) U [3,6) U [5,8)\n\n2.  [0,4) U [3,8)\n\n3.  [0,4) U [2,5) U [5,8)\n\nClearly, the minimum number of intervals required to cover the complete intervals is 2 i.e. intervals [0,4) and [3,8). So the output is 2.",
      "output_format": "<p>Output integer <i>x</i> mentioned in the problem statement.</p>",
      "samples": [
        {
          "input": "5 8\n0 4\n5 8\n2 5\n3 6\n3 8",
          "output": "2"
        },
        {
          "input": "5 4\n0 2\n2 4\n0 3\n1 3\n3 4",
          "output": "2"
        },
        {
          "input": "2 4\n0 4\n0 4",
          "output": "1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Solve Intervals 1",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given a non-empty string S consisting of lower case characters. You can change at most K letters to maximise the cost. If in the final string, X immediately precedes Y, you get an increase in cost by C. You have to determine the maximum cost possible.",
      "complete_approach": "",
      "constraints": "1. $$1 \\leq T \\leq 100$$\n2. $$1 \\leq |S| \\leq 100$$ where $|S|$ denotes the length of the string $S$\n3. $$0 \\leq K \\leq 100$$\n4. $$0 \\leq M \\leq 676$$\n5. $$a \\leq X, Y \\leq z$$\n6. $$-1000 \\leq C \\leq 1000$$\n7. It is guaranteed that no pair $X Y$ is mentioned twice in the input data.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\nint dp[102][102][26];\n\nsigned main(){\n    IOS\n    int t;\n    cin>>t;\n    while(t--) {\n        string s;\n        int k,m;\n        cin>>s>>k>>m;\n        int n=s.size();\n        int c[26][26]={0};\n        while(m--){\n            char c1,c2;\n            int t;\n            cin>>c1>>c2>>t;\n            c[c1-'a'][c2-'a']=t;\n        }\n        for(int i=0; i<=n; ++i){\n            for(int j=0; j<=k; ++j){\n                for(int p=0; p<26; ++p){\n                    dp[i][j][p]=-1e9;\n                }\n            }\n        }\n        for(int i=0; i<26; ++i){\n            dp[0][1][i]=0;\n        }\n        dp[0][0][s[0]-'a']=0;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<=k; ++j){\n                for(int p=0; p<26; ++p){\n                    if(dp[i][j][p] != -1e9){\n                        for(int d=0; d<26; ++d){\n                            int t;\n                            if(s[i+1]-'a' == d) t=0;\n                            else t=1;\n                            dp[i+1][j+t][d]=max(dp[i+1][j+t][d], dp[i][j][p] + c[p][d]);\n                        }\n                    }\n                }\n            }\n        }\n        int ans=-1e18;\n        for(int i=0; i<=k; ++i){\n            for(int j=0; j<26; ++j){\n                ans=max(ans, dp[n-1][i][j]);\n            }\n        }\n        cout<<ans<<\"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:33:55.367381+00:00"
      },
      "hints": {
        "hint1": "It can be seen that if we put some character c at position p of the string S, it will not affect symbols at positions (p+2) and greater.",
        "hint2": "We make a DP array as DP[i][j][p] where i denotes the index of the currently processed symbol of the string, j denotes the number of symbols already changed and  p– the previous symbol.",
        "solution_approach": "To calculate the answer for a state, you should choose the best value among all symbols for the current position or just go to the next index with the current symbol s[p]. Thus we get the followings DP transitions:\n\nWhen changing the symbol, DP[i+1][j+1][d]=max(DP[i+1][j+1][d], DP[i][j][p] + c[p][d])\n\nGoing to next character without changing, DP[i+1][j][d]=max(DP[i+1][j][d], DP[i][j][p] + c[p][d])\n\nTime Complexity per test case: O(N*K*26*26)"
      },
      "id": 187,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains string S and an integer K - the number of characters you can change at most.\n\nThe second line of each test case contains M - the number of cost values.\n\nThe following M lines contain two space-separated integers along with a character X Y C - you get an increase in cost by C if X immediately precedes Y.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, change string to adcbz, cost becomes 100+55 = 155\n\nFor the second test case, changing any character will result in negative cost, we don’t change the original string/we can change the string so that e,a and c,v are not adjacent.\n\nFor the third test case, change string to yzcd, cost becomes 100.",
      "output_format": "For each test case, print a single integer denoting the maximum cost possible on a separate line.",
      "samples": [
        {
          "input": "3\nakcbd 2\n3\na d 55\nb z 100\nb c 50\nsrtlmx 2\n2\ne a -167\nc v -932\nabcd 2\n4\nx y 10\ny z 100\na x -150\nz d -150",
          "output": "155\n0\n100"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 8,
      "title": "Maximising The Cost",
      "video_editorial_id": 8165
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given a directed graph with $N$ vertices and $M$ edges.\n\nWhat is the minimum number of edges needed to reverse in order to have at least one path from vertex $1$ to vertex $N$, where the vertices are numbered from $1$ to $N$ ?",
      "complete_approach": "",
      "constraints": "$1 ≤ T ≤ 10$\n$1 ≤ N, M ≤ 10^{5}$\n1 ≤ $X_i$, $Y_i$ ≤ $N$\nThere can be multiple edges connecting the same pair of vertices, There can be self-loops too i.e. $X_i$ = $Y_i$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint n, m;\nvector<vector<array<int, 2>>> adj;\nvoid solve() {\n\tcin >> n >> m;\n\tadj.assign(n + 1, vector<array<int, 2>>());\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].push_back({v, 0}); // normal edge having weight 0.\n\t\tadj[v].push_back({u, 1}); // reverse edge having weight 1.\n\t}\n\tdeque<int> dq;\n\tvector<int> dist(n + 1, 1e9);\n\tdist[1] = 0;\n\tdq.push_front(1);\n\twhile (!dq.empty()) {\n\t\tauto v = dq.front();\n\t\tdq.pop_front();\n\t\tfor (auto x : adj[v]) {\n\t\t\tif (dist[x[0]] > dist[v] + x[1]) {\n\t\t\t\tdist[x[0]] = dist[v] + x[1];\n\t\t\t\tif (x[1])dq.push_back(x[0]);\n\t\t\t\telse dq.push_front(x[0]);\n\t\t\t}\n\t\t}\n\t}\n\tif (dist[n] == 1e9)cout << -1<<endl;\n\telse cout << dist[n]<<endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:26:19.185583+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Add a reverse edge of each original edge in the graph. Give reverse edge a weight=1 and all original edges a weight of 0. Now, the length of the shortest path will give us the answer.\n\nHow?\n\nIf the shortest path length is $k$: it means we used $k$ reverse edges in the shortest path. So, it will give us the answer.\nThe shortest path algorithm will always try to use as few reverse paths as possible because they have a higher weight than the original edges.\n\nTo find the shortest path, we can use Dijkstra’s Algorithm which works in $O(|E| log |V|)$ if implemented using adjacency lists and priority queue.\nAlso, since there are only 0 and 1 weight edges, we can also do this by $0/1$ **BFS** in $O(N+M)$: maintain a deque instead of a queue and add a vertex to the front of the deque if 0 edges are used and to the back of the deque otherwise.\n\n**Note**: Intended time complexity for this problem is $O(N+M)$ per test case."
      },
      "id": 900,
      "input_format": "The first line contains $T$ - the number of test cases.\n\nThe first line of each test case contains two space-separated integers $N$ and $M$, denoting the number of vertices and the number of edges in the graph respectively. \nThe $i^{th}$ line of the next $M$ lines of each test case contains two space-separated integers $X_i$ and $Y_i$, denoting that the $i^{th}$ edge connects vertices from $X_i$ to $Y_i$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "We can consider two paths from 1 to 7:\n\n$1-2-3-4-7$\n$1-2-6-5-7$\n\nIn the first one we need to revert edges $(3-2), (7-4)$. In the second one - $(6-2), (5-6), (7-5)$. So the answer is $min(2, 3) = 2$.",
      "output_format": "For each test case, In a single line, print the minimum number of edges we need to revert. If there is no way of having at least one path from $1$ to $N$, print -1.",
      "samples": [
        {
          "input": "1\n7 7\n1 2 \n3 2\n3 4\n7 4\n6 2\n5 6\n7 5\n",
          "output": "2\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Edge Reverse",
      "video_editorial_id": 8236
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "We can scramble a string $s$ to get a string $t$ using the following algorithm:\n\n1. If the length of the string is $1$, stop.\n2. If the length of the string is $> 1$, do the following:\n    2.1 Split the string into two non-empty substrings at a random index, i.e., if the string is $s$, divide it to $x$ and $y$ where $s = x + y$.\n    2.2 Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, $s$ may become $s = x + y$ or $s = y + x$.\n\n3. Apply step $1$ recursively on each of the two substrings $x$ and $y$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$\n$s1.length == s2.length$\n$1 <= s1.length <= 40$\n$s1$ and $s2$ consist of lower-case English letters.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint dp[41][41][41];\nstring s1, s2;\nbool rec(int l, int r, int i) {\n    int j = i + r - l; // relationship... to reduce DP state.\n\n    // we are trying to match if s1[l...r] is scrable of s2[i...j].\n    // pruning\n    if (l > r || i > j)return false;\n    // basecase .. if single element, check if same.\n    if (l == r) {\n        if (s1[l] == s2[i])return true;\n        return false;\n    }\n    auto &ans = dp[l][r][i];\n    if (ans != -1)return ans;\n\n    ans = 0; // by default we asume false.\n\n    // if the two strings are same, trivially true.\n    if (s1.substr(l, r - l + 1) == s2.substr(i, j - i + 1))return ans = 1;\n\n\n    for (int k = l; k < r; k++) {\n    \t// try to take first [l.. k] and [i...k] and rest part.\n        ans |= (rec(l, k, i)&rec(k + 1, r, i + k - l + 1));\n        // try to take first [l.. k] and [same length of s1] and rest part.\n        ans |= (rec(l, k, j - (k - l + 1) + 1)&rec(k + 1, r, i));\n    }\n    return ans;\n}\nvoid solve() {\n    cin >> s1 >> s2;\n    memset(dp, -1, sizeof(dp));\n    if (rec(0, s1.size() - 1, 0)) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:29:48.632533+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "#### Note -:\nFor this problem, the expected time complexity is $O(N^{4})$ per test case, where $N=|s1|$.\nSo, try to reduce trivial $O(N^{5})$ into $O(N^{4})$ time."
      },
      "id": 909,
      "input_format": "The first-line contains $T$ - the number of test cases. \nEach test case contains two strings $s1$ and $s2$ of the same length.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For test case $3$,\nOne possible scenario applied on s1 is:\n- \"great\" --> \"gr/eat\" // divide at random index.\n- \"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n- \"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at ranom index each of them.\n- \"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n- \"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n- \"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\n\nThe algorithm stops now and the result string is \"rgeat\" which is $s2$.\nAs there is one possible scenario that led s1 to be scrambled to $s2$, we ouput \"Yes\".",
      "output_format": "For each test case, output \"*Yes*\" if $s2$ is a scrambled string of $s1$, otherwise, output \"*No*\", in a newline.",
      "samples": [
        {
          "input": "3\nabcde caebd\na a\ngreat rgeat\n",
          "output": "No\nYes\nYes\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Scrambled String",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given an array <i>A</i>. The diversity of the array <i>A</i> is defined as the number of pairs <i>i, j</i>, <i>i &lt; j</i> such that <i>A<sub>i</sub> ≠ A<sub>j</sub></i>.<br>You want to maximize the diversity of the array. For that, you are allowed to make at most <i>K</i> operations on it, in any of which, you can select a particular element and change its value to any integer in the range 1 to 10<sup>9</sup>, both inclusive.<br>Find out the maximum diversity of the array that you can obtain.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>T</i> ≤ 20<br>0 ≤ <i>K</i> ≤ 10<sup>9</sup><br>2 ≤ <i>N</i> ≤ 10<sup>5</sup><br>1 ≤ <i>A<sub>i</sub></i> ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int T; cin >> T;\n    while(T--) {\n        int n, k; cin >> n >> k;\n\n        map<int,int> M;\n\n        for(int i = 0; i < n; i++) {\n            int x; cin >> x;\n            M[x]++;\n        }\n\n        priority_queue<pair<int,int>> q;\n\n        ll ans = 1LL * n * (n - 1) / 2;\n\n        for(auto it : M) {\n            if(it.second > 1) {\n                q.push({it.second, it.first});\n                ans -= 1LL * it.second * (it.second - 1) / 2;\n            }\n        }\n\n        for(int i = 0; i < k; i++) {\n            if(q.empty()) break;\n            auto it = q.top();\n            q.pop();\n            ans += it.first - 1;\n            it.first--;\n            if(it.first > 1) q.push(it);\n        }\n\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:17:52.093351+00:00"
      },
      "hints": {
        "hint1": "<p>Try to think in a greedy way. Note that we can change any number to any number in between 1 to 10<sup>9</sup>. And the max size of the array is 10<sup>5</sup>.<br>That means in the best case, it's always possible to make all elements distinct (obviously when <i>K</i> is sufficiently large).</p>",
        "hint2": "<p>Let <i>cnt<sub>i</sub></i> denotes the number of occurrence of <i>i</i> in the array. In the current step, it's always better to change such <i>i</i> which has maximum <i>cnt<sub>i</sub></i> value.<br>Because it will add <i>cnt<sub>i</sub></i>-1 <strong>extra</strong> value in the current diversity.</p>",
        "solution_approach": "<p>Note that we can change any number to any number in between 1 to 10<sup>9</sup>. And the max size of the array is 10<sup>5</sup>.<br>That means in the best case, it's always possible to make all elements distinct (obviously when <i>K</i> is sufficiently large).<br><br>Let <i>cnt<sub>i</sub></i> denotes the number of occurrence of <i>i</i> in the array. In the current step, it's always better to change such <i>i</i> which has maximum <i>cnt<sub>i</sub></i> value.<br>Because it will add <i>cnt<sub>i</sub></i>-1 <strong>extra</strong> value in the current diversity.<br><br>Based on these observations we can design our algorithm using a <strong>priority queue</strong>.</p><ol><li>Enumerate <i>cnt<sub>i</sub></i> structure, where <i>cnt<sub>i</sub></i> denotes the count of occurrence of <i>i</i> in the array.</li><li>In the current step, change the value of number <i>i</i> such that <i>cnt<sub>i</sub></i> is maximum. Update <i>cnt<sub>i</sub></i>, i.e., <i>cnt<sub>i</sub>--</i>. Note that we have sufficiently large non-occurred numbers available because the max size of the array is 10<sup>5</sup>, and allowed-change varies from 1 to 10<sup>9</sup>.</li><li>Do step 2, for <i>K</i> times. To find max <i>cnt<sub>i</sub></i> value, maintain a <strong>priority queue</strong> structure with pairs {<i><strong>cnt<sub>i</sub>, i</strong></i>}. And arranged the priority queue structure with <i>cnt<sub>i</sub></i> values.</li><li><i>cnt<sub>i</sub></i> values can be maintained using <strong>Map</strong> in <i>STL C++.</i><br>&nbsp;</li></ol><p>See the solution code.<br><br><strong>Time complexity:</strong> <i>O(NlogN)</i><br><strong>Space complexity:</strong> <i>O(N) extra space</i></p>"
      },
      "id": 97,
      "input_format": "<p>The first line will contain <i>T</i>, number of test cases. Then the test cases follow.<br>The first line of each test case contains two integers <i>N</i>, <i>K</i>. where <i>N</i> denotes the length of array <i>A</i>.<br>The next line of each test case contains <i>N</i> space-separated integers, the <i>i</i>-th of which denotes <i>A<sub>i</sub></i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>Every element in the array is different. The diversity is 6, which is the maximum possible.<br><br><i><strong>Explanation 2:</strong></i><br>Change the array to <i>A</i> = [1, 3, 2, 5]. Here we only need to change elements at 2nd and 4th positions. Now all elements are different.<br>The maximum diversity is 6.<br><br><i><strong>Explanation 3:</strong></i><br>Change the array to <i>A</i> = [5, 6, 2, 3, 4, 4]. Here we change the elements at positions 1 and 2. The maximum diversity is 14.</p>",
      "output_format": "<p>For each test case, output in a single line, the answer corresponding to the test case, which should be an integer denoting the maximum possible diversity.</p>",
      "samples": [
        {
          "input": "3\n3 10\n1 2 3\n4 2\n1 1 2 2\n6 2\n2 3 3 2 4 4",
          "output": "3\n6\n14"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Diversify the Array",
      "video_editorial_id": 8149
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a weighted tree consisting of <i>N</i> vertices. Vertices <i>u<sub>i</sub></i> and <i>v<sub>i</sub></i> are connected by an edge with weight <i>w<sub>i</sub></i>.</p><p>Let's define the <i>K</i>-coloring of the tree as an assignment of exactly <i>K</i> colors to each vertex so that each color is used no more than two times. You can assume that you have infinitely many colors available. We say that an edge is saturated in the given <i>K</i>-coloring if its endpoints share at least one color (i.e. there exists a color that is assigned to both endpoints).</p><p>Let's also define the value of a <i>K</i>-coloring as the sum of weights of saturated edges.</p><p>Please calculate the maximum possible value of a <i>K</i>-coloring of the given tree.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:47:23.909841+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 448,
      "input_format": "<p>The first line contains an integer T ( 1 ≤ T ≤ 10^5) - the number of test case.</p><p>The first line of each test case contains two space-separated integers N, K ( 1 ≤ N, K ≤ 10^6).</p><p>The next N-1 lines contain a description of an edge → u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub> (1 ≤ u<sub>i</sub>, v<sub>i</sub> ≤ N, u<sub>i</sub>≠v<sub>i</sub>, 1 ≤ w ≤ 10^5). Vertices u<sub>i</sub> and v<sub>i</sub> are connected by an undirected edge of weight w<sub>i</sub>.</p><p>It is guaranteed that sum of all <i>N</i> over all test cases does not exceed 10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case print the maximum possible value of a <i>K</i>-coloring of the given tree in a new line.</p>",
      "samples": [
        {
          "input": "10\n9 3\n7 4 10\n6 8 1\n1 3 6\n2 4 10\n2 9 1\n5 4 9\n3 6 5\n1 2 5\n2 6\n1 2 2\n2 4\n1 2 8\n7 7\n4 3 2\n6 5 1\n3 2 3\n3 5 7\n7 1 10\n1 2 9\n3 9\n3 2 6\n2 1 8\n7 10\n1 5 9\n3 4 2\n1 3 6\n7 3 9\n3 6 3\n1 2 3\n6 3\n2 1 4\n4 2 10\n3 5 2\n3 1 5\n2 6 5\n1 2\n9 8\n4 7 7\n4 6 2\n2 9 9\n2 3 5\n5 3 3\n8 2 2\n2 1 1\n1 4 4\n7 4\n7 1 2\n1 2 8\n2 5 2\n2 3 9\n2 4 7\n5 6 1",
          "output": "47\n2\n8\n32\n14\n32\n26\n0\n33\n29"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "K Coloring Tree",
      "video_editorial_id": 8205
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a singly linked list, rotate the list to the right by <i>K</i> places.</p><p>Complete the function</p><pre><code class=\"language-plaintext\">ListNode* rotateList(ListNode* head, int K)</code></pre><p><i>head </i>points to the beginning of the list.</p>",
      "complete_approach": "",
      "constraints": "<p>0 ≤ Length of the linked list ≤ 10<sup>6</sup><br>0 ≤ K ≤ 10<sup>9</sup><br>0 ≤ Value stored in node ≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* rotateList(ListNode* head, int K) {\n    if(!head) return NULL;\n    if(!K) return head;\n\n    int n = 0;\n    ListNode *cur = head;\n    ListNode *last = head;\n\n    while(cur) {\n        n++;\n        last = cur;\n        cur = cur->next;\n    }\n\n    K %= n;\n\n    cur = head;\n\n    for(int i = 0; i < n - K - 1; i++)\n        cur = cur->next;\n\n    last->next = head;\n\n    ListNode *temp = cur->next;\n    cur->next = NULL;\n\n    return temp;\n}\n\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    int K;\n    cin >> K;\n\n    ListNode* head = GetList(num);\n\n    head = rotateList(head, K);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:15:08.116398+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 529,
      "input_format": "<p>The first line of input contains <i>n </i>- the length of the linked list.<br>The second line contains <i>n </i>space-separated integers denoting the sequence of values stored in nodes of the linked list.<br>The last of the input contains <i>K.</i></p><p>The following function creates the linked list from the input</p><pre><code class=\"language-plaintext\">ListNode* GetList(vector&lt;int&gt; &amp;num)</code></pre>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "3\n1 2 3\n0",
          "output": "1 2 3"
        },
        {
          "input": "3\n1 2 3\n1",
          "output": "3 1 2"
        },
        {
          "input": "3\n1 2 3\n6",
          "output": "1 2 3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</fix>\n\nListNode* rotateList(ListNode* head, int K) {\n    //Complete the function\n}\n\n<fix>\nListNode* GetList(vector<int> &num) {\n    ListNode* head = nullptr;\n\n    if(num.empty()) {\n        return head;\n    }\n\n    ListNode* cur = head;\n    \n    for(int i  = 0; i < (int)num.size(); i++) {\n        ListNode* temp = new ListNode(num[i]);\n        if(!cur) {\n            cur = temp;\n            head = cur;\n        }\n        else {\n            cur->next = temp;\n            cur = temp;\n        }\n    }\n    \n    return head;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> num;\n    for(int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        num.push_back(x);\n    }\n\n    int K;\n    cin >> K;\n\n    ListNode* head = GetList(num);\n\n    head = rotateList(head, K);\n\n    while(head) {\n        cout << head->val << \" \";\n        head = head->next;\n    }\n    cout << \"\\n\";\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Rotate List",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are <i>2*N</i> Chess players and <i>N</i> Boards in a chess tournament. The rating of the Chess Player is given by array <i>A</i>. Every player can play only with one player.<i> </i>N board pairing to be done, and if you match Player i and Player j in the board K, then the Happiness Score increases by K*abs(A[i]-A[j])*gcd(A[i],A[j]). Find the Maximum Happiness score you can make by designing an ideal pairing. Every player should play a match.</p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma comment(linker, \"/stack:200000000\")\n#define mod 1000000007\n#define pb emplace_back\n#define mp make_pair\n#define fi first\n#define sec second\ntypedef long long int ll;\ntypedef long double  ld;\n#define pii pair<ll,ll> \n#define vi vector< ll > \n#define vvi vector< vi > \n#define vpi vector< pii > \n#define vvpi vector< vpi > \n#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define test(t) ll t;cin>>t;while(t--)\n#define mem(a,b) memset(a,b,sizeof(a))\n#define inn freopen(\"input.txt\", \"r\", stdin)\n#define outt freopen(\"output.txt\", \"w\", stdout)\n#define all(arr) arr.begin(),arr.end()\n#define fr(i,n) for(ll i=0;i<(n);++i)\n#define rep(i,a,b) for(ll i=a;i<=b;++i)\n#define per(i,a,b) for(ll i=a;i>=b;i--)\n#define remin(a,b) (a=min((a),(b)))\n#define remax(a,b) (a=max((a),(b)))\n#ifndef ONLINE_JUDGE\n#define debarr(a,n)cerr<<#a<<\":\";for(ll i=0;i<n;i++)cerr<<a[i]<<\" \";cerr<<endl;\n#define debmat(mat,row,col)cerr<<#mat<<\":\\n\";for(ll i=0;i<row;i++){for(ll j=0;j<col;j++)cerr<<mat[i][j]<<\" \";cerr<<endl;}\n#define pr(...)dbs(#__VA_ARGS__,__VA_ARGS__)\ntemplate<class S,class T>ostream &operator<<(ostream &os,const pair<S,T> &p){return os<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T>ostream &operator<<(ostream &os,const vector<T> &p){os<<\"[\";for(auto&it:p)os<<it<<\" \";return os<<\"]\";}\ntemplate<class T>ostream &operator<<(ostream &os,const set<T>&p){os<<\"[\";for(auto&it:p)os<<it<<\" \";return os<<\"]\";}\ntemplate<class T>ostream &operator<<(ostream &os,const multiset<T>&p){os<<\"[\";for(auto&it:p)os<<it<<\" \";return os<<\"]\";}\ntemplate<class S,class T>ostream &operator<<(ostream &os,const map<S,T>&p){os<<\"[\";for(auto&it:p)os<<it<<\" \";return os<<\"]\";}\ntemplate<class T>void dbs(string str,T t){cerr<<str<<\":\"<<t<<\"\\n\";}\ntemplate<class T,class...S>void dbs(string str,T t,S... s){ll idx=str.find(',');cerr<<str.substr(0,idx)<<\":\"<<t<<\",\";dbs(str.substr(idx+1),s...);}\n#else\n#define pr(...){}\n#define debarr(a,n){}\n#define debmat(mat,row,col){}\n#endif\nll power(ll x,ll y){ll res = 1;while(y){if(y&1) res = (res*x)%mod;y=y/2,x=(x*x)%mod;}return res%mod;}\nll dp[1<<20];\nvvi pre_bits(1<<20);\nll pre_gcd[20][20];\nll arr[20];\nll n;\nll gcd(ll a, ll b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b); \n     \n}\nll func(ll mask){\n    if(mask==((1<<n)-1)){\n        return 0;\n    }\n    ll &ret = dp[mask];\n    if(ret!=-1)return ret;\n    ret = 0;\n    ll k = (n-pre_bits[mask].size())/2+1;\n    fr(i,pre_bits[mask].size()){\n        rep(j,i+1,pre_bits[mask].size()-1){\n            ret = max(ret,k*abs(arr[pre_bits[mask][i]]-arr[pre_bits[mask][j]])*pre_gcd[pre_bits[mask][i]][pre_bits[mask][j]] + func(mask|(1<<pre_bits[mask][i])|(1<<pre_bits[mask][j])));\n        }\n    }\n    return ret;\n}\nsigned main()\n{\n    fast;\n    test(t){\n        cin>>n;\n        n*=2;\n        fr(i,(1<<n)){\n            pre_bits[i].clear();\n            fr(j,n){\n                if(i&(1<<j))continue;\n                pre_bits[i].pb(j);\n            }\n        }\n        fr(i,n)cin>>arr[i];\n        mem(dp,-1);\n        fr(i,n)fr(j,n)pre_gcd[i][j] = gcd(arr[i],arr[j]);\n        cout<<func(0)<<\"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:42:54.200663+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Can we use Bitmask DP in some way?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">We would make the DP array as DP[pos][vis] which denotes the maximum happiness that could be achieved by taking pos number of chess boards and vis is the subset of people assigned any chess board. Any board would be assigned to two people, this can be done by taking a nested loop and assigning two people, who have not been assigned a board yet. The base case would be when all the boards have been assigned. But this solution would result in TLE as it is O(N^3 * 2^(2*N)). Can you optimise the solution by removing ‘pos’ from the DP array?</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">It can be seen that any chess board is assigned to exactly two people, so the number of chess boards would be equal to half of the subset of people who have been assigned a chess board. Doing this optimisation would reduce the time complexity from O(N^3 * 2^(2*N)) to O(N^2 * 2^(2*N)). Note that you need to use memoization otherwise the answer will result in TLE.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N^2 * 2^(2*N))</span></p>"
      },
      "id": 453,
      "input_format": "<p>The first line contains an integer T (1 ≤ T ≤ 2) - the number of test cases.</p><p>The first line of each test case contains an integer N. 1 ≤ N ≤ 10.</p><p>The next line contains 2*N space-separated integers, 1 ≤ A[i] ≤ 10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>Third test case - Optimal pairing is (2,10),(4,8),(1,6).</p>",
      "output_format": "<p>For each test case print the output in a new line.</p>",
      "samples": [
        {
          "input": "3\n3\n55 86 61 8 9 39 \n7\n35 68 51 23 66 61 85 34 2 65 64 6 7 32 \n3\n2 10 1 6 4 8",
          "output": "654\n19318\n85"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Chess And GCD",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Your task is to build a tower whose width is <strong>2</strong> and height is <strong>n</strong>. You have an unlimited supply of blocks whose width and height are integers.</p><p>For example, here are some possible solutions for &nbsp;<strong>n = 6</strong>:</p><figure class=\"image\"><img src=\"https://algozenith.s3.ap-south-1.amazonaws.com/content/07-02-22/99_1644200296111.png\"></figure><p>Given <strong>n</strong>, how many different towers can you build? Mirrored and rotated towers are counted separately if they look different.</p>",
      "complete_approach": "",
      "constraints": "<ul><li>1 ≤ <strong>t</strong> ≤ 10<sup>6</sup><br>&nbsp;</li><li>1 ≤ <strong>n </strong>≤ 10<sup>6</sup></li></ul>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nconst int mx = 1e6 + 10, mod = 1e9 + 7;\nll dp[mx][2];\nll rec(int i, bool f) {\n\tif (i == 1) return 1;\n\tauto &ans = dp[i][f];\n\tif (ans != -1)return ans;\n\tans = 0;\n\tif (f)(ans += 4 * rec(i - 1, 1) + rec(i - 1, 0)) %= mod;\n\telse (ans += 2 * rec(i - 1, 0) + rec(i - 1, 1)) %= mod;\n\treturn ans;\n}\nvoid solve() {\n\tmemset(dp, -1, sizeof(dp));\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tcout << (rec(n, 0) + rec(n, 1)) % mod << endl;\n\t}\n\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\t// cin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:30:19.516764+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "<p>Think about the last row of the tower. You can either have both cells as a part of the same block, or both cells as parts of different blocks. Let's call towers of the first kind type-1 towers and the towers of the second kind type-2 towers.</p><p>Let's call <strong>a<sub>n</sub></strong> be the number of type-1 towers and <strong>b<sub>n</sub></strong> be the number of type-2 towers.</p><p>For computing <strong>a<sub>n</sub></strong>, look at what remains when you remove the last row from the tower. Corresponding to a type-1 tower of height <strong>n−1</strong>, there will be two such towers, and corresponding to a type-2 tower of height <strong>n−1</strong>, there will be one such tower, so <strong>a<sub>n </sub>= 2*a<sub>n-1 </sub>+ b<sub>n−1</sub></strong>. In a similar manner, you have <strong>b<sub>n </sub>= 4*b<sub>n−1 </sub>+ a<sub>n−1</sub></strong>.</p><p>Base Cases will be &nbsp;<strong>a<sub>1</sub> = b<sub>1</sub> = 1</strong>.</p><p>Then you can precompute the answers to all possible queries using DP. The answer is <strong>a<sub>n</sub>+b<sub>n</sub></strong>.</p><p><strong>Time Complexity</strong>: <strong>O(N) </strong>precomputation,<strong> O(1) </strong>per test case<strong>.</strong></p>"
      },
      "id": 907,
      "input_format": "<p>The first input line contains an integer <strong>t</strong>: the number of tests.</p><p>After this, there are <strong>t</strong> lines, and each line contains an integer <strong>n</strong>: the height of the tower</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test, print the number of towers modulo <strong>10<sup>9</sup>+7.</strong></p>",
      "samples": [
        {
          "input": "3\n2\n6\n1337",
          "output": "8\n2864\n640403945"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Jenga Tower",
      "video_editorial_id": 8239
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "There is a building with $N$ floors (numbered $1$ through $N$ from top to bottom), each with $M$ windows. All the windows need to be cleaned. For each valid $i$ and $j$, the window $(i, j)$ must be cleaned on the $A(i, j)$-th turn.  \n\n**From window $(i, j)$, water flows to the windows $(i+1, j-1)$, $(i+1, j)$, and $(i+1, j+1)$ if they exist.**  \nWhen a window $(i, j)$ is cleaned, the windows $(i+1, j-1)$, $(i+1, j)$, and $(i+1, j+1)$ become dirty because of dirty water after cleaning window $(i, j)$.  \n\nWater flows further down from these dirty windows, making the next level of windows dirty. The same process continues recursively.\n\n### Example:\nWhen the window $(0, 5)$ is cleaned:  \n- Water flows down to windows $(1, 4)$, $(1, 5)$, and $(1, 6)$, making them dirty.  \n- Then water flows from window $(1, 4)$ to $(2, 3)$, $(2, 4)$, $(2, 5)$.  \n- From window $(1, 5)$, water flows to $(2, 4)$, $(2, 5)$, $(2, 6)$.  \n- And so on.\n\n### Task:\nYou have to determine whether each window will be clean after the cleaning process ends.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤ 1000</p><p>1 ≤ N, M ≤ 1000</p><p>1 ≤ Ai,j ≤ N*M</p><p>Sum of N*M across all test cases &lt;= 10^7.</p><p>&nbsp;</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main(){\n   IOS\n   int t;\n   cin>>t;\n   while(t--) {\n       int n,m;\n       cin>>n>>m;\n       bool a[n][m];\n       int dp[n][m];\n\n       for(int i=0; i<n; ++i){\n           for(int j=0; j<m; ++j){\n               dp[i][j]=0,a[i][j]=0;\n               int x;\n               cin>>x;\n               if(i-1>=0){\n                   dp[i][j]=max(dp[i][j], dp[i-1][j]);\n                   if(j-1>=0)\n                       dp[i][j]=max(dp[i][j], dp[i-1][j-1]);\n                   if(j+1<m)\n                       dp[i][j]=max(dp[i][j], dp[i-1][j+1]);\n               }\n               if(x>=dp[i][j])\n                   a[i][j]=1;\n               dp[i][j]=max(dp[i][j], x);\n           }\n       }\n       for(int i=0; i<n; ++i){\n           for(int j=0; j<m; ++j){\n               cout<<a[i][j];\n           }\n           cout<<\"\\n\";\n       }\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:36:32.557285+00:00"
      },
      "hints": {
        "hint1": "Dirty water reaches (i,j) only from (i-1,j-1), (i-1,j) and (i-1,j+1).",
        "hint2": "We can make DP array as DP[i][j] = max(DP[i-1][j-1], DP[i-1][j], DP[i-1][j+1]) which will denote the time when dirty water is reached at (i,j). We are given the time when (i,j) is cleaned, when this is greater than or equal to DP[i][j], the window(i,j) is clean, otherwise dirty.\n\nTime Complexity per test case: O(N*M)",
        "solution_approach": "Another simple approach -> just start from the window that will be cleaned at last. For sure that window will be cleaned. Find out the cells that are reachable from that cell. All that cells will be dirty for sure. Now pick the 2nd last cleaned window, if it is not already dirty due to the last window. You can mark it as cleaned and again find all the windows reachable and mark the windows as dirty. If the window is already dirty then no need to do anything. Keep on doing that. You will visit each window only once, so the time complexity is O(n*m)."
      },
      "id": 188,
      "input_format": "<p>The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</p><p>The first line of each test case contains two space-separated integers N, M - the size of the building.</p><p>Each of the next N lines contains Ai,j - the time at which window (i,j) is cleaned. At a time, only one window can be cleaned.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, when window(1,1) and window(1,2) are cleaned, they make the window(2,1) and window(2,2) dirty. They were cleaned earlier, so they remain dirty.\n\nFor the second test case, all the windows remain clean because when a window becomes dirty, it gets cleaned afterwards.",
      "output_format": "For each test case, print N lines, each with M integers denoting whether the (i,j)-th window will be clean or not after the cleaning process ends.",
      "samples": [
        {
          "input": "3\n2 2\n4 3\n2 1\n3 3\n1 2 3\n6 5 4\n7 8 9\n3 4\n1 4 7 3\n5 8 2 6\n12 11 9 10",
          "output": "11\n00\n111\n111\n111\n1111\n1100\n1111"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Cleaning Window",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an $N \\times N$ chessboard and a knight with starting position $(Sx, Sy)$. You are given a final position $(Fx, Fy)$. You have to find the minimum number of moves required to reach the final position.\n\nComplete the function:\n\n```cpp\nint KnightWalk(int N, int Sx, int Sy, int Fx, int Fy);",
      "complete_approach": "",
      "constraints": "<p><i>1 ≤ T ≤ 20</i><br><i>1 ≤ N ≤ 1000</i><br><i>1 ≤ Sx, Sy, Fx, Fy ≤ N</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint KnightWalk(int N, int Sx, int Sy, int Fx, int Fy)\n{\n\tSx--, Sy--, Fx--, Fy--;\n\n\tint ans = -1;\n\t\n\tpair<int, int> mv[] = {{1, 2}, {1, -2}, {2, 1}, {2, -1}, {-1, 2}, {-1, -2}, {-2, 1}, {-2, -1}};\n\t\n\tint vis[N][N];\n\tmemset(vis, -1, sizeof(vis));\n\t\n\tqueue<pair<int, int>> q;\n\t\n\tq.push({Sx, Sy});\n\tvis[Sx][Sy] = 0;\n\t\n\twhile (q.size())\n\t{\n\t\tauto a = q.front();\n\t\tq.pop();\n\t\t\n\t\tint x = a.first, y = a.second, curr = vis[x][y];\n\t\t\n\t\tif (x == Fx && y == Fy)\n\t\t{\n\t\t\tans = curr;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (auto i : mv)\n\t\t{\n\t\t\tint x1 = x + i.first, y1 = y + i.second;\n\t\t\t\n\t\t\tif (x1 < 0 || y1 < 0 || x1 >= N || y1 >= N || vis[x1][y1] != -1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvis[x1][y1] = curr + 1;\n\t\t\tq.push({x1, y1});\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint test_case;\n\tcin >> test_case;\n\n\twhile (test_case--)\n\t{\n\t\tint N, Sx, Sy, Fx, Fy;\n\t\tcin >> N >> Sx >> Sy >> Fx >> Fy;\n\n\t\tcout << KnightWalk(N, Sx, Sy, Fx, Fy) << \"\\n\";\n\t}\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:13:08.939231+00:00"
      },
      "hints": {
        "hint1": "Convert this into a graph problem.",
        "hint2": "Use BFS to find the shortest path between 2 squares.",
        "solution_approach": "<p>This problem can be seen as a shortest path problem in an unweighted undirected graph. Consider a graph where the nodes represent the chessboard squares and there is an undirected edge between two nodes only if a knight can move between the corresponding squares. Now use <a href=\"https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/\">Breadth First Search(BFS)</a> to find the shortest path between the source and the destination.</span><br>We try all 8 possible positions where a knight can move to from its current position, if it is inside the board. Push this new position into the queue with distance 1 more than the current position. Repeat this process till you reach the desired position.<br>Time Complexity - <i>O(N<sup>2</sup>)</i></p>"
      },
      "id": 607,
      "input_format": "The first line contains a single integer T - the number of test cases.\nThe first line of each test case contains five integers N Sx Sy Fx Fy - the size of the board, initial position and final position.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "The situation described in **test case 1** is:\n\n![Chessboard Knight Move](https://lh3.googleusercontent.com/sOy4y9cSf98V6NHFG_ATkvHQ-Rp9-B46v7QeUcOR8TG4lKyzjWy6RO5m1yInqI68s95kq9vTnBQRHpeFMpMbj2gS77mDqwGFy9QnW6HAwKbc3sjXuf_JQrRcQ-ikCGfKrnCrnXiA)\n\nThe minimum number of moves is **3**.",
      "output_format": "For every test case print the minimum number of moves required. If it is not possible print -1.",
      "samples": [
        {
          "input": "3\n6 4 5 1 1\n6 3 3 6 6\n6 6 1 1 6",
          "output": "3\n2\n4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint KnightWalk(int N, int Sx, int Sy, int Fx, int Fy)\n{\n\t// Complete the function\n}\n\n<fix>\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint test_case;\n\tcin >> test_case;\n\n\twhile (test_case--)\n\t{\n\t\tint N, Sx, Sy, Fx, Fy;\n\t\tcin >> N >> Sx >> Sy >> Fx >> Fy;\n\n\t\tcout << KnightWalk(N, Sx, Sy, Fx, Fy) << \"\\n\";\n\t}\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 4,
      "title": "KWALK",
      "video_editorial_id": 10667
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given two integers representing the numerator and denominator of a fraction, print the fraction in string format.<br>If the fractional part is repeating, enclose the repeating part in parentheses.<br>If multiple answers are possible, print the one which has the smallest length.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n\n  for (int i1 = 0; i1 < n; ++i1) {\n    int a, b, num1, num2;\n    char ch = '+';\n    cin >> a >> b;\n    // checking whether the final answer will be -ve or +ve\n    if (a * b < 0) ch = '-';\n    a = abs(a);\n    b = abs(b);\n    if (a % b == 0)  // Case 1 : When the numerator is completely divisible by\n                     // denominator\n    {\n      if (ch == '-')\n        cout << ch << a / b << endl;\n      else\n        cout << a / b << endl;\n    }\n\n    else {\n      // Case 2 and 3 , Terminating and recurring\n      // Using a map to store the repetition of remainders and their positions\n      map<int, int> m1;\n      int i = 0, pos;\n      string s = \"\";\n      bool flag = true;\n      num1 = a / b;\n      a = a % b;\n      m1.insert({a, i});\n      a = a * 10;\n      ++i;\n      while (1) {\n        int x, rem;\n        x = a / b;\n        rem = a % b;\n        if (rem == 0)  // If rem is 0 that means terminating decimal\n        {\n          s += char(x + 48);\n          break;\n        } else if (m1.count(rem))  // Checking if the rem has occured previously\n        {\n          s += char(x + 48);\n          pos = m1[rem];  // position for opening parenthesis\n          flag = false;\n          break;\n        }\n        // When rem is neither zero or not repeated just insert rem in map\n        else {\n          m1.insert({rem, i});\n          ++i;\n          s += char(x + 48);\n          a = rem * 10;\n        }\n      }\n      if (flag == false) {\n        if (ch == '-')\n          cout << ch << num1 << '.' << s.substr(0, pos) << '('\n               << s.substr(pos, s.length() - pos) << ')' << endl;\n        else\n          cout << num1 << '.' << s.substr(0, pos) << '('\n               << s.substr(pos, s.length() - pos) << ')' << endl;\n\n      }\n\n      else {\n        if (ch == '-')\n          cout << ch << num1 << '.' << s << endl;\n        else\n          cout << num1 << '.' << s << endl;\n      }\n    }\n  }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:47:54.621075+00:00"
      },
      "hints": {
        "hint1": "Just break the problem into subparts such as \n* Whether the final answer is negative or positive\n* Whether the answer would be terminating or recurring",
        "hint2": "The sign part would be easy to find, the problem lies in finding whether the answer is terminating or decimal, and if recurring where to put the brackets?\nNotice that once the remainder starts repeating, so does the divided result. Make sure to handle edge cases properly.",
        "solution_approach": "* When the numerator is 0, then the answer is \"0\".\n* When the numerator is non-zero\n    * Find the sign of the answer.\n    * If the numerator is divisible by the denominator, then just print it with the proper sign.\n    * If the numerator is not divisible by the denominator, then try to find digits in decimal representation using the reminder in long division (high-school method of division).\n    * Also, store the position of the remainder that we used to calculate the digit in decimal-form. Once the remainder starts repeating, so the portion of the decimal part. Now you can calculate the repeating part of decimal.\n\nIn our code, we have adopted the following methodology:\n* The program checks if the numerator is completely divisible by the denominator, in which case it directly outputs the quotient.\n* If the numerator is not completely divisible by the denominator, the program checks if the decimal is terminating or recurring.\n* For this purpose, a map 'm1' is created to store the remainders and their positions. If the remainder repeats, it is a recurring decimal, otherwise it is a terminating decimal.\n* The program then calculates the quotient and remainder and updates the map 'm1' with the remainder and its position.\n* The loop continues until the remainder becomes zero or repeats.\n* If the remainder becomes zero, it is a terminating decimal and the program simply outputs the quotient and decimal point followed by the remaining digits.\n* If the remainder repeats, it is a recurring decimal and the program finds the position where the remainder repeats and outputs the quotient, decimal point, and the recurring digits enclosed in parentheses.\n* The program also checks whether the final answer will be negative or positive and outputs accordingly.\n\nThe time complexity would be of the order of $O(den - 1)$ because we need to keep going on dividing until we get a same remainder again. To get the same remainder again in the worst case we need to divide $den-1$ number of times. So worst case time complexity per test case is $O(100)$"
      },
      "id": 72,
      "input_format": "The first line contains \\( T \\) ($$1 \\leq T \\leq 100000$$), the number of test cases.  \nEach of the next \\( T \\) lines contains two space-separated integers representing numerator and denominator respectively:  \n$$0 \\leq |\\text{numerator}| \\leq 100$$ and $$1 \\leq |\\text{denominator}| \\leq 100$$.  \n\nIt is guaranteed that the denominator is always a non-zero integer.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>1 / 2 = 0.5</p><p><i><strong>Explanation 2:</strong></i><br>2 / 1 = 2</p><p><i><strong>Explanation 3:</strong></i><br>2 / 3 = 0.(6). Note that 0.(66) is also the correct representation in decimal format, but it has a greater length than 0.(6).</p>",
      "output_format": "<p>For each test case, print the fraction in string format.</p>",
      "samples": [
        {
          "input": "4\n1 2\n2 1\n2 3\n-3 7",
          "output": "0.5\n2\n0.(6)\n-0.(428571)"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Recurring Fractions",
      "video_editorial_id": 8140
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given a directed acyclic graph with $n$ vertices and $m$ edges. There are no self-loops or multiple edges between any pair of vertices. The graph can be disconnected.\n\nYou should assign labels to all vertices in such a way that:\n\n- Labels form a valid permutation of length $n$ — an integer sequence such that each integer from $1$ to $n$ appears exactly once in it.\n- If there exists an edge from vertex $v$ to vertex $u$ then $label_{v}$ should be smaller than $label_{u}$.\n- Permutation should be lexicographically smallest among all suitable.\n\nFind such a sequence of labels to satisfy all the conditions.",
      "complete_approach": "",
      "constraints": "- $2 ≤ n ≤ 10^{5}$\n- $1 ≤ m ≤ 10^{5}$\n- $1 ≤ v, u ≤ n,  v ≠ u$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint n, m;\nvector<vector<int>> adj;\nvoid solve()\n{\n    cin >> n >> m;\n    adj.assign(n + 1, vector<int>());\n    vector<int> out_deg(n + 1, 0);\n    for (int i = 0; i < m; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        adj[v].push_back(u); // reverse edge.\n        out_deg[u]++;        // out-degree\n    }\n    int t = n;\n    vector<int> ans(n + 1);\n    priority_queue<int> pq; // labelling higher node with higher label.\n    for (int i = 1; i <= n; i++)\n        if (out_deg[i] == 0)\n            pq.push(i);\n    while (!pq.empty())\n    {\n        int v = pq.top();\n        pq.pop();\n        ans[v] = t--; // labelling from n to 1.( decreasing order )\n        for (auto x : adj[v])\n        {\n            out_deg[x]--;\n            if (out_deg[x] == 0)\n                pq.push(x);\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        cout << ans[i] << \" \";\n    cout << endl;\n}\nint main()\n{\n    ios_base ::sync_with_stdio(0);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--)\n    {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:15:43.347529+00:00"
      },
      "hints": {
        "hint1": "This is topological ordering problem with some lexicographical twist.\n\nThink of this input:\n$4$ $2$  \n$4$ $1$  \n$2$ $3$",
        "hint2": "In this problem, the following approach won't work !\n\n1. pick vertex with zero in-degree (and with minimum node number, in case of a tie in degree)\n2. remove this vertex from the graph and update the degree of all other nodes attached to this.\n3. assign label to this removed vertex\n4. repeat the above steps while there are nodes in the graph labels are assigned from 1 to N\n\nTry both algorithms for the input :-\n\n$4$ $2$  \n$4$ $1$  \n$2$ $3$\n\nThe output according to your algorithm would be giving the output will be :-\n$4$ $1$ $2$ $3$\n\nCorrect output should be :-\n$2$ $3$ $4$ $1$",
        "solution_approach": "Let's set labels in descending order starting from label $N$ to label $1$. Look at the first step. Vertex with label $𝑁$\n should have an out-degree equal to zero. Among all such vertices, we should put the label on the one that has the largest index. Ok, but why will this produce the lexicographically smallest labeling?\n\nWe can prove this by contradiction. \nTo see why this is true, suppose there exists a labeling where \n1. a vertex with label 𝑋 (𝑋<𝑁) is assigned the label 𝑁.\n2. The algorithm then changes the label of this vertex to 𝑁 and, \n3. re-labels all vertices with labels between 𝑋+1 and 𝑁 to labels between 𝑋 and 𝑁-1. \n4. This re-labeling leads to a lexicographically smaller labeling, contradicting the assumption that the original labeling was lexicographically smallest.\n\nThe algorithm repeats this process for each label in descending order until all vertices are labeled. To efficiently find vertices with out-degree equal to zero, the algorithm maintains a set of vertices with minimal out-degree. \nThe overall time complexity of the algorithm is $𝑂((n+m)*\\log n)$, where $n$ is the number of vertices and $m$ is the number of edges in the graph."
      },
      "id": 392,
      "input_format": "The first line contains two integer numbers $n$, $m$.\n\nNext $m$ lines contain two integer numbers $v$ and $u$ — edges of the graph. Edges are directed, the graph doesn't contain loops or multiple edges.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "In Sample Test 2, Assigning $label_{1}=4$ , $label_{2}=1$, $label_{3}=2$ and $label_{4}=3$ will give the lexicographically smallest correct permutation of labels of vertices which will be $4$ $1$ $2$ $3$.",
      "output_format": "Print $n$ numbers — lexicographically smallest correct permutation of labels of vertices.",
      "samples": [
        {
          "input": "3 3\n1 2\n1 3\n3 2\n",
          "output": "1 3 2 \n"
        },
        {
          "input": "4 5\n3 1\n4 1\n2 3\n3 4\n2 4\n",
          "output": "4 1 2 3 \n"
        },
        {
          "input": "5 4\n3 1\n2 1\n2 3\n4 5\n",
          "output": "3 1 2 4 5 \n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Topological Labelling",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given an $n \\times m$ $board$ of characters and a list of strings $words$, output all words in the list $words$ that are present on the board in lexicographical order.\n\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10$\n$1 \\leq n,m \\leq 12$\n$1 \\leq words.size() \\leq 10^4$\n$1 \\leq words[i].size() \\leq 10$\n$board[i][j]$ is a lowercase English letter.\n$words[i]$ consists of lowercase English letters.\nAll the strings of words are unique.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstruct trie {\n    struct node {\n        node* child[26];\n        bool wend, taken;\n        string word;\n        node() {\n            wend = false;\n            taken = false;\n            for (int i = 0; i < 26; i++)child[i] = nullptr;\n        }\n    };\n    node *root ;\n    trie() {\n        root = new node();\n    }\n    void insert(string s) {\n        node *cur = root;\n        for (auto c : s) {\n            int x = c - 'a';\n            if (cur->child[x] == nullptr)cur->child[x] = new node();\n            cur = cur->child[x];\n        }\n        cur->wend = true;\n        cur->word = s;\n    }\n    vector<string> ans; // can also use set to prevent duplicates.\n    int dx[4] = {0, 0, -1, +1};\n    int dy[4] = { -1, +1, 0, 0};\n    int n, m;\n    void dfs(vector<vector<char>> &grid, int i, int j, node* cur) {\n        if (cur == nullptr)return;\n        if (cur->wend && !cur->taken)ans.push_back(cur->word), cur->taken = true;\n        char v = grid[i][j];\n        grid[i][j] = 'X';\n        for (int k = 0; k < 4; k++) {\n            int x = i + dx[k], y = dy[k] + j;\n            if (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != 'X') {\n                char t = grid[x][y];\n                dfs(grid, x, y, cur->child[t - 'a']);\n            }\n        }\n        grid[i][j] = v; // backtracking visited.\n    }\n};\nvector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n    trie tr;\n    for (auto word : words)tr.insert(word);\n    tr.n = board.size(), tr.m = board[0].size();\n    for (int i = 0; i < tr.n; i++) {\n        for (int j = 0; j < tr.m; j++) {\n            tr.dfs(board, i, j, tr.root->child[board[i][j] - 'a']);\n        }\n    }\n    return tr.ans;\n}\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vector < vector<char >> g(n, vector<char>(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> g[i][j];\n        }\n    }\n    int l;\n    cin >> l;\n    vector<string> v;\n    while (l--) {\n        string s;\n        cin >> s;\n        v.push_back(s);\n    }\n    auto x = findWords(g, v);\n    sort(x.begin(), x.end());\n    for (auto y : x)cout << y << endl;\n\n    cout << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:25:17.040691+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "**Idea:** The brute-force solution is to DFS all cells for every word in the dictionary. The time complexity will be $O(m * n * wl * l)$ where $m$ is $board.length$, $n$ is $board[0].length$, $l$ is $words.length$ and $wl$ is the average of length of words in $words'$.\n\nInstead, we use a Trie to check multiple words at the same time when DFS from a certain cell.\n\n**Complexity -** \n**Time:** $O(m * n * wl * l) = max(O(wl * l), O(m * n * l * wl))$ where\n$O(wl * l)$ - Build the trie\n$O(m * n * wl * l)$ - In the worst case where all words start with different characters, and there is a word starting with a character\nIn the cell $board[m - 1][n - 1]$, we have $O(m * n * wl * l)$. However, if there are words starting with the same characters and paths sharing\ncells, Trie can check multiple words when DFS from a certain cell, rather than check ONLY ONE word when DFS from a certain cell, like the brute-force solution.\n\n**Space:** $O(wl * l) = max(O(wl), O(wl * l))$ where\n$O(wl)$ - The recursive stack can grow at most to wl layers. \n$O(wl * l)$ - In the worst case when all words start with different characters, the trie has $wl*l$ nodes. Also, since each word is stored in a leaf node, all the leaf nodes require $wl * l$ memory."
      },
      "id": 992,
      "input_format": "First-line contains $T$ - the number of test cases.\nThe first line of each test case contains two integers $n$ and $m$.\nThe next $n$ lines of each test case contain $n \\times m$ board of characters.\nNext line contains $l$ - size of the list of strings $words$.\nThe next $l$ lines contain strings of the list $words$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output all words in the list $words$ that are present on the board in lexicographical order on a new line, and output a newline after every test case.",
      "samples": [
        {
          "input": "2\n5 5\na b c d e \nf g h i j\nk l m n o \np q r s t\nu v w x y\n6\nabcdej\nxyz\nkpu\ngmns\naaab\njoty\n4 4\no  a  a  n \ne  t  a  e \ni  h  k  r \ni  f  l  v \n4\noath\npea\neat  \nrain  \n",
          "output": "abcdej\njoty\nkpu\n\neat\noath\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Word Boggle",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given N bricks in a line and M different coloured buckets of paint. You have to find the number of ways you can colour the brick wall such that there are exactly K positions out of the N bricks such that it has </span>a <span style=\"background-color:transparent;color:#000000;\">different colour from </span>the brick <span style=\"background-color:transparent;color:#000000;\">wall on its immediate left. (except the first brick, since there is no left brick). Print it modulo 10^9+7.</span></p><p>&nbsp;</p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "<p>1≤ T ≤ 100</p><p>1≤ N, M ≤ 2000</p><p>0≤ K ≤ N-1</p><p><span style=\"background-color:#ffffff;color:#000000;\">It is guaranteed that the sum of N*K over all test cases does not exceed 4*10<sup>8</sup>.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\n\nconst int mod=1000000007;\nint dp[2001][2001];\n\nsigned main() {\n    IOS\n    int t;\n    cin >> t;\n    while(t--) {\n        int n, m, k;\n        cin >> n >> m >> k;\n        for(int i=0;i<=n;i++)\n            for(int j=0;j<=k;j++)\n                dp[i][j] = 0;\n        dp[1][0] = m;\n        for (int i = 2; i <= n; ++i) {\n            for (int j =0; j <= k; ++j) {\n                dp[i][j] = dp[i-1][j];\n                if(j)\n                    dp[i][j] = (dp[i][j] + (dp[i-1][j-1]*(m-1))%mod)%mod;\n            }\n        }\n        cout << dp[n][k] << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:33:42.781639+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">You can colour the first brick in any of the M colours.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">We define DP array, DP[i][j] as the number of ways such that there are j bricks of different color from its left-adjacent brick among bricks numbered 1 to i.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">At any brick, you have two choices, either colour it the same as the previous brick or colour it a different colour if the number of bricks with a colour different than on its left is less than K.</span></p><p><span style=\"background-color:transparent;color:#000000;\">We have the following DP transition: DP[i][j] = DP[i-1][j] (to colour it with the same colour as previous brick) and DP[i][j] = DP[i-1][j-1]*(M-1) (to colour it with a different colour than previous brick, we have M-1 choices)</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N*K)</span></p>"
      },
      "id": 181,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first and only line of each test case contains three space-separated integers N, M, K.</span></p><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, the following are the 2 different arrangements possible:\n1. [1, 2, 1]\n2. [2, 1, 2]\n\nFor the second test case, the following are the 2 different arrangements possible:\n1. [1, 2]\n2. [2, 1]",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the number of ways you can colour the brick wall satisfying the given condition % 10^9+7.</span></p>",
      "samples": [
        {
          "input": "3\n3 2 2\n2 2 1\n3 5 0",
          "output": "2\n2\n5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Bricks Colouring",
      "video_editorial_id": 8162
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You recently learnt to use the C++ STL deque and decided to play a game on it. You are given a deque with N elements. You take the first two elements of the deque, pop them and push the larger of the two in the front and the smaller at the back of the deque. You are given Q queries, asking the first two elements of the deque you will take on the X-th operation.&nbsp;</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:#ffffff;color:#000000;\">2≤ N ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">0</span><span style=\"background-color:#ffffff;color:#000000;\">≤ Q ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">0</span><span style=\"background-color:#ffffff;color:#000000;\">≤ A<sub>i</sub> ≤ 10<sup>9</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ X<sub>i</sub> ≤ 10<sup>18</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of N and the sum of Q over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>6</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\n\nsigned main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, q;\n        cin >> n >> q;\n        int m = 0;\n        deque<int> d;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            cin >> x;\n            d.push_back(x);\n            m = max(m, x);\n        }\n        int j = 0;\n        for (int i = 0; i < n; ++i) {\n            if(d[i] == m) {\n                j = i;\n                break;\n            }\n        }\n        vector<pair<int, int>> v;\n        v.push_back({0, 0});\n        for (int i = 0; i <= j; ++i) {\n            int a = d.front();\n            d.pop_front();\n            int b = d.front();\n            d.pop_front();\n            v.push_back({a, b});\n            if(a > b) {\n                d.push_front(a);\n                d.push_back(b);\n            }\n            else {\n                d.push_front(b);\n                d.push_back(a);\n            }\n        }\n        d.pop_front();\n        n--;\n        while (q--) {\n            int x;\n            cin >> x;\n            if(x < v.size()) {\n                cout << v[x].first << \" \" << v[x].second << \"\\n\";\n            }\n            else {\n                cout << m << \" \" << d[(x - v.size())%n] << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:25:30.339570+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">If you get the largest element in the deque at the first position, the first position will remain the same after the operation. The second element will go to the back of the deque.</span></p>",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Find the largest element of the deque, if a query is given before the largest element can come to the first position, you can find it manually by storing the answer in a vector. Otherwise, the answer will change in cycles of size N-1 where N is the size of deque.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N + Q)</span></p>"
      },
      "id": 385,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains two space-separated integers N Q - the number of elements in the deque and the number of queries.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The second line of each test case contains N space-separated integers.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Each of the next Q lines contain a single integer X.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, in operation 1, you take 1 and 2</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, in operation 1, you take 1 and 3, deque becomes [3, 4, 4, 1]</span></p><p><span style=\"background-color:transparent;color:#000000;\">In operation 2, you take 3 and 4, deque becomes [4, 4, 1, 3]</span></p><p><span style=\"background-color:transparent;color:#000000;\">In operation 3, you take 4 and 4, deque becomes [4, 1, 3, 4]</span></p><p><span style=\"background-color:transparent;color:#000000;\">In operation 4, you take 4 and 1, deque becomes [4, 3, 4, 1]</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the first two elements of the deque you will take on the X-th operation for each query. They should be printed in the order in which they will be pulled out of the deque.</span></p>",
      "samples": [
        {
          "input": "2\n2 1\n1 2\n1\n4 4\n1 3 4 4\n1\n2\n3\n4\n",
          "output": "1 2\n1 3\n3 4\n4 4\n4 1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Game on Deque AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two strings $str1$ and $str2$, return the shortest string that has both $str1$ and $str2$ as subsequences. If there are multiple valid strings, return any of them.\n\nA string $s$ is a subsequence of string $t$ if deleting some number of characters from $t$ (possibly $0$) results in the string $s$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 100$\n$1 \\leq |str1| \\leq 1000$\n$1 \\leq |str2| \\leq 1000$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n\nint dp[1001][1001];\nstring s1, s2;\nint rec(int i, int j) {\n    if (i == s1.size() || j == s2.size())return 0;\n    auto &ans = dp[i][j];\n    if (ans != -1)return ans;\n    ans = max(rec(i + 1, j), rec(i, j + 1));\n    if (s1[i] == s2[j])ans = max(ans, 1 + rec(i + 1, j + 1));\n    return ans;\n}\nstring ShortestCommonSupersequence(string &str1, string &str2) {\n    s1 = str1, s2 = str2;\n    memset(dp, -1, sizeof(dp));\n    string ans;\n    int i = 0, j = 0;\n    while (i < s1.size() && j < s2.size()) {\n        if (s1[i] == s2[j]) {\n            ans.push_back(s1[i]);\n            i++;\n            j++;\n        }\n        else {\n            if (rec(i + 1, j) > rec(i, j + 1)) {\n                ans.push_back(s1[i]);\n                i++;\n            }\n            else {\n                ans.push_back(s2[j]);\n                j++;\n            }\n        }\n    }\n    while (i < s1.size())ans.push_back(s1[i++]);\n    while (j < s2.size())ans.push_back(s2[j++]);\n    return ans;\n}\n\nvoid checker() {\n    string x, y;\n    cin >> x >> y;\n    auto s = ShortestCommonSupersequence(x, y);\n    cout << s.size() << endl;\n    bool f = 1;\n    int i = 0, j = 0;\n    while (i < x.size() && j < s.size()) {\n        if (x[i] == s[j])i++, j++;\n        else j++;\n    }\n    if (i != x.size())f = 0;\n    i = 0, j = 0;\n    while (i < y.size() && j < s.size()) {\n        if (y[i] == s[j])i++, j++;\n        else j++;\n    }\n    if (i != y.size())f = 0;\n    cout << f << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        checker();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:18:02.929977+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "Computing Shortest Common Supersequence is similar to computing longest common subsequence (LCS)\n\n**Idea**:The result string should contain all characters of $s1$ and $s2$, discarding the common ones.\n-> $S1+S2-LCS$\nbecause characters appearing in LCS are coming twice in the result. So count them only once.\n\nHere is the approach using dynamic programming:\n\n1. Compute the LCS using Dynamic Programming tabulation where each cell resturs the length of the cell upto $i$ characters of $str1$ and $j$ characters of $str2$.\n2. We will start processing the table using the last cell till $i>0$ or $j>0$\n    2.1 Check if $str1[i-1]==str2[j-1]$. If equal, we must add this character to the result string only once\n    2.2 If not equal, then find the maximum of $t[i-1][j]$ and $t[i][j-1]$ (this is how you had calculated LCS length first) , start moving in the max direction afte inserting the character to the result string. Moving in max direction means discarding that character of the string that has not contributed in LCS. But still inserting in the final string because it will contribute in SuperSequence.\n    2.3 Compute till $i>0$ $&&$ $j>0$. If any of the string is left i.e if $i>0$ or $j>0$ then add its characters to the result. This means that we copied 1 complete string but other is still remaining.\n\nWe have got the required string but stored all the characters in reverse order. So, just reverse the result and you will get the final answer.\n\n**Time Complexity** : $O(|str1|*|str2|)$."
      },
      "id": 914,
      "input_format": "Given function **string ShortestCommonSupersequence( string &str1, string &str2)** with string $str1$ and $str2$ as input.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Complete the given function **string ShortestCommonSupersequence( string &str1, string &str2)** and return the shortest common supersequence of the $2$ input strings. If there are multiple valid strings, return any of them.",
      "samples": [
        {
          "explanation": "$Test $ $ Case $ $ 1:$\nalgozenith\n$Test $ $ Case $ $ 2:$\nzzzzz\n$Test $ $ Case $ $ 3:$\ncabac\n$Test $ $ Case $ $ 4:$\nxyzabc",
          "input": "4\nalgozenith az\nzzzzz zzzz\nabc caba\nabc xyz\n",
          "output": "10\n1\n5\n1\n5\n1\n6\n1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n</fix>\n\nstring ShortestCommonSupersequence(string &str1, string &str2) {\n    // write code here.\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<fix>\nvoid checker() {\n    string x, y;\n    cin >> x >> y;\n    auto s = ShortestCommonSupersequence(x, y);\n    cout << s.size() << endl;\n    bool f = 1;\n    int i = 0, j = 0;\n    while (i < x.size() && j < s.size()) {\n        if (x[i] == s[j])i++, j++;\n        else j++;\n    }\n    if (i != x.size())f = 0;\n    i = 0, j = 0;\n    while (i < y.size() && j < s.size()) {\n        if (y[i] == s[j])i++, j++;\n        else j++;\n    }\n    if (i != y.size())f = 0;\n    cout << f << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        checker();\n        // i++;\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "Shortest Common Supersequence",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a number N in base A. Convert the number to base B.</p><p>The base of the numbers can be anything such that all digits can be represented using 0 to 9 and A to Z.</p><p>The value of ‘A’ is 10, ‘B’ is 11, ‘C’ is 12 and so on.</p>",
      "complete_approach": "",
      "constraints": "<p>1≤ T ≤ 10<sup>3</sup></p><p>1≤ N ≤ 10<sup>18</sup></p><p>2≤ A ≤ 16</p><p>2≤ B ≤ 36</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\n\nsigned main() {\n    IOS\n    int t=1;\n    cin >> t;\n    while (t--) {\n        string s;\n        int a, b;\n        cin >> s >> a >> b;\n        // base a to decimal\n        int deci = 0;\n        int pw = 1;\n        for (int i = (int)s.size()-1; i >= 0; --i) {\n            int x;\n            if(s[i] >= '0' && s[i] <= '9') {\n                x = s[i] - '0';\n            }\n            else {\n                x = s[i] - 'A' + 10;\n            }\n            deci += x * pw;\n            pw *= a;\n        }\n        // decimal to base b\n        string ans;\n        while(deci) {\n            int x = deci % b;\n            char c;\n            if(x >=0 && x <= 9) {\n                c = x + '0';\n            }\n            else {\n                c = x - 10 + 'A';\n            }\n            ans += c;\n            deci /= b;\n        }\n        reverse(ans.begin(), ans.end());\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:16:55.856927+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;\">First convert the number in base A to decimal and then decimal to base B.</span></p>",
        "hint2": "<p>Pay attention to using long long, as the numbers won't fit in int.</p>",
        "solution_approach": "<p><span style=\"background-color:transparent;\">If the number is considered as string with length n, the decimal equivalent of the number in base A is = 1*S[n-1] + A*S[n-2] + A</span><span style=\"background-color:#ffffff;\"><sup>2</sup></span><span style=\"background-color:transparent;\">*S[n-3] + …&nbsp;</span></p><p><span style=\"background-color:transparent;\">If the decimal equivalent of the number in base B is known, it can be found by repeatedly dividing by the base B, and adding the remainder to the answer.</span></p><p><span style=\"background-color:transparent;\">Time Complexity per test case: O(|N|)</span></p>"
      },
      "id": 334,
      "input_format": "<p>The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</p><p>The first line of each test case contains three space-separated integers N, A, B.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case, print N in base B.</p>",
      "samples": [
        {
          "input": "3\n1010 2 16\nA14 16 8\n12 10 4\n",
          "output": "A\n5024\n30\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Convert Base Number AZ101",
      "video_editorial_id": 8183
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers, find the sum of <i>XOR</i> of all pairs of numbers in the array, sum of <i>XOR</i> of all subset of numbers in the array, sum of <i>AND</i> of all pairs of numbers in the array, sum of <i>AND</i> of all subset of numbers in the array. Calculate it %1000000007.&nbsp;<br>For pair you should select two index <i>i, j</i> such that <i>i&lt;j</i>.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\nconst ll N = 100001;\nconst ll BITS = 31;\n\nll addMod(ll a,ll b){\n   a = a+b;\n   if(a>=mod)\n       a-=mod;\n   return a;\n}\nll nc2(ll x){\n   return ((x*(x-1))/2)%mod;\n}\nsigned main()\n{\n   ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n   ll powerOfTwo[N];\n   powerOfTwo[0] = 1;\n   for(ll i=1;i<N;i++){\n       powerOfTwo[i] = addMod(powerOfTwo[i-1],powerOfTwo[i-1]);\n   }\n\n   ll testCase;\n   cin>>testCase;\n   while(testCase--){\n       ll n;\n       cin>>n;\n       ll arr[n];\n       for(ll i=0;i<n;i++)\n           cin>>arr[i];\n\n       ll sumPairXor = 0;\n       ll sumSubsetXor = 0;\n       ll sumPairAnd = 0;\n       ll sumSubsetAnd = 0;\n\n       for(ll i=0;i<BITS;i++){\n           ll cnt = 0;\n           for(ll j=0;j<n;j++){\n               if(arr[j]&(1LL<<i))  \n                   cnt++;\n           }\n\n           sumPairXor = addMod(sumPairXor , (1LL<<i)*cnt%mod*(n-cnt)%mod);\n           if(cnt)\n               sumSubsetXor = addMod(sumSubsetXor, (1LL<<i)*powerOfTwo[n-1]%mod);\n\n           sumPairAnd = addMod(sumPairAnd, (1LL<<i)*nc2(cnt)%mod);\n           sumSubsetAnd = addMod(sumSubsetAnd, (1LL<<i)*(powerOfTwo[cnt]-1+mod)%mod);\n\n       }\n       cout<<sumPairXor<<\" \"<<sumSubsetXor<<\" \"<<sumPairAnd<<\" \"<<sumSubsetAnd<<\"\\n\";\n   }\n\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:20:59.155765+00:00"
      },
      "hints": {
        "hint1": "<p>Try to calculate the contribution of every bit of a number. In how many possible pairs or subset the bit is set. If ith bit is set in 'x' possible pair or subset then the contribution of this bit in the total answer will be x*(1LL&lt;&lt;i).</p><p>So find the contribution of every bit, then sum it.</p>",
        "hint2": "<p>Property of XOR, 1^1 = 0, 1^1^1 = 1, 1^1^1^1 = 0, 1^1^1^1^1 = 1.</p><p>For ith bit to be set while taking XOR, ith bit should be set an odd number of times. So when you take a pair of numbers then in one of the numbers the ith bit should be set and in the other number it should be unset. So calculate in how many numbers ith bit is set (cnt), then the total number of pairs with ith bit set in the XOR of the pair is cnt*(n-cnt).</p><p>So total contribution if ith bit = cnt*(n-cnt)*(1LL&lt;&lt;i).</p><p>For AND, the bit should be set in both the numbers. So if ith bit is set in 'cnt' numbers, then the total possible pair in which ith bit will be set after doing AND is <sup>cnt</sup>C<sub>2</sub> = (cnt*(cnt-1))/2, choosing any two number with ith bit set. So contribution of ith bit = (1LL&lt;&lt;i) * ((cnt*(cnt-1))/2).</p><p>Now try to solve for all the subset.</p>",
        "solution_approach": "<p>If ith bit is set in 'cnt' numbers, then choosing 1 or 3 or 5..... basically odd numbers from cnt in the subset and any number from the 'n-cnt' in the subset, then after doing XOR of the subset we will have ith bit set. So total number of subset which will have ith bit set = (cntC1 + cntC3 + cntC5 + ….)) * (2^(n-cnt)). You can simplify the summation of (cntC1 + cntC3 + cntC5 + ….)) = 2^(cnt-1), if cnt&gt;0 otherwise 0. So total contribution of ith bit &nbsp;= (1LL&lt;&lt;i) * 2^(n-1), if cnt&gt;0.</p><p>For AND, the ith bit is set if and only if all the numbers in the subset have ith bit set. So the total number of subset with ith bit set after doing AND of all the numbers in the subset = (2^cnt)-1. So total contribution of ith bit &nbsp;= (1LL&lt;&lt;i) * ((2^cnt)-1).</p><p>Take % properly and check for overflow.</p>"
      },
      "id": 49,
      "input_format": "<p>The first line of the input contains a single integer <i>T</i> denoting the number of test cases, <i>(1&lt;=T&lt;=100)</i>.</p><p>The first line of each test case contains a single integer <i>N</i>, <i>(2&lt;=N&lt;=100000)</i>.</p><p>The second line contains <i>N</i> space-separated integers A<sub>1</sub>,A<sub>2</sub>,…,A<sub>N</sub>, <i>(1&lt;=A<sub>i</sub>&lt;=10^9)</i>.</p><p>Sum of <i>N</i> over all test cases does not exceed 10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "<p><strong>1st test case:</strong> all pairs and corresponding XOR and AND value:<br>(1,2) - 3, 0<br>(1,3) - 2, 1<br>(1,4) - 5, 0<br>(1,5) - 4, 1<br>(2,3) - 1, 2<br>(2,4) - 6, 0<br>(2,5) - 7, 0<br>(3,4) - 7, 0<br>(3,5) - 6, 1<br>(4,5) - 1, 4<br>Sum of XOR of all pairs = 42, Sum of AND of all pairs = 9</p><p><strong>3rd test case:</strong> all subset XOR and AND values:<br>(1) - 1, 1<br>(1,2) - 3, 0<br>(1,3) - 2, 1<br>(2,3) - 1, 2<br>(2) - 2, 2<br>(3) - 3, 3<br>(1,2,3) - 0, 0<br>Sum of XOR of all subset = &nbsp;12, Sum of AND of all subset = 9</p>",
      "output_format": "<p>For each test case output, 4 space-separated integers in a new line in the order the sum of XOR of all pairs of numbers in the array, sum of XOR of all subset of numbers in the array, sum of AND of all pairs of numbers in the array, sum of AND of all subset of numbers in the array. Since these numbers may be very large, compute them modulo 1000000007 (10^9+7)</p>",
      "samples": [
        {
          "input": "6\n5\n1 2 3 4 5\n5\n1 1 2 3 5\n3\n1 2 3\n4\n1 2 2 4\n10\n989098 987656790 989098765 234543 3456543 234567543 1234567 5678 56789 8909876\n10\n123 1234543 2345 6776 8787 8765467 234567 98765444 1234 4561",
          "output": "42 112 9 25\n32 112 8 25\n6 12 3 9\n23 56 2 11\n378768679 755809533 328561458 769714220\n962949537 271171227 9132543 118419489"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "XOR and AND",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers, find a subarray with at most <i>K</i> odd numbers and the total sum is maximum but not more than <i>D</i>. If no such subarray exists print <i>\"IMPOSSIBLE\"</i> without double-quotes.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nsigned main()\n{\n   ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n   ll testCases;\n   cin>>testCases;\n   while(testCases--)\n   {\n     ll n,k,s;\n     cin>>n>>k>>s;\n     ll arr[n+1];\n     ll prefix[n+1];\n     prefix[0] = 0;\n     ll ans = -1e18;\n     for(ll i=1;i<=n;i++){\n       cin>>arr[i];\n       prefix[i]=prefix[i-1]+arr[i];\n     }\n     ll cntOdd = 0;\n     multiset < ll > currWindowPrefixSum;\n     currWindowPrefixSum.insert(0);\n     ll prev = 1;\n     for(ll i=1;i<=n;i++){\n       cntOdd+=(abs(arr[i])%2);\n       if(cntOdd>k){\n           while(prev<=i){\n               currWindowPrefixSum.erase(currWindowPrefixSum.find(prefix[prev-1]));\n               if(abs(arr[prev])%2){\n                   prev++;\n                   cntOdd--;\n                   break;\n               }\n               prev++;\n           }\n       }\n       if(!currWindowPrefixSum.empty()){\n           auto itr = currWindowPrefixSum.lower_bound(prefix[i]-s);\n           if(itr!=currWindowPrefixSum.end()){\n               ans = max(ans,prefix[i]-(*itr));\n           }\n       }\n       currWindowPrefixSum.insert(prefix[i]);\n     }\n     if(ans==-1e18){\n       cout<<\"IMPOSSIBLE\\n\";\n       continue;\n     }\n     cout<<ans<<\"\\n\";\n }\n\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:34:50.679454+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">If a subarray from index L to R has number of distinct odd elements at most K, then all subarrays from index X to R (L &lt; X) will also have number of distinct odd elements at most K. Note that the sum of the subarray won’t follow a similar rule since negative elements are also present in the array.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">We would be using two pointers to solve this problem. We start both the pointers from the beginning i.e. L = 0 and R = 0. While traversing, we would keep the count of the number of distinct odd elements from L to R. We start from the beginning of the array and keep increasing the right pointer, R till the number of distinct elements is less than or equal to K. We need to check if the current subarray sum is ≤ D. We would use prefix sum and multiset for finding this. Sum of the subarray can be given by prefix[R] - prefix[L-1]. So for a fixed R, we need to find L such that the number of distinct odd elements is at most K and prefix[R] - prefix[L-1] ≤ D ⇒ prefix[L-1] ≥ prefix[R] - D. Since prefix[R] - prefix[L-1] would be maximum, prefix[L-1] would be minimum. In the multiset, we need to keep prefix[L-1] for all L such that the subarray from L to R has at most K distinct odd elements. We can use lower_bound(prefix[R] - D) to find the smallest such prefix[L-1].</span></p>",
        "solution_approach": "<p>Check the solution approach.</p>"
      },
      "id": 51,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases <i>(1&lt;=T&lt;=10)</i>.</p><p>The first line contains two space separated integers <i>N, K, D</i> where <i>1&lt;=N&lt;=10^5, &nbsp;0&lt;=K&lt;=10^5, -1e9&lt;=D&lt;=1e9</i>.</p><p>Next line contains <i>N</i> space-separated integers <i>(-1e4&lt;=Ai&lt;=1e4).</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "<p>For the first test case, the optimal subarray - (2,3) → number of odd number is 1&lt;=2 and sum is 5&lt;=5.</p><p>For the second test case, the optimal subarray - (-1) → number of odd number is 1&lt;=2 and sum is -1&lt;=2.</p><p>For the third test case, the optimal subarray - (-1,2,3,4) → number of odd number is 2&lt;=2 and sum is 8&lt;=8.</p><p>For the fourth test case, the optimal subarray - (-4) → number of odd number is 0&lt;=0 and sum is -4&lt;=-2.</p>",
      "output_format": "<p>For each test case print the sum of subarray with at most <i>K</i> odd numbers and the total sum is maximum, but not more than <i>D</i> in a newline. If no subarray is possible then print <i>\"IMPOSSIBLE\" </i>without double-quotes.</p>",
      "samples": [
        {
          "input": "6\n3 2 5\n1 2 3\n3 1 2\n-3 -1 -3\n5 2 8\n-1 2 3 4 -5\n7 0 -2\n1 -4 1 0 1 0 2\n10 3 14\n1 0 -7 1 -10 4 -2 10 -1 3\n3 0 1000\n-101 201 -301",
          "output": "5\n-1\n8\n-4\n14\nIMPOSSIBLE"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "K Odd Number",
      "video_editorial_id": 8133
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">An integer array is called arithmetic if it consists of <strong>at least three elements</strong> and if the difference between any two consecutive elements is the same.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences, whereas [1,2,4,5] is not an arithmetic sequence.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Given an integer array <i>A</i>, print <i>the number of arithmetic <strong>subsequences</strong> of</i> <i>A</i>. Since this number can be large print it modulo 10<sup>9</sup>+7.</span></p><p><span style=\"background-color:transparent;color:#000000;\">A <strong>subsequence</strong> of any array can be formed by deleting several, possibly none, elements from the array.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1 ≤&nbsp; N ≤ 10<sup>3</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">-10<sup>6</sup> ≤ A[i] ≤ 10<sup>6</sup></span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long MOD = 1e9 + 7;\n\nlong long findArithmeticSeq(int a[], int n)\n{\n    unordered_map<int, int> cnt[n];\n    long long ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < i; j++)\n        {\n            long long d = a[i] - a[j];\n            if (cnt[j].find(d) != cnt[j].end())\n            {\n                (cnt[i][d] += cnt[j][d]) %= MOD;\n                (ans += cnt[j][d]) %= MOD;\n            }\n            (cnt[i][d] += 1) %= MOD;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    cout << findArithmeticSeq(a, n) << '\\n';\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing"
        ],
        "last_updated": "2024-06-22T02:19:24.235011+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Can you think of using Dynamic Programming? Consider the state dp(i, j) → represents the number of arithmetic sequences ending at <i>i<sup>th</sup></i> index with common difference equal to <i>j</i>. Think of transition.</span></p>",
        "solution_approach": "<p>For every index <i>i</i> we iterate from indices <i>j = 0 … i - 1</i>, add update the value of dp[i][a[i] - a[j]]. The <i>dp</i> transition can be written as:</p><pre><code class=\"language-plaintext\">dp[i][d]+=dp[j][d] for all j&lt;i and d=a[i]-a[j]</code></pre><p>The answer will be the sum of all dp values. Since the value of common difference can be very large we maintain a hash map for every index which stores the count of arithmetic sequences for every value of common difference encountered. The time complexity will be <i>O(N<sup>2</sup>)</i> as the total number of differences cannot be more than N<sup>2</sup>.</p>"
      },
      "id": 634,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains a single integer N -&nbsp; the size of the array.</span><br><span style=\"background-color:transparent;color:#000000;\">The second line contains N integers - the elements of the array.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">All arithmetic subsequence slices are:</span><br><span style=\"background-color:transparent;color:#000000;\">[2,4,6]</span><br><span style=\"background-color:transparent;color:#000000;\">[4,6,8]</span><br><span style=\"background-color:transparent;color:#000000;\">[6,8,10]</span><br><span style=\"background-color:transparent;color:#000000;\">[2,4,6,8]</span><br><span style=\"background-color:transparent;color:#000000;\">[4,6,8,10]</span><br><span style=\"background-color:transparent;color:#000000;\">[2,4,6,8,10]</span><br><span style=\"background-color:transparent;color:#000000;\">[2,6,10]</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print <i>the number of arithmetic <strong>subsequences</strong> of</i> <i>A modulo 10<sup>9</sup>+7</i>.</span></p>",
      "samples": [
        {
          "input": "5\n2 4 6 8 10",
          "output": "7"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nlong long findArithmeticSeq(int a[], int n)\n{\n    //add code here\n\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    int a[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    cout << findArithmeticSeq(a, n) << '\\n';\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "SLICES-II",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You are given an array A of N integers. Find the number of pairs (i, j) such that i &lt; j and A<sub>i</sub> + A<sub>j</sub> is a power of 2.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ T ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ N ≤ 10<sup>5</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">1</span><span style=\"background-color:#ffffff;color:#000000;\">≤ A<sub>i</sub> ≤ 2<sup>30</sup></span></p><p><span style=\"background-color:transparent;color:#000000;\">It is guaranteed that the sum of N over all test cases does not exceed </span><span style=\"background-color:#ffffff;color:#000000;\">10<sup>5</sup></span><span style=\"background-color:transparent;color:#000000;\">.</span></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define int long long\n\nsigned main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        int a[n];\n        map<int, int> m;\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            m[a[i]]++;\n        }\n        int x = 1;\n        int ans = 0;\n        for (int j = 0; j < 32; ++j) {\n            for (int i = 0; i < n; ++i) {\n           \t// WE'RE SUBTRACTING CONTRIBUTION OF a[i] from m\n           \t// SO in future indices > i, the value of a[i] will not contribute.\n           \t// It's same as deleting the past and only keeping future elements.\n           \t// Here past means, < i values and future means > i values. \n                m[a[i]]--;\n                if(m.count(x - a[i])) {\n                    ans += m[x-a[i]];\n                }\n            }\n            for (int i = 0; i < n; ++i) {\n                m[a[i]]++;\n            }\n            x *= 2;\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:26:17.345364+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Store all the integers in a map.</span></p>",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Iterate through all powers of 2 possible as sum and store the integers in a map. As you iterate through the array, check for every possible power of 2, the number of pairs possible.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(N log N)</span></p>"
      },
      "id": 368,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of the input contains one integer T - the number of test cases. Then T test cases follow.</span></p><p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains one integer N - the length of the array.&nbsp;</span></p><p><span style=\"background-color:transparent;color:#000000;\">The second line of each test case contains N space-separated integers.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, possible pairs having powers of two as sum are: [1, 7], [1, 3], [1, 1], [7, 1], [3, 1]</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the second test case, possible pairs having powers of two as sum are: [1, 1], [1, 1], [1, 1]</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, possible pairs having powers of two as sum are: [2, 6], [2, 14]</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the number of pairs (i, j) such that i &lt; j and A<sub>i</sub> + A<sub>j</sub> is a power of 2.</span></p>",
      "samples": [
        {
          "input": "3\n5\n1 7 2 3 1\n3\n1 1 1\n3\n2 6 14\n",
          "output": "5\n3\n2\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Powers of Two",
      "video_editorial_id": 8187
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You have a top-secret message which is coded in the following manner:</span><br><span style=\"background-color:transparent;color:#000000;\">A -&gt; 1</span><br><span style=\"background-color:transparent;color:#000000;\">B -&gt; 2</span><br><span style=\"background-color:transparent;color:#000000;\">….</span><br><span style=\"background-color:transparent;color:#000000;\">Z -&gt; 26.</span></p><p><span style=\"background-color:transparent;color:#000000;\">So the string <strong>AXRY</strong> is coded as <strong>1241825</strong>. (A -&gt; 1, X -&gt; 24, R -&gt; 18, Y -&gt; 25)</span><br><span style=\"background-color:transparent;color:#000000;\">You are given the coded string <strong>s</strong>. The task is to output the number of ways in which this string can be decoded, i.e, the number of strings which when coded using the above rules give the string <strong>s</strong>. Since the answer can be huge, output it modulo 10<sup>9</sup> + 7.</span><br>It is guaranteed that there is at least one way to decode the string.</p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= |s| &lt;= 100000\n( |s| = length of the string )</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n\nconst ll mod = 1e9 + 7;\nstring s;\nvector <ll> dp;\nll n;\n\nll solve(ll i) {\n\tif (dp[i] != -1)\n\t\treturn dp[i];\n\tif (i == n - 1) {\n\t\tif (s[i] == '0')\n\t\t\treturn dp[i] = 0;\n\t\telse\n\t\t\treturn dp[i] = 1;\n\t}\n\tif (s[i] == '0')\n\t\treturn dp[i] = 0;\n\tll ans = 0;\n\tans = (ans + solve(i + 1)) % mod;\n\tll x = s[i] - '0';\n\tx = x * 10;\n\tx = x + (s[i + 1] - '0');\n\tif (x >= 1 && x <= 26) {\n\t\tif (i == n - 2)\n\t\t\tans = (ans + 1) % mod;\n\t\telse\n\t\t\tans = (ans + solve(i + 2)) % mod;\n\t}\n\treturn dp[i] = ans;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcin >> s;\n\tn = s.length();\n\tdp.resize(n);\n\tfor (ll i = 0; i < n; i++)\n\t\tdp[i] = -1;\n\tll ans = solve(0);\n\tcout << ans << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:29:09.581422+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Can you think of a recursive solution?</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Can the problem be reduced into sub-problems that can be solved recursively?</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">This problem can be solved using dynamic programming.</span><br><span style=\"background-color:transparent;color:#000000;\">This problem is recursive and can be broken into sub-problems. We start from the beginning of the given digit sequence. We initialize the total count of decodings as 0. We recur for two subproblems.&nbsp;</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">If the current digit is non-zero, recur for the remaining (n-1) digits and add the result to the total count.&nbsp;</span></li><li><span style=\"background-color:transparent;color:#000000;\">If the first two digits form a valid character (or smaller than 27), recur for the remaining (n-2) digits and add the result to the total count.</span></li></ol><p><span style=\"background-color:transparent;color:#000000;\">We use memoization to store the results of the sub-problems and solve the problem in <strong>O(n)</strong> time complexity.</span></p>"
      },
      "id": 351,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The only line of input contains the string <strong>s.</strong></span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">BFAG - (2, 6, 1, 7)</span><br><span style=\"background-color:transparent;color:#000000;\">ZQ -&gt; (26, 17)</span><br><span style=\"background-color:transparent;color:#000000;\">ZAG -&gt; (26, 1, 7)</span><br><span style=\"background-color:transparent;color:#000000;\">BFQ -&gt; (2, 6, 17)</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the number of ways in which the string can be decoded.</span></p>",
      "samples": [
        {
          "input": "2617",
          "output": "4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Message Decoding",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have been given an array <i>A</i> of <i>N</i> integers and <i>M</i> ranges. <i>ith</i> range is defined by the two integers <i>l<sub>i</sub></i> and <i>r<sub>i</sub></i>, <i>l<sub>i</sub>≤r<sub>i</sub></i>.</p><p>Initially, array <i>S</i> is empty. For range i, add elements <i>A[l<sub>i</sub>],A[l<sub>i+1</sub>]…..A[r<sub>i</sub>]</i> in the array <i>S</i>. After adding all the elements in each of the range, sort the elements of <i>S</i> in ascending order.</p><p>You need to answer <i>Q</i> queries. Each query consists of a number <i>K</i> &gt; 0. You have to find the <i>Kth </i>smallest element in <i>S</i>, i.e., the element at <i>Kth</i> position in sorted <i>S</i>.</p><p>It may be possible that the same element presents multiple times in S.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n\nvoid solve() {\n  ll n, k, q, i, a, b, x;\n  cin >> n >> k >> q;\n  vector<ll> v(n + 1), pre(n + 2, 0), dp(n);\n  vector<pair<ll, ll> > suf;\n\n  for (i = 1; i <= n; i++) {\n    cin >> v[i];\n  }\n  for (i = 0; i < k; i++) {\n    cin >> a >> b;\n    pre[a] += 1;\n    pre[b + 1] -= 1;\n  }\n\n  for (i = 1; i <= n; i++) {\n    if (i != 0) {\n      pre[i] = pre[i - 1] + pre[i];\n      suf.push_back({v[i], pre[i]});\n    }\n  }\n  sort(suf.begin(), suf.end());\n  for (i = 0; i < n; i++) {\n    if (i == 0)\n      dp[i] = suf[i].second;\n    else\n      dp[i] = dp[i - 1] + suf[i].second;\n  }\n  for (i = 0; i < q; i++) {\n    cin >> a;\n    if (lower_bound(dp.begin(), dp.end(), a) != dp.end()) {\n      x = lower_bound(dp.begin(), dp.end(), a) - dp.begin();\n      cout << suf[x].first << \" \";\n    } else {\n      cout << \"-1 \";\n    }\n  }\n  cout << endl;\n}\n\nint main() {\n  // #ifndef ONLINE_JUDGE\n  // freopen(\"input.txt\",\"r\",stdin);\n  // freopen(\"output.txt\",\"w\",stdout);\n  // #endif\n\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int i, T;\n\n  T = 1;\n  cin >> T;\n\n  for (i = 1; i <= T; i++) {\n    solve();\n  }\n  return 0;\n}\n```\n\n\n",
          "language": "C++14"
        },
        {
          "code": "\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int _; cin >> _;\n    while(_--) {\n        int n, m, q;\n        cin >> n >> m >> q;\n        pair<int,int> A[n];\n        for(int i = 0; i < n; i++) {\n            cin >> A[i].first;\n            A[i].second = 0;\n        }\n        for(int i = 0; i < m; i++) {\n            int l, r; cin >> l >> r;\n            l--; r--;\n            A[l].second++;\n            if(r + 1 < n) A[r + 1].second--;\n        }\n        for(int i = 1; i < n; i++)\n            A[i].second += A[i - 1].second;\n\n        sort(A, A + n);\n\n        int ans[q];\n        pair<ll,int> Q[q];\n        for(int i = 0; i < q; i++) {\n            cin >> Q[i].first;\n            Q[i].second = i;\n        }\n\n        sort(Q, Q + q);\n\n        int ptr = 0;\n        ll sum = 0;\n\n        for(int i = 0; i < q; i++) {\n            ll x = Q[i].first;\n            while(ptr < n && sum + A[ptr].second < x) {\n                sum += A[ptr].second;\n                ptr++;\n            }\n            if(ptr < n) ans[Q[i].second] = A[ptr].first;\n            else ans[Q[i].second] = -1;\n        }\n\n        for(int i = 0; i < q; i++)\n            cout << ans[i] << \" \";\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:30:37.238255+00:00"
      },
      "hints": {
        "hint1": "The problem is to find the $k^{th}$ smallest element in the sorted list of integers obtained by concatenating the elements of given ranges. One direct approach to solve this problem would be to concatenate all the elements of the ranges into a list and sort it. Then, we can find the $k^{th}$ smallest element in the sorted list.\n\nHowever, adding each element of the ranges into the list S is a costly process. Therefore, we need a more efficient approach.\nCan you find which element in the array $A$ occurs how many times in the final array $S$?",
        "hint2": "We can use the partial sums concept to find the contribution of each index in the array $A$ in the final array $S$.",
        "solution_approach": "Check the video solution\n\nhttps://www.youtube.com/watch?v=F43IOF2MJKo\n\n## Solution 1\n\n* By idea of partial sums find keep track of which ranges are added in the final array\n* Calculating the prefix sum of the partial sums array will give us the frequency of each element added in the final array.\n* To find the smallest element, sort the elements in the final array, make sure you also keep track of their frequency. An easy way to do this is use a vector of pairs where the first element will be the element value and the second element is the frequency of that number.\n* Once we have the sorted order, we just need to find the $K$th smallest now. How to find this?\n* At any index can you find the number of elements which has occured before that particular element?\n* Yes! We need to calculate the prefix sums of the frequency of each element. By doing that at any particular value we can say from the prefix sums array how many elements has occured before that element.\n* From the prefix sums array using binary search find where $k$ lies in the prefix sums array. The result will contain the index where the value of prefix sums just exceeds or equals $k$. Getting the element will be easy if we use the index for accessing the element from the vector of pairs.  \n* Time complexity of this approach : $O(N \\log N + N + Q \\log N)$ for sorting, calculating the prefix sums array, and using binary search to find position of each k\n\n## Solution 2\nThis solution is almost same to the other version. Only difference here is, since we know the queries beforehand, so we can preprocess them in such a way that in one iteration through the prefix sums array of frequency of elements we can directly find out answers for all the queries. To do that sort the queries on the basis of the value $k$. Keep track of the query number too, since that would be important when printing the final answer. After having the sorted queries, just keep moving through the prefix frequency array, whenever you encounter a value from the query array which exceeds or equals the prefix sums array we know that we found our element. Store the answer.  \nTime complexity of this approach : $O(N \\log N + Q \\log Q + N)$ for sorting, sorting queries, and iterating through the prefix sums array."
      },
      "id": 34,
      "input_format": "<p>The first line of the input contains a single integer <i>T</i> - the number of test cases(1 ≤ <i>T </i>≤ 10). Then <i>T</i> test cases follow.</p><p>The first line of each test case contains three integers <i>N</i>, <i>M</i>, and <i>Q, (</i>1 <i>≤ N, M, Q ≤ </i>10^5<i>).</i></p><p>The second line contains <i>N</i> space-separated integers A<sub>1</sub>, A<sub>2</sub>,….,A<sub>N</sub>, the elements of the array A, (1≤<i>A<sub>i</sub></i>≤10^9).</p><p>Next <i>M</i> lines contain two space-separated integers <i>l<sub>i</sub></i> and <i>r<sub>i</sub></i> - ith range, (1 ≤ <i>l<sub>i</sub></i><sub> </sub>≤ <i>r<sub>i</sub></i><sub> </sub>≤ <i>N</i>).</p><p>The last line of a test case contains <i>Q</i> space-separated integers <i>K<sub>1</sub>, K<sub>2</sub>,….,K<sub>Q</sub>,</i> where <i>K<sub>i</sub></i> denotes the ith query. (1 ≤ <i>K<sub>i </sub></i>≤1 0^18).</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "<p><strong>Test Case 1</strong>: Initially array S is empty.</p><p>Add the 1st range -&gt; S = {1,3,2}.</p><p>Add the 2nd range -&gt; S = {1,3,2,3,2}</p><p>Add the 3rd range -&gt; S = {1,3,2,3,2,1}</p><p>After sorting the array, S = {1,1,2,2,3,3}</p><p>For K = 8, the 8th element doesn't exist in the atta S. So the answer of the 4th query is -1.</p><p><strong>Test Case 2</strong>: Initially array S is empty.</p><p>Add the 1st range -&gt; S = {1,5,4,3}.</p><p>Add the 2nd range -&gt; S = {1,5,4,3,1,5,4}.</p><p>After sorting the array, S = {1,1,3,4,4,5,5}.</p>",
      "output_format": "<p>For each test case, print <i>Q</i> space-separated integers, where <i>ith</i> number denotes the answer of <i>ith</i> query. If the <i>Kth</i> value doesn't exist for a particular query, print <i>-1</i>.</p>",
      "samples": [
        {
          "input": "2\n3 3 4\n1 3 2\n1 3\n2 3\n1 1\n1 2 5 8\n4 2 3\n1 5 4 3\n1 4\n1 3\n1 5 7",
          "output": "1 1 3 -1 \n1 4 5 \n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Kth Val",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array <i>A</i> of <i>N</i> integers and an integer <i>target</i>, find three integers in <i>A</i> such that the sum is closest to the <i>target (absolute value of (sum-target) is minimum)</i>. Print the minimum absolute value of (sum-target). You cannot select an index more than one. All three indexes should be distinct.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nsigned main()\n{\n   ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n   int testcases;\n   cin>>testcases;\n   while(testcases--){\n       ll n,target;\n       cin>>n>>target;\n       vector< ll > arr(n);\n       for(int i=0;i<n;i++)\n           cin>>arr[i];\n       sort(arr.begin(),arr.end());\n       ll best = arr[0]+arr[1]+arr[2];\n       for(ll i=1;i<(ll)arr.size()-1;i++){\n           ll lo = 0;\n           ll hi = (ll)arr.size()-1;\n           while(1){\n               if(abs(arr[lo]+arr[i]+arr[hi]-target)<abs(best-target)){\n                   best=arr[lo]+arr[i]+arr[hi];\n               }\n               if(arr[lo]+arr[i]+arr[hi]>target)hi--;\n               else lo++;\n               if(lo==i||hi==i)break;\n           }\n       }\n       cout<<abs(best-target)<<\"\\n\";\n   }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:46:38.505965+00:00"
      },
      "hints": {
        "hint1": "<p>Sorting the given array would help us use the two-pointer technique.</p>",
        "hint2": "<p>We iterate through the array and fix the first number of the array (index, K), and then use the two-pointer technique on the array to its right side. We take the left pointer as L = K + 1 and the right pointer as R = size(A) - 1. This would help us ensure that all the indexes taken are distinct. Find the sum of the three integers and take the minimum absolute difference between all such sums and target. If the sum &lt; target, decreasing the value of R would only decrease the sum and hence increase the absolute difference, so we increase the value of L. Similarly if sum &gt; target, we decrease the value of R. Continue doing the two-pointer until L &lt; R and find the minimum possible absolute difference of sum and target.</p>",
        "solution_approach": ""
      },
      "id": 65,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases <i>(1&lt;=T&lt;=100)</i>.</p><p>The first line contains two space-separated integers <i>N, target</i> where 3<i>&lt;=N&lt;=10^3, -1e18&lt;=target&lt;=1e18.</i></p><p>Next line contains <i>N</i> space-separated integers (-1e9&lt;=Ai&lt;=1e9).</p><p>The Sum of <i>N</i> across all test cases ≤ 10^4.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>For each test case print the minimum absolute value of (sum-target).</p>",
      "samples": [
        {
          "input": "1\n5 3\n1 2 3 4 5",
          "output": "3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "3 Sum",
      "video_editorial_id": 10685
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are <i>N</i> students and ith student likes all numbers in the range [<i>l<sub>i</sub></i> ,<i>r<sub>i </sub></i>]<i>, </i>both inclusive<i>.</i> A number is good if it is liked by at least <i>K</i> students.</p><p>You are even <i>Q</i> queries. Each query consists of two numbers L, R. You have to find how many numbers in the range <i>[L,R]</i> is good.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000005;\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, k, q;\n  cin >> n >> k >> q;\n  int arr[N];  // note that N and n are different.\n  for (int i = 0; i < N; i++) arr[i] = 0;\n\n  for (int i = 1; i <= n; i++) {\n    int l, r;\n    cin >> l >> r;\n    // use the technique of Partial sum to build the value at each index.\n    arr[l]++;\n    arr[r + 1]--;\n  }\n  // finally build the prefix sum.\n  for (int i = 1; i < N; i++) arr[i] += arr[i - 1];\n\n  // keep the values 1 where values >=k or else 0.\n  for (int i = 1; i < N; i++) arr[i] = (arr[i] >= k);\n\n  // now to answer query in O(1), we will build prefix sum on this 0/1 array to\n  // get count of positions.\n  int prefixSum[N];\n  prefixSum[0] = 0;\n  for (int i = 1; i < N; i++) {\n    prefixSum[i] = prefixSum[i - 1] + arr[i];\n  }\n\n  while (q--) {\n    int l, r;\n    cin >> l >> r;\n    // gives the count of 1 positions in O(1).\n    int ans = prefixSum[r] - prefixSum[l - 1];\n    cout << ans << \"\\n\";\n  }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:31:41.247301+00:00"
      },
      "hints": {
        "hint1": "Use partial sum and then get the final array where $arr[i] =$ the number of students who like the ith number.",
        "hint2": "We know that a student i likes all the numbers between $l_i$ and $r_i$.So the effect of that student on the likeness of all the numbers between $l_i$ and $r_i$ is $1$. This is similar to adding $+1$ to all the numbers in the range $l_i$ and $r_i$. We can solve this using partial sums concept. Make an array $arr$ in which whenever we find a student likes numbers between l and r we take care of its contribution using partial sums as follows,  \n$arr[l]+=1$,  \n$arr[r+1]+ = -1$  \nAfter performing prefix sum on the partial sum array $arr$ we can get a count of the number of students liking a number $i$.  \n$arr[i]+=arr[i-1]$",
        "solution_approach": "Now that we have got the number of students liking the number $i$, we can find which are good numbers and which are not by simply finding which number has been liked by $K$ or greater than $K$ number of students,  \nIf $arr[i]>=k$ then $arr[i] = 1$ which means it is a good number otherwise $0$.  \nNow we have the array $arr$ which simply stores whether a number is good number or not. So if a number $i$ is good $arr[i]=1$ else $arr[i]=0$ and we are to find the number of good numbers in a range $l$ to $r$.  \n Doesn't it seem familiar??  \n  Well you are right!  \n   We need to find the prefix sum of this array $arr$ to find the number of good numbers in a range. After doing a prefix sum any index i gives the number of good numbers from the beginning of the array to the index $i$. So to find the number of good numbers between range $l$ and $r$ we can do,  \n$ans = arr[r]-arr[l-1]$\n\nTime complexity of this solution is $O(n+ N + Q)$, where $N$ is the maximum number $r_i$, we take it to be around $1000005$, $n$ is the number of students and $Q$ is the number of queries."
      },
      "id": 23,
      "input_format": "<p>The first line of input contains three integers, <i>N</i>, <i>K</i> (1 ≤ <i>K</i> ≤ <i>N</i> ≤ 1000000), and <i>Q</i> (1 ≤ <i>Q</i> ≤ 1000000).</p><p>The next <i>N</i> lines contain two integers <i>l<sub>i</sub></i> and <i>r<sub>i</sub></i> (1 ≤ <i>l<sub>i</sub></i> ≤ <i>r<sub>i</sub></i>≤ 1000000), describing that the i-th student likes all the numbers <i>[l<sub>i</sub>,r<sub>i</sub>]</i>.</p><p>The next <i>Q</i> lines contain <i>L</i> and <i>R</i>, (1 ≤ <i>L</i> ≤ <i>R</i> ≤ 1000000).</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "",
      "output_format": "<p>For each query print how many numbers in the range <i>[L,R]</i> is good in a new line.</p>",
      "samples": [
        {
          "input": "10 3 10\n1 5\n2 7\n3 9\n1 5\n3 8\n4 10\n7 10\n8 8\n5 5\n6 7\n1 5\n3 8\n4 9\n3 10\n2 6\n3 9\n7 7\n5 5\n8 8\n3 7",
          "output": "4\n6\n6\n7\n5\n7\n1\n1\n1\n5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Good Numbers",
      "video_editorial_id": 10654
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Given a chessboard of size <i>N × M</i>, find the number of ways in which you can place 2 knights - one black and one white, such that they do not attack each other.</span></p>",
      "complete_approach": "",
      "constraints": "<p><span style=\"background-color:transparent;color:#000000;\"><i>1 ≤ N,M ≤ 10<sup>5</sup></i></span><br><span style=\"background-color:transparent;color:#000000;\"><i>1 &lt; N x </i></span><i>M</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nint MOD = 1e9 + 7;\n\nint main()\n{\n    ll n, m;\n    cin >> n >> m;\n\n    ll tot = (n * m % MOD) * ((n * m - 1) % MOD) % MOD; //tot = (n*m)*(n*m-1)\n    ll att = max(0LL, n - 1) * max(0LL, m - 2) * 4 % MOD;\n    (att += max(0LL, n - 2) * max(0LL, m - 1) * 4 % MOD) %= MOD;\n\n    cout << (tot - att + MOD) % MOD << '\\n';\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:24:10.116772+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">No of possible arrangements = Total Number - Number of ways where they attack</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">The knights attack each other when they are placed in the corners of a rectangle of size 2×3 or 3×2<i>.</i></span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">The total number of ways is equal to <i>(N × M) × (N × M - 1).</i> (You can place the first knight in any of the boxes and the second one in any box where you didn’t place the first one)</span><br><span style=\"background-color:transparent;color:#000000;\">The knights attack each other when they are placed in the corners of a rectangle of size 2×3 or 3×2<i>.</i> You can find the number of such rectangles in the chessboard and there are 4 possible orientations for the knights in the corners. So total arrangements where they attack each other is <i>4 × No of horizontal rectangles + 4 × No of vertical rectangles</i>.</span></p>"
      },
      "id": 603,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The one and only line of each input file contains two integers - <i>N</i> and <i>M</i>.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the possible number of arrangements modulo <i>10<sup>9</sup> +7.</i></span></p>",
      "samples": [
        {
          "input": "2 2",
          "output": "12"
        },
        {
          "input": "2 3",
          "output": "26"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "BLAWHI",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You will be given an array <strong>A</strong> of <strong>N</strong> non-negative integers. Your task is to find the rightmost non-zero digit&nbsp;in the&nbsp;product of array elements if exist.</p>",
      "complete_approach": "",
      "constraints": "<ul><li>1 ≤ N ≤ 10<sup>5</sup></li><li>0 ≤ A[i] ≤ 10<sup>5</sup>&nbsp;</li></ul>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int a[n];\n    bool flag = 1;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        if (a[i] == 0)flag = false;\n    }\n    if (!flag) { // when product of elements if 0.\n        cout << -1;\n        return;\n    }\n    int cnt2 = 0, cnt5 = 0;\n    for (int i = 0; i < n; i++) { // counting  frequency of 2 and 5 in the product.\n        int x = a[i];\n        while (x % 2 == 0)cnt2++, x /= 2;\n        while (x % 5 == 0)cnt5++, x /= 5;\n    }\n    int tens = min(cnt2, cnt5); // number of ending zeroes in the final product.\n    cnt2 = cnt5 = tens; // 2 and 5 cnts to be removed from product, to remove all ending zeroes.\n    ll prod = 1;\n    for (int i = 0; i < n; i++) { // O(n*logn)\n        while (cnt2 && a[i] % 2 == 0)cnt2--, a[i] /= 2;\n        while (cnt5 && a[i] % 5 == 0)cnt5--, a[i] /= 5;\n        (prod *= a[i]) %= 10; // prod will always have last non zero digit.\n    }\n    cout << prod;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:13:49.261553+00:00"
      },
      "hints": {
        "hint1": "<p>Think in terms of prime factors- 2 and 5.<br>Number of zeroes at the end of the product = min( count of 2 as prime factor of product, count of 5 as prime factor of product ).&nbsp;<br>How can you remove these ending zeroes from the final product?</p>",
        "hint2": "<p>We will count the frequency of 2 and 5 as a prime factor in the final product. let it be <strong>x </strong>and<strong> y </strong>respectively.</p><p>We will remove now remove all <strong>min(x,y) </strong>counts of 2 and 5 in the final product to remove all ending zeroes. Now final product will not have any ending zero.</p><p>While calculating the final product, how can you prevent the overflow? Do you still need to calculate the whole final product just to get the last non zero digit ?</p>",
        "solution_approach": "<p>If the array has any element equal to 0, then the product will be equal to 0, in that case, print -1, as no non-zero digit exists.&nbsp;</p><p>It is given that you have to find the rightmost positive digit. Now a number is a multiple of 10 or have the last digit as 0 if both 2 and 5 are present as a prime factor.</p><p>We will count the frequency of 2 and 5 as a prime factor in the final product. let it be <strong>x </strong>and<strong> y </strong>respectively.<br>We will remove now remove all <strong>min(x,y) </strong>counts of 2 and 5 in the final product to remove all ending zeroes. Now final product will not have any ending zero.</p><p>While calculating the final product, we will % it by 10, to store only the last non-zero digit, and thus preventing overflow.</p><p>Refer to the editorial's code for the implementation details.</p><p><strong>Time Complexity : O(N*logN)&nbsp;</strong></p>"
      },
      "id": 870,
      "input_format": "<p>First-line contains <strong>N</strong>, the size of the array <strong>A</strong>.<br>The second line contains <strong>N</strong> non-negative integers.&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For Sample 1: Product of these numbers \nare 93150. Rightmost \nnon-zero digit is 5.</p>",
      "output_format": "<p>Print the rightmost non-zero digit&nbsp;in the&nbsp;product of array elements, if there is no rightmost non-zero digit, then print -1.</p>",
      "samples": [
        {
          "input": "4\n3 23 30 45",
          "output": "5"
        },
        {
          "input": "5\n1 0 2 3 4",
          "output": "-1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Non Zero Digit",
      "video_editorial_id": 8231
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array of N integers. In one operation, you can increase the value of any element by one. Find the minimum number of operations to make the array non-decreasing.",
      "complete_approach": "",
      "constraints": "- $1 \\leq T \\leq 10^5$\n- $1 \\leq N \\leq 10^5$\n- $1 \\leq A_i \\leq 10^9$\n\nIt is guaranteed that the sum of $N$ over all test cases does not exceed $10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nint main() {\n    IOS\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        long long ans = 0;\n        for (int i = 1; i < n; ++i) {\n            if (a[i-1] > a[i]) {\n                ans += a[i-1] - a[i];\n                a[i] = a[i-1];\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:25:13.242669+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "For an increasing array, A[i-1] ≤ A[i]. It is only allowed to increase an element, so if A[i-1] > A[i], change A[i] to A[i-1]. \n\nTime Complexity per test case: O(N)"
      },
      "id": 335,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer N - the length of the array. \n\nThe second line of each test case contains N space-separated integers.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, increasing array would be: 4, 5, 5, 9\n\nFor the second test case, increasing array would be: 1, 3, 4, 4, 4\n\nFor the third test case, increasing array would be: 1, 1, 1",
      "output_format": "For each test case, print the minimum number of operations to make the array Non-Decreasing.",
      "samples": [
        {
          "input": "3\n4\n4 5 1 9\n5\n1 3 4 4 3\n3\n1 1 1\n",
          "output": "4\n1\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Increasing Array AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given a grid of <i>N </i>x<i> M</i>. You are initially at position <i>A(0, 0)</i> and you want to reach <i>B(N, M)</i>. From the given cell (i, j), we are allowed to move to cells (i + 1, j) and (i, j + 1) only.<br>Find the number of different ways to reach <i>B</i> from <i>A</i>?<br>&nbsp;</p><figure class=\"image\"><img src=\"https://lh6.googleusercontent.com/CCALDGjC9FQv5ofh10hy6y3Pmc4cfRmiy4wFEVfSxRDmd0v8MdvdeoGvlsAgwTDejItDX_ajO8ZfDBRIoz5ovHadaLfA98FMFfflM-pRGK6YEV_siMKAyUPzwvOL5W6lL9xOBl71\"></figure>",
      "complete_approach": "",
      "constraints": "1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>T</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 100000\n\n<i>N, M</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>5</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 200010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += mod;\n}\n\ninline int mul(int a, int b) {\n  return (int) ((long long) a * b % mod);\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= mod;\n  if (a < 0) a += mod;\n  int b = mod, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += mod;\n  return u;\n}\n\nint fact[N];\n\nvoid pre() {\n    fact[0] = 1;\n    for(int i = 1; i < N; i++)\n        fact[i] = mul(fact[i - 1], i);\n    return;\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    pre();\n\n    int T; cin >> T;\n    while(T--) {\n        int n, m; cin >> n >> m;\n        int ans = fact[n + m];\n        ans = mul(ans, inv(fact[n]));\n        ans = mul(ans, inv(fact[m]));\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:38:28.978921+00:00"
      },
      "hints": {
        "hint1": "Suppose moves are U (up) and R (right). Any valid sequence of moves which reaches B has exactly N Us and M Rs.",
        "hint2": "Initially we are at (0,0), we need to reach (N,M). We are only given the choices of moving right and up. So its obvious that we need to take N up movements and M right turns to reach the final destination of B. There will be a total of N+M moves.  \nIt reduces to a problem of this sort \"N red balls and M black balls, arrange all the balls in a straight line. How many distinct ways to arrange them\".  \nHere you can think of red balls as the \"movement Up\" and black balls as the \"movement Down\"",
        "solution_approach": "Any valid sequence of moves contains exactly total $N + M$ moves. We can calculate the total number of ways as $N+M\\choose N$ = $N+M\\choose M$.  \n${(N+M)\\choose N} \\% 1000000007$ or ${(N+M)\\choose M} \\% 1000000007$.  \n\nTime complexity : $O(N+M)!$ which we need to precalculate at the beginning. For each test case we need to find the inv() values, which in the worst case would take $O(\\log N)$ time.\nSo we can assume overall time complexity to be around $O(N+M)!$"
      },
      "id": 71,
      "input_format": "<p>The first line contains <i>T</i> (1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>T</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 100000), the number of test cases.<br>Each of the next <i>T</i> lines contains two positive integers <i>N, M</i> (1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>N, M</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>5</sup>).</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each test case, print the number of ways to reach <i>B</i> from <i>A</i>. Since answer can be large, print it with modulo 1000000007.</p>",
      "samples": [
        {
          "input": "2\n2 1\n3 2",
          "output": "3\n10"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Number of Ways to Reach B",
      "video_editorial_id": 8139
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given an integer N, break it into the sum of K **positive integers**, where K >= 2, and maximize the product of those integers.",
      "complete_approach": "",
      "constraints": "<p><i>1 ≤ T ≤ 10<sup>4</sup></i><br><i>2 ≤ N ≤ 10<sup>6</sup></i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define MOD 1000000007\n\nint power(long long a, long long b)\n{ //a^b\n    long long res = 1;\n    a = a % MOD;\n    while (b > 0)\n    {\n        if (b & 1)\n        {\n            res = (res * a) % MOD;\n            b--;\n        }\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint findMaxProd(int n)\n{\n    if (n == 2)\n        return 1;\n    if (n == 3)\n        return 2;\n    if (n == 4)\n        return 4;\n    if (n % 3 == 0)\n        return power(3, n / 3);\n    if (n % 3 == 2)\n        return 2ll * power(3, n / 3) % MOD;\n    return 4ll * power(3, n / 3 - 1) % MOD;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        cout << findMaxProd(n) << '\\n';\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:19:22.421563+00:00"
      },
      "hints": {
        "hint1": "<p>Can you come up with a greedy logic to break the number such that the product is maximized?</p>",
        "hint2": "<p>Can you prove why the most profitable way of breaking the number is into 2's and 3's?</p>",
        "solution_approach": "<p>The given problem can be solved using DP, but it'll be too slow. We can show that we would always want to break the number into 2's and 3's. For <i>N</i> ≥ 5, we can see that it is always beneficial to break N further. For example if <i>N = 6 + x</i>, the product we get is <i>6*x.</i> But if we write <i>N</i> as <i>N = 3 + 3 + x</i>, the product will be <i>9*x. </i>Also breaking the number into 3's is more profitable as <i>3*(x-3) ≥ 2*(x-2)</i> for <i>x ≥ 5.</i> So we can simply find the answer by multiplying by 3, N/3 times. To find the product efficiently you can use binary exponentiation.</p>"
      },
      "id": 631,
      "input_format": "The first line contains a single integer <i>T</i> - the number of test cases.<br><i>T</i> lines follow containing a single integer <i>N.</i>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<pre><code class=\"language-plaintext\">1 + 1 = 2\n1 + 2 = 3\n2 + 2 = 4\n2 + 3 = 5\n3 + 3 + 4 = 10</code></pre>",
      "output_format": "For each test case print in a new line the maximum output possible modulo <i>10<sup>9</sup>+7</i>.",
      "samples": [
        {
          "input": "5\n2\n3\n4\n5\n10",
          "output": "1\n2\n4\n6\n36"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nint findMaxProd(int n)\n{\n    //add code here\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        cout << findMaxProd(n) << '\\n';\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "INTBREAK",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given two arrays <i>A</i> of size <i>N</i> and <i>B</i> of size <i>M</i> and an integer <i>K</i>. Create a new array <i>C</i> of size <i>N*M</i> consisting of <i>A[i]+B[j]</i> for <i>1≤i≤N, 1≤j≤M</i>. Find the <i>Kth</i> smallest element in the array <i>C</i>.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> Pair;\ntypedef long long ll;\nvector<int> a, b;\n#define int long long\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n, m, k;\n        cin >> n >> m >> k;\n        a.resize(n);\n        b.resize(m);\n        for (int i = 0; i < n; i++)\n        {\n\n            cin >> a[i];\n        }\n        for (int i = 0; i < m; i++)\n        {\n\n            cin >> b[i];\n        }\n        if (n > m)\n        {\n            swap(n, m);\n            swap(a, b);\n        }\n        sort(a.begin(), a.end());\n        sort(b.begin(), b.end());\n        int l = a[0] + b[0];\n        int h = a[n - 1] + b[m - 1];\n        int ans = l;\n        while (l <= h)\n        {\n            int mid = (l + h) / 2;\n            int ne = 0;\n            for (int i = 0; i < n; i++)\n            {\n                ne += upper_bound(b.begin(), b.end(), mid - a[i]) - b.begin();\n            }\n            if (ne >= k)\n            {\n                ans = mid;\n                h = mid - 1;\n            }\n            else\n                l = mid + 1;\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:41:30.542020+00:00"
      },
      "hints": {
        "hint1": "We can use binary search on the possible sums between A and B. For a given value in A, you can find the possible solutions in B for a sum, say X i.e. $A[i] + B[j] \\leq X$.",
        "hint2": "If the count for values with sum $X \\geq K$, then we can divide the array into two parts and perform binary search on one part. Similarly, we can do this if $count \\leq K$.",
        "solution_approach": "Let’s say $N \\leq M$(swap the arrays if this is not the case). We are doing this to reduce the time complexity. We would be performing binary search on the possible sum of the K-th element in the new array, $A_i + B_i$. Sort both the arrays and take the left pointer as L, the smallest sum possible i.e. A[0] + B[0], and the right pointer as R, the largest sum possible i.e. $A[N-1] + B[M-1]$. We take $mid = \\dfrac{L+R}{2}$.\n\nWe would traverse through the first array (with size N) and find the count of numbers such that its sum with $A_i$ is ≤ mid. If the count of such numbers is $\\geq K$, that can be a possible answer and we continue binary search from $L$ to $R = mid-1$. Otherwise, we need to increase the sum of numbers and hence we perform binary search from $L = mid+1$ to $R$.\n\nRemember that you must iterate in the check function over the smaller array otherwise you will get TLE.So try to find the array which is smaller and do the iteration over it and apply the upper bound over the larger function.\n\nCondition is given as min(n,m) over all test cases doesnt exceed $10^5$ so we must take the hint to take the smaller array as the iterating version.\n\n**Time Complexity per test case: $O(N \\times log_2M \\times log_2(max(A_i + B_i) - min(A_i + B_i))$ where $N \\leq M$**"
      },
      "id": 102,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases (<i>1&lt;=T&lt;=10000</i>).</p><p>The first line contains 3 space-separated integer <i>N, M, K</i> where <i>1&lt;=N&lt;=10^6, 1&lt;=M&lt;=10^6, 1&lt;=K&lt;=N*M</i>.</p><p>Next line contains <i>N</i> space-separated integers (<i>0&lt;=Ai&lt;=1e4</i>).</p><p>Next line contains <i>M</i> space-separated integers (<i>0&lt;=Bi&lt;=1e4</i>).</p><p>Sum of <i><strong>min(N, M) across all test cases&lt;=10^5</strong></i>.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 512000,
      "note": "<p>Array C -&gt; [1+4,1+5,1+6,2+4,2+5,2+6,3+4,3+5,3+6] -&gt; [5,6,7,6,7,8,7,8,9]<br>Array C after sorting - [5,6,6,7,7,7,8,8,9]<br>6th element is 7.</p>",
      "output_format": "<p>For each test case print the <i>Kth</i> smallest element in the array <i>C</i>.</p>",
      "samples": [
        {
          "input": "1\n3 3 6\n1 2 3\n4 5 6",
          "output": "7"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Kth Sum Value",
      "video_editorial_id": 10683
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Find the number of *Prime Cycles* with the permutation of the first $N$ positive integers. The cycle is called a *Prime Cycle* if all **neighbouring** pairs sum up to be a prime.\n\nThe two **distinct** prime cycles for *N = 6* are:\n\n1. 1, 4, 3, 2, 5, 6\n2. 1, 6, 5, 2, 3, 4\n\nThe permutation of `3, 2, 5, 6, 1, 4` is considered the same as the first sequence.",
      "complete_approach": "",
      "constraints": "<p>2 ≤ <i>N</i> ≤ 19</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nconst int N = 100;\n\nll ans = 0;\nbool isPrime[N];\nbool marked[N];\nvector<int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\nvoid solve(int m, int n, int prev, int par)\n{\n    if (!m)\n    {\n        if (isPrime[prev + 1])\n        {\n            ans++;\n        }\n        return;\n    }\n    for (int i = 1 + par; i <= n; i += 2)\n    {\n        if (!marked[i] && isPrime[i + prev])\n        {\n            marked[i] = true;\n            solve(m - 1, n, i, 1 - par);\n            marked[i] = false;\n        }\n    }\n    return;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    if (n % 2 == 1)\n    {\n        cout << \"0\\n\";\n        return 0;\n    }\n\n    memset(isPrime, false, sizeof(isPrime));\n    memset(marked, false, sizeof(marked));\n\n    for (int u : prime)\n    {\n        isPrime[u] = true;\n    }\n\n    marked[1] = true;\n    solve(n - 1, n, 1, 1);\n\n    cout << ans << \"\\n\";\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:42:30.683606+00:00"
      },
      "hints": {
        "hint1": "Since we have to find a distinct number of cycles. Without loss of generality, we can assume that the cycle starts with number $1$.",
        "hint2": "Observe that when the two consecutive numbers are of the same parity, then the sum will be definitely going to divisible by $2$.",
        "solution_approach": "The brute force solution will be to generate all N! permutations and check for each whether it is a prime cycle or not. But this solution will not pass the limits. We have to perform some kind of optimizations.\n\nLet's note down some observations.\n\n1. Since we have to find a distinct number of cycles. Without loss of generality, we can assume that the cycle starts with number 1.\n2. Hence, the two neighbouring in numbers in the prime cycle has to be of opposite parity.\nUsing these observations we can optimize the brute force solution. \n### Level\nWe can use the length of the sequence as our level. Here we use the remaining number of items to be put to complete the sequence as our level. In addition we keep track of the previous element in the sequence, the parity of the current element we are expecting and the limiting value of the sequence.\n### Check\nCheck if the sequence length generated is as desired and if the summation of the last element and the first element of the sequence is a prime number too then we can increment our ans since its a valid solution.\n### Choice\nAt each recursive step we iterate through either even numbers or odd numbers whichever is required depending on the parity. While iterating for each element check if it has been already taken and if it along with the previous element sums up to a prime number. If YES, we take this element in our sequence and transition forward.\n### Transition\nWhen we take an element we update our previous element as the current element. This will serve as the previous element for the next recursion. We udpate our remaining number of numbers to fill the sequence and update the parity which we need in our next recursion."
      },
      "id": 142,
      "input_format": "<p>The input contains only a single integer <i>N</i> - denoting the number of positive integers.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "**_Explanation 1:_**  \nOnly one Prime Cycle exists: `{1, 2}`.\n\n**_Explanation 2:_**  \nTwo Prime Cycles are: `{1, 2, 3, 4}` and `{1, 4, 3, 2}`.\n\n**_Explanation 3:_**  \nTwo Prime Cycles are: `{1, 4, 3, 2, 5, 6}` and `{1, 6, 5, 2, 3, 4}`.",
      "output_format": "<p>Print the number of Prime Cycles that are possible to form from first <i>N</i> positive numbers.</p>",
      "samples": [
        {
          "input": "2",
          "output": "1"
        },
        {
          "input": "4",
          "output": "2"
        },
        {
          "input": "6",
          "output": "2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Prime Cycles",
      "video_editorial_id": 8154
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a string s and two integers x and y. You can perform two types of operations any number of times.</p><p>Remove substring \"ab\" and gain x points.</p><p>For example, when removing \"ab\" from \"cabxbae\" it becomes \"cxbae\".</p><p>Remove substring \"ba\" and gain y points.</p><p>For example, when removing \"ba\" from \"cabxbae\" it becomes \"cabxe\".</p><p>Return the maximum points you can gain after applying the above operations on s.</p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 ≤ T ≤ 10^5\n1 ≤ X,Y ≤ 10^9\n1 ≤ |S| ≤ 10^5.\nSum of |S| across all test cases ≤ 10^6.</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nvoid solve() {\n    stack<char> st;\n    int x, y;\n    string s;\n    cin >> s >> x >> y;\n\n    string o = \"ab\";\n    string p = \"ba\";\n\n    if (y > x) {\n        swap(x, y);\n        swap(o, p);\n    }\n\n    int ans = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (!st.empty() && st.top() == o[0] && s[i] == o[1]) {\n            st.pop();\n            ans += x;\n        } else {\n            st.push(s[i]);\n        }\n    }\n\n    string m;\n    while (!st.empty()) {\n        m += st.top();\n        st.pop();\n    }\n\n    reverse(m.begin(), m.end());\n\n    for (int i = 0; i < m.length(); i++) {\n        if (!st.empty() && st.top() == p[0] && m[i] == p[1]) {\n            st.pop();\n            ans += y;\n        } else {\n            st.push(m[i]);\n        }\n    }\n\n    cout << ans << endl;\n}\n\nsigned main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:17:18.282028+00:00"
      },
      "hints": {
        "hint1": "Points are gained when you remove all occurrences of “ab”  and “ba” from the string. Clearly, it is wise to remove that substring first which has more points than the other.",
        "hint2": "You can remove “ab” and “ba” (if they are present) in any possible order and find the maximum point from all such possibilities. However, that would not be an optimum solution. Instead, try to remove that substring that has more points than the other. Continue to do so till the string has no other occurrence of “ab” or “ba”.",
        "solution_approach": "This problem is solved by a greedy approach of first removing the substring, which scores more points. Erase all occurrences of that larger substring till it isn’t present in the current state of the string anymore. Then remove all occurrences of the smaller substring from the string. Remember, after every removal, the string size reduces.\n\nAlso, from observation, it is clear,  once you remove all substrings of a type (say A) from the string, then the changed string will not contain another substring of the same type. So now you can easily check for the second type of substring.\n\nEXAMPLE RUN : \n\n1\n\nbabadbaba 45 32\n\n\n \n\nSince x>y “ab” is removed first.\n\nTwo occurrences of “ab” is seen in the current state of S = babadbaba → S = badba \n\nCost = 45*2 = 90\n\nTwo occurrences of “ba” is seen in current state of S = badba → S = d \n\nCost = 90+32*2 = 154\n\nThis is the required answer."
      },
      "id": 490,
      "input_format": "<p>The first line contains an integer T (number of test cases), 1 ≤ T ≤ 10^5.</p><p>The next T lines contain a string S and 2 space-separated integers S, X, Y where 1 ≤ X,Y ≤ 10^9, 1 ≤ |S| ≤ 10^6.</p><p>Sum of |S| across all test cases ≤ 10^7.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "### For the first sample input:\n\n#### TEST CASE 1:\nS = `abdsbab`, x = 23, y = 50  \n\n1. Remove “ba” → Points = 50 → S = `abdsb`.  \n2. Remove “ab” → Points = 50 + 23 = 73 → S = `dsb`.  \n\nNothing else to remove, so the total points are **73**.\n\n---\n\n#### TEST CASE 2:\nS = `babababa`, x = 45, y = 32  \n\n1. Remove “ab” → Points = 45 → S = `bababa`.  \n2. Remove “ab” → Points = 45 + 45 = 90 → S = `baba`.  \n3. Remove “ab” → Points = 90 + 45 = 135 → S = `ba`.  \n4. Remove “ba” → Points = 135 + 32 = 167 → S = ` ` (empty string).  \n\nNothing else to remove, so the total points are **167**.\n\n---\n\n#### TEST CASE 3:\nS = `ujaabba`, x = 4, y = 5  \n\n1. Remove “ba” → Points = 5 → S = `ujaab`.  \n2. Remove “ab” → Points = 5 + 4 = 9 → S = `uja`.  \n\nNothing else to remove, so the total points are **9**.\n\n---\n\n#### TEST CASE 4:\nS = `cxbaeab`, x = 17, y = 9  \n\n1. Remove “ab” → Points = 17 → S = `cxbae`.  \n2. Remove “ba” → Points = 17 + 9 = 26 → S = `cxe`.  \n\nNothing else to remove, so the total points are **26**.",
      "output_format": "<p>For each test case print the maximum point possible in a new line.</p>",
      "samples": [
        {
          "input": "4\nabdsbab 23 50\nbabababa 45 32\nujaabba 4 5\ncxbaeab 17 9",
          "output": "73\n167\n9\n26"
        },
        {
          "input": "20\nab 7 4\naaba 10 8\nbaba 6 4\nba 4 8\nbaabbbb 5 6\naaabab 1 7\nbabaaba 8 10\nb 1 8\nabbaaa 2 7\nb 5 6\naa 7 4\nbbbaa 8 4\nbbbba 7 6\nbabba 8 7\nbababbab 3 1\nbaa 6 9\nbabbba 3 6\naa 9 2\nbaababaaba 10 8\nbbbbbbaab 3 6",
          "output": "7\n10\n10\n8\n11\n8\n30\n0\n14\n0\n0\n8\n6\n15\n9\n9\n12\n0\n38\n12"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Substring Removal",
      "video_editorial_id": 8212
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Vivek wants to travel from city $1$ to $N$, He can travel across each consecutive city i.e $i$ → $i+1$ using Bus by paying cost $A[i]$, and can also travel from city $i$ to a different city $j$ , at most $k$ cities away from $i$ i.e $abs(i-j) \\leq k$ through a Flight by paying $B[i]+B[j]$ charges, but he cannot take more than $M$ flights during his travel.\n\nFind the minimum cost to reach from city $1$ to $N$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 1000$\n$1 \\leq k \\leq N \\leq 10^{6}$\n$0 \\leq M \\leq N$\n$1 \\leq A[i], B[i] \\leq 10^{6}$\n\nSum of $N*M$ over all test cases $\\leq 10^{8}$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvector<vector<ll>> dp;\nvector<int> a, b;\nint n, m, k;\n\nvoid solve() { // O(N*M) Time, O(N) space.\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<int> a(n + 1), b(n + 1);\n    for (int i = 1; i <= n; i++)cin >> a[i];\n    for (int i = 1; i <= n; i++)cin >> b[i];\n    vector<vector<ll>> dp(n + 1, vector<ll>(2, 1e18));\n    dp[1][0] = 0;\n    ll ans = 1e18;\n    for (int j = 0; j <= m; j++) {\n        deque<int> dq;\n        dq.push_front(1);\n        for (int i = 2; i <= n; i++) {\n            dp[i][j & 1] = min(dp[i][j & 1], dp[i - 1][j & 1] + a[i - 1]);\n            if (j == 0)continue;\n            while (!dq.empty() && dq.front() < i - k)dq.pop_front();\n            dp[i][j & 1] = min(dp[i][j & 1], dp[dq.front()][(j - 1) & 1] + b[dq.front()] + b[i]);\n            while (!dq.empty() && dp[dq.back()][(j - 1) & 1] + b[dq.back()] >= dp[i][(j - 1) & 1] + b[i])dq.pop_back();\n            dq.push_back(i);\n        }\n        ans = min(ans, dp[n][j & 1]);\n    }\n    cout << ans << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:14:19.885747+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "**Naive $O(N*K*M)$ DP** :\n\n**State** : $dp[i][f]$ → min cost to reach $i^{th}$ city from $1^{st}$ city using $f$ flights.\n\n**Transition**:  $dp[i][f] = min( dp[i-1][f]+A[i-1], Z )$ \nwhere $Z = min( dp[i-j][ f-1 ]+B[i]+B[i-j])$ , over all $1≤ i-k ≤ j < i$. \n\n→ $O(k)$ in transition, $O(N*k*M)$ overall complexity.\n \n**Transition Optimisations**: ( Only applicable to Bottom up approach )\n1. $O( logK )$ Time transition and $O( N*M*logK )$ overall time solution using multiset to store $min( dp[i-j][f-1]+B[ i - j ] )$ of previous $k$ size window.\n \n2. $O(1)$ Time transition , $O(N*M)$ overall Time and $O(N*M)$ Space overall solution using min deque to store $min( dp[i-j][f-1]+B[ i - j ] )$ of previous $k$ size window.\n\n**Further Memory Optimisations** : ( $O(N)$ Space Reduction )\nTransitions of the current state only depend on the last state of flight count, so store only $2$ rows of memory.\n\n#####Note -: \nExpected Complexity per test case for this problem is -\nTime : $O(N*M)$. \nSpace : $O(N)$."
      },
      "id": 924,
      "input_format": "First-line contains $T$ - the number of test cases.\nThe First Line of each test case contains $N$, $M$, and $k$.\nThe second line of each test case contains $N$ elements of cost array $A$.\nThe third line of each test case contains $N$ elements of cost array $B$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "Travel from 1 to 2 using Bus  -> 1\nTravel from 2 to 4 using Flight -> 1 + 1 = 2\nTravel From 4 to 5 using Bus -> 4\nTotal Cost = 7",
      "output_format": "For each test case, Output the minimum cost to reach from city $1$ to $N$.",
      "samples": [
        {
          "input": "1\n5 3 2\n1 2 3 4 5\n1 1 2 1 7\n",
          "output": "7\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 3,
      "title": "Travel Optimisation",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Find the number of unordered ways, $N$ can be partitioned into $K$ positive integers (i.e $> 0$ ), i.e sum of all $K$ numbers must be $N$.\n\nPrint the answer $mod$  $10^{9}+7 $.\n\nFor eg. $N=7$, $K=3$, then the number of unordered ways are $4$.\nExplanation : { 1, 5, 1 }, { 2, 2, 3 }, { 4, 2, 1 }, and { 3, 1, 3 }.\nNote : { 1, 5, 1 }, { 1, 1, 5 } and { 5, 1, 1 } are treated as same combination, i.e order doesn't matter.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^{6}$\n$1 \\leq N \\leq 5000$\n$1 \\leq K \\leq 5000$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nll dp[5001][5001], mod = 1e9 + 7;\nll rec(int n, int k) {\n    if (n == 0)return 1;\n    if (n < 0 || k == 0)return 0;\n    auto &ans = dp[n][k];\n    if (ans != -1)return ans;\n    ans = rec(n - k, k);\n    (ans += rec(n, k - 1)) %= mod;\n    return ans;\n}\nvoid solve() {\n    memset(dp, -1, sizeof(dp));\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        cout << rec(n - k, k) << endl;\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Editorial code is not passing the Sample cases.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:17:24.111505+00:00"
      },
      "hints": {
        "hint1": "One way to approach this problem is to use dynamic programming. We can define $dp[n][k]$ to be the number of ways to partition the number $n$ into $k$ positive integers. To compute $dp[n][k]$, we can try to add the first positive integer of the partition and recursively compute the number of ways to partition the remaining sum into $k - 1$ positive integers.",
        "hint2": "Here's the key idea: instead of trying to compute $dp[n][k]$ directly, we can compute $dp[n][k]$ in terms of smaller subproblems. Specifically, we can compute $dp[n][k]$ by considering the number of ways to partition n into k positive integers when the first positive integer is $1$, when the first positive integer is $2$, and so on, up to when the first positive integer is $n$.\n\nTo see why this works, consider the case when we fix the first positive integer to be $1$. Then we need to partition the remaining sum $n-1$ into $k-1$ positive integers. This corresponds to the subproblem $dp[n-1][k-1]$. Similarly, if we fix the first positive integer to be $2$, then we need to partition the remaining sum $n-2$ into $k-1$ positive integers, which corresponds to the subproblem $dp[n-2][k-1]$. We can continue this process up to when the first positive integer is $n$, which corresponds to the subproblem $dp[0][k-1]$ (since the remaining sum is 0 in this case).\n\nSo, to compute $dp[n][k]$, we can sum up the values of $dp[n-1][k-1]$, $dp[n-2][k-1]$, ..., $dp[0][k-1]$, which gives us the total number of ways to partition n into k positive integers. Mathematically, we can write:\n\n$dp[n][k] = dp[n-1][k-1] + dp[n-2][k-1] + ... + dp[0][k-1]$\n\nTo compute the values of dp, we can use dynamic programming with a time complexity of O(NK).",
        "solution_approach": "Let us consider {1,3,5}  a way of partitioning $9$, and permutations {3,1,5} , {5,1,3} ... etc are treated as same, so let us work for the sorted partition i.e {1,3,5}.\nwe can think of each number as a stack of **1's**.\nSo, {1,3,5} can be represented as -:\n```\n      1  -> number of 1's = 1 \n      1  -> number of 1's = 1 \n    1 1  -> number of 1's = 2 \n    1 1  -> number of 1's = 2 \n+ 1 1 1  -> number of 1's = 3\n---------\n  1 3 5\n---------\n```\nSo, on each level, the number of 1's is decreasing( not strictly ) as we move up.\nBy inserting the different decreasing numbers of 1's at each level we can generate any sorted permutation partition of the sum.\n$dp[n][k]$ - Number of ways to partition $n$ when inserting $k$ number of **1's** at the current level.\n\nOne can fix the number of ones in final partition:\n\n$0$ ones -- $dp[n - k][k]$ ways,\n\n$1$ one -- $dp[n - k][k - 1]$ ways,\n\n...\n\n$n$ ones -- $dp[n - k][0]$ ways.\n\nSo $dp[n][k] = \\Sigma_{j=0}^{k} dp[n-k][j]$.\n\n**Time Complexity** : $O(N*K)$ for pre-computation, O(1) per test case."
      },
      "id": 921,
      "input_format": "First-line contains $T$ - the number of test cases.\nThe first line of each test case contains two integers - $N$ and $K$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, Output the number of unordered ways, $N$ can be partitioned into $K$ positive integers $ % 10^{9}+7 $.",
      "samples": [
        {
          "input": "3\n1 1\n7 3\n4 5\n",
          "output": "1\n4\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Sum Partition",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an integer N. You have to tell whether the number is prime or not.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ T ≤ 100</p><p>1 ≤ N ≤ 10<sup>7</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n\nint main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    bool is_prime = 1;\n    for (int i = 2; i * i <= n; ++i) {\n      if (n % i == 0) {\n        is_prime = 0;\n      }\n    }\n    if (n == 1 || is_prime == 0) {\n      cout << \"NO\\n\";\n    } else {\n      cout << \"YES\\n\";\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:15:06.168223+00:00"
      },
      "hints": {
        "hint1": "$1$ is neither prime, nor composite.",
        "hint2": "",
        "solution_approach": "If $x$ is a divisor of $N$, then $\\dfrac{N}{x}$ is also a divisor of $N$. Either $x \\leq \\sqrt(N)$ or $\\dfrac{N}{x} \\leq \\sqrt(N)$. So we iterate from $1$ to $\\sqrt(N)$ to check if it is a prime.\n\nTime Complexity per test case: $O(\\sqrt(N))$"
      },
      "id": 323,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer N.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, divisors of 5 are 1 and 5, so it is a prime number.\n\nFor the second test case, divisors of 12 are 1, 2, 3, 4, 6 and 12, so it is not a prime number.\n\nFor the third test case, divisors of 37 are 1 and 37, so it is a prime number.",
      "output_format": "For each test case, print “YES” if the number is prime and “NO” if the number is not prime.",
      "samples": [
        {
          "input": "3\n5\n12\n37\n",
          "output": "YES\nNO\nYES\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Prime Check AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Your task is to maintain an array of <i>n</i> values and efficiently process the following types of queries:</p><ol><li>Increase each value in range [<i>a</i>, <i>b</i>] by <i>x.</i></li><li>Set each value in range [<i>a</i>, <i>b</i>] to <i>x.</i></li><li>Calculate the sum of values in range [<i>a</i>, <i>b</i>].<br>&nbsp;</li></ol>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n</i>, <i>q </i>≤ 2 x 10<sup>5</sup><br>1 ≤ <i>t<sub>i</sub></i>, <i>x </i>≤ 10<sup>6</sup><br>1 ≤ <i>a </i>≤ <i>b </i>≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nstruct node {\n    int l, r;\n    ll sum, lazysum;\n    int lazyset;\n    node(int l = 0, int r = 0, ll sum = 0LL, ll lazysum = 0LL, int lazyset= 0) :\n        l(l), r(r), sum(sum), lazysum(lazysum), lazyset(lazyset) {}\n};\n\nstruct STLazy {\n    vector<node> T;\n    vector<int> A;\n\n    STLazy(int n = N) {\n        T.resize(4 * n);\n        A.resize(n);\n    }\n\n    void pushdown(int node) {\n        if(T[node].lazyset) {\n            T[node].sum = 1LL * (T[node].r - T[node].l + 1) * T[node].lazyset;\n            if(T[node].l < T[node].r) {\n                T[2 * node].lazyset = T[node].lazyset;\n                T[2 * node].lazysum = 0;\n                T[2 * node + 1].lazyset = T[node].lazyset;\n                T[2 * node + 1].lazysum = 0;\n            }\n            T[node].lazyset = 0;\n        }\n        if(T[node].lazysum) {\n            T[node].sum += 1LL * (T[node].r - T[node].l + 1) * T[node].lazysum;\n            if(T[node].l < T[node].r) {\n                T[2 * node].lazysum += T[node].lazysum;\n                T[2 * node + 1].lazysum += T[node].lazysum;\n            }\n            T[node].lazysum = 0;\n        }\n    }\n\n    void pushup(int node) {\n        T[node].sum = T[2 * node].sum + T[2 * node + 1].sum;\n    }\n\n    void build(int node, int start, int end) {\n        T[node].l = start; T[node].r = end;\n        if(start == end) {\n            T[node].sum = A[start];\n            return;\n        }\n        int mid = (start + end) >> 1;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        pushup(node);\n    }\n\n    void update(int node, int start, int end, int l, int r, int val, bool set) {\n        pushdown(node);\n        if(start > r || end < l) {\n            return;\n        }\n        if(start >= l && end <= r) {\n            if(!set) T[node].lazysum += val;\n            else {\n                T[node].lazyset = val;\n                T[node].lazysum = 0;\n            }\n            pushdown(node);\n            return;\n        }\n        int mid = (start + end) >> 1;\n        update(2 * node, start, mid, l, r, val, set);\n        update(2 * node + 1, mid + 1, end, l, r, val, set);\n        pushup(node);\n    }\n\n    ll query(int node, int start, int end, int l, int r) {\n        if(start > r || end < l) {\n            return 0;\n        }\n        pushdown(node);\n        if(start >= l && end <= r) {\n            return T[node].sum;\n        }\n        int mid = (start + end) >> 1;\n        return query(2 * node, start, mid, l, r) + query(2 * node + 1, mid + 1, end, l, r);\n    }\n};\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n, q; cin >> n >> q;\n\n    STLazy T(n);\n    for(int i = 0; i < n; i++) cin >> T.A[i];\n\n    T.build(1, 0, n - 1);\n\n    while(q--) {\n        int t; cin >> t;\n        if(t == 1) {\n            int a, b, x;\n            cin >> a >> b >> x;\n            a--; b--;\n            T.update(1, 0, n - 1, a, b, x, false);\n        }\n        else if(t == 2) {\n            int a, b, x;\n            cin >> a >> b >> x;\n            a--; b--;\n            T.update(1, 0, n - 1, a, b, x, true);\n        }\n        else {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            cout << T.query(1, 0, n - 1, a, b) << \"\\n\";\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:47:13.687919+00:00"
      },
      "hints": {
        "hint1": "<p>Lazy Segment Tree…</p>",
        "hint2": "<p>Lets maintain the following fields in the node of the lazy segment tree.</p><ol><li>sum: total sum of the values in the range of that node</li><li>lazyset: set value that we need to set for all elements in that range</li><li>lazysum: value that we need to add to all elements in that range</li></ol><p>Now think about the merging.</p>",
        "solution_approach": "<p>Lets maintain the following fields in the node of the lazy segment tree.</p><ol><li>sum (S): total sum of the values in the range of that node</li><li>lazyset (LSet): set value that we need to set for all elements in that range</li><li>lazysum (LSum): value that we need to add to all elements in that range</li></ol><p>Suppose for the current node <i>i </i>the node values are (<i>S<sub>i</sub>, LSet<sub>i</sub>, LSum<sub>i</sub></i>). And assuming node <i>j</i> and <i>k</i> are the children nodes with (<i>S<sub>j</sub>, LSet<sub>j</sub>, LSum<sub>j</sub></i>) and (<i>S<sub>k</sub>, LSet<sub>k</sub>, LSum<sub>k</sub></i>) respectively. Then we will do the following lazy steps.</p><ul><li>If<i> LSet<sub>i</sub> &gt; 0, then S<sub>i</sub> = (r<sub>i</sub> - l<sub>i</sub> + 1) * LSet<sub>i</sub>.&nbsp;</i><ul><li><i>LSet<sub>j </sub>= LSet<sub>i</sub> &amp; LSum<sub>j</sub> = 0</i></li><li><i>LSet<sub>k </sub>= LSet<sub>i</sub> &amp; LSum<sub>k</sub> = 0</i></li></ul></li><li>If <i>LSum<sub>i </sub>&gt; 0, then S<sub>i</sub> += (r<sub>i</sub> - l<sub>i</sub> + 1) * LSum<sub>i</sub>.</i><ul><li><i>LSum<sub>j </sub>+= LSum<sub>i</sub></i></li><li><i>LSum<sub>k </sub>+= LSum<sub>i</sub></i></li></ul></li></ul><p><i><strong>Please be careful while handling lazy propagation. Be sure that while updating any node, its lazy and its children's lazy values are properly handled. This is the most common mistake.&nbsp;</strong></i></p>"
      },
      "id": 407,
      "input_format": "The first input line has two integers $n$ and $q$: the array size and the number of queries.\n\nThe next line has $n$ values $t_1, t_2, \\dots, t_n$: the initial contents of the array.\n\nFinally, there are $q$ lines describing the queries. The format of each line is one of the following:  \n- \"1 a b x\"  \n- \"2 a b x\"  \n- \"3 a b\"",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Print the answer to each sum query.</p>",
      "samples": [
        {
          "input": "6 5\n2 3 1 1 5 3\n3 3 5\n1 2 4 2\n3 3 5\n2 2 4 5\n3 3 5",
          "output": "7\n11\n15"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Lazy Queries",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "For the given *n*, consider the array *A* = {1, 2, …, *n*}. There exist *n*! unique permutations of the array. When we list all these *n*! permutations in lexicographical order, your task is to find the *k*th permutation in that list.",
      "complete_approach": "",
      "constraints": "1 ≤ *n* ≤ 10<sup>5</sup>  \n1 ≤ *k* ≤ min(*n*! , 10<sup>9</sup>)",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define IOS                       \\\n    ios_base::sync_with_stdio(0); \\\n    cin.tie(0);                   \\\n    cout.tie(0);\n\nvoid func(int k, vector<int> &arr)\n{\n    int n = (int)arr.size();\n    k--;\n    vector<int> ans;\n    int fact = 1;\n    for (int i = 1; i < n; i++)\n    {\n        fact = i * fact;\n    }\n    while (1)\n    {\n        ans.push_back(arr[k / fact]);\n        arr.erase(arr.begin() + k / fact);\n        if ((int)arr.size() == 0)\n            break;\n        k %= fact;\n        fact /= (int)arr.size();\n    }\n    for (auto i : ans)\n    {\n        cout << i << \" \";\n    }\n    cout << \"\\n\";\n}\n\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    if (n <= 13)\n    {\n        vector<int> arr;\n        for (int i = 1; i <= n; i++)\n        {\n            arr.push_back(i);\n        }\n        func(k, arr);\n    }\n    else\n    {\n        vector<int> arr;\n        for (int i = 1; i < n - 12; i++)\n        {\n            cout << i << \" \";\n        }\n        for (int i = n - 12; i <= n; i++)\n        {\n            arr.push_back(i);\n        }\n        func(k, arr);\n    }\n}\n\nsigned main()\n{\n    IOS;\n    solve();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:27:04.342796+00:00"
      },
      "hints": {
        "hint1": "<p>Observe that 13! &gt; 10<sup>9</sup>.</p>",
        "hint2": "<p>At max, the last 13 numbers are only important. Remaining <i>n</i> - 13 numbers will remain the same in the answer permutation.</p>",
        "solution_approach": "<p>Let a = {1, 2, …, <i>n</i>}. See 13! &gt; 10<sup>9</sup>.&nbsp;</p><p>At max, the last 13 numbers are important when <i>n</i> &gt; 13, because only they're permutating in the answer array, and remaining <i>n</i> - 13 numbers will remain same. If <i>n </i>≤ 13, then the whole array can get permutated.</p><p>Now do iteratively. Find out the farthest index from the last, that has to be changed. Suppose index <i>i </i>needs to change, then we've to choose <i><strong>ceil(k / (n - i)!)</strong></i> th smallest number from a[<i>i</i>] to a[<i>n</i> - 1].</p><p>How the expression in bold is derived? You can observe this when you try to simulate the process on your pen and paper. Just think about it.</p><p>And go on doing the same for other indices from <i>i</i> + 1 to <i>n</i> - 1.</p><p>See editorial code for more clear understanding.</p>"
      },
      "id": 477,
      "input_format": "The first line contains two space-separated integers $n$ and $k$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print $n$ space-separated integers, denoting the $k$th permutation.",
      "samples": [
        {
          "input": "3 4",
          "output": "2 3 1"
        },
        {
          "input": "10 3",
          "output": "1 2 3 4 5 6 7 9 8 10"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Kth Permutation - hard version",
      "video_editorial_id": 8210
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Given an array <i>A</i> of size <i>N</i>, you have to find the longest sub-array of such that the sum of all elements in the sub-array is divisible by <i>K.</i></span></p>",
      "complete_approach": "",
      "constraints": "<p><i>1 ≤ N ≤ 2 x 10<sup>5</sup></i><br><i>1 ≤ K ≤ 2 x 10<sup>5</sup></i><br><i>-10<sup>9</sup> ≤ A[i] ≤ 10<sup>9</sup></i><br>&nbsp;</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    ll n, k;\n    cin >> n >> k;\n\n    ll a[n + 1], sum = 0, first_idx[k], ans = 0;\n    \n    memset(first_idx, -1, sizeof(first_idx));\n    \n    for (int i = 0; i < n; i++)\n        cin >> a[i + 1];\n    \n    first_idx[sum] = 0;\n    \n    for (int i = 1; i <= n; i++)\n    {\n        (sum += a[i]) %= k;\n        sum = (sum + k) % k;\n        \n        if (first_idx[sum] == -1)\n            first_idx[sum] = i;\n        else\n            ans = max(ans, i - first_idx[sum]);\n    }\n    \n    cout << ans << '\\n';\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:18:50.290229+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Maintain prefix sums modulo <i>K</i>.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Store the first index for every modulo value.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Maintain the prefix sum modulo <i>K</i> for every index and store the index where every modulo sum value first occurs. For every index we check if the current modulo value has been encountered before. If we have seen this value before we update the answer by the length of this segment else we update the first seen index of the current value.</span></p>"
      },
      "id": 596,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line of each test case contains two integers <i>N</i> and <i>K</i>.</span><br><span style=\"background-color:transparent;color:#000000;\">The second line contains <i>N</i> integers - the elements of the array <i>A</i>.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">In the first test case the sum of the segment [7 6 1 4] is 18 which is divisible by 3 and it is the longest segment with sum divisible by 3.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the length of the longest sub-array satisfying the given condition in a new line.</span></p>",
      "samples": [
        {
          "input": "6 3\n2 7 6 1 4 5",
          "output": "4"
        },
        {
          "input": "14 10\n10 16 8 13 19 16 2 2 12 6 4 15 13 2",
          "output": "11"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "KSUM",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Given a grid of size n*m with lowercase alphabets, you need to find the number of paths from (1, 1) to (n, m) such that they are palindromic. You are allowed to move from (x, y) to (x+1, y) and (x, y) to (x, y+1).</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ n, m ≤ 500</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\n \nconst int mod = 1e9 + 7;\n \nint dp[505][505][2];\nstring s[505];\n \nint check(int x1, int y1, int x2, int y2) {\n    if(x1 > x2 || y1 > y2) return 0;\n    if(s[x1][y1] != s[x2][y2]) return 0;\n \n    return dp[x1][x2][(x1+y1)%2];\n}\n \nint solve(int x1, int y1, int x2, int y2) {\n    if(x1 > x2 || y1 > y2) return 0;\n    if(s[x1][y1] != s[x2][y2]) return 0;\n \n    int ans = 0;\n    if(((x1==x2) && ((y1 == y2) || (y1 == y2-1))) || ((x1 == x2 - 1) && (y1 == y2))) {\n        ans = 1;\n    }\n    else {\n        ans = (ans + check(x1+1, y1, x2-1,y2))%mod;\n        ans = (ans + check(x1, y1+1, x2-1,y2))%mod;\n        ans = (ans + check(x1+1, y1, x2,y2-1))%mod;\n        ans = (ans + check(x1, y1+1, x2,y2-1))%mod;\n    }\n    return dp[x1][x2][(x1+y1)%2] = ans;\n}\n \nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < n; ++i) {\n            cin >> s[i];\n        }\n        int d = (n + m)/2;\n        while(d--) {\n            for (int x1 = 0, y1 = d; x1 < n; ++x1, --y1) {\n                if(y1 >= 0 && y1 < m) {\n                    for (int x2 = n-1; x2 >= 0; --x2) {\n                        int y2 = (n - 1 + m - 1) - x2 - d;\n                        if(y2 >= 0 && y2 < m) {\n                            solve(x1, y1, x2, y2);\n                        }\n                    }\n                }\n            }\n        }\n        cout << check(0, 0, n-1, m-1) << \"\\n\";\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:29:24.323333+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">Palindromic paths read the same forwards and backwards. So for any two pairs of cells, they should be at equal distance from top-left and bottom-right cell respectively and have the same character.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">Make a function f(x1, y1, x2, y2) which gives the number of paths from (x1, y1) to (x2, y2). If any three variables from x1, y1, x2, y2 are known, the fourth one can be found since the distance of the points from top-left and bottom-right cell is the same.</span></p>",
        "solution_approach": "<p>If the value of the cell at (x1, y1) and (x2, y2) is the same, consider the next move, it can be right and down for (x1, y1) and left and up for (x2, y2). The space complexity for this solution would be O(n^3), this will result in MLE, the space complexity can be reduced to O(n^2) since the answer for a particular row is only dependent on the previous row.</p><p>Time Complexity per test case: O(n3)</p>"
      },
      "id": 500,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains two space-separated integers n, m - the size of the grid.</span></p><p><span style=\"background-color:transparent;color:#000000;\">Each of the following n lines contains a string s - the description of that row. (lowercase characters)</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the number of palindromic paths from (1, 1) to (n, m). Since the answer can be large, print the answer modulo 10<sup>9</sup> + 7.</span></p>",
      "samples": [
        {
          "input": "10 10\naaaaaaaaaa\naaaaaaaaaa\naaaaaaaaaa\naaaaaaaaaa\naaaaaaaaaa\naaaaaaaaaa\naaaaaaaaaa\naaaaaaaaaa\naaaaaaaaaa\naaaaaaaaaa",
          "output": "48620"
        },
        {
          "input": "5 3\naba\naba\nccc\nbaa\nbaa",
          "output": "1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Palindromic Paths",
      "video_editorial_id": 8215
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "There are $n$ cities and $m$ roads. The capital is located at $1$. Your task is to determine the length of the shortest route from the capital to every city.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n </i>≤ 10<sup>5</sup><br>1 ≤ <i>m </i>≤ 2 x 10<sup>5</sup><br>1 ≤ <i>a</i>, <i>b </i>≤ <i>n</i><br>1 ≤ <i>c </i>≤ 10<sup>9</sup></p>",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nvector<vector<pair<int, int>>> g;\nvector<bool> vis;\nvector<int> dis;\nint n, m;\n\nclass comp{\n    public:\n    bool operator()(pair<int, int> p1, pair<int, int> p2){\n        return p1.second > p2.second;\n    }\n};\n\n\nvoid dijkstra(){\n    dis[1] = 0;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, comp> pq;\n    pq.push({1, 0});\n\n    while(!pq.empty()){\n        auto val = pq.top();\n        int node = val.first;\n        int curWeight = val.second;\n\n        pq.pop();\n        if(vis[node]) continue;\n        vis[node] = true;\n\n        for(auto neighNode : g[node]){\n            int neigh = neighNode.first;\n            int weight = neighNode.second;\n            if(dis[neigh] > dis[node] + weight){\n                dis[neigh] = dis[node] + weight;\n                pq.push(make_pair(neigh, dis[neigh]));\n            }\n        }\n    }\n}\n\nvoid solve(){\n    cin >> n >> m;\n    g.assign(n+1, vector<pair<int, int>>());\n    vis.assign(n+1, false);\n    dis.assign(n+1, 1e18);\n    for(int i=0; i<m; i++){\n        int a, b, c; cin >> a >> b >> c;\n        g[a].push_back({b, c});\n    }\n    dijkstra();\n\n    for(int i=1; i<=n; i++) cout << dis[i] << \" \";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    //int _t; cin >> _t; while(_t--)\n    solve();\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:19:27.005843+00:00"
      },
      "hints": {
        "hint1": "This problem requires finding the shortest path from the capital (vertex 1) to every other vertex in a graph with weighted edges.",
        "hint2": "This problem can be solved using Dijkstra's algorithm. Dijkstra's algorithm is a greedy algorithm that finds the shortest path between nodes in a weighted graph.",
        "solution_approach": "1. Initialize an array of distances called dist, with the distance to the starting vertex set to 0 and all other distances set to infinity.\n\n2. Create a priority queue called pq to store vertices and their distances. Insert the starting vertex with distance 0 into the priority queue.\n\n3. While the priority queue is not empty, remove the vertex with the smallest distance from the queue.\n\n4. For each neighbor of the removed vertex, calculate the tentative distance to that neighbor by adding the distance to the removed vertex and the weight of the edge connecting them.\n\n5. If the tentative distance is less than the current distance stored in the dist array for that neighbor, update the dist array with the new distance and insert the neighbor into the priority queue with its updated distance.\n\n6. Repeat steps 3-5 until all vertices have been visited or the destination vertex has been removed from the queue.\n\n7. The shortest path to any vertex from the starting vertex is the distance stored in the dist array for that vertex.\n\nDijkstra's algorithm guarantees finding the shortest path in a graph with non-negative edge weights. The algorithm works by maintaining a set of visited vertices and a set of unvisited vertices, and at each iteration, it selects the unvisited vertex with the smallest tentative distance and adds it to the visited set. The algorithm then relaxes all the edges of the selected vertex, updating the tentative distances of its neighbors if a shorter path is found.\n\nThe priority queue is used to efficiently retrieve the vertex with the smallest tentative distance. By using a priority queue, we avoid the need to search through the entire set of unvisited vertices for the vertex with the smallest tentative distance, which would result in a time complexity of $O(V^2)$. Instead, the priority queue provides a faster time complexity of $O(E \\log V)$ for processing all the edges and vertices in the graph, where E is the number of edges and V is the number of vertices."
      },
      "id": 207,
      "input_format": "The first input line has two integers $n$ and $m$: the number of cities and road connections. The cities are numbered $1$, $2$, …, $n$, and city $1$ is Capital.\n\nAfter that, there are $m$ lines describing the roads. Each line has three integers $a$, $b$, and $c$: a road begins at city $a$, ends at city $b$, and its length is $c$. Each road is a one-way road.\n\nYou can assume that it is possible to travel from Capital to all other cities.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print $n$ integers: the shortest route lengths from Capital to cities $1$, $2$, …, $n$.",
      "samples": [
        {
          "input": "3 4\n1 2 6\n1 3 2\n3 2 3\n1 3 4",
          "output": "0 5 2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Shortest Path I",
      "video_editorial_id": 10669
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Implement a data structure that supports appending a value to an integer sequence, adding or multiplying a given value to all elements present in the sequence and displaying the value present at any index of the sequence.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ val, inc, m ≤ 100</p><p>0 ≤ idx ≤ 10<sup>5</sup></p><p>At most 10<sup>5</sup> calls are made in total to <i>append</i>, <i>add</i>, <i>mult</i> and <i>get.</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass AddMul\n{\npublic:\n    long long i, m, MOD;\n    vector<long long> v;\n\n    AddMul()\n    {\n        i = 0, m = 1, MOD = 1e9 + 7;\n    }\n\n    long long power(long long a, long long b)\n    {\n        long long res = 1;\n        a = a % MOD;\n        while (b > 0)\n        {\n            if (b & 1)\n            {\n                res = (res * a) % MOD;\n                b--;\n            }\n            a = (a * a) % MOD;\n            b >>= 1;\n        }\n        return res;\n    }\n\n    long long inverse(long long x)\n    {\n        return power(x, MOD - 2);\n    }\n\n    void append(long long val)\n    {\n        (val += MOD - i) %= MOD;\n        (val *= inverse(m)) %= MOD;\n        v.push_back(val);\n    }\n\n    void add(long long inc)\n    {\n        (i += inc) %= MOD;\n    }\n\n    void mult(long long mul)\n    {\n        (m *= mul) %= MOD;\n        (i *= mul) %= MOD;\n    }\n\n    int get(int idx)\n    {\n        if (idx >= v.size())\n            return -1;\n        return (v[idx] * m % MOD + i) % MOD;\n    }\n};\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int q;\n    cin >> q;\n    \n    AddMul *obj = new AddMul();\n    \n    for (int i = 0; i < q; i++)\n    {\n        string op;\n        cin >> op;\n        \n        if (op == \"append\")\n        {\n            int val;\n            cin >> val;\n            obj->append(val);\n        }\n        else if (op == \"add\")\n        {\n            int inc;\n            cin >> inc;\n            obj->add(inc);\n        }\n        else if (op == \"mult\")\n        {\n            int mul;\n            cin >> mul;\n            obj->mult(mul);\n        }\n        else\n        {\n            int idx;\n            cin >> idx;\n            cout << obj->get(idx) << '\\n';\n        }\n    }\n    \n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:14:12.622739+00:00"
      },
      "hints": {
        "hint1": "Maintain 2 variables i and m which store the total to be added and multiplied for all the elements in the sequence.",
        "hint2": "<p>Each element in the array can be represented as <i>a[i] = a[i](initial) *m + i.</i></p>\n\n\n\n\n",
        "solution_approach": "<p>When a number is added to all the elements increase <i>i </i>by the corresponding value.<br>When a number is multiplied to all the elements, <i>m = m*mul</i> and <i>i = i*mul.</i><br>When a number <i>val</i> is appended to the sequence, we can update the values of all the other elements for the current values of <i>i</i> and <i>m</i>. But this will exceed the time limit. So we append a value <i>x</i> to sequence such that <i>x*m + i = val.</i> In this way we can avoid updating all the values and not have to reset <i>i</i> and <i>m.</i> Since we are finding the answer modulo 10<sup>9</sup>+7, you can find the inverse using Fermat's Little Theorem when dividing.</p>"
      },
      "id": 644,
      "input_format": "Implement the `AddMul` class:\n\n- `AddMul()`: Initializes the object with an empty sequence.\n- `void append(val)`: Appends an integer `val` to the end of the sequence.\n- `void add(inc)`: Increments all existing values in the sequence by an integer `inc`.\n- `void mult(mul)`: Multiplies all existing values in the sequence by an integer `mul`.\n- `int get(idx)`: Gets the current value at index `idx` (0-indexed) of the sequence **modulo** $10^9 + 7$. If the index is greater or equal to the length of the sequence, return `-1`.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>The sequence after the operations:</p><pre><code class=\"language-plaintext\">[2]\n[2+3] -&gt; [5]\n[5, 7]\n[5*2, 7*2] -&gt; [10, 14]\nA[0] = 10\n[10+3, 14+3] -&gt; [13, 17]\n[13, 17, 10]\n[13*2, 17*2, 10*2] -&gt; [26, 34, 20]\nA[0] = 26\nA[1] = 34\nA[2] = 20</code></pre>",
      "output_format": "For every time the get function is called return the value present at the given index.",
      "samples": [
        {
          "input": "11\nappend 2\nadd 3\nappend 7\nmult 2\nget 0\nadd 3\nappend 10\nmult 2\nget 0\nget 1\nget 2",
          "output": "10\n26\n34\n20"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nclass AddMul\n{\npublic:\n    \n    AddMul()\n    {\n        \n    }\n\n    void append(long long val)\n    {\n        \n    }\n\n    void add(long long inc)\n    {\n        \n    }\n\n    void mult(long long mul)\n    {\n        \n    }\n\n    int get(int idx)\n    {\n        \n    }\n};\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int q;\n    cin >> q;\n    \n    AddMul *obj = new AddMul();\n    \n    for (int i = 0; i < q; i++)\n    {\n        string op;\n        cin >> op;\n        \n        if (op == \"append\")\n        {\n            int val;\n            cin >> val;\n            obj->append(val);\n        }\n        else if (op == \"add\")\n        {\n            int inc;\n            cin >> inc;\n            obj->add(inc);\n        }\n        else if (op == \"mult\")\n        {\n            int mul;\n            cin >> mul;\n            obj->mult(mul);\n        }\n        else\n        {\n            int idx;\n            cin >> idx;\n            cout << obj->get(idx) << '\\n';\n        }\n    }\n    \n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "ADDMUL",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You need to answer <strong>t</strong> test cases. In each case, your program should take in a string <strong>s</strong> and convert it into an integer. If the string is not valid print ‘<strong>Invalid</strong>’. Do not use built-in functions.</span></p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-plaintext\">1 &lt;= t &lt;= 1000\n1 &lt;= |s| &lt;= 18\n|s| = length of the string</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Response\n{\n    bool isValid;\n    long long int integer;\n\n    Response() : isValid(true), integer(0) {}\n    Response(bool isValid, long long int integer) : isValid(isValid), integer(integer){};\n};\n\nResponse STOI(string s)\n{\n    int n = s.length();\n    int f = 0;   // to show that the string is invalid\n    int neg = 0; // to show that the integer is negative\n    long long int ans = 0;\n    int pos = 0;\n\n    Response response;\n\n    if (s[0] == '-')\n        neg = 1;\n    if (s[0] == '+')\n        pos = 1;\n    for (int i = 0; i < n; i++)\n    {\n        if (neg && i == 0)\n            continue;\n        if (pos && i == 0)\n            continue;\n        ans = ans * 10 + (s[i] - '0');\n        if (s[i] < '0' || s[i] > '9')\n        {\n            f = 1;\n            break;\n        }\n    }\n    if (f || (neg && n == 1) || (pos && n == 1))\n    {\n        response.isValid = false;\n    }\n    else\n    {\n        if (neg)\n            ans = ans * -1;\n        response.isValid = true;\n        response.integer = ans;\n    }\n    return response;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int test_cases;\n    cin >> test_cases;\n\n    while (test_cases--)\n    {\n        string s;\n        cin >> s;\n\n        Response response = STOI(s);\n\n        if (!response.isValid)\n            cout << \"Invalid\\n\";\n        else\n            cout << response.integer << \"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:43:27.739414+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">How to find a number if we know the digits at each position?</span></p>",
        "hint2": "",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">We can convert the string into an integer by traversing the string and adding digits one by one to the answer.</span><br><span style=\"background-color:transparent;color:#000000;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;answer = answer*10 + (s[i]-’0’);</span><br><span style=\"background-color:transparent;color:#000000;\">The length of the strings can go up to 18 so we need to use 64-bit integers.</span></p><p><span style=\"background-color:transparent;color:#000000;\">We need to handle few edge cases.</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">The first character of the string can be ‘-’ which denotes that it is a negative integer.</span></li><li><span style=\"background-color:transparent;color:#000000;\">The string cannot have anything other than digits at all positions.</span></li><li><span style=\"background-color:transparent;color:#000000;\">The first character of the string can be ‘+’.</span></li></ol><p><span style=\"background-color:transparent;color:#000000;\">If the string has anything other than digits we print <strong>‘Invalid’</strong>.</span></p>"
      },
      "id": 604,
      "input_format": "<p><span style=\"background-color:transparent;color:#000000;\">The first line contains a single integer <strong>t</strong> denoting the number of test cases. Then <strong>t </strong>lines follow.</span><br><span style=\"background-color:transparent;color:#000000;\">Each line contains a string <strong>s</strong> which you need to convert into an integer or report that the string is invalid.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">In the first two cases, the string is converted into the corresponding integer. Note that the integer can be <strong>negative</strong>.</span><br><span style=\"background-color:transparent;color:#000000;\">The third test case is not a valid string so we print <strong>Invalid</strong>.</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">Print the integer or print <strong>‘Invalid’</strong>.</span></p>",
      "samples": [
        {
          "input": "4\n745612\n-12\n+13\n524a2",
          "output": "745612\n-12\n13\nInvalid"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Response\n{\n    bool isValid;\n    long long int integer;\n\n    Response() : isValid(true), integer(0) {}\n    Response(bool isValid, long long int integer) : isValid(isValid), integer(integer){};\n};\n</fix>\n\nResponse STOI(string s)\n{\n    // Complete the function\n}\n\n<fix>\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int test_cases;\n    cin >> test_cases;\n\n    while (test_cases--)\n    {\n        string s;\n        cin >> s;\n\n        Response response = STOI(s);\n\n        if (!response.isValid)\n            cout << \"Invalid\\n\";\n        else\n            cout << response.integer << \"\\n\";\n    }\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "STOI",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given an array of <i>N</i> integers and an integer <i>D</i>. Consider all subarray with length <i>D</i>, the penalty of the subarray is the number of distinct elements present in the subarray. Find a subarray of length <i>D</i> with minimum penalty. Print the minimum penalty.</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int testcases;\n    cin >> testcases;\n    int freq[1000001] = {0};\n    while (testcases--)\n    {\n        int n, k;\n        cin >> n >> k;\n        int arr[n];\n        for (int i = 0; i < n; i++)\n            cin >> arr[i];\n        int ans = k;\n        int start = 0;\n        int current = 0;\n        int currSum = 0;\n        while (current < n)\n        {\n            if (freq[arr[current]] == 0)\n                currSum++;\n            freq[arr[current]]++;\n            if (current >= k)\n            {\n                freq[arr[current - k]]--;\n                if (freq[arr[current - k]] == 0)\n                    currSum--;\n            }\n            if (current >= k - 1)\n                ans = min(ans, currSum);\n            current++;\n        }\n        for (int i = n - k; i < n; i++) // only the frequency of last d element is set, so for next testcase making it zero.\n            freq[arr[i]]--;\n        cout << ans << \"\\n\";\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:44:40.473722+00:00"
      },
      "hints": {
        "hint1": "Use the sliding window technique to consider all subarray of length $D$. Suppose you have an answer for index $1$ to index $D$. Then next step you will remove the element at index $1$ and add the element at index $D+1$ to get the subarray of length $D$ starting at $1$. Next step remove the element at index $2$ and add the element at index $D+2$. Think about how you will calculate the distinct number.",
        "hint2": "Just keep a frequency array, when you add a number increase the frequency, when you delete a number decrease the frequency. Suppose the number you are adding has $frequency = 0$, which means it is added the first time, so you should increase your count of the distinct element. Similarly after deleting a number if it's $frequency = 0$, then you should decrease the count of your distinct element.",
        "solution_approach": "Try to do it in $O(n)$. For clearing the frequency array for each test case, notice that only the frequency of the number present in the array can change. So iterate over the array and initialize the frequency of number present int the $array = 0$. So overall you will do $O(n)$ transition.\n\nWhenever possible use a frequency array instead of a map . Here we can use frequency array because each element is lesser than $10^6$ . By this we reduced the time complexity of searching distinct elements from $O(logn)$ to $O(1)$.\n\nAlso its better to use a global frequency array instead of every time defining a vector of size $O(10^6)$ becasue that would require $O(T*10^6)$ time complexity. Rather define a global array of size $10^6$ and every time just use it."
      },
      "id": 64,
      "input_format": "<p>The first line contains <i>T</i>, the number of test cases <i>(1&lt;=T&lt;=10000)</i>.</p><p>The first line contains two space-separated integers <i>N, D</i> where <i>1&lt;=N&lt;=10^6, 1&lt;=D&lt;=N.</i></p><p>Next line contains <i>N</i> space-separated integers (0&lt;=Ai&lt;=1e6).</p><p>The Sum of <i>N</i> across all test cases ≤ 5*10^6.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For first test case all the subarray with length = 3 and minimum element -&gt;<br>0,1,1 - 2<br>1,1,2 - 2<br>1,2,2 - 2<br>2,2,2 - 1<br>So minimum penalty = 1</p>",
      "output_format": "<p>For each test case print the minimum penalty in a newline.</p>",
      "samples": [
        {
          "input": "5\n6 3\n0 1 1 2 2 2\n5 3\n1 0 1 2 3\n5 5\n1 1 2 3 4\n5 1\n1 2 3 4 5\n7 3\n1 2 1 2 3 4 2",
          "output": "1\n2\n4\n1\n2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Minimum Penalty",
      "video_editorial_id": 10664
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are going back to KGP and want to travel from Delhi to Kolkata by plane. You would like to find answers to the following questions:\n\n$1.$ What is the minimum price of such a route?\n$2.$ How many minimum-price routes are there? (modulo $10^{9}+7$)\n$3.$ What is the minimum number of flights in a minimum-price route?\n$4.$ What is the maximum number of flights in a minimum-price route?",
      "complete_approach": "",
      "constraints": "$ 1 ≤ n ≤ 10^{5}$\n$ 0 ≤ m ≤ 2⋅10^{5}$\n$ 1 ≤ a , b ≤ n$\n$ 1 ≤ c ≤ 10^{9}$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll int64_t\r\n#define endl '\\n'\r\n\r\n\r\nconst ll MOD = 1e9 + 7;\r\nint n, m;\r\nvector<vector<array<int, 2>>> adj;\r\nvector<ll> dist, cnt, d, mnd, mxd;\r\n\r\n//State(node):{ min price,node,cnt of min price routes, min lenght path, max lenght path for min price }\r\n\r\nvoid dijktra(int src) {\r\n\tdist.assign(n + 1, 1e18);\r\n\tcnt.assign(n + 1, 0);\r\n\td.assign(n + 1, 0);\r\n\tmnd.assign(n + 1, 0);\r\n\tmxd.assign(n + 1, 0);\r\n\tdist[src] = 0;\r\n\tcnt[src] = 1;\r\n\tpriority_queue<array<ll, 2>, vector<array<ll, 2>>, greater<array<ll, 2>>> pq;\r\n\tpq.push({0, src});\r\n\twhile (!pq.empty()) {\r\n\t\tauto x = pq.top();\r\n\t\tpq.pop();\r\n\t\tint u = x[1];\r\n\t\tif (x[0] > dist[u])continue;\r\n\t\tfor (auto y : adj[u]) {\r\n\t\t\tint v = y[0], w = y[1];\r\n\t\t\tif (dist[v] > dist[u] + w) {\r\n\t\t\t\tdist[v] = dist[u] + w;\r\n\t\t\t\tpq.push({dist[v], v});\r\n\t\t\t\tcnt[v] = cnt[u];\r\n\t\t\t\tmnd[v] = mnd[u] + 1;\r\n\t\t\t\tmxd[v] = mxd[u] + 1;\r\n\t\t\t}\r\n\t\t\telse if (dist[v] == dist[u] + w) {\r\n\t\t\t\t(cnt[v] += cnt[u]) %= MOD;\r\n\t\t\t\tmnd[v] = min({mnd[v], mnd[u] + 1, mxd[u] + 1});\r\n\t\t\t\tmxd[v] = max({mxd[v], mnd[u] + 1, mxd[u] + 1});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nvoid solve() {\r\n\tcin >> n >> m;\r\n\tint u, v, w;\r\n\tadj.assign(n + 1, vector<array<int, 2>>());\r\n\tfor (int i = 0; i < m; i++) {\r\n\t\tcin >> u >> v >> w;\r\n\t\tadj[u].push_back({v, w});\r\n\t}\r\n\tdijktra(1);\r\n\tif (dist[n] == 1e18)cout << -1 << endl;\r\n\telse cout << dist[n] << \" \" << cnt[n] << \" \" << mnd[n] << \" \" << mxd[n] << endl;\r\n}\r\nint main() {\r\n\tios_base :: sync_with_stdio(0);\r\n\tcin.tie(nullptr); cout.tie(nullptr);\r\n\r\n#ifdef Mastermind_\r\n\tfreopen(\"input.txt\", \"r\", stdin); \\\r\n\tfreopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n\tint t = 1;\r\n\t// int i = 1;\r\n\t// cin >> t;\r\n\twhile (t--) {\r\n\t\t// cout << \"Case #\" << i << \": \";\r\n\t\tsolve();\r\n\t\t// i++;\r\n\t}\r\n\treturn 0;\r\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:23:10.830197+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We can run Dijkstra keeping track of\n\nthe distance: $\\texttt{dist}[]$\nthe number of ways with the minimum distance: $\\texttt{num}[]$\nthe minimum flights with the minimum distance: $\\texttt{minf}[]$, and\nthe maximum flights with the minimum distance: $\\texttt{maxf}[]$.\n\n\nFor every node, $v$, we take into consideration all of its neighbors, $u$. If we\ncan reach $u$ in a shorter distance than its current minimum, we update the\ndistance and reset $\\texttt{num}[u]$, $\\texttt{minf}[u]$, and $\\texttt{maxf}[u]$.\n\nWe also have to take into\nconsideration if we can reach $u$ in an equivalent distance. If so, we update:\n\n- $\\texttt{num}[u] = \\texttt{num}[v] + \\texttt{num}[u]$\n\n- $\\texttt{minf}[u] = \\min(\\texttt{minf}[u], \\texttt{minf}[v] + 1)$\n\n- $\\texttt{maxf}[u] = \\max(\\texttt{maxf}[u], \\texttt{maxf}[v] + 1)$\n\nTime Complexity: $\\mathcal{O}((N + M)*\\log N)$"
      },
      "id": 885,
      "input_format": "The first input line contains two integers $n$ and $m$: the number of cities and the number of flights. The cities are numbered $1,2,…,n$. City $1$ is Delhi, and city $n$ is Kolkata.\n\nAfter this, there are $m$ lines describing the flights. Each line has three integers $a$, $b$, and $c$: there is a flight from city $a$ to city $b$ with price $c$. All flights are one-way flights.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Print four integers according to the problem statement in a single line. If there is no route from Delhi to Kolkata, then print $-1$.",
      "samples": [
        {
          "input": "4 5\n1 4 5\n1 2 4\n2 4 5\n1 3 2\n3 4 3\n",
          "output": "5 2 1 2\n"
        },
        {
          "input": "5 5\n1 2 4\n3 4 6\n2 1 3\n3 5 10\n5 4 6\n",
          "output": "-1\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Back to KGP",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "In the standard *Kadane* problem, you are given an array of integers, and you have to find one or more consecutive elements in this array where their sum is the maximum possible sum or in sort the *Maximum Subarray Sum*.\n\nBut in this problem, you are given $n$ small arrays, and you will create one big array from the concatenation of one or more instances of the small arrays (each small array could occur more than once). The big array will be given as an array of indexes ($1$-based) of the small arrays, and the concatenation should be done in the same order as in this array. Then you should apply the standard problem mentioned above on the resulting big array.\n\nFor example let's suppose that the small arrays are $(1, 6, -2)$, $(3, 3)$ and $(-5, 1)$. And the indexes in the big array are $(2, 3, 1, 3)$. So the actual values in the big array after formatting it as the concatenation of the small arrays will be $(3, 3, -5, 1, 1, 6, -2, -5, 1)$. In this example, the maximum sum is $9$.",
      "complete_approach": "",
      "constraints": "$1$ $\\leq$ $T$ $\\leq$ $100$.\n$1$ $\\leq$ $n$ $\\leq$ $50$.\n$1$ $\\leq$ $m$ $\\leq$ $250000$.\n$1$ $\\leq$ $l$ $\\leq$ $5000$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nvoid solve() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<ll> pref(n + 1), suff(n + 1), sum(n + 1), dp(m + 1), mx(n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint sz;\n\t\tcin >> sz;\n\t\tvector<ll> a(sz);\n\t\tfor (int j = 0; j < sz; j++)cin >> a[j], sum[i] += a[j];\n\t\tll  ans = -1e18, p = 0;\n\t\tfor (int j = 0; j < sz; j++) {\n\t\t\tp = max(p + a[j], a[j]);\n\t\t\tans = max(ans, p);\n\t\t}\n\t\tsuff[i] = p;\n\t\tp = 0;\n\t\tfor (int j = sz - 1; j >= 0; j--) {\n\t\t\tp = max(p + a[j], a[j]);\n\t\t}\n\t\tpref[i] = p;\n\t\tmx[i] = ans;\n\t}\n\tll ans = -1e18, p = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tdp[i] = max(dp[i - 1] + sum[x], suff[x]);\n\t\tans = max({ans, dp[i], dp[i - 1] + pref[x], pref[x], mx[x]});\n\t}\n\tcout << ans << endl;\n}\nint main() {\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n\tfreopen(\"input.txt\", \"r\", stdin); \\\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint t = 1;\n\t// int i = 1;\n\tcin >> t;\n\twhile (t--) {\n\t\t// cout << \"Case #\" << i << \": \";\n\t\tsolve();\n\t\t// i++;\n\t}\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:14:04.939466+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "We can't construct the big array, so we can't apply the standard solution for this problem.\nLet's see first how to solve the standard problem, the following code solves it for a given array arr with length len:\n\n<pre><code class=\"language-cpp\">\nint mx = -(1 << 30);\nint sum = 0;\nfor (int j = 0; j < len; j++) {\n    mx = max(mx, arr[i]); // we need this for the case where all elements in the array are negatives\n    sum += arr[i];\n    if (sum < 0)\n        sum = 0;\n    else\n        mx = max(mx, sum);\n}\n</code></pre>\n\nNow let's solve the big array problem, the first step is to calculate 4 values for each small array:\n1. The total sum of it, let's call it $tot$.\n2. The maximum sum of 0 or more consecutive elements starting from the first element in the array, let's call it $lft$.\n3. The maximum sum of 0 or more consecutive elements ending at the last element in the array, let's call it $rght$.\n4. The maximum sum of 1 or more consecutive elements, let's call it $gen$.\n\nThe final result will be 1 of 2 cases:\n1. The consecutive elements with the maximum sum will start and end inside the same small array.\n2. The consecutive elements with the maximum sum will start and end inside different small arrays.\n\nFor the first case, we can simply pick the maximum gen for all small arrays which exist in the big array.\nFor the second case, we can apply something similar to the standard solution, we will keep a variable called sum, and it's initialized to 0, this will be the maximum sum of 0 or more consecutive elements ending at the last element in the previous small array. Now for each small array, if the maximum possible sum will end in this small array, it will be $sum+lft$ and maximize over this value (make sure this will be for 1 or more elements). And we need to update the sum to be the maximum of the following 3 values:\n1. $sum+tot$ (we will include all elements of this small array to the old sum).\n2. $rght$ (we will take the maximum sum ending at the last element in the current small array).\n3. $0$ (we will not take any elements in sum).\n\n**Time Complexity** : $O(m+\\Sigma {l})$ per test case."
      },
      "id": 908,
      "input_format": "The first line contains $T$ - the number of test cases.\nThe first line of each test case contains two integers $n$ and $m$, $n$ is the number of the small arrays, and $m$ is the number of indexes in the big array.\nThen follow $n$ lines, the $i^{th}$ line starts with one integer $l$ which is the size of the $i^{th}$ array, followed by $l$ integers each one will be greater than or equal $-1000$ and less than or equal $1000$. The last line contains $m$ integers which are the indexes in the big array, and you should concatenate the small arrays in the same order, and each index will be greater than or equal to $1$ and less than or equal to $n$.\n\nThe small arrays are numbered from $1$ to $n$ in the same order as given in the input. Some of the given small arrays may not be used in a big array.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, print one line containing the maximum sum in the big array after formatting it as described above. You must choose at least one element for the sum, i. e. it cannot be empty.",
      "samples": [
        {
          "input": "2\n3 4\n3 1 6 -2\n2 3 3\n2 -5 1\n2 3 1 3\n6 1\n4 0 8 -3 -10\n8 3 -2 -5 10 8 -9 -5 -4\n1 0\n1 -3\n3 -8 5 6\n2 9 6\n1\n",
          "output": "9\n8\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Kadane Twist",
      "video_editorial_id": 8240
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Shubham and Vivek have planned to play $N$ games of Rock-Paper-Scissor. Vivek has already decided upon the sequences of his $N$ moves. He told his sequence to Shubham and challenged him. \n\nGiven a sequence of length $N$ of Vivek’s moves, Help Shubham to find a sequence of moves that give him the maximum number of wins among $N$ games, provided that he can only change his current move w.r.t his previous move at most $K$ times among all $N$ Moves.\n\nOut of all optimal sequences of moves, print the lexicographically smallest one.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 50$\n$1 \\leq N \\leq 1000$\n$0 \\leq K \\leq 1000$\nString $S$ can only have ‘$R$’, ‘$P$’ and, ‘$S$’ characters.",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nint n, k;\nstring s; // PRS\nint dp[1001][1001][3], a[1001];\nint rec(int i, int cnt, int p) {\n    if (i == n)return 0;\n    auto &ans = dp[i][cnt][p];\n    if (ans != -1)return ans;\n    ans = rec(i + 1, cnt, p) + (((p + 1) % 3) == a[i]);\n    for (int j = 0; j < 3; j++) {\n        if (j != p && cnt < k) {\n            ans = max(ans, rec(i + 1, cnt + 1, j) + (((p + 1) % 3) == a[i]));\n        }\n    }\n    return ans;\n}\nvoid solve() {\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'P')a[i] = 0;\n        if (s[i] == 'R')a[i] = 1;\n        if (s[i] == 'S')a[i] = 2;\n    }\n    memset(dp, -1, sizeof(dp));\n    int cnt = 0, p = 0, ans2;\n    int ans = rec(0, 0, 0);\n    if (ans < rec(0, 0, 1))ans = rec(0, 0, 1), p = 1;\n    if (ans < rec(0, 0, 2))ans = rec(0, 0, 2), p = 2;\n    cout << ans << endl;\n    assert(ans > 0);\n    ans2 = ans;\n    string moves;\n    // getting lexicologically smallest.\n    for (int i = 0; i < n; i++) {\n        if (cnt + (p != 0) <= k && ans == rec(i, cnt + (p != 0), 0)) {\n            if (i && p != 0)cnt++;\n            p = 0;\n            moves.push_back('P');\n            if (a[i] == 1)ans--;\n        }\n        else if (cnt + (p != 1) <= k && ans == rec(i, cnt + (p != 1), 1)) {\n            if (i && p != 1)cnt++;\n            p = 1;\n            moves.push_back('R');\n            if (a[i] == 2)ans--;\n        }\n        else if (cnt + (p != 2) <= k && ans == rec(i, cnt + (p != 2), 2)) {\n            if (i && p != 2)cnt++;\n            p = 2;\n            moves.push_back('S');\n            if (a[i] == 0)ans--;\n        }\n        else {\n            assert(false);\n        }\n    }\n    cout << moves << endl;\n\n    // verify.\n    assert(moves.size() == n);\n    assert(ans == 0);\n    char prev = moves[0];\n    int cnts = 0;\n    for (int i = 0; i < n; i++) {\n        if (moves[i] == 'P' && a[i] == 1)ans2--;\n        if (moves[i] == 'R' && a[i] == 2)ans2--;\n        if (moves[i] == 'S' && a[i] == 0)ans2--;\n        if (moves[i] != prev)cnts++;\n        prev = moves[i];\n    }\n    assert(cnts <= k);\n    assert(ans2 == 0);\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:23:27.531148+00:00"
      },
      "hints": {
        "hint1": "Use dynamic programming",
        "hint2": "The solution uses dynamic programming to determine the maximum score that Shubham can achieve and to extract a string representing the optimal sequence of moves that Shubham should make. The dp state dp[level][cnt][choice] represents the maximum score possible if Shubham chooses to move choice in the level'th round, he has cnt changes left, and we are considering rounds from level to N-1. If Shubham chooses to change his move, he can only do so a limited number of times (cnt). Therefore, we decrement cnt when Shubham decides to change his move.",
        "solution_approach": "Transitions can be in the following way:\nLets say the current choice is 2 \ndp[level][cnt][choice] = (if\\_Shubham\\_wins?1:0) + max({rec(level + 1, cnt-1, 1), rec(level + 1, cnt, 2), rec(level + 1, cnt - 1, 3)});\n\nWhenever the choice changes in the next chance we reduce the cnt value by 1 because now we can make one less change.\n\nTime complexity for each test case : O(#states * transitions) = $O(9NK)$"
      },
      "id": 913,
      "input_format": "First-line contains $T$ - the number of test cases.\nFirst line of each test case contains $2$ integers $N$ and $K$.\nSecond-line of each test case contains the string $S$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the maximum number of wins possible, and on the next line, print the lexicographically smallest sequences of moves required for the maximum wins.",
      "samples": [
        {
          "input": "4\n6 2\nRPSSPR\n6 3\nSRRRRR\n6 0\nRPSRPS\n6 1\nPSSPPS\n",
          "output": "4\nPPRRPP\n6\nRPPPPP\n2\nPPPPPP\n4\nRRRSSS\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 5,
      "title": "Rock Paper Scissor",
      "video_editorial_id": 8241
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>There are n light bulbs in a row. Each bulb is either on or off given in input as 1 or 0 respectively.</p><p>In one operation you can select any k consecutive bulbs and flip their switches, that is, if a bulb was off it becomes on and vice versa.</p><p>Find minimum number of operations to turn all the bulbs on. If it's impossible to do so print -1.</p>",
      "complete_approach": "",
      "constraints": "<p>T ≤ 1000</p><p>0 ≤ k ≤ n ≤ 2*10<sup>5</sup></p><p>s<sub>i </sub>= {0,1}</p><p>Sum of n over all test cases is less than 2*10<sup>5</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int t, i, j;\r\n\r\n    cin >> t;\r\n    while (t--)\r\n    {\r\n        int k,n;\r\n        cin>>n>>k;\r\n        vector<int> A(n);\r\n        bool zero=0;\r\n        for(i=0;i<n;i++) \r\n        {\r\n            cin>>A[i];\r\n            if(A[i]==0) zero=1;\r\n        }\r\n\r\n        if(k==0)\r\n        {\r\n            if(zero) cout<<\"-1\\n\";\r\n            else cout<<\"0\\n\";\r\n            continue;\r\n        }\r\n\r\n        vector<bool> change(n + 1, 0);\r\n        int ans = 0;\r\n        bool flip = 0, ok = 1;\r\n\r\n        for (i = 0; i < n; i++)\r\n        {\r\n            flip ^= change[i];\r\n            if ((A[i] ^ flip) == 0)\r\n            {\r\n                if (i + k - 1 < n)\r\n                {\r\n                    ans++;\r\n                    flip ^= 1;\r\n                    change[i + k] = change[i + k] ^ 1;\r\n                }\r\n                else\r\n                    ok = 0;\r\n            }\r\n        }\r\n\r\n        if(!ok) ans=-1;\r\n        cout<<ans<<\"\\n\";\r\n    }\r\n}\r\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:38:21.707509+00:00"
      },
      "hints": {
        "hint1": "If A[0] = 0, there is only one way to flip the switches, i.e. from 0 to K-1.",
        "hint2": "When you are at index i, you need to ensure that all index j (j &lt; i) are equal to 1. So if A[i] = 0, you just need to flip the switches from i to i+K-1.",
        "solution_approach": "\nTraverse through the given array, if you get $A[i] = 1$, flipping the switch here would only increase the answer, so we skip this. If you get $A[i] = 0$, you need to flip the switches from $i$ to $i+K-1$. If $i+K-1$ is outside the given array, then there is no possible way to flip the switches and so the answer is $-1$.\n\nEven flips result in the same configuration and odd flips change it. To flip the switches from $i$ to $i+K-1$ efficiently, we can use the xor properties, since they are similar to flipping the switches. You can flip the current switch, $i$, and the switch $i+K$ and simultaneously maintain another variable which would maintain the xor of the array in the run. When you take xor of this number with $i+K$, the flip would be nullified since it would be done twice.\n\n**Time Complexity per test case:** $O(N)$\n"
      },
      "id": 300,
      "input_format": "<p>First line of input contains T, number of test cases.</p><p>First line of each test case contains n and k.</p><p>Second line contains n integers, i<sup>th </sup>integer s<sub>i</sub> represents the state of the i<sup>th </sup>bulb.</p><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>Perform the operation on the subarrays(1 indexed): [1..2] and [2..3] to get 1 1 1 1 1 .</p>",
      "output_format": "<p>For each testcase if its possible to turn all the bulbs on, print the minimum operations required, else print -1.</p>",
      "samples": [
        {
          "input": "1\n5 1\n0 1 0 1 1",
          "output": "2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Light em up",
      "video_editorial_id": 8181
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given two strings. The task is to find the length of the longest common substring.",
      "complete_approach": "",
      "constraints": "$ 1 \\leq T \\leq 100$\n$ 1 \\leq |s1| \\leq 1000$\n$ 1 \\leq |s2| \\leq 1000$\n$s1$ and $s2$ contains small letters only.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll int64_t\n#define endl '\\n'\n\nstring s1, s2;\nint n, m;\nint dp[1001][1001];\nint rec(int i, int j) {\n    if (i == n || j == m)return 0;\n    auto &ans = dp[i][j];\n    if (ans != -1)return ans;\n    ans = 0;\n    if (s1[i] == s2[j])ans = max(ans, 1 + rec(i + 1, j + 1));\n    rec(i + 1, j), rec(i, j + 1);\n    return ans;\n}\nvoid solve() {\n    cin >> s1 >> s2;\n    n = s1.size(), m = s2.size();\n    memset(dp, -1, sizeof(dp));\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)ans = max(ans, rec(i, j));\n    }\n    cout << ans << endl;\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:23:25.898517+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "The longest common suffix has the following optimal substructure property. \n- If last characters match, then we reduce both lengths by $1$ \n$LCSuff(X, Y, m, n) = LCSuff(X, Y, m-1, n-1) + 1$, if $X[m-1] = Y[n-1]$ \n- If last characters do not match, then result is $0$, i.e., $LCSuff(X, Y, m, n) = 0$ , if $(X[m-1] != Y[n-1])$\n\nNow we consider suffixes of different substrings ending at different indexes. \nThe maximum length Longest Common Suffix is the longest common substring. \n$LCSubStr(X, Y, m, n) = Max(LCSuff(X, Y, i, j))$ where $1 <= i <= m$ and $1 <= j <= n$ \n\n**Time Complexity** : $O(|s1|*|s2|)$"
      },
      "id": 910,
      "input_format": "First-line contains $T$ - the number of test cases.\nEach test case contains two strings $s1$ and $s2$ in a single line.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the length of the longest common substring of the two strings, in a new line.",
      "samples": [
        {
          "input": "3\nabc abc\nalgozenith algo\nalgo zenith\n",
          "output": "3\n4\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Longest Common Substring",
      "video_editorial_id": 10655
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Given a grid of size n*m, you need to find the number of paths from (1, 1) to (n, m). You are allowed to move from (x, y) to (x+1, y) and (x, y) to (x, y+1). The grid may have some blocked cells, represented by 1, and it is not allowed to move to a blocked cell. An empty cell is represented by 0.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ t ≤ 10<sup>5</sup></p><p>1 ≤ n, m ≤ 10<sup>3</sup></p><p>0 ≤ a<sub>ij</sub> ≤ 1</p><p>It is guaranteed that the sum of n*m over all test cases does not exceed 10<sup>6</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\n \nconst int mod = 1e9 + 7;\nint dp[1005][1005];\nbool grid[1005][1005];\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                cin >> grid[i][j];\n                dp[i][j] = 0;\n            }\n        }\n        if(grid[0][0] || grid[n-1][m-1]) {\n            cout << 0 << \"\\n\";\n            continue;\n        }\n        dp[0][0] = 1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if(grid[i][j]) {\n                    continue;\n                }\n                if(i) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][j])%mod;\n                }\n                if(j) {\n                    dp[i][j] = (dp[i][j] + dp[i][j-1])%mod;\n                }\n            }\n        }\n        cout << dp[n-1][m-1] << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:42:01.321987+00:00"
      },
      "hints": {
        "hint1": "<p><span style=\"background-color:transparent;color:#000000;\">The cell (i, j) can only be reached from the cells (i-1, j) and (i, j-1). Since precomputed values are being used, the problem can be solved using dynamic programming.</span></p>",
        "hint2": "<p><span style=\"background-color:transparent;color:#000000;\">If a cell is blocked, it cannot be reached and will not contribute to the final path.</span></p>",
        "solution_approach": "<p><span style=\"background-color:transparent;color:#000000;\">Find the number of paths from (1, 1) to (i, j) using the cells (i-1, j) and (i, j-1). Define dp[i][j] which denotes the number of paths to reach (i, j). The number of paths for arriving at an unblocked cell (i, j) can be given as dp[i][j] = dp[i-1][j] + dp[i][j-1]. If the cell is blocked, dp[i][j] = 0. The base case would be at cell (1, 1), there is only one way to reach it, if it is unblocked. Use the same recurrence for finding dp[n][m].</span></p><p><span style=\"background-color:transparent;color:#000000;\">Time Complexity per test case: O(n*m)</span></p>"
      },
      "id": 492,
      "input_format": "<p>The first line of the input contains one integer t - the number of test cases. Then t test cases follow.</p><p>The first line of each test case contains two space-separated integers n, m - the size of the grid.</p><p>Each of the following n lines contains m space-separated integers, a<sub>ij</sub> - the number at that cell.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, there is only one path, (1, 1) → (2, 1) → (2, 2) → (2, 3).</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, no path can reach (2, 2) since the starting point is blocked.</span></p>",
      "output_format": "<p>For each test case, print the number of paths modulo 10<sup>9</sup> + 7.</p>",
      "samples": [
        {
          "input": "3\n2 3\n0 1 0\n0 0 0\n3 3\n0 0 1\n0 0 0\n0 0 0\n2 2\n1 0\n0 0",
          "output": "1\n5\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Number of Paths in Grid - 1",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You have given an equation of the form &nbsp;<i><strong>(a op1 b op2 c) mod p</strong></i><br><i>op1</i>, <i>op2</i> are operators which can be {+, -, *, /}.<br>Consider the example: <i>(a * b / c) mod p</i>. Here <i>op1 = * and op2 = /</i>.<br>It is guaranteed that <i>(a, p) = (b, p) = (c, p) = 1</i> and <i>p</i> is a prime number.<br>Compute the value of the equation.</p><p><i>Note:&nbsp;</i></p><ol><li>(<i>a, b</i>) = 1, means <i>a</i> and <i>b</i> are coprime numbers.</li><li>Operators follow the same precedence rules as in mathematics.</li></ol>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n#define ll long long\n\nll mod = 1000000007;\n\nll add(ll a, ll b) { return ((a % mod) + (b % mod)) % mod; }\nll sub(ll a, ll b) {\n  ll ans = ((a % mod) - (b % mod)) % mod;\n  ans %= mod;\n  ans = (ans + mod) % mod;\n  return ans;\n}\nll mul(ll a, ll b) { return ((a % mod) * (b % mod)) % mod; }\nll power(ll a, ll b) {\n  ll ans = 1;\n  while (b) {\n    if (b % 2) {\n      ans = ((ans % mod) * (a % mod)) % mod;\n    }\n    a = ((a % mod) * (a % mod)) % mod;\n    b /= 2;\n  }\n  return ans;\n}\nll res(char op, ll a, ll b) {\n  if (op == '+')\n    return add(a, b);\n  else if (op == '-')\n    return sub(a, b);\n  else if (op == '*')\n    return mul(a, b);\n  else\n    return mul(a, power(b, mod - 2));\n}\n\nsigned main() {\n  IOS ll t;\n  cin >> t;\n  ll a, b, c;\n  string s;\n  getline(cin, s);\n  while (t--) {\n    char op1, op2;\n    string s1, s2, s3;\n    cin >> s1 >> op1 >> b >> op2 >> s2 >> s3 >> mod;\n    a = stoi(s1.substr(1));\n    s2.pop_back();\n    c = stoi(s2);\n    ll ans = 0;\n    if ((op1 == '+') || (op1 == '-')) {\n      if ((op2 == '+') || (op2 == '-')) {\n        ans = res(op1, a, b);\n        ans = res(op2, ans, c);\n      } else {\n        ans = res(op2, b, c);\n        ans = res(op1, a, ans);\n      }\n    } else {\n      ans = res(op1, a, b);\n      ans = res(op2, ans, c);\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:38:25.301211+00:00"
      },
      "hints": {
        "hint1": "Parse the string properly, and do the operations correctly. This is the Implementation Problem, with a flavour of modulus maths.",
        "hint2": "",
        "solution_approach": "The given solution is a C++ program that reads input from standard input and prints output to standard output. The input consists of several test cases, each containing an equation of the form (a op1 b op2 c) mod p, where op1 and op2 are operators that can be $+$, $-$, $*$, or $/$. The program reads each equation, evaluates it, and prints the result.\n\nThe program uses several helper functions to perform arithmetic operations modulo mod = $1000000007$. The add, sub, and mul functions perform addition, subtraction, and multiplication modulo mod, respectively. The power function calculates $a^b$ modulo mod using binary exponentiation. The res function takes an operator op and two integers a and b, performs the operation a op b modulo mod, and returns the result.\n\nThe main function reads the input and processes each test case. It reads the values of a, b, c, op1, op2, and mod from the input string, using stoi to convert the strings to integers. It then evaluates the equation by performing the operations in the correct order, depending on the operators op1 and op2. Finally, it prints the result.\n\nIn summary, the program reads an equation of the form (a op1 b op2 c) mod p, evaluates it using modular arithmetic, and prints the result. It uses several helper functions to perform arithmetic operations modulo mod.  \nThe time complexity of the above code is $O(T \\log P)$, where $T$ is the number of test cases and $P$ is the value of mod. The power function, which performs binary exponentiation to calculate $a^b$ modulo mod, has a time complexity of $O(\\log b)$, where $b$ is the exponent. In the main function, the res function is called twice, and each call performs at most one arithmetic operation and one exponentiation. Therefore, the time complexity of each test case is $O(\\log P)$. Since there are $T$ test cases, the overall time complexity is $O(T \\log P)$."
      },
      "id": 73,
      "input_format": "<p>The first line contains <i>T</i> (1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>T</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 100000), the number of test cases.<br>Each of the next <i>T</i> lines contains an equation in the form (a op1 b op2 c) mod p (1 <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> <i>a, b, c, p</i> <span style=\"background-color:rgb(255,255,255);color:rgb(34,34,34);\">≤</span> 10<sup>9</sup>).<br>It is guaranteed that <i>(a, p) = (b, p) = (c, p) = 1</i> and <i>p</i> is a prime number.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><i><strong>Explanation 1:</strong></i><br>(1 + 2 / 1) mod 3 = 3 mod 3 = 0.</p><p><i><strong>Explanatino 2:</strong></i><br>(2 * 3 - 8) mod 5 = -2 mod 5 = 3.</p>",
      "output_format": "<p>For each test case, print a single number denoting the value of the equation. Since it is <i>mod p</i>, the value must belong to <i>0</i> to <i>p - 1</i>.</p>",
      "samples": [
        {
          "input": "2\n(1 + 2 / 1) mod 3\n(2 * 3 - 8) mod 5",
          "output": "0\n3"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Solve the Equation",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Find the Kth smallest element in a BBST.<br>BBST - Balanced Binary Search Tree (height of BST is around O(logN)).</p>",
      "complete_approach": "",
      "constraints": "",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:34:38.075859+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 672,
      "input_format": "<p>The first line contains an integer T, (1 ≤ T ≤ 10^5), the number of test cases.</p><p>The first line of each test case contains an integer N, Q the length of the array representing the serialized representation of a tree, the number of queries.</p><p>The next line contains N-space-separated distinct integers.&nbsp;</p><p>The next line contains Q-space-separated integers.&nbsp;</p><p>The input is given as a serialized representation of a tree.</p><p>The following function parses the input:</p><p><i>Node* getBinaryTree(vector&lt;int&gt; &amp;num, int*ind)</i></p><p><i>Sum of N across all test cases ≤ 10^7.</i></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>For each query print the Kth smallest element in a BST in a new line.</p>",
      "samples": [
        {
          "input": "1\n21 10\n605 192 87 -1 -1 308 -1 -1 758 637 624 -1 -1 668 -1 -1 792 -1 954 -1 -1 \n1 2 3 4 5 6 7 8 9 10 ",
          "output": "87 192 308 605 624 637 668 758 792 954 "
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node *left, *right;\n    Node(int x) : val(x), left(NULL), right(NULL) {}\n};\n</fix>\nint getKthElement(Node* node, int k)\n{\n    //Complete the function\n}\n<fix>\nNode* getBinaryTree(vector<int> &num, int*ind) {\n    if(num[*ind] == -1)\n        return NULL;\n    Node* node = new Node(num[*ind]);\n    (*ind)++;\n    node->left = getBinaryTree(num,ind);\n    (*ind)++;\n    node->right = getBinaryTree(num,ind);\n    return node;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n,q;\n        cin>>n>>q;\n        assert(n<=1000000);\n        vector<int>arr(n);\n        for(int i=0;i<n;i++){\n            cin>>arr[i];\n        }\n        int ind = 0;\n        Node* tree = getBinaryTree(arr,&ind);\n        for(int i=0;i<q;i++){\n            int k;\n            cin>>k;\n            cout<<getKthElement(tree,k)<<\" \";\n        }\n        cout<<\"\\n\";\n\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Kth element of BST",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are climbing a staircase. It takes $N$ steps to reach the top.\n\nEach time you can either climb $1$ or $M$ steps. What is the minimum number of climbs you need to do to reach the top, i.e., $N$th stair?",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^6$\n$1 \\leq M \\leq N \\leq 10^9$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() \n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n\n        cout << n / m + n % m << \"\\n\";\n    }\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:26:31.163832+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "If $N$ = $q \\times M + r$, then the minimum number of climbs is $q + r$."
      },
      "id": 1051,
      "input_format": "The first line of input contains $T$ - the number of test cases. Then $T$ test cases follow.\nThe only line of each test case contains two space-separated integers - $N$ and $M$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, we can reach top by $0 \\to1 \\to 2 \\to 3 \\to 4 \\to 5$.\n\nFor the second test case, we can reach top by $0 \\to 1 \\to 5 \\to 6$.",
      "output_format": "For each test case, print the minimum number of climbs require to climb the top on a new line.",
      "samples": [
        {
          "input": "2\n5 1\n6 4\n",
          "output": "5\n3\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Climbing Stairs",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">Given a grid of size n*m, you need to find the total number of different paths from (1, 1) to (n, m). You are allowed to move from (x, y) to (x+1, y) and (x, y) to (x, y+1). The grid may have some blocked cells, represented by 1, and it is not allowed to move to a blocked cell. An empty cell is represented by 0. You are also given an integer k and you can convert at most k blocked cells into unblocked cells.</span></p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ t ≤ 10<sup>5</sup></p><p>1 ≤ n, m ≤ 200</p><p>0 ≤ k ≤ 400</p><p>0 ≤ a<sub>ij</sub> ≤ 1</p><p>It is guaranteed that the sum of n*m*k over all test cases does not exceed 10<sup>8</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod = 1e9 + 7;\n\nint n, m, k;\nint grid[210][210];\nint dp[210][210][410];\n\nint rec(int i, int j, int left)\n{\n\n    if (left < 0)\n    {\n        return 0;\n    }\n\n    if (i == n - 1 && j == m - 1)\n    {\n        if (grid[i][j] == 0 || left > 0)\n            return 1;\n        return 0;\n    }\n\n    if (i == n || j == m)\n    {\n        return 0;\n    }\n\n    if (dp[i][j][left] != -1)\n    {\n        return dp[i][j][left];\n    }\n\n    int ans = 0;\n    if (grid[i][j] == 0)\n    {\n        ans = (rec(i + 1, j, left) % mod + rec(i, j + 1, left) % mod) % mod;\n    }\n    else\n    {\n        ans = (rec(i + 1, j, left - 1) % mod + rec(i, j + 1, left - 1) % mod) % mod;\n    }\n\n    return dp[i][j][left] = ans % mod;\n}\n\nvoid solve()\n{\n    cin >> n >> m >> k;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            cin >> grid[i][j];\n        }\n    }\n    for (int i = 0; i <= n; i++)\n    {\n        for (int j = 0; j <= m; j++)\n        {\n            for (int l = 0; l <= k; l++)\n            {\n                dp[i][j][l] = -1;\n            }\n        }\n    }\n    cout << rec(0, 0, k) << endl;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio();\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        solve();\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:34:26.411825+00:00"
      },
      "hints": {
        "hint1": "The cell $(i, j)$ can only be reached from the cells $(i-1, j)$ and $(i, j-1)$.",
        "hint2": "If a cell (i, j) is blocked, it can be reached only if the number of unblocked cells till (i-1, j) or (i, j-1) is at most K - 1.\n\nUse the dp structure as $dp[i][j][left]$ which gives the number of paths from $(i,j)$ to $(n,m)$ with chance of converting left number of blocked cells to unblocked cells.",
        "solution_approach": "The transitions would be as follows :\n\nCase1 :  If $(i,j)$ is a blocked cell \nans = rec(i + 1, j, left - 1) + rec(i, j + 1, left - 1) ;\nConverting blocked cell to unblocked takes one of our chances and hence in the next recursive step we would have left-1 number of chances left.\n\nCase2 :  If $(i,j)$ is unblocked\nans = rec(i + 1, j, left) + rec(i, j + 1, left ) ;\n\nTime Complexity per test case: $O(n*m*k)$"
      },
      "id": 493,
      "input_format": "<p>The first line of the input contains one integer t - the number of test cases. Then t test cases follow.</p><p>The first line of each test case contains three space-separated integers n, m, k - the size of the grid and the number of cells you can convert.</p><p>Each of the following n lines contains m space-separated integers, aij - the number at that cell.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p><span style=\"background-color:transparent;color:#000000;\">For the first test case, any path from (1,1) to (n,m) has 2 blocked cells, which can be unblocked.</span></p><p><span style=\"background-color:transparent;color:#000000;\">For the third test case, no cells can be unblocked and the first cell is blocked, so there are no paths from (1,1) to (n,m).</span></p>",
      "output_format": "<p><span style=\"background-color:transparent;color:#000000;\">For each test case, print the number of paths modulo 10^9 + 7.</span></p>",
      "samples": [
        {
          "input": "3\n3 3 2\n0 1 1\n1 1 0\n1 0 0\n3 3 1\n0 1 1\n1 1 0\n1 0 0\n2 3 0\n1 0 0\n0 1 0",
          "output": "6\n0\n0"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Number of Paths in Grid - 2",
      "video_editorial_id": 10652
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given n jobs. The i<sup>th</sup> job has a duration L<sub>i</sub> and a deadline D<sub>i</sub>. Duration is the amount of time it takes to complete the job. Jobs must be completed on or before their deadline.&nbsp;</p><p>You can start completing jobs at time 0. Only one job can be taken up at a time. Any job when taken up must be completed fully without switching to any other job. &nbsp;</p><p>If you finish a job at time t then you may start another job at t.</p><p>Find maximum number of jobs that can be completed from the n given jobs.</p>",
      "complete_approach": "",
      "constraints": "<pre><code class=\"language-css\">T ≤ 100\nn ≤ 20,000\n1 ≤ Di, Li ≤ 10^9\nSum of n over all test cases is ≤ 10^5</code></pre>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int t, i, n;\n\n    cin >> t;\n    while (t--)\n    {\n        cin >> n;\n        vector<pair<int,int>> jobs(n); // deadline, duration\n        for(i=0;i<n;i++) cin>>jobs[i].first;\n        for(i=0;i<n;i++) cin>>jobs[i].second;\n        jobs.push_back({0,0}); // dummy job\n\n        sort(jobs.rbegin(), jobs.rend()); // sort in decreasing order of deadlines\n\n        int ans=0;\n        priority_queue<int> min_heap; // push negatives of durations;\n\n        min_heap.push(-jobs[0].second);\n        for(i=1;i<jobs.size();i++)\n        {\n            int interval = jobs[i-1].first - jobs[i].first;\n            // use this time to find out how much of the minimum \n            // duration job in the heap could have been completed.\n            while(interval>0 and !min_heap.empty())\n            {\n                int duration = -min_heap.top();\n                min_heap.pop();\n                int spend_time = min(interval, duration);\n                interval-=spend_time;\n                duration -= spend_time;\n                if(duration>0) min_heap.push(-duration); // push remaining job time back\n                else ans++; //job can be completed\n            }\n\n            // push this new job into heap\n            min_heap.push(-jobs[i].second);\n        }\n        \n        cout<< ans<<'\\n';\n    }\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:22:41.459569+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "## Understanding the Problem\n\nBefore diving into the algorithms and implementation, let's understand the problem\nstatement:\n\nGiven a set of jobs with their respective deadlines and durations, we need to schedule these\njobs in such a way that the total time required is minimized while meeting all the deadlines.\n\nTo clarify further, let's consider an example:\n\nSuppose we have the following jobs:\n* Job $1$: Deadline = $4$, Duration = $2$\n* Job $2$: Deadline = $2$, Duration = $1$\n* Job $3$: Deadline = $3$, Duration = $2$\n* Job $4$: Deadline = $1$, Duration = $3$\n\nThe optimal schedule in this case would be:\n* Job $2$: Starts at time $1$, finishes at time $2$\n* Job $3$: Starts at time $2$, finishes at time $4$\n* Job $1$: Starts at time $4$, finishes at time $6$\n* Job $4$: Starts at time $6$, finishes at time $9$\n\nIn this schedule, all the deadlines are met, and the total time required is minimized.\n\n## Solving\n\nThe algorithm of the solving is greedy. Let’s sort all the jobs by their deadlines and look at them in descending order. Also, let’s create a queue  $q$ , in which we’ll gradually put the jobs and extract one with the least run-time (for instance, we can use set or priority_queue). Initially,  $q$  is empty.\n\nSuppose, we’re looking at the  $i$ -th job. First of all, let’s put it into  $q$ . Let’s consider the period of time between the deadline of  $i$ -th job and the deadline of  $i-1$ -th job. That is the segment of some length  $T$ . We will extract jobs from  $q$  (in their left duration ascending order) and execute them until the whole segment  $T$  is filled. Important: if at any moment of time the extracted job can only be partly executed until segment  $T$  is filled, then we execute this job partly just as far as possible, i.e., during the  $T$ -time, and we put the remaining part of a job back into  $q$ .\n\nOn the algorithm’s completion we’ll choose the optimal solution (or, at least, one of several solutions). The running time of algorithm is  $O(n \\log n)$ ."
      },
      "id": 240,
      "input_format": "<p>First line of input contains T, number of test cases.</p><p>First line of each test case contains n, the number of jobs.</p><p>Second line contains n integers, D<sub>i , </sub>deadline of the i<sup>th</sup> job.</p><p>Third line contains n integers, L<sub>i , </sub>duration of the i<sup>th</sup> job.</p><p>&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>In test case 1, &nbsp;start job 1 at t=0 and job 2 at t=2 .</p><p>In test case 2, both the jobs cannot be completed together.</p>",
      "output_format": "<p>For each test case print a single integer in a new line: Maximum number of jobs that you can complete.</p>",
      "samples": [
        {
          "input": "2\n2\n2 4\n2 2\n2\n3 4\n3 3",
          "output": "2\n1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Jobs",
      "video_editorial_id": 8173
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a sequence <i>A<sub>1</sub>, A<sub>2</sub>, …, A<sub>N</sub></i>. Let's call a subsequence <i>A<sub>i1</sub>, A<sub>i2</sub>, …, A<sub>ik</sub></i> (for any <i>k</i> &gt; 0, 1 ≤ <i>i<sub>1</sub></i> &lt; <i>i<sub>2</sub></i> &lt; … &lt; <i>i<sub>k</sub></i> ≤ <i>N</i>) good if the median of this subsequence is an element of this subsequence.&nbsp;<br>Find the number of good subsequences. Since this number may be large, compute it modulo 1000000007 (10<sup>9</sup>+7).</p><p><i>Note:</i></p><ol><li>The median of a set of data is the middlemost number in the set. The median is also the number that is halfway into the set. To find the median, the data should first be arranged in order from least to greatest.</li><li>For odd length sequence, the median is the middle element in the sorted sequence. While for even length sequence, it is the average of the middle two elements.</li></ol>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>T</i> ≤ 30<br>1 ≤ <i>N</i> ≤ 1000<br>1 ≤ <i>A<sub>i</sub></i> ≤ 2<i>N</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nvector<ll> fact;\nvector<ll> factInv;\nint mod = 1e9 + 7;\n\nll binpow(ll a, ll b) {\n  ll ans = 1;\n  while (b) {\n    if (b % 2) ans = (ans * a) % mod;\n    a = (a * a) % mod;\n    b /= 2;\n  }\n  return ans;\n}\n\nll ncr(ll n, ll r) {\n  return (((fact[n] * factInv[n - r]) % mod) * factInv[r]) % mod;\n}\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> v(n);\n  vector<int> pos(n, 1);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i];\n  }\n  sort(v.begin(), v.end());\n\n  for (int i = n - 2; i >= 0; i--) {\n    if (v[i] == v[i + 1]) {\n      pos[i] += pos[i + 1];\n    }\n  }\n\n  ll ans = binpow(2, n - 1);\n\n  for (int i = 0; i < n; i++) {\n    if (pos[i] == 1) continue;\n    int temp = min(i, n - i - 1 - 1);\n    for (int j = 0; j <= temp; j++) {\n      if (j == 0) {\n        ans = (ans + ncr(pos[i + 1], j + 1)) % mod;\n        continue;\n      }\n      ans += (ncr(i, j) * ncr(n - 1 - i, j + 1)) % mod;\n      ans %= mod;\n      if (n - 1 - i - pos[i + 1] >= (j + 1)) {\n        ans -= (ncr(i, j) * ncr(n - 1 - i - pos[i + 1], j + 1)) % mod;\n        ans = (ans + mod) % mod;\n      }\n    }\n  }\n  cout << ans << \"\\n\";\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  fact = vector<ll>(2001);\n  factInv = vector<ll>(2001);\n  fact[0] = 1;\n  for (int i = 1; i <= 2000; i++) {\n    fact[i] = (i * fact[i - 1]) % mod;\n  }\n  factInv[2000] = binpow(fact[2000], mod - 2);\n  for (int i = 2000; i > 0; i--) {\n    factInv[i - 1] = (i * factInv[i]) % mod;\n  }\n\n  int _t;\n  cin >> _t;\n  while (_t--) solve();\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:46:21.147888+00:00"
      },
      "hints": {
        "hint1": "<ul><li>Every subset of odd size has its median present in the subset, so, we can directly add 2<i>N </i>− 1 to answer.</li><li>For even size subset, The subset is good, if and only if the middle two elements are equal.</li></ul>",
        "hint2": "We can fix the left middle element, and for every possible even size of the subset, say 2X, try to find count.",
        "solution_approach": "<p>First of all, let us formulate the definition of median. If the size of the selected subset is odd, the median is just the middle element of subset after sorting. Since the middle element is present in the subset, all subsets of odd size are valid. It can be easily proven that there are 2<i><sup>N</sup></i>−1 such subsets. So, we can directly count these and move toward even size subsets.<br>If the size of the selected subset is even, the median is defined as the average of two middlemost elements after sorting. Now, say we have two middle elements <i>x</i> and <i>y</i>, with condition <i>x </i>≤ <i>y</i>. Let <i>z </i>= (<i>x </i>+ <i>y</i>) / 2 be the median of sequence. If we write <i>y </i>= <i>x </i>+ <i>d</i>, <i>d </i>≥ 0, we can see, <i>z </i>= <i>x </i>+ <i>d </i>/ 2 and also, <i>z </i>= <i>y </i>− <i>d </i>/ 2. This way, we can see, that the median of a sequence can never be smaller than <i>x</i> and greater than <i>y</i>. So, For <i>z</i> to be present in subset, we need either <i>z </i>= <i>x</i> or <i>z </i>= <i>y</i>. But, this would imply <i>d </i>= 0, Hence leading to the conclusion that f<strong>or an even size subset to be valid, the two middlemost elements should be equal.</strong> This forms the crux of our solution, and now, we need to count the number of even sized subsets with equal middle elements.<br>After all this, there are a number of approaches to solving this problem, all of which required us to sort the array&nbsp;A<i>A</i> first.</p><p>Let us consider a <i>O</i>(<i>N</i><sup>3</sup>) solution first. Iterate over every pair of equal elements (<i>i</i>, <i>j</i>) such that <i>A<sub>i </sub></i>​= <i>A<sub>j</sub></i>​ and iterate over the size 2<i>X</i> of subset from <i>X </i>= 1 to <i>N</i>. The number of ways to make the subset of size <i>X</i> with two fixed middle elements is just the product of the number of ways we can select <i>X </i>− 1 elements from [1, <i>i </i>− 1] and <i>X </i>− 1 elements from [<i>j </i>+ 1, <i>N</i>].</p><p>This solution requires to iterate over every pair (<i>i</i>, <i>j</i>) which takes <i>O</i>(<i>N</i><sup>2</sup>) time and <i>O</i>(<i>N</i>) time per pair, leading to Overall time complexity <i>O</i>(<i>N</i><sup>3</sup>).</p><p>We were fixing two equal elements and tried to count the number of ways we can make subsets of all sizes. Now, We shall fix only the <strong>Left Middle Element</strong> (Or Right one, whichever implementation you prefer).</p><p>Suppose we fixed the <i>i</i>th element as the left middle element. Now, We will iterate over all sizes 2<i>X</i> and try to include <i>X </i>− 1 elements from [1, <i>i </i>− 1] and <i>X</i> elements from [<i>i </i>+ 1, <i>N</i>]. We need the right middle element to be same as the left middle element. So, When choosing <i>X</i> elements from [<i>i</i>+1,<i>N</i>], we need at least one occurrence of <i>A</i>[<i>i</i>]. This is same as subtracting all the ways to select <i>X</i> elements in the range [<i>i </i>+ 1, <i>N</i>] which do not have <i>A</i>[<i>i</i>] at all. Suppose Number of occurrence of <i>A</i>[<i>i</i>] in range [<i>i </i>+ 1, <i>N</i>] is <i>f</i>, then we can count the number of ways to select <i>X</i> elements from range [<i>i </i>+ 1, <i>N</i>] such that it contains at least one occurrence of <i>A</i>[<i>i</i>] as <i>T</i> = Number of ways to select <i>X</i> elements out of <i>N</i>−<i>i</i> elements less Number of ways to select <i>X</i> elements out of <i>N</i>−<i>i</i>−<i>f</i> elements.</p><p>We can select <i>X</i>−1 elements from [1, <i>i </i>− 1] in suppose <i>U</i> ways. Then, Number of ways we can have good subsets with <i>A</i>[<i>i</i>] as the left middle element is&nbsp;<i>UT</i>. Summation of this product for all sizes for all elements gives us the number of good subsets of even size. We can add to it, the number of good odd sized subsets and print the answer.</p>"
      },
      "id": 198,
      "input_format": "<p>The first line of input contains <i>T</i> - the number of test cases.<br>The first line of each test case contains a number <i>N</i> - the size of the array.<br>The second line of each test case contains <i>N</i> space-separated integers <i>A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub></i>.&nbsp;</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>The good subsequences are [2], [3], [2], [2,2], [2,3,2].</p>",
      "output_format": "<p>For each test case, print the number of good subsequences on a new line.</p>",
      "samples": [
        {
          "input": "1\n3\n2 3 2",
          "output": "5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Count Good Subsequences",
      "video_editorial_id": 8167
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>In a Board of Dimensions N x M, each cell is colored with color Cij. Now, You need to select a Connected set of cells from the board such that the Number of Distinct colored cells in the set is at most 2.</p><p>Two cells are called Connected if they share an edge. A pair of cells in the Connected set should either be Connected Directly or indirectly via some connected path.</p><p>Find out the size of the Maximum Connected Set of Cells that you can create.</p>",
      "complete_approach": "",
      "constraints": "<p>1 &lt;= N , M &lt;= 1000</p><p>1 &lt;= Cij &lt;= 1000000</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma comment(linker, \"/stack:200000000\")\nusing namespace std;\n#define F first\n#define S second\n#define EB emplace_back\n#define MP make_pair\n#define all(o) (o).begin(), (o).end()\n#define mset(m,v) memset(m,v,sizeof(m))\n#define fr(i,n) for(lli i=0;i<(n);++i)\n#define rep(i,a,b) for(lli i=a;i<=b;++i)\n#define per(i,a,b) for(lli i=a;i>=b;i--)\n#define remin(a,b) (a=min((a),(b)))\n#define remax(a,b) (a=max((a),(b))) \n#define sz(x) (lli)(x).size()\n#define endl '\\n'\ntypedef long long lli;        typedef long double ld;\ntypedef pair<lli,lli> ii;     typedef vector<lli> vi;\ntypedef vector<ii> vii;       typedef vector<vi> graph;\nlong long MOD=1000000007;     long double EPS=1e-9;\n#ifndef ONLINE_JUDGE\n#define debarr(a,n)cerr<<#a<<\":\";for(int i=0;i<n;i++)cerr<<a[i]<<\" \";cerr<<endl;\n#define debmat(mat,row,col)cerr<<#mat<<\":\\n\";for(int i=0;i<row;i++){for(int j=0;j<col;j++)cerr<<mat[i][j]<<\" \";cerr<<endl;}\n#define pr(...)dbs(#__VA_ARGS__,__VA_ARGS__)\ntemplate<class S,class T>ostream &operator<<(ostream &os,const pair<S,T> &p){return os<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T>ostream &operator<<(ostream &os,const vector<T> &p){os<<\"[\";for(auto&it:p)os<<it<<\" \";return os<<\"]\";}\ntemplate<class T>ostream &operator<<(ostream &os,const set<T>&p){os<<\"[\";for(auto&it:p)os<<it<<\" \";return os<<\"]\";}\ntemplate<class T>ostream &operator<<(ostream &os,const multiset<T>&p){os<<\"[\";for(auto&it:p)os<<it<<\" \";return os<<\"]\";}\ntemplate<class S,class T>ostream &operator<<(ostream &os,const map<S,T>&p){os<<\"[\";for(auto&it:p)os<<it<<\" \";return os<<\"]\";}\ntemplate<class T>void dbs(string str,T t){cerr<<str<<\":\"<<t<<\"\\n\";}\ntemplate<class T,class...S>void dbs(string str,T t,S... s){int idx=str.find(',');cerr<<str.substr(0,idx)<<\":\"<<t<<\",\";dbs(str.substr(idx+1),s...);}\n#else\n#define pr(...){}\n#define debarr(a,n){}\n#define debmat(mat,row,col){}\n#endif\nlli binpow(lli b,lli p,lli mod){lli ans=1;b%=mod;for(;p;p>>=1){if(p&1)ans=ans*b%mod;b=b*b%mod;}return ans;}\n\nvoid pre(){\n\n}\n\nint uf[1000100];\nint rankk[1000100];\nmultiset<int> compSize;\nvoid init(){\n    compSize.clear();\n    fr(i,1000001){uf[i]=i;rankk[i]=1;compSize.insert(1);}\n}\nint get(int x){\n    while(x!=uf[x])x=uf[x];return x;\n}\nvector<pair<int,int>> st;\nvoid merge(int x,int y){\n    x=get(x);y=get(y);\n    if(x==y)return;\n    if(rankk[x] < rankk[y])swap(x,y);\n    compSize.erase(compSize.find(rankk[x]));\n    compSize.erase(compSize.find(rankk[y]));\n    rankk[x]+=rankk[y];\n    uf[y]=x;\n    st.EB(y,x);\n    compSize.insert(rankk[x]);   \n}\nvoid revert(){\n    while(!st.empty()){\n        int y = st.back().F;\n        int x = st.back().S;\n        st.pop_back();\n        compSize.erase(compSize.find(rankk[x]));\n        uf[y]=y;\n        rankk[x]-=rankk[y];\n        compSize.insert(rankk[x]);\n        compSize.insert(rankk[y]);\n    }\n}\nint getMax(){\n    auto it=compSize.end();it--;\n    return *it;\n}\n\n\nint n,m;\nbool check(int i,int j){\n    if(i<n&&i>=0&&j<m&&j>=0)return 1;\n    return 0;\n}\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint arr[1001][1001];\nint node[1001][1001];\n\nvector<pair<ii,ii>> edges;\n\nvoid solve(){\n    cin>>n>>m;\n    init();\n    int cnt=1;\n    fr(i,n)fr(j,m){cin>>arr[i][j];node[i][j]=cnt++;}\n    fr(i,n)fr(j,m){\n        fr(k,2){\n            int xx = i+dx[k];\n            int yy = j+dy[k];\n            if(check(xx,yy)){\n                int cc1 = arr[i][j];\n                int cc2 = arr[xx][yy];\n                if(cc1>cc2)swap(cc1,cc2);\n                if(cc1!=cc2){\n                    edges.EB(MP(MP(cc1,cc2),MP(node[i][j],node[xx][yy])));\n                }else{\n                    merge(node[i][j],node[xx][yy]);\n                } \n            }\n        }\n    }\n    st.clear();\n    sort(all(edges));\n    int ans=getMax();\n    for(int i=0;i<edges.size();i++){\n        int j=i;\n        while(j<edges.size() && edges[i].F==edges[j].F){\n            merge(edges[j].S.F,edges[j].S.S);\n            j++;\n        }\n        remax(ans,getMax());\n        revert();\n        i=j-1;\n    }\n    cout << ans << endl; \n}\n\nsigned main(){\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    //cout<<fixed<<setprecision(15);\n    //clock_t begin = clock();\n    pre();lli _t=1;//cin>>_t;\n    for(lli i=1;i<=_t;i++){\n        //cout<<\"Case #\"<<i<<\": \";\n        solve();\n    }\n    // clock_t end = clock();double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;cerr << elapsed_secs;\n}\n```\n\n\n",
          "language": "C++14"
        },
        {
          "code": "\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \nconst int px[] = {0, 0, -1, 1};\nconst int py[] = {-1, 1, 0, 0};\nconst int nn = 2008;\n \nint n, m;\nint sz;\npair<int, int> q[nn * nn];\nbool ed[nn][nn][4];\nint a[nn][nn];\nint trv[nn][nn];\nint id;\n \nbool inside(int x, int y) {\n    return x > 0 && x <= n && y > 0 && y <= m;\n}\n \nint bfs(int u, int v, int c1, int c2) {\n    id++;\n    trv[u][v] = id;\n    int l, r;\n    l = r = 0;\n    q[0] = {u, v};\n    sz = 0;\n    int res = 0;\n    while (l <= r) {\n        u = q[l].first;\n        v = q[l].second;\n        l++;\n        for (int i = 0; i < 4; i++) {\n            int x = u + px[i];\n            int y = v + py[i];\n            if (inside(x, y) && (a[x][y] == c1 || a[x][y] == c2) && trv[x][y] != id) {\n                trv[x][y] = id;\n                q[++r] = {x, y};\n            }\n        }\n    }\n    for (int i = 0; i <= r; i++) {\n        for (int j = 0; j < 4; j++) {\n            int x = q[i].first + px[j];\n            int y = q[i].second + py[j];\n            if (inside(x, y) && trv[x][y] == id) {\n                ed[q[i].first][q[i].second][j] = true;\n            }\n        }\n    }\n    return l;\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            cin >> a[i][j];\n        }\n    }\n    int res = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            for (int k = 0; k < 4; k++) {\n                int x = i + px[k];\n                int y = j + py[k];\n                if (inside(x, y) && !ed[i][j][k]) {\n                    res = max(res, bfs(i, j, a[i][j], a[x][y]));\n                }\n            }\n        }\n    }\n    cout << res;\n}\n ```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:28:21.481746+00:00"
      },
      "hints": {
        "hint1": "<p>Compressing the components of a single color is easy, how to we decide on which pair of color will give us optimal? How many Pairs of colors can potentially give the answer?</p>",
        "hint2": "<p>We only have O(N*M) number of pairs of color to check, which occur as a neighbor once. How do you check these pairs efficiently?</p>",
        "solution_approach": "<p>Solution 1:</p><p>We maintain a UnionFind with Rollback. First Compress all Components of the Same Colour. Then to check each pair of Potential colors, add those edges, maintaining the Components Size in a multiset, to find the largest component in the UnionFind. To removes these, rollback the Union Find. There are in total O(N*M) edges across all color pairs. So the total time complexity would be O(N*M*log(N*M)).</p><p>&nbsp;</p><p>Solution 2:</p><p>We do a BFS for every pair of colors that are neighbors from a cell. To restrict the BFS to O(N*M), we can make sure that each edge is covered in BFS only once! You can draw and check that you will visit the maximum Connected Set at least once.</p>"
      },
      "id": 39,
      "input_format": "<p>The first line contains the Dimensions of the board, N and M.&nbsp;</p><p>The next N line contains the M integers each. j<sup>th</sup> integer on i<sup>th</sup> Line denoting the colours of the cell C<sub>ij</sub> .</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "<p>Single integer, denoting the size of maximum number of cells in a connected Set.</p>",
      "samples": [
        {
          "input": "3 3\n1 2 5\n1 4 4\n3 6 4",
          "output": "5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 4,
      "title": "Two Kingdoms",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Given an array of size $N$, and $Q$ queries, for each query, you need to get the indices of the elements of the array whose subset-sum is equal to the queried sum $sum_{i}$, if possible, else return $-1$.\n\nComplete the Function **subset_queries( vector<int> &arr, vector<int> &queries )** that takes vector $a$ and $queries$ vector as input.",
      "complete_approach": "",
      "constraints": "$1 \\leq N \\leq 100$   , size of **vector < int > arr**\n$1 \\leq Q \\leq 10^{5}$   ,  size of **vector < int > queries**\n$1 \\leq arr[i] \\leq 10^{5}$\n$1 \\leq sum_{i} \\leq 10^{5}$",
      "editorial_code": [
        {
          "code": "```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define ll int64_t\n\n#define endl '\\n'\n\nconst int mx = 1e5 + 10;\nint n, q, dp[100][mx], a[100];\nbool rec(int i, int sum) {\n    if (sum < 0)return 0;\n    if (i == -1) {\n        if (sum == 0)return 1;\n        return 0;\n    }\n    auto &ans = dp[i][sum];\n    if (ans != -1)return ans;\n    ans = (rec(i - 1, sum) | rec(i - 1, sum - a[i]));\n    return ans;\n}\nvector<vector<int>> subset_queries(vector<int> &arr, vector<int> &queries) {\n    n = arr.size(), q = queries.size();\n    for (int i = 0; i < n; i++)a[i] = arr[i];\n    memset(dp, -1, sizeof(dp));\n    vector<vector<int>> ans;\n    for (auto x : queries) {\n        if (rec(n - 1, x)) {\n            vector<int> t;\n            int i = n - 1;\n            while (x) {\n                if (rec(i-1, x - a[i]))x -= a[i], t.push_back(i);\n                i--;\n            }\n            reverse(t.begin(), t.end());\n            ans.push_back(t);\n        }\n        else {\n            ans.push_back({ -1});\n        }\n    }\n    return ans;\n}\n\n\n\nvoid solve() {\n    int N, Q;\n    cin >> N >> Q;\n    vector<int> arr(N);\n    for (int i = 0; i < N; i++)cin >> arr[i];\n    vector<int> queries(Q);\n    for (int i = 0; i < Q; i++)cin >> queries[i];\n    auto ans = subset_queries(arr, queries);\n\n    // checker.\n    if (ans.size() != Q) {\n        cout << 101 << endl;\n        return;\n    }\n    for (int i = 0; i < Q; i++) {\n        auto x = ans[i];\n        if (x.size() == 0) {\n            cout << 101 << endl;\n            continue;\n        }\n        if (x.size() == 1 && x[0] == -1) {\n            cout << -1 << endl;\n            continue;\n        }\n        ll sum = 0, p = -10;\n        for (auto y : x) {\n            if (y < 0 || y >= N || p >= y ) { // valid 0-indexed.\n                sum = -1111;\n                break;\n            }\n            p = y;\n            sum += arr[y];\n        }\n        if (sum == queries[i]) {\n            cout << 1 << endl;\n        }\n        else cout << 101 << endl;\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Editorial code is not passing the Sample cases.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:21:45.565630+00:00"
      },
      "hints": {
        "hint1": "To solve this problem efficiently, we can use the technique of Dynamic Programming. We can pre-compute all the possible subset sums for each index of the array using a 2D boolean array, let's call it dp.\n\nSpecifically, $dp[i][j]$ will be true if there is a subset of the elements from the array $arr[0]$ to $arr[i]$ whose sum is equal to $j$",
        "hint2": "We can compute dp[i][j] for all i and j using the following recurrence:  \n$dp[i][j] = dp[i-1][j] || dp[i-1][j-arr[i]]$",
        "solution_approach": "$dp[i-1][j]$ for when we dont take the $i^{th}$ element into our subset.\n$dp[i-1][j-arr[i]]$ to consider the case when we take the $i^{th}$ element into our subset and check if it is possible to form a subset in the first $i-1$ elements to form a sum of $j-arr[i]$\n\nThe base cases are $dp[0][0] =$ true and $dp[0][j] =$ false for all $j > 0$.\n\nOnce we have pre-computed all the possible subset sums using the above recurrence, we can answer each query in constant time by checking if $dp[N-1][sum]$ is true or false. If it is true, we can find the indices of the elements that contribute to the subset sum using a simple backtracking technique."
      },
      "id": 760,
      "input_format": "The first line of input contains two integers - $N$, $Q$ where $N$ is the size of the array and $Q$ is a number of queries.\nThe second line of input contains $N$ space-separated integers, which are array elements.\nThe third line of input contains $Q$ space-separated integers, which are queries.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "Return a **vector < vector < int > >** having $0$-based indices of the elements of the array whose subset-sum is equal to the queried sum $sum_{i}$ for each $i^{th}$ query, if possible, else return vector { $-1$ }.\nIf the returned **vector < vector < int > >** from the function **subset_queries( vector<int> &arr, vector<int> &queries )** is valid, then the program prints 1. Otherwise, prints -1.",
      "samples": [
        {
          "input": "5 3\n1 2 3 4 5\n7 16 3\n",
          "output": "1\n-1\n1"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\n#define ll int64_t\n\nvector<vector<int>> subset_queries(vector<int> &arr, vector<int> &queries) {\n    // Write code here.\n    return {};\n}\n\n<fix>\nvoid solve() {\n    int N, Q;\n    cin >> N >> Q;\n    vector<int> arr(N);\n    for (int i = 0; i < N; i++)cin >> arr[i];\n    vector<int> queries(Q);\n    for (int i = 0; i < Q; i++)cin >> queries[i];\n    auto ans = subset_queries(arr, queries);\n\n    // checker.\n    if (ans.size() != Q) {\n        cout << 101 << endl;\n        return;\n    }\n    for (int i = 0; i < Q; i++) {\n        auto x = ans[i];\n        if (x.size() == 0) {\n            cout << 101 << endl;\n            continue;\n        }\n        if (x.size() == 1 && x[0] == -1) {\n            cout << -1 << endl;\n            continue;\n        }\n        ll sum = 0, p = -10;\n        for (auto y : x) {\n            if (y < 0 || y >= N || p >= y ) { // valid 0-indexed.\n                sum = -1111;\n                break;\n            }\n            p = y;\n            sum += arr[y];\n        }\n        if (sum == queries[i]) {\n            cout << 1 << endl;\n        }\n        else cout << 101 << endl;\n    }\n}\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n#ifdef Mastermind_\n    freopen(\"input.txt\", \"r\", stdin); \\\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t = 1;\n    // int i = 1;\n    // cin >> t;\n    while (t--) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n        // i++;\n    }\n    return 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Subset Sum Queries",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Design the algorithm which supports the following operations.</p><ol><li><strong>add(int x)</strong>: Add x to the back of the current list of numbers.</li><li><strong>getProduct(int k)</strong>: Print the product of the last k numbers % 1000000007 in the current list. It's guaranteed that the list will contain at least k elements.</li></ol><p>Initially, the list is empty.</p><p>Complete the code.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>Q</i> ≤ 10<sup>5</sup><br>0 ≤ x ≤ 10<sup>9</sup></p>",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty.",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:35:10.340031+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 542,
      "input_format": "<p>The first line contains <i>Q</i> - the number of queries.<br>Each query is one of the types of queries explained in the problem statement.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "10\nadd 3\nadd 0\nadd 2\nadd 5\nadd 4\ngetProduct 2\ngetProduct 3\ngetProduct 4\nadd 8\ngetProduct 2",
          "output": "20\n40\n0\n32"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass ProductOfKNumbers {\npublic:\n\n\tProductOfKNumbers() {\n\t\n\t}\n\n\tvoid add(int num) {\n\t\t\n\t}\n\n\tint getProduct(int k) {\n\t\t\n\t}\n};\n\nint main()\n{\n\tios_base::sync_with_stdio(NULL);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint Q;\n\tcin >> Q;\n\n\tProductOfKNumbers productOfKNumbers;\n\n\twhile(Q--) {\n\t\tstring op;\n\t\tcin >> op;\n\n\t\tif (op == \"add\") {\n\t\t\tint num;\n\t\t\tcin >> num;\n\t\t\tproductOfKNumbers.add(num);\n\t\t}\n\t\telse {\n\t\t\tint k;\n\t\t\tcin >> k;\n\n\t\t\tcout << productOfKNumbers.getProduct(k) << \"\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 2,
      "title": "Product of the Last K numbers",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given an array of $N$ elements. You can perform the below operation at most one time.\n\n**Operation:** You can pick any array element and change it to $0$.\n\nYou are required to maximize the number of the partition of the given array such that after the partition sum of the first subarray is equal to the sum of another subarray.\n\n**Note:** In this problem, the partition of the array is defined as dividing the given array into two contiguous subarrays. Any of the two subarrays in the partition can't be empty.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$\n$2 \\leq N \\leq 2 \\times 10^5$\n$-10^9 \\leq a_i \\leq 10^9$\nIt's guaranteed that the sume of $N$ over all test cases is $\\leq 2 \\times 10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define int long long  \n// Use long long to prevent integer overflow\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> arr(n, 0);\n    for (auto &x : arr)\n        cin >> x;\n\n    int k = 0, ans;\n    int tot = 0, sum = 0, d;\n    unordered_map<int, int> dif, dif1;  // dif: counts for left part, dif1: counts for right part\n\n    // Calculate total sum of the array\n    for (int i = 0; i < n; ++i) {\n        tot += arr[i];\n    }\n\n    // First pass: left to right\n    for (int i = 0; i < n - 1; ++i) {\n        sum += arr[i];\n        ++dif[2*sum - tot];  // Count occurrences of each difference\n    }\n\n    // Handle the case where the last element is changed to 0\n    ans = max(dif[0], dif[k - arr[n - 1]]);\n\n    // Second pass: right to left\n    sum = tot - arr[n - 1];\n    for (int i = n - 2; i > 0; --i) {\n        d = sum + sum - tot;\n        --dif[d];    // Remove this difference from left part\n        ++dif1[d];   // Add this difference to right part\n\n        // Calculate potential improvement if arr[i] is changed to 0\n        d = k - arr[i];\n        if (d != 0) {\n            ans = max(ans, dif[d] + dif1[-d]);  // Update max achievable partitions\n        }\n        sum -= arr[i];\n    }\n\n    // Handle the case where the first element is changed to 0\n    ++dif1[2*sum - tot];\n    ans = max(ans, dif1[sum - k]);\n\n    cout << ans << endl;\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--)  \n        solve();\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:26:47.156176+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": "###### The Problem\n\nSuppose that we have an array of numbers $X=[x_0, x_1,\\ldots x_i, \\ldots x_{n-1}]$\nLet's check value of $(sum(X[0:i]) - sum(X[i+1:n-1])) == 0$ denoted by $M$.\nIt is allowed to replace $x_j$ with $0$, i.e. at most one number in $X$ could be changed. \nThe question is to find the largest value of $M$: i.e. maximize $(M)$\n\nPlease be noticed:\n- $0 \\le i < n-1$\n- $0 \\le j \\le n-1$\n\n###### The Algorithm\n\n###### Step 1: Calculate $M$ without changing anything. (which should be $O(n)$)\nBrief: \n- Find total sum\n- Find sum of $X[0:i]$\n- Compare $sum(X[0:i])$ with $total - sum(X[0:i])$\n\nNote: Sum will become large enough to overflow an int, use long long.\n\n###### Step 2: For each $j$, $0 \\le j \\le n-1$, identify and understand how things are updated.\nHere, we count and store the value of $sum(X[0:i]) * 2 - tot$ (aka $sum(X[0:i]) - sum(X[i+1:n-1])$).\n\nFurthermore:\n1. For all $i$, $0 \\le i < j$,  $dif[d]$ is the number of pairs $(0, i)$, where $sum(X[0:i]) - sum(X[i+1:n-1]) == d$\n2. For all $i$, $j \\le i \\le n-1$,  $dif1[d]$ is the number of pairs $(0, i)$, where $sum(X[0:i]) - sum(X[i+1:n-1]) == d$\n\nSuppose that $q = 0 - X[i]$. As long as we change the value of $X[i]$ with $0$, what happens with the number of zero-difference:\n\n1. For $0 \\le i < j$, the sum of $X[i+1:n-1]$ is now increased by $q$, which means that the sum of $X[0:i]$ should be $q$ larger previously. So, we have $dif[d]$ zeros.\n   Case Studied: $(0,0), (0,1) \\ldots (0, i-1)$\n\n2. For $j \\le i \\le n-1$, the sum of $X[0:i]$ is now increased by $q$, which means that the sum of $X[0:i]$ should be $-q$ larger previously. So, we have $dif1[-d]$ zeros.\n   Case Studied: $(0,i), (0,i+1) \\ldots (0, n-1)$\n\n3. Special Case: the first element $x_0$ can only be used for left part; and the last $x_{n-1}$ can only be treated as right part.\n\n###### Step 3: Try to scan left to right and right to left, so that we can avoid extra counting"
      },
      "id": 1058,
      "input_format": "The first line contains a single integer $T$, which denotes the number of test cases.\nFor each test case:\n1. The first line contains $N$, denoting the size of the array.\n2. The second line contains $N$ space-separated integers $a_i$, denoting the elements of the array.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the above sample, change -1 to 0.\n\nNew array will be [0, 5, 0, 0, 5, 0].\n\nAll possible partitions:\n1. [0, 5] [0, 0, 5, 0]\n2. [0, 5, 0] [0, 5, 0]\n3. [0, 5, 0, 0] [5, 0]\n\nTherefore answer is 3.",
      "output_format": "For each test case, print a single integer on a new line.",
      "samples": [
        {
          "input": "1\n6\n-1 5 0 0 5 0\n",
          "output": "3\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "Number of Partition",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p><span style=\"background-color:transparent;color:#000000;\">You have an empty array and can perform the following operations on it:</span></p><ol><li><span style=\"background-color:transparent;color:#000000;\">insert x - add integer x to the array</span></li><li><span style=\"background-color:transparent;color:#000000;\">remove x - remove integer x from the array. </span>It's<span style=\"background-color:transparent;color:#000000;\"> g</span>uaranteed<span style=\"background-color:transparent;color:#000000;\"> the element present in it.</span></li><li><span style=\"background-color:transparent;color:#000000;\">getMean - find the mean of elements currently </span>presents<span style=\"background-color:transparent;color:#000000;\"> in the array.</span></li><li><span style=\"background-color:transparent;color:#000000;\">getMedian - find the median of elements currently present in the array,&nbsp; if </span>the <span style=\"background-color:transparent;color:#000000;\">count of the numbers is even, take the average of the two middle elements.</span></li><li><span style=\"background-color:transparent;color:#000000;\">getMode - find the mode of elements currently present in the array, if there is more than one potential element, assume that the mode is the smaller of all.</span></li></ol><p>If the array is empty at the point a query is asked about a metric(mean, median, mode), print -1.</p><p><span style=\"background-color:transparent;color:#000000;\">If any of the answers for the query is a fraction, let's say, P / Q in reduced form, the return the number (P*Q<sup>-1</sup>) Modulo 1000000007.</span></p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou have an empty array and can perform the following operations on it:\n\n1. **`insert x`** - Add integer $x$ to the array.\n2. **`remove x`** - Remove integer $x$ from the array.  \n   *It is guaranteed that the element is present in the array.*\n3. **`getMean`** - Find the mean of elements currently present in the array.\n4. **`getMedian`** - Find the median of elements currently present in the array.  \n   *If the count of the numbers is even, take the average of the two middle elements.*\n5. **`getMode`** - Find the mode of elements currently present in the array.  \n   *If there is more than one potential mode, assume the mode is the smallest of all.*\n\n---\n\nIf the array is empty at the point a query is asked about a metric (**mean**, **median**, or **mode**), print `-1`.\n\n---\n\n\nIf any of the answers for the query is a fraction, let's say, $\\frac{P}{Q}$ in reduced form, return the number:\n\n$\n(P \\times Q^{-1}) \\mod 1000000007\n$\n\nwhere $Q^{-1}$ is the modular multiplicative inverse of $Q$ modulo $1000000007$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$  \n$1 \\leq Q \\leq 10^5$  \n$1 \\leq x \\leq 10^9$  \nIt is guaranteed that the sum of $Q$ over all test cases does not exceed $10^5$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree <pair<int,int>, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n/*\n    order_of_key (k)\n    find_by_order(k)\n*/\n\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += mod;\n}\n\ninline int mul(int a, int b) {\n  return (int) ((long long) a * b % mod);\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= mod;\n  if (a < 0) a += mod;\n  int b = mod, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += mod;\n  return u;\n}\n\nstruct Mean {\n    int sum, cnt;\n\n    Mean() : sum(0), cnt(0) {};\n\n    void insert(int x) {\n        add(sum, x);\n        add(cnt, 1);\n    }\n\n    void remove(int x) {\n        sub(sum, x);\n        sub(cnt, 1);\n    }\n\n    int GetMean() const {\n        if (!cnt) return -1;\n        return mul(sum, inv(cnt));\n    }\n};\n\nstruct Mode {\n    set<pair<int,int>> s;\n    map<int,int> M;\n\n    void insert(int x) {\n        M[x]++;\n        if (M[x] > 1) s.erase(s.find({-(M[x] - 1), x}));\n        s.insert({-M[x], x});\n    }\n\n    void remove(int x) {\n        s.erase(s.find({-M[x], x}));\n        M[x]--;\n        if (M[x]) s.insert({-M[x], x});\n    }\n\n    int GetMode() {\n        if (s.empty()) return -1;\n        return s.begin()->second;\n    }\n};\n\nstruct Median {\n    ordered_set s;\n    map<int,int> M;\n\n    void insert(int x) {\n        M[x]++;\n        s.insert({x, M[x]});\n    }\n\n    void remove(int x) {\n        s.erase(s.find({x, M[x]}));\n        M[x]--;\n    }\n\n    int GetMedian() {\n        if (s.empty()) return -1;\n        int n = (int)s.size();\n        if (n % 2 == 0) {\n            int sum = s.find_by_order(n / 2 - 1)->first;\n            add(sum, s.find_by_order(n / 2)->first);\n            return mul(sum, inv(2));\n        }\n        return s.find_by_order(n / 2)->first;\n    }\n};\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int q;\n        cin >> q;\n\n        Mean mean;\n        Mode mode;\n        Median median;\n\n        while (q--) {\n            string s;\n            cin >> s;\n\n            if (s == \"insert\") {\n                int x;\n                cin >> x;\n                mean.insert(x);\n                mode.insert(x);\n                median.insert(x);\n            } else if (s == \"remove\") {\n                int x;\n                cin >> x;\n                mean.remove(x);\n                mode.remove(x);\n                median.remove(x);\n            } else if (s == \"getMean\") {\n                cout << mean.GetMean() << \"\\n\";\n            } else if (s == \"getMode\") {\n                cout << mode.GetMode() << \"\\n\";\n            } else if (s == \"getMedian\") {\n                cout << median.GetMedian() << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:15:40.642652+00:00"
      },
      "hints": {
        "hint1": "Mean  = sum of all numbers/count of numbers\n\nMedian = Middle element if the array was sorted, if count of the numbers is even, take the average of the two middle elements.\n\nMode = Maximum occurring element, if there is more than one element,  assume that the mode is the smaller of the two.",
        "hint2": "",
        "solution_approach": "For mean, keep track of the sum of the numbers along with the count of numbers in two separate variables.\n\nFor median, you can use pair<int, int> in the indexed set to get multiple elements with the same value in the set and hence get the middle values easily.\n\nFor mode, store the count of each number in a map and use set of pair to find the maximum occurring number.\n\nTime Complexity per test case: O(Q log Q)"
      },
      "id": 391,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\nThe first line of each test case contains one integer Q - the number of queries. \nEach of the next Q lines contains a string S and integer X or just a string S - description of the query.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "1. Array becomes: [4]\n2. Array becomes [3, 4]\n3. Array becomes [3, 4, 5]\n4. Mean = (3+4+5) / 3 = 4\n5. Median = 4 (middle element)\n6. Mode = 3 (since it is smallest in value)\n7. Array becomes [3, 4, 4, 5]\n8. Array becomes [4, 4, 5]\n9. Array becomes [4, 4, 5, 5]\n10. Mean = (4+4+5+5)/4 = 4.5 (=500000008 in mod domain)\n11. Median = (4+5)/2 = 4.5 (average of the two middle elements)\n12. Mode = 4 (since it is smallest in value)",
      "output_format": "For each test case, print the answer for the queries.",
      "samples": [
        {
          "input": "1\n12\ninsert 4\ninsert 3\ninsert 5\ngetMean\ngetMedian\ngetMode\ninsert 4\nremove 3\ninsert 5\ngetMean\ngetMedian\ngetMode",
          "output": "4\n4\n3\n500000008\n500000008\n4"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Running Mean, Median and Mode AZ101",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Find the number of binary strings of length n where “0100” is not present as a substring.",
      "complete_approach": "",
      "constraints": "<p>1 ≤ t ≤ 10<sup>6</sup></p><p>1 ≤ n ≤ 10<sup>6</sup> where n is the length of the string.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int mod = 1e9 + 7;\n\nint pw(int a,int b,int p){\n   if(b==0)return 1;\n   int t=pw(a,b/2,p);\n   t=(t*t)%p;\n   if(b%2)return (a*t)%p;\n   return t;\n}\nint dp[1000001][5];\nsigned main(){\n   ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n       dp[0][0] = 1;\n       for (int i = 1; i <= 1000000; ++i) {\n           for (int j = 0; j <= 4; ++j) {\n               // 0100\n               vector<int> v;\n               if(j == 0) {\n                   v = {0, 2};\n               }\n               else if(j == 1) {\n                   v = {0,1};\n               }\n               else if(j == 2) {\n                   v = {1, 3};\n               }\n               else if(j == 3) {\n                   v = {2};\n               }\n               else {\n                   v = {3, 4, 4};\n               }\n               for (int k:v) {\n                   dp[i][j] = (dp[i][j] + dp[i-1][k])%mod;\n               }\n           }\n       }\n   int t;\n   cin >> t;\n   while(t--) {\n       int n;\n       cin>>n;\n       cout << (pw(2,n,mod) - dp[n][4] + mod)%mod << \"\\n\";\n   }\n   return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:17:27.631512+00:00"
      },
      "hints": {
        "hint1": "<p>The total number of binary strings of length n is 2<sup>n</sup>. Find the number of binary strings where “0100” is present as a string and subtract it from 2<sup>n</sup>.</p>",
        "hint2": "Define `dp[i][j]` which is the number of binary strings if the current string is of `i` characters and it matches first `j` characters of “0100”.",
        "solution_approach": "Consider all the cases from $j = 0$ to $j = 4$. Use String Matching with Finite Automata to find the DP transitions. At index $i$, the values for $dp[i-1][j]$, $0 \\leq j \\leq 4$ would be known already. The final answer would be $dp[n][4]$.\n\n**Time Complexity per test case:** $O(n)$"
      },
      "id": 503,
      "input_format": "- The first line of the input contains one integer $t$ - the number of test cases. Then $t$ test cases follow.\n- The first and only line of each test case contains an integer $n$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>For the first test case, n = 3, so “0100” cannot be a substring.</p><p>For the second test case, there are total 2<sup>4</sup> = 16 substrings out of which “0100” is a substring. So, the answer is 16-1 = 15.</p>",
      "output_format": "For each test case, print the number of binary strings of length n where “0100” is not present as a substring mod 10^9+7.",
      "samples": [
        {
          "input": "3\n3\n4\n5",
          "output": "8\n15\n28"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Count of Binary Strings",
      "video_editorial_id": 10674
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Zenithland has $n$ cities and $m$ flight connections. Your task is to design a round trip that begins in a city, goes through one or more other cities, and finally returns to the starting city. Every intermediate city on the route has to be distinct.",
      "complete_approach": "",
      "constraints": "$ 1 ≤ T ≤ 10 $\n$ 1 ≤ n ≤ 10^{5}$\n$ 1 ≤ m ≤ 2⋅10^{5}$\n$ 1 ≤ a , b ≤ n$",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll int64_t\r\n#define endl '\\n'\r\n\r\nint n, m;\r\nvector<int> color;\r\nvector<vector<int>> adj;\r\nbool f;\r\nvoid dfs(int v) {\r\n\tif (f)return;\r\n\tcolor[v] = 1;// being visited\r\n\tfor (auto x : adj[v]) {\r\n\t\tif (color[x] == 1) {\r\n\t\t\tf = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (color[x] == 0) {\r\n\t\t\tdfs(x);\r\n\t\t}\r\n\t}\r\n\tcolor[v] = 2; // already visted\r\n}\r\nvoid solve() {\r\n\tcin >> n >> m;\r\n\tadj.assign(n + 1, vector<int>());\r\n\tfor (int i = 0; i < m; i++) {\r\n\t\tint u, v;\r\n\t\tcin >> u >> v;\r\n\t\tadj[u].push_back(v);\r\n\t}\r\n\tcolor.assign(n + 1, 0);\r\n\tf = false;\r\n\tfor (int i = 1; i <= n; i++) {\r\n\t\tif (color[i] == 0)dfs(i);\r\n\t}\r\n\tif (!f)cout << \"No\" << endl;\r\n\telse cout << \"Yes\" << endl;\r\n}\r\nint main() {\r\n\tios_base :: sync_with_stdio(0);\r\n\tcin.tie(nullptr); cout.tie(nullptr);\r\n\r\n#ifdef Mastermind_\r\n\tfreopen(\"input.txt\", \"r\", stdin); \\\r\n\tfreopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n\tint t = 1;\r\n\t// int i = 1;\r\n\tcin >> t;\r\n\twhile (t--) {\r\n\t\t// cout << \"Case #\" << i << \": \";\r\n\t\tsolve();\r\n\t\t// i++;\r\n\t}\r\n\treturn 0;\r\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:28:15.904726+00:00"
      },
      "hints": {
        "hint1": "Apply DFS to find the cycle with length ≥ 2 in the graph.",
        "hint2": "To check if a cycle exists in a directed graph, you can use a modified depth-first search (DFS) algorithm.\n\n1. First, you can represent the graph as an adjacency list or matrix.\n2. Next, you can perform a DFS starting from each vertex in the graph. During the DFS, you can keep track of the visited vertices and mark each visited vertex as you visit it. If you encounter a visited vertex again during the DFS, then you have found a cycle in the graph.\n3. However, in a directed graph, you need to consider the direction of the edges. Therefore, you need to keep track of not only visited vertices, but also which vertices are on the current path being traversed.\n4. To do this, you can use a color array to keep track of each vertex's state during the DFS. The color array can have the following values:  \n        $0$: the vertex is completely unvisited.   \n        $1$: the vertex whose some but not all children are visited.   \n        $2$: the vertex whose all the children are visited.    \n5. During the DFS, if you encounter a vertex that is already on the current path being traversed (i.e. has a color value of $1$), then you have found a cycle.  \n\nTime complexity : $O(V+E)$",
        "solution_approach": "To check if a cycle exists in a directed graph, you can use a modified depth-first search (DFS) algorithm.\n\n1. First, you can represent the graph as an adjacency list or matrix.\n2. Next, you can perform a DFS starting from each vertex in the graph. During the DFS, you can keep track of the visited vertices and mark each visited vertex as you visit it. If you encounter a visited vertex again during the DFS, then you have found a cycle in the graph.\n3. However, in a directed graph, you need to consider the direction of the edges. Therefore, you need to keep track of not only visited vertices, but also which vertices are on the current path being traversed.\n4. To do this, you can use a color array to keep track of each vertex's state during the DFS. The color array can have the following values:  \n        $0$: the vertex is completely unvisited.   \n        $1$: the vertex whose some but not all children are visited.   \n        $2$: the vertex whose all the children are visited.    \n5. During the DFS, if you encounter a vertex that is already on the current path being traversed (i.e. has a color value of $1$), then you have found a cycle.  \n\nTime complexity : $O(V+E)$\n\n*Note : Difference between Round Trip and this question is  that in the former one we could have counted 2 nodes as forming a cycle i.e, if the node is connected with its parent in a loop we can call it a circle. In this question we dont consider a cycle unless and until there are 3 nodes in the cycle. So we dont consider the parent child loops in cycles .*\n\n\n*Note : It is important to note that when dealing with graphs that are not explicitly stated to be connected, one must perform a depth-first search (DFS) on all unvisited nodes to ensure that all components of the graph are explored. This is because running DFS only on one starting node may miss components of the graph that are not connected to that starting node.*"
      },
      "id": 388,
      "input_format": "First line contains $T$ - Number of test cases.\nFirst input line of each test case has two integers $n$ and $m$: the number of cities and flights. The cities are numbered $1,2,…,n$.\nThen, for each test case, there are $m$ lines describing the flights. Each line has two integers $a$ and $b$: there is a flight connection from city $a$ to city $b$. All connections are one-way flights from a city to another city.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, Print *\"Yes\"* if such round trip exists, otherwise print *\"No\"* in a new line.",
      "samples": [
        {
          "input": "1\n4 5\n1 3\n2 1\n2 4\n3 2\n3 4\n",
          "output": "Yes\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Round Trip II",
      "video_editorial_id": 10653
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You have an empty set and can perform the following operations on it:\n\n1. 1 x - Add integer x to the set\n2. 2 x - Find the smallest integer that is not present in the set, which is greater than or equal to x.",
      "complete_approach": "",
      "constraints": "- $1 \\leq T \\leq 10^5$\n- $1 \\leq Q \\leq 10^5$\n- $1 \\leq t_i \\leq 2$\n- $1 \\leq x_i \\leq 10^{12}$\n\nIt is guaranteed that the sum of $Q$ over all test cases does not exceed $10^6$.",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS                \\\n  ios::sync_with_stdio(0); \\\n  cin.tie(0);              \\\n  cout.tie(0);\n#define int long long\n\nsigned main() {\n  IOS int t;\n  cin >> t;\n  while (t--) {\n    int q;\n    cin >> q;\n    set<int> s, ns;\n    while (q--) {\n      int t, x;\n      cin >> t >> x;\n      if (t == 1) {\n        s.insert(x);\n        ns.erase(x);\n        if (!s.count(x + 1)) {\n          ns.insert(x + 1);\n        }\n      } else {\n        if (!s.count(x)) {\n          cout << x << \"\\n\";\n        } else {\n          cout << *ns.lower_bound(x) << \"\\n\";\n        }\n      }\n    }\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:15:23.442228+00:00"
      },
      "hints": {
        "hint1": "Maintain two sets - one which contains the  values of xi and other which contains $x_i + 1$(erase it afterwards if it comes as $x_i$)",
        "hint2": "",
        "solution_approach": "This solution uses two sets `s` and `ns` to maintain the values of $x_i$ and $x_i+1$ , respectively. When we perform an operation of type `1 x`, we insert `x` into `s`. If $x+1$ is not already in `s`, we also insert it into `ns`. If $x+1$ is already in `s`, we remove it from `ns`. This is because if $xi+1$ is already in the set, we do not need to keep track of it separately, since we know that xi is present in the set.\n\nWhen we perform an operation of type `2 x`, we check if `x` is in `s`. If it is not, we return `x` as the smallest integer not present in the set that is greater than or equal to `x`. If `x` is in `s`, we use the lower_bound function on `ns` to find the smallest integer in `ns` that is greater than or equal to `x`, and return that as the answer.\n\nThe reason this solution works is because the values in `s` represent the integers that are present in the set, and the values in `ns` represent the integers that are not present in the set but have an immediate neighbor that is present in the set. This means that the smallest integer not present in the set that is greater than or equal to `x` will either be `x` itself (if `x` is not in the set), or the smallest value in `ns` that is greater than or equal to `x` (if `x` is in the set).\n\n\nTime Complexity per test case: $O(Q \\log Q)$, because each operation takes $O(\\log Q)$ time to perform (due to the use of sets and the `lower_bound` function)."
      },
      "id": 358,
      "input_format": "The first line of the input contains one integer T - the number of test cases. Then T test cases follow.\n\nThe first line of each test case contains one integer Q - the number of queries. \n\nEach of the next Q lines contain two space-separated integers t<sub>i</sub> and x<sub>i</sub> - type and value of the query.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, the set is [1, 3]. Value which is not present and is ≥ 1 is 2 and ≥ 4 is 4.\n\nFor the second test case, the value which is not present and is ≥ 4 is 4. Then set becomes [4]. Value which is not present and is ≥ 4 is 5 now.",
      "output_format": "For each test case, print the answer for the queries.",
      "samples": [
        {
          "input": "2\n4\n1 1\n1 3\n2 1\n2 4\n3\n2 4\n1 4\n2 4\n",
          "output": "2\n4\n4\n5\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Set Queries AZ101",
      "video_editorial_id": 8185
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>You are given a tree consisting of <i>n</i> nodes. The diameter of a tree is the maximum distance between two nodes. Your task is to count the number of different diameters of the tree.</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ <i>n </i>≤ 2 x 10<sup>5</sup><br>1 ≤ <i>a</i>, <i>b </i>≤ <i>n</i></p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 200010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nvector<int> graph[N];\nint diameter = 0;\nll cnt_diameter = 0;\n\nvoid update(int dia, ll cnt) {\n    if(diameter < dia) {\n        diameter = dia;\n        cnt_diameter = cnt;\n    }\n    else if(diameter == dia) {\n        cnt_diameter += cnt;\n    }\n    return;\n}\n\npair<int,int> findDiameter(int cur, int prev) {\n    vector<pair<int,int>> len;\n\n    for(int u : graph[cur]) {\n        if(u == prev) continue;\n        auto it = findDiameter(u, cur);\n        len.push_back({it.first, it.second});\n    }\n\n    sort(len.begin(), len.end(), [&](pair<int,int> A, pair<int,int> B) {\n        return A.first > B.first;\n    });\n\n    if(len.empty()) {\n        update(1, 1);\n    }\n    else if((int)len.size() == 1) {\n        update(len[0].first + 1, len[0].second);\n    }\n    else if(len[0].first == len[1].first) {\n        int dia = len[0].first + len[1].first + 1;\n        ll cnt = 0;\n        ll sqcnt = 0;\n        for(auto it : len) {\n            if(it.first == len[0].first) {\n                cnt += it.second;\n                sqcnt += 1LL * it.second * it.second;\n            }\n        }\n        cnt = cnt * cnt - sqcnt; cnt /= 2;\n        update(dia, cnt);\n    }\n    else {\n        int dia = len[0].first + len[1].first + 1;\n        ll a = 0, b = 0;\n        for(auto it : len) {\n            if(it.first == len[0].first) {\n                a += it.second;\n            }\n            else if(it.first == len[1].first) {\n                b += it.second;\n            }\n        }\n        ll cnt = a * b;\n        update(dia, cnt);\n    }\n    int maxi = 0, maxi_cnt = 1;\n    for(auto it : len) {\n        if(it.first > maxi) {\n            maxi = it.first;\n            maxi_cnt = it.second;\n        }\n        else if(it.first == maxi) {\n            maxi_cnt += it.second;\n        }\n    }\n    return {maxi + 1, maxi_cnt};\n}\n\nsigned main()\n{\n    //freopen(\"IN\", \"r\", stdin);\n    //freopen(\"OUT\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n; cin >> n;\n    for(int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    findDiameter(1, -1);\n\n    cout << cnt_diameter << \"\\n\";\n\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "Second Hint is missing"
        ],
        "last_updated": "2024-06-22T02:35:00.216048+00:00"
      },
      "hints": {
        "hint1": "Find the center of the tree, then find how many diameters you can form.",
        "hint2": "",
        "solution_approach": "1. A tree can have at most two centers. The center of a tree is also the center of its diameter. To find the center(s) of a tree, follow these steps:\n\n2. Find the length of the diameter of the tree. The diameter is the longest path between any two nodes in the tree.\n\n3. Once you have the length of the diameter, move from the farthest node towards the center by going up a distance of diameter/2 nodes.\n\n4. If the length of the diameter (diameter) is even, there are two centers in the tree. These centers are located at nodes $\\lfloor\\frac{\\text{diameter}}{2}\\rfloor$ and $\\lfloor\\frac{\\text{diameter}}{2}\\rfloor - 1$ on the diameter path.\n\nBy identifying the length of the diameter and then moving towards the center, you can determine the center(s) of the tree. If the diameter length is even, there will be two centers at equal distances from both ends of the diameter.\n\n\nLets approach both the cases :\n### Case 1 : 1 center\n1. Consider the center of the tree, let's call it Center.\n\n2. Imagine the tree to be rooted at the Center.\n\n3. Traverse each adjacent node from the Center and consider them as separate subtrees.\n\n4. For each subtree, determine the number of leaf nodes that are located at a depth of $\\lfloor\\frac{\\text{diameter}}{2}\\rfloor$ from the root of that subtree. (The diameter is the maximum distance between two nodes in the tree.)\n\n5. Calculate the summation of all possible pairwise products of the number of leaf nodes in each subtree obtained from step 4. This will give you the count of all possible diameters in the tree when there is only one center.\n\nThe idea behind this approach is that each adjacent node from the center represents a separate subtree. By finding the number of leaf nodes at a depth of diameter/2 in each subtree and considering pairwise combinations, you account for all possible diameters that can be formed by connecting leaf nodes from different subtrees via the center.\n\nBy following these steps, you can determine the count of all possible diameters in a tree when there is one center.\n\n### Case 2 : 2 centers\n1. Consider the two centers of the tree. Let's call them Center1 and Center2.\n\n2. Start by imagining the tree to be rooted at Center1. From Center1, explore each adjacent node and consider them as separate subtrees.\n\n3. For each subtree, determine the number of leaf nodes that are located at a depth of $\\lfloor\\frac{\\text{diameter}}{2}\\rfloor$ from the root of that subtree. (The diameter is the maximum distance between two nodes in the tree.)\n\n4. Repeat the same process, but this time imagine the tree to be rooted at Center2. Explore each adjacent node from Center2 and determine the number of leaf nodes at a depth of $\\lfloor\\frac{\\text{diameter}}{2}\\rfloor$ from the root of each subtree.\n\n5. For each subtree on the side of Center1, and for each subtree on the side of Center2, calculate the number of leaf nodes satisfying the condition mentioned in step 3 and step 4.\n\n6. Finally, find the summation of all possible pairwise products of the number of leaf nodes in each subtree obtained from step 5. This will give you the count of all possible diameters in the tree.\n\nBy following these steps, you can determine the count of all possible diameters in a tree with 2 centers."
      },
      "id": 428,
      "input_format": "<p><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">The first input line contains an integer <i>n</i>: the number of nodes. The nodes are numbered 1, 2, …, <i>n</i>.</span><br><span style=\"background-color:rgb(255,255,255);color:rgb(0,0,0);\">Then there are <i>n </i>− 1 lines describing the edges. Each line contains two integers <i>a</i> and <i>b</i>: there is an edge between nodes <i>a</i> and <i>b</i>.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "<p>Two diameters are:</p><ol><li>2 → 1 → 3 → 4</li><li>2 → 1 → 3 → 5</li></ol>",
      "output_format": "<p>Print the count of diameters of the tree.</p>",
      "samples": [
        {
          "input": "5\n1 2\n1 3\n3 4\n3 5",
          "output": "2"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Tree Diameter - II",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You are given four integers - $A, B, C$, and $P$. $P$ is a prime number.\nFind $A^{B ^ C}  \\%  P$.\n\n**NOTE**: $0^0 = 1$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 2 \\times 10^5$\n$0 \\leq A, B, C \\leq 10^9$\n$2 \\leq P \\leq 10^4$",
      "editorial_code": [
        {
          "code": "```cpp\n// Enter your code below\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nll expo(ll a, ll x, ll p)  //(a^x)%p\n{\n  ll n, ans = 1;\n  // prod= (a^(2^p1))\n  while (x) {\n    if (x % 2) {\n      ans = ((ans % p) * (a % p)) % p;\n    }\n    a = ((a % p) * (a % p)) % p;\n    x = x / 2;\n  }\n  return ans;\n}\nvoid solve() {\n  // write your code here\n  ll n, res, ans, a, b, c, p;\n  cin >> a >> b >> c >> p;\n  if (b == 0 && c != 0) {\n    cout << '1' << '\\n';\n  }\n\n  else if (a % p == 0 || a == 0) {\n    cout << \"0\\n\";\n  } else {\n    res = expo(b, c, p - 1);\n    ans = expo(a, res, p);\n    cout << ans << endl;\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int i, T;\n\n  T = 1;\n  cin >> T;\n\n  for (i = 1; i <= T; i++) {\n    solve();\n  }\n  return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-06-22T02:42:59.721983+00:00"
      },
      "hints": {
        "hint1": "Remember little Fermat's theorem is just to make your simplification simpler. Try to think logically about a few test cases.\nIf you directly try to apply little fermats and then print the answer without taking care of edge cases these are the difficulties which you may face.\nRemember $0^0$=1 always.",
        "hint2": "* 0 2 9 3. The correct answer should be 0 without any doubt. Because no matter how many times you multiply 0 with itself it will always be 0. Correct??\n\nBut what happens when we apply little fermats theorem directly?? We get $$(2^9) \\bmod 2 = 0$$ and this simplifies the problem as $0^0$ and we get the wrong answer as $1$. This should not be the case. So handling edge cases are necessary.\n\nSome other edge cases to consider are \n* 6 8 9 3\n* 0 0 0 13",
        "solution_approach": "The edge cases which we need to take care of are as follows\n1. If $(B^C)=0$ i.e., $B=0$ and $C \\neq 0$, then answer is $1$.\n2. If $A=0$ and $(B^C) \\neq 0$ , then answer is 0.\n3. If $A \\neq 0$ and $(B^C) \\neq 0$ , and $A$ is divisible by $P$, then answer is $0$.\n4. If $A \\neq 0$ and $(B^C) \\neq 0$ , and $A$ is not divisible by $P$, then we need to use Fermat's Little Theorem which states that $A^{P-1} =1\\mod P$, if $P$ is prime.  \nLet $(B^C) = X \\times(P-1)+Y $, which means that $A^{B^C} = A^Y$.  \nFind $Z=(B^C)(\\mod P-1)$ and then find $A^Z(\\mod P)$.  \n\nTime Complexity per test case: $O(\\log C + \\log P)$"
      },
      "id": 387,
      "input_format": "The first line of the input contains one integer $T$ - the number of test cases. Then $T$ test cases follow.\nThe first line of each test case contains four space-separated integers $A, B, C, P$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, $2 ^ {4 ^ 2} \\% 7 = 2^{16} \\% 7 = 65536 \\% 7 = 2$.\nFor the second test case, $1 ^ {6 ^ {20}} \\% 5 = 1 \\% 5 = 1$.\nFor the third test case, $3 ^ {1 ^ {200}} \\% 3 = 3 ^ 1 \\% 3 = 3 \\% 3 = 0$.",
      "output_format": "For each test case, print&nbsp; $A^{B ^ C}  \\%  P$",
      "samples": [
        {
          "input": "3\n2 4 2 7\n1 6 20 5\n3 1 200 3\n",
          "output": "2\n1\n0\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Exponentiation AZ101",
      "video_editorial_id": 8196
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Implement a <strong>SnapshotArray</strong> that supports the following interface:</p><ul><li><strong>SnapshotArray(int length)</strong> initializes an array-like data structure with the given length. Initially, each element equals 0.</li><li><strong>void set(index, val)</strong> sets the element at the given index to be equal to val.</li><li><strong>int snap()</strong> takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.</li><li><strong>int get(index, snap_id)</strong> returns the value at the given index, at the time we took the snapshot with the given snap_id.</li></ul>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ Q ≤ 10<sup>5</sup><br>1 ≤ L ≤ 10<sup>9</sup><br>0 ≤ val ≤ 10<sup>9</sup><br>0 ≤ snap_id &lt; (the total number of times we call snap())<br>0 ≤ index &lt; L</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass SnapshotArray\n{\npublic:\n\tunordered_map<int, vector<pair<int, int>>> v;\n\tint snapId;\n\n\tSnapshotArray(int length)\n\t{\n\t\tsnapId = 0;\n\t}\n\n\tvoid set(int index, int val)\n\t{\n\t\tif (v.find(index) != v.end())\n\t\t{\n\t\t\tif (v[index].back().second == snapId)\n\t\t\t\tv[index].back().first = val;\n\t\t\telse\n\t\t\t\tv[index].push_back({val, snapId});\n\t\t}\n\t\telse\n\t\t\tv[index].push_back({val, snapId});\n\t}\n\n\tint snap()\n\t{\n\t\tsnapId++;\n\t\treturn snapId - 1;\n\t}\n\n\tint get(int index, int snap_id)\n\t{\n\t\tif (v.find(index) == v.end())\n\t\t\treturn 0;\n\n\t\tvector<pair<int, int>> &temp = v[index];\n\n\t\tint L = 0, R = (int)temp.size() - 1;\n\t\tint ans = 0;\n\n\t\twhile (L <= R)\n\t\t{\n\t\t\tint mid = (L + R) / 2;\n\t\t\tif (temp[mid].second <= snap_id)\n\t\t\t{\n\t\t\t\tans = temp[mid].first;\n\t\t\t\tL = mid + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tR = mid - 1;\n\t\t}\n\n\t\treturn ans;\n\t}\n};\n\nint main()\n{\n\tios_base::sync_with_stdio(NULL);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint Q, L;\n\tcin >> Q >> L;\n\n\tSnapshotArray snapshotArray(L);\n\n\twhile (Q--)\n\t{\n\t\tstring op;\n\t\tcin >> op;\n\n\t\tif (op == \"set\")\n\t\t{\n\t\t\tint index, val;\n\t\t\tcin >> index >> val;\n\n\t\t\tsnapshotArray.set(index, val);\n\t\t}\n\t\telse if (op == \"get\")\n\t\t{\n\t\t\tint index, snap_id;\n\t\t\tcin >> index >> snap_id;\n\n\t\t\tcout << snapshotArray.get(index, snap_id) << \"\\n\";\n\t\t}\n\t\telse if (op == \"snap\")\n\t\t{\n\t\t\tcout << snapshotArray.snap() << \"\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:18:10.862297+00:00"
      },
      "hints": {
        "hint1": "<p>Observe that L ≤ 10<sup>9</sup>, and Q ≤ 10<sup>5</sup>. From these constraints, it's clear that not all elements will be set. Most of them will be 0 only.</p>",
        "hint2": "<p>Maintain unordered map, adding both element and snap_id.</p>",
        "solution_approach": "<p>Look into the constraints carefully. L ≤ 10<sup>9</sup>, and Q ≤ 10<sup>5</sup>. Most of the elements will be 0. So we'll maintain unordered_map on the index of the array to store data. We'll also maintain curSnapId to store what index of snap we currently at, or how many snaps we've taken till now.</p><ul><li><strong>set(index, val)</strong>: Look for the last time you take a snap of the value at index. We can get that using the last value store at the index. If the snapId of the last element is same as curSnapId, just update the element. Otherwise push back new entry {val, curSnapId}.</li><li><strong>snap</strong>: This is the simplest operation in this design. Just increment the curSnapId.</li><li><strong>get(index, val)</strong>: Look for if we've set index before or not. We can do it by checking if index is present in map or not. If not, then return 0. Otherwise, now we've vector of pairs with value and snap_id (the value at the time of snap_id). Since it's in increasing order of snap_id, we do binary search on snap_id to find the ≤ snap_id snap.</li></ul><p>Look into the editorial code for a better understanding.</p>"
      },
      "id": 463,
      "input_format": "<p><span style=\"background-color:transparent;color:#222222;\">The first line of input contains <strong>Q</strong>, <strong>L</strong> - the number of queries and the length of the array.</span><br><span style=\"background-color:transparent;color:#222222;\">Next, <strong>Q</strong> lines contain queries of the types mentioned in the problem statement.</span></p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "",
      "samples": [
        {
          "input": "4 3\nset 0 5\nsnap\nset 0 6\nget 0 0",
          "output": "0\n5"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [
        {
          "code": "<fix>\n#include <bits/stdc++.h>\nusing namespace std;\n</fix>\n\nclass SnapshotArray\n{\npublic:\n\t\n\tSnapshotArray(int length)\n\t{\n\t\t\n\t}\n\n\tvoid set(int index, int val)\n\t{\n\t\t\n\t}\n\n\tint snap()\n\t{\n\t\t\n\t}\n\n\tint get(int index, int snap_id)\n\t{\n\t\t\n\t}\n};\n\n<fix>\nint main()\n{\n\tios_base::sync_with_stdio(NULL);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint Q, L;\n\tcin >> Q >> L;\n\n\tSnapshotArray snapshotArray(L);\n\n\twhile (Q--)\n\t{\n\t\tstring op;\n\t\tcin >> op;\n\n\t\tif (op == \"set\")\n\t\t{\n\t\t\tint index, val;\n\t\t\tcin >> index >> val;\n\n\t\t\tsnapshotArray.set(index, val);\n\t\t}\n\t\telse if (op == \"get\")\n\t\t{\n\t\t\tint index, snap_id;\n\t\t\tcin >> index >> snap_id;\n\n\t\t\tcout << snapshotArray.get(index, snap_id) << \"\\n\";\n\t\t}\n\t\telse if (op == \"snap\")\n\t\t{\n\t\t\tcout << snapshotArray.snap() << \"\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}\n</fix>",
          "language": "C++14"
        }
      ],
      "time_limit_sec": 1,
      "title": "Snapshot Array",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "Can you write a program to solve the following problem?\n\n$\\left(a(a(...a(a(a+\\underbrace{b)+b)+b...)+b)+b}_{n\\text{ times}}\\right) \\% (10^9 + 9)$",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 2 \\times 10^5$\n$1 \\leq a, b \\leq 10^9$\n$1 \\leq n \\leq 10^{18}$",
      "editorial_code": [],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "Editorial Code data is currently empty."
        ],
        "last_updated": "2024-06-22T02:47:23.908171+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 153,
      "input_format": "The first line contains a single integer $T$  -- the number of test cases. The description of the test cases follows.\nThe only line of each test case contains three integers $a, b, n$.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "Explanation $1$: $2 \\times (2 + 3) + 3 = 13$\n\nExplanation $2$: $3  \\times (3 \\times (3 + 3) + 3) + 3 = 66$",
      "output_format": "For each test case, output the value of the expression, since it can be large print it with modulo $10^9 + 9$.",
      "samples": [
        {
          "input": "2\n2 3 2\n3 3 3\n",
          "output": "13\n66\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 2,
      "title": "High School Maths",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "You've given a matrix containing non-negative elements. Find the maximum size submatrix having sum of elements less than or equal to $K$.\n\n**Note**: The sum of elements in an empty-submatrix (size $0$) is $0$.",
      "complete_approach": "",
      "constraints": "$1 \\leq T \\leq 10^5$\n$1 \\leq N, M \\leq 10^2$\n$0 \\leq$ Elements in the matrix $\\leq 10^3$\n$0 \\leq K \\leq 10^9$\nIt's guaranteed that the sum of all $N \\times M$ over all test cases $\\leq 10^4$",
      "editorial_code": [
        {
          "code": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n#define LD long double\n\nconst int N = 100010;\n\nint inf = 1e9;\nint mod = 1e9 + 7;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, m, k;\n        cin >> n >> m >> k;\n\n        vector<vector<int>> a(n, vector<int>(m, 0));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> a[i][j];\n            }\n        }\n\n        for (int j = 1; j < m; j++) {\n            for (int i = 0; i < n; i++) {\n                a[i][j] += a[i][j - 1];\n            }\n        }\n\n        function<int(int,int,int)> get = [&](int j, int l, int i) -> int {\n            int ans = a[i][l];\n            if (j) ans -= a[i][j - 1];\n            return ans;\n        };\n\n        int ans = 0;\n\n        for (int j = 0; j < m; j++) {\n            for (int l = j; l < m; l++) {\n                int ptr = -1;\n                int sum = 0;\n                for (int i = 0; i < n; i++) {\n                    while (ptr + 1 < n && sum + get(j, l, ptr + 1) <= k) {\n                        ptr++;\n                        sum += get(j, l, ptr);\n                    }\n                    ans = max(ans, (l - j + 1) * (ptr - i + 1));\n                    if (ptr >= i) {\n                        sum -= get(j, l, i);\n                    }\n                }\n            }\n        }\n\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [
          "First Hint is missing",
          "Second Hint is missing",
          "Solution Approach is missing",
          "No sample explanation provided."
        ],
        "last_updated": "2024-06-22T02:27:21.191722+00:00"
      },
      "hints": {
        "hint1": "",
        "hint2": "",
        "solution_approach": ""
      },
      "id": 1068,
      "input_format": "The first line of input contains $T$ - the number of test cases. Then $T$ test cases follow.\nThe first line of each test case contains $N$, $M$ and $K$ - the number of rows and columns in a matrix, and an integer respectively.\nThen, next $N$ line contains $M$ numbers, denoting the $i$-th row of the matrix.",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "",
      "output_format": "For each test case, output the answer on a new line.",
      "samples": [
        {
          "input": "1\n3 3 9\n1 2 3\n1 2 3\n1 2 3\n",
          "output": "6\n"
        }
      ],
      "status": "PUBLISHED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Kadane 2",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  },
  {
    "code": 200,
    "data": {
      "body": "<p>Given a grid of size n*m with integers, you need to find the maximum sum of a subgrid.</p><p>Example:</p><figure class=\"image\"><img src=\"https://docs.google.com/drawings/u/0/d/sn89H9-es56rO4VoHHP8wmw/image?w=168&amp;h=127&amp;rev=191&amp;ac=1&amp;parent=1VjM_9wDxQyjvaQpycTQ7qD0SUFpPC-ji4wYYfoYsXVU\"></figure><p>The subgrid coloured in yellow has the maximum sum which is 15.</p><p>&nbsp;</p>",
      "complete_approach": "",
      "constraints": "<p>1 ≤ t ≤ 10<sup>5</sup></p><p>1 ≤ n, m ≤ 200</p><p>-10<sup>5</sup> ≤ a<sub>ij </sub>≤ 10<sup>5</sup></p><p>It is guaranteed that the sum of n*m over all test cases does not exceed 10<sup>5</sup>.</p>",
      "editorial_code": [
        {
          "code": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nsigned main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while(t--) {\n        int n, m;\n        cin >> n >> m;\n        int grid[n][m];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                cin >> grid[i][j];\n            }\n        }\n        int ans = -2e18;\n        if(n <= m) {\n            for (int l = 0; l < m; ++l) {\n                int temp[n];\n                bool allNeg = true;\n                int num = -2e18;\n                memset(temp, 0, sizeof(temp));\n                for (int r = l; r < m; ++r) {\n                    for (int k = 0; k < n; ++k) {\n                        temp[k] += grid[k][r];\n                        num = max(num, grid[k][r]);\n                        if(grid[k][r] >= 0) {\n                            allNeg = false;\n                        }\n                    }\n                    if(allNeg) {\n                        ans = max(ans, num);\n                    }\n                    else {\n                        int maxSum = temp[0], curSum = 0;\n                        for (int k = 0; k < n; ++k) {\n                            curSum += temp[k];\n                            maxSum = max(maxSum, curSum);\n                            curSum = max(0ll, curSum);\n                        }\n                        ans = max(ans, maxSum);\n                    }\n                }\n            }\n        }\n        else {\n            for (int l = 0; l < n; ++l) {\n                int temp[m];\n                bool allNeg = true;\n                int num = -2e18;\n                memset(temp, 0, sizeof(temp));\n                for (int r = l; r < n; ++r) {\n                    for (int k = 0; k < m; ++k) {\n                        temp[k] += grid[r][k];\n                        num = max(num, grid[k][r]);\n                        if(grid[k][r] >= 0) {\n                            allNeg = false;\n                        }\n                    }\n                    if(allNeg) {\n                        ans = max(ans, num);\n                    }\n                    else {\n                        int maxSum = temp[0], curSum = 0;\n                        for (int k = 0; k < m; ++k) {\n                            curSum += temp[k];\n                            maxSum = max(maxSum, curSum);\n                            curSum = max(0ll, curSum);\n                        }\n                        ans = max(ans, maxSum);\n                    }\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}```",
          "language": "C++14"
        }
      ],
      "health_check": {
        "issues": [],
        "last_updated": "2024-04-08T01:28:11.704348+00:00"
      },
      "hints": {
        "hint1": "If the left and right columns of the subgrid are fixed, think of an algorithm to find the consecutive rows which should be taken to maximize the sum.\n",
        "hint2": "Kadane’s Algorithm is used to find the maximum sum subarray. Same can be used for the grid.",
        "solution_approach": "<p>In Kadane’s algorithm, maximum sum is found between two indexes. Here, maximum sum between two rows can be found. Since the columns are fixed, a rectangle would be there. Consider the edge case when all elements in the grid are negative.</p><p>Time Complexity per test case: O(n*m<sup>2</sup>), if m ≤ n</p>"
      },
      "id": 496,
      "input_format": "<p>The first line of the input contains one integer t - the number of test cases. Then t test cases follow.</p><p>The first line of each test case contains two space-separated integers n, m - the size of the grid.</p><p>Each of the next n lines contains m space-separated integers, aij - the number at that cell.</p>",
      "languages": [
        "C",
        "C++14",
        "Java",
        "Python3"
      ],
      "memory_limit_mb": 256000,
      "note": "For the first test case, the top-left $2 \\times 2$ subgrid, $10 + 2 - 4 + 5 = 13$.\n\nFor the second test case, all cells have a maximum sum which is $-1$.\n\nFor the third test case, all cells are positive, and the maximum sum subgrid is the entire grid with sum $10$.",
      "output_format": "For each test case, print the maximum sum.",
      "samples": [
        {
          "input": "3\n2 3\n10 2 -1\n-4 5 -1\n2 2\n-1 -1\n-1 -1\n2 2\n1 2\n3 4",
          "output": "13\n-1\n10"
        }
      ],
      "status": "CREATED",
      "tags": "online_judge.CodingProblem.None",
      "template_code": [],
      "time_limit_sec": 1,
      "title": "Maximum Sum in Grid",
      "video_editorial_id": null
    },
    "details": "Problem Details"
  }
]